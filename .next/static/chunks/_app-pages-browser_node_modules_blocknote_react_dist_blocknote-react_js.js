"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_blocknote_react_dist_blocknote-react_js"],{

/***/ "(app-pages-browser)/./node_modules/@blocknote/core/dist/blocknote.js":
/*!********************************************************!*\
  !*** ./node_modules/@blocknote/core/dist/blocknote.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioBlock: () => (/* binding */ gr),\n/* harmony export */   BlockNoteEditor: () => (/* binding */ _o),\n/* harmony export */   BlockNoteSchema: () => (/* binding */ Be),\n/* harmony export */   COLORS_DARK_MODE_DEFAULT: () => (/* binding */ wc),\n/* harmony export */   COLORS_DEFAULT: () => (/* binding */ kc),\n/* harmony export */   CodeBlock: () => (/* binding */ wr),\n/* harmony export */   DEFAULT_LINK_PROTOCOL: () => (/* binding */ $i),\n/* harmony export */   EMPTY_CELL_HEIGHT: () => (/* binding */ ac),\n/* harmony export */   EMPTY_CELL_WIDTH: () => (/* binding */ mo),\n/* harmony export */   Exporter: () => (/* binding */ yc),\n/* harmony export */   FILE_AUDIO_ICON_SVG: () => (/* binding */ dr),\n/* harmony export */   FILE_ICON_SVG: () => (/* binding */ cr),\n/* harmony export */   FILE_IMAGE_ICON_SVG: () => (/* binding */ Tr),\n/* harmony export */   FILE_VIDEO_ICON_SVG: () => (/* binding */ ps),\n/* harmony export */   FileBlock: () => (/* binding */ Br),\n/* harmony export */   FilePanelProsemirrorPlugin: () => (/* binding */ Pi),\n/* harmony export */   FilePanelView: () => (/* binding */ Mi),\n/* harmony export */   FormattingToolbarProsemirrorPlugin: () => (/* binding */ Ai),\n/* harmony export */   FormattingToolbarView: () => (/* binding */ Ii),\n/* harmony export */   HTMLToBlocks: () => (/* binding */ Mo),\n/* harmony export */   ImageBlock: () => (/* binding */ Ar),\n/* harmony export */   LinkToolbarProsemirrorPlugin: () => (/* binding */ Vi),\n/* harmony export */   PageBreak: () => (/* binding */ _r),\n/* harmony export */   SideMenuProsemirrorPlugin: () => (/* binding */ ea),\n/* harmony export */   SideMenuView: () => (/* binding */ Zi),\n/* harmony export */   SuggestionMenuProseMirrorPlugin: () => (/* binding */ sa),\n/* harmony export */   TableHandlesProsemirrorPlugin: () => (/* binding */ da),\n/* harmony export */   TableHandlesView: () => (/* binding */ la),\n/* harmony export */   UniqueID: () => (/* binding */ ve),\n/* harmony export */   UnreachableCaseError: () => (/* binding */ $),\n/* harmony export */   VALID_LINK_PROTOCOLS: () => (/* binding */ Ui),\n/* harmony export */   VideoBlock: () => (/* binding */ bs),\n/* harmony export */   addIdsToBlock: () => (/* binding */ Ta),\n/* harmony export */   addIdsToBlocks: () => (/* binding */ xa),\n/* harmony export */   addInlineContentAttributes: () => (/* binding */ Ct),\n/* harmony export */   addInlineContentKeyboardShortcuts: () => (/* binding */ $n),\n/* harmony export */   addStyleAttributes: () => (/* binding */ Gn),\n/* harmony export */   applyNonSelectableBlockFix: () => (/* binding */ Vn),\n/* harmony export */   assertEmpty: () => (/* binding */ tc),\n/* harmony export */   audioBlockConfig: () => (/* binding */ ur),\n/* harmony export */   audioParse: () => (/* binding */ fr),\n/* harmony export */   audioPropSchema: () => (/* binding */ pr),\n/* harmony export */   audioRender: () => (/* binding */ hr),\n/* harmony export */   audioToExternalHTML: () => (/* binding */ mr),\n/* harmony export */   blockToNode: () => (/* binding */ ie),\n/* harmony export */   blocksToMarkdown: () => (/* binding */ Gs),\n/* harmony export */   camelToDataKebab: () => (/* binding */ He),\n/* harmony export */   checkBlockHasDefaultProp: () => (/* binding */ uc),\n/* harmony export */   checkBlockIsDefaultType: () => (/* binding */ Cs),\n/* harmony export */   checkBlockIsFileBlock: () => (/* binding */ lc),\n/* harmony export */   checkBlockIsFileBlockWithPlaceholder: () => (/* binding */ pc),\n/* harmony export */   checkBlockIsFileBlockWithPreview: () => (/* binding */ dc),\n/* harmony export */   checkBlockTypeHasDefaultProp: () => (/* binding */ vs),\n/* harmony export */   checkDefaultBlockTypeInSchema: () => (/* binding */ L),\n/* harmony export */   checkDefaultInlineContentTypeInSchema: () => (/* binding */ ys),\n/* harmony export */   checkPageBreakBlocksInSchema: () => (/* binding */ Ss),\n/* harmony export */   cleanHTMLToMarkdown: () => (/* binding */ ht),\n/* harmony export */   combineByGroup: () => (/* binding */ Ec),\n/* harmony export */   contentNodeToInlineContent: () => (/* binding */ _e),\n/* harmony export */   contentNodeToTableContent: () => (/* binding */ Jt),\n/* harmony export */   createAddFileButton: () => (/* binding */ ar),\n/* harmony export */   createBlockSpec: () => (/* binding */ Se),\n/* harmony export */   createBlockSpecFromStronglyTypedTiptapNode: () => (/* binding */ Z),\n/* harmony export */   createDefaultBlockDOMOutputSpec: () => (/* binding */ z),\n/* harmony export */   createExternalHTMLExporter: () => (/* binding */ Ve),\n/* harmony export */   createFigureWithCaption: () => (/* binding */ dt),\n/* harmony export */   createFileBlockWrapper: () => (/* binding */ lt),\n/* harmony export */   createFileNameWithIcon: () => (/* binding */ lr),\n/* harmony export */   createInlineContentSpec: () => (/* binding */ rc),\n/* harmony export */   createInlineContentSpecFromTipTapNode: () => (/* binding */ zn),\n/* harmony export */   createInternalBlockSpec: () => (/* binding */ Kt),\n/* harmony export */   createInternalHTMLSerializer: () => (/* binding */ ir),\n/* harmony export */   createInternalInlineContentSpec: () => (/* binding */ Fn),\n/* harmony export */   createInternalStyleSpec: () => (/* binding */ Zt),\n/* harmony export */   createLinkWithCaption: () => (/* binding */ $e),\n/* harmony export */   createResizableFileBlockWrapper: () => (/* binding */ lo),\n/* harmony export */   createStronglyTypedTiptapNode: () => (/* binding */ W),\n/* harmony export */   createStyleSpec: () => (/* binding */ sc),\n/* harmony export */   createStyleSpecFromTipTapMark: () => (/* binding */ ee),\n/* harmony export */   createSuggestionMenu: () => (/* binding */ bc),\n/* harmony export */   defaultBlockSchema: () => (/* binding */ ks),\n/* harmony export */   defaultBlockSpecs: () => (/* binding */ go),\n/* harmony export */   defaultBlockToHTML: () => (/* binding */ yt),\n/* harmony export */   defaultCodeBlockPropSchema: () => (/* binding */ br),\n/* harmony export */   defaultInlineContentSchema: () => (/* binding */ ws),\n/* harmony export */   defaultInlineContentSpecs: () => (/* binding */ ko),\n/* harmony export */   defaultProps: () => (/* binding */ S),\n/* harmony export */   defaultStyleSchema: () => (/* binding */ cc),\n/* harmony export */   defaultStyleSpecs: () => (/* binding */ bo),\n/* harmony export */   esmDependencies: () => (/* binding */ ce),\n/* harmony export */   fileBlockConfig: () => (/* binding */ Cr),\n/* harmony export */   fileParse: () => (/* binding */ Er),\n/* harmony export */   filePropSchema: () => (/* binding */ yr),\n/* harmony export */   fileRender: () => (/* binding */ vr),\n/* harmony export */   fileToExternalHTML: () => (/* binding */ Sr),\n/* harmony export */   filenameFromURL: () => (/* binding */ nc),\n/* harmony export */   filterSuggestionItems: () => (/* binding */ fc),\n/* harmony export */   formatKeyboardShortcut: () => (/* binding */ K),\n/* harmony export */   formattingToolbarPluginKey: () => (/* binding */ Li),\n/* harmony export */   getBlockFromPos: () => (/* binding */ Rn),\n/* harmony export */   getBlockInfo: () => (/* binding */ ne),\n/* harmony export */   getBlockInfoFromResolvedPos: () => (/* binding */ Ce),\n/* harmony export */   getBlockInfoFromSelection: () => (/* binding */ C),\n/* harmony export */   getBlockInfoWithManualOffset: () => (/* binding */ st),\n/* harmony export */   getBlockNoteExtensions: () => (/* binding */ ka),\n/* harmony export */   getBlockSchemaFromSpecs: () => (/* binding */ Xt),\n/* harmony export */   getColspan: () => (/* binding */ ge),\n/* harmony export */   getDefaultEmojiPickerItems: () => (/* binding */ vc),\n/* harmony export */   getDefaultSlashMenuItems: () => (/* binding */ hc),\n/* harmony export */   getInlineContentParseRules: () => (/* binding */ Wn),\n/* harmony export */   getInlineContentSchemaFromSpecs: () => (/* binding */ Yt),\n/* harmony export */   getNearestBlockPos: () => (/* binding */ X),\n/* harmony export */   getNodeById: () => (/* binding */ D),\n/* harmony export */   getPageBreakSlashMenuItems: () => (/* binding */ gc),\n/* harmony export */   getParseRules: () => (/* binding */ Un),\n/* harmony export */   getRowspan: () => (/* binding */ Ye),\n/* harmony export */   getStyleParseRules: () => (/* binding */ qn),\n/* harmony export */   getStyleSchemaFromSpecs: () => (/* binding */ Qt),\n/* harmony export */   imageBlockConfig: () => (/* binding */ Mr),\n/* harmony export */   imageParse: () => (/* binding */ Ir),\n/* harmony export */   imagePropSchema: () => (/* binding */ xr),\n/* harmony export */   imageRender: () => (/* binding */ Pr),\n/* harmony export */   imageToExternalHTML: () => (/* binding */ Lr),\n/* harmony export */   inheritedProps: () => (/* binding */ qt),\n/* harmony export */   initializeESMDependencies: () => (/* binding */ ut),\n/* harmony export */   inlineContentToNodes: () => (/* binding */ O),\n/* harmony export */   insertOrUpdateBlock: () => (/* binding */ P),\n/* harmony export */   isAppleOS: () => (/* binding */ _n),\n/* harmony export */   isLinkInlineContent: () => (/* binding */ wt),\n/* harmony export */   isPartialLinkInlineContent: () => (/* binding */ it),\n/* harmony export */   isPartialTableCell: () => (/* binding */ me),\n/* harmony export */   isSafari: () => (/* binding */ oc),\n/* harmony export */   isStyledTextInlineContent: () => (/* binding */ J),\n/* harmony export */   isTableCell: () => (/* binding */ at),\n/* harmony export */   isTableCellSelection: () => (/* binding */ It),\n/* harmony export */   linkToolbarPluginKey: () => (/* binding */ Ri),\n/* harmony export */   mapTableCell: () => (/* binding */ Je),\n/* harmony export */   mappingFactory: () => (/* binding */ Cc),\n/* harmony export */   markdownToBlocks: () => (/* binding */ Qs),\n/* harmony export */   markdownToHTML: () => (/* binding */ Po),\n/* harmony export */   mergeCSSClasses: () => (/* binding */ Y),\n/* harmony export */   nodeToBlock: () => (/* binding */ E),\n/* harmony export */   nodeToCustomInlineContent: () => (/* binding */ Ze),\n/* harmony export */   pageBreakConfig: () => (/* binding */ Nr),\n/* harmony export */   pageBreakParse: () => (/* binding */ Dr),\n/* harmony export */   pageBreakRender: () => (/* binding */ Hr),\n/* harmony export */   pageBreakSchema: () => (/* binding */ wo),\n/* harmony export */   pageBreakToExternalHTML: () => (/* binding */ Or),\n/* harmony export */   parseEmbedElement: () => (/* binding */ xt),\n/* harmony export */   parseFigureElement: () => (/* binding */ Ue),\n/* harmony export */   partialBlockToBlockForTesting: () => (/* binding */ Ro),\n/* harmony export */   partialBlocksToBlocksForTesting: () => (/* binding */ Sc),\n/* harmony export */   propsToAttributes: () => (/* binding */ Ee),\n/* harmony export */   shikiHighlighterPromiseSymbol: () => (/* binding */ We),\n/* harmony export */   shikiParserSymbol: () => (/* binding */ Bt),\n/* harmony export */   sideMenuPluginKey: () => (/* binding */ Qi),\n/* harmony export */   stylePropsToAttributes: () => (/* binding */ jn),\n/* harmony export */   tableContentToNodes: () => (/* binding */ Re),\n/* harmony export */   tableHandlesPluginKey: () => (/* binding */ fe),\n/* harmony export */   updateBlock: () => (/* binding */ tr),\n/* harmony export */   updateBlockCommand: () => (/* binding */ x),\n/* harmony export */   uploadToTmpFilesDotOrg_DEV_ONLY: () => (/* binding */ ic),\n/* harmony export */   videoBlockConfig: () => (/* binding */ hs),\n/* harmony export */   videoParse: () => (/* binding */ ms),\n/* harmony export */   videoPropSchema: () => (/* binding */ us),\n/* harmony export */   videoRender: () => (/* binding */ fs),\n/* harmony export */   videoToExternalHTML: () => (/* binding */ gs),\n/* harmony export */   withPageBreak: () => (/* binding */ mc),\n/* harmony export */   wrapInBlockStructure: () => (/* binding */ Te)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var prosemirror_highlight__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! prosemirror-highlight */ \"(app-pages-browser)/./node_modules/prosemirror-highlight/dist/index.js\");\n/* harmony import */ var prosemirror_highlight_shiki__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! prosemirror-highlight/shiki */ \"(app-pages-browser)/./node_modules/prosemirror-highlight/dist/shiki.js\");\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-tables */ \"(app-pages-browser)/./node_modules/prosemirror-tables/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(app-pages-browser)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-code */ \"(app-pages-browser)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(app-pages-browser)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(app-pages-browser)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(app-pages-browser)/./node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_cell__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-table-cell */ \"(app-pages-browser)/./node_modules/@tiptap/extension-table-cell/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_header__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-table-header */ \"(app-pages-browser)/./node_modules/@tiptap/extension-table-header/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_row__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-table-row */ \"(app-pages-browser)/./node_modules/@tiptap/extension-table-row/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"(app-pages-browser)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ \"(app-pages-browser)/./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-link */ \"(app-pages-browser)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-text */ \"(app-pages-browser)/./node_modules/@tiptap/extension-text/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-collaboration */ \"(app-pages-browser)/./node_modules/@tiptap/extension-collaboration/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-collaboration-cursor */ \"(app-pages-browser)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! prosemirror-view */ \"(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(app-pages-browser)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n/* harmony import */ var _en_B7ycW7c8_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./en-B7ycW7c8.js */ \"(app-pages-browser)/./node_modules/@blocknote/core/dist/en-B7ycW7c8.js\");\nvar Vo = Object.defineProperty;\nvar Uo = (e, o, t) => o in e ? Vo(e, o, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[o] = t;\nvar u = (e, o, t) => Uo(e, typeof o != \"symbol\" ? o + \"\" : o, t);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass $ extends Error {\n  constructor(o) {\n    super(`Unreachable case: ${o}`);\n  }\n}\nfunction tc(e, o = !0) {\n  const { \"data-test\": t, ...n } = e;\n  if (Object.keys(n).length > 0 && o)\n    throw new Error(\"Object must be empty \" + JSON.stringify(e));\n}\nfunction X(e, o) {\n  const t = e.resolve(o);\n  if (t.nodeAfter && t.nodeAfter.type.isInGroup(\"bnBlock\"))\n    return {\n      posBeforeNode: t.pos,\n      node: t.nodeAfter\n    };\n  let n = t.depth, r = t.node(n);\n  for (; n > 0; ) {\n    if (r.type.isInGroup(\"bnBlock\"))\n      return {\n        posBeforeNode: t.before(n),\n        node: r\n      };\n    n--, r = t.node(n);\n  }\n  const s = [];\n  e.descendants((a, c) => {\n    a.type.isInGroup(\"bnBlock\") && s.push(c);\n  }), console.warn(`Position ${o} is not within a blockContainer node.`);\n  const i = e.resolve(\n    s.find((a) => a >= o) || s[s.length - 1]\n  );\n  return {\n    posBeforeNode: i.pos,\n    node: i.nodeAfter\n  };\n}\nfunction st(e, o) {\n  if (!e.type.isInGroup(\"bnBlock\"))\n    throw new Error(\n      `Attempted to get bnBlock node at position but found node of different type ${e.type}`\n    );\n  const t = e, n = o, r = n + t.nodeSize, s = {\n    node: t,\n    beforePos: n,\n    afterPos: r\n  };\n  if (t.type.name === \"blockContainer\") {\n    let i, a;\n    if (t.forEach((c, l) => {\n      if (c.type.spec.group === \"blockContent\") {\n        const d = c, p = n + l + 1, h = p + c.nodeSize;\n        i = {\n          node: d,\n          beforePos: p,\n          afterPos: h\n        };\n      } else if (c.type.name === \"blockGroup\") {\n        const d = c, p = n + l + 1, h = p + c.nodeSize;\n        a = {\n          node: d,\n          beforePos: p,\n          afterPos: h\n        };\n      }\n    }), !i)\n      throw new Error(\n        `blockContainer node does not contain a blockContent node in its children: ${t}`\n      );\n    return {\n      isBlockContainer: !0,\n      bnBlock: s,\n      blockContent: i,\n      childContainer: a,\n      blockNoteType: i.node.type.name\n    };\n  } else {\n    if (!s.node.type.isInGroup(\"childContainer\"))\n      throw new Error(\n        `bnBlock node is not in the childContainer group: ${s.node}`\n      );\n    return {\n      isBlockContainer: !1,\n      bnBlock: s,\n      childContainer: s,\n      blockNoteType: s.node.type.name\n    };\n  }\n}\nfunction ne(e) {\n  return st(e.node, e.posBeforeNode);\n}\nfunction Ce(e) {\n  if (!e.nodeAfter)\n    throw new Error(\n      `Attempted to get blockContainer node at position ${e.pos} but a node at this position does not exist`\n    );\n  return st(e.nodeAfter, e.pos);\n}\nfunction C(e) {\n  const o = X(e.doc, e.selection.anchor);\n  return ne(o);\n}\nfunction Dn(e, o = JSON.stringify) {\n  const t = {};\n  return e.filter((n) => {\n    const r = o(n);\n    return Object.prototype.hasOwnProperty.call(t, r) ? !1 : t[r] = !0;\n  });\n}\nfunction On(e) {\n  const o = e.filter(\n    (n, r) => e.indexOf(n) !== r\n  );\n  return Dn(o);\n}\nconst ve = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"uniqueID\",\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 1e4,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      setIdAttribute: !1,\n      generateID: () => {\n        if (typeof window < \"u\" && window.__TEST_OPTIONS) {\n          const e = window.__TEST_OPTIONS;\n          return e.mockID === void 0 ? e.mockID = 0 : e.mockID++, e.mockID.toString();\n        }\n        return (0,uuid__WEBPACK_IMPORTED_MODULE_16__[\"default\"])();\n      },\n      filterTransaction: null\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (e) => e.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (e) => {\n              const o = {\n                [`data-${this.options.attributeName}`]: e[this.options.attributeName]\n              };\n              return this.options.setIdAttribute ? {\n                ...o,\n                id: e[this.options.attributeName]\n              } : o;\n            }\n          }\n        }\n      }\n    ];\n  },\n  // check initial content for missing ids\n  // onCreate() {\n  //   // Don’t do this when the collaboration extension is active\n  //   // because this may update the content, so Y.js tries to merge these changes.\n  //   // This leads to empty block nodes.\n  //   // See: https://github.com/ueberdosis/tiptap/issues/2400\n  //   if (\n  //     this.editor.extensionManager.extensions.find(\n  //       (extension) => extension.name === \"collaboration\"\n  //     )\n  //   ) {\n  //     return;\n  //   }\n  //   const { view, state } = this.editor;\n  //   const { tr, doc } = state;\n  //   const { types, attributeName, generateID } = this.options;\n  //   const nodesWithoutId = findChildren(doc, (node) => {\n  //     return (\n  //       types.includes(node.type.name) && node.attrs[attributeName] === null\n  //     );\n  //   });\n  //   nodesWithoutId.forEach(({ node, pos }) => {\n  //     tr.setNodeMarkup(pos, undefined, {\n  //       ...node.attrs,\n  //       [attributeName]: generateID(),\n  //     });\n  //   });\n  //   tr.setMeta(\"addToHistory\", false);\n  //   view.dispatch(tr);\n  // },\n  addProseMirrorPlugins() {\n    let e = null, o = !1;\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"uniqueID\"),\n        appendTransaction: (t, n, r) => {\n          const s = t.some((m) => m.docChanged) && !n.doc.eq(r.doc), i = this.options.filterTransaction && t.some((m) => {\n            let g, b;\n            return !(!((b = (g = this.options).filterTransaction) === null || b === void 0) && b.call(g, m));\n          });\n          if (!s || i)\n            return;\n          const { tr: a } = r, { types: c, attributeName: l, generateID: d } = this.options, p = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.combineTransactionSteps)(\n            n.doc,\n            t\n          ), { mapping: h } = p;\n          if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.getChangedRanges)(p).forEach(({ newRange: m }) => {\n            const g = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.findChildrenInRange)(\n              r.doc,\n              m,\n              (w) => c.includes(w.type.name)\n            ), b = g.map(({ node: w }) => w.attrs[l]).filter((w) => w !== null), k = On(b);\n            g.forEach(({ node: w, pos: y }) => {\n              let T;\n              const F = (T = a.doc.nodeAt(y)) === null || T === void 0 ? void 0 : T.attrs[l];\n              if (F === null) {\n                const v = n.doc.type.createAndFill().content;\n                if (n.doc.content.findDiffStart(v) === null) {\n                  const ae = JSON.parse(\n                    JSON.stringify(r.doc.toJSON())\n                  );\n                  if (ae.content[0].content[0].attrs.id = \"initialBlockId\", JSON.stringify(ae.content) === JSON.stringify(v.toJSON())) {\n                    a.setNodeMarkup(y, void 0, {\n                      ...w.attrs,\n                      [l]: \"initialBlockId\"\n                    });\n                    return;\n                  }\n                }\n                a.setNodeMarkup(y, void 0, {\n                  ...w.attrs,\n                  [l]: d()\n                });\n                return;\n              }\n              const { deleted: j } = h.invert().mapResult(y);\n              j && k.includes(F) && a.setNodeMarkup(y, void 0, {\n                ...w.attrs,\n                [l]: d()\n              });\n            });\n          }), !!a.steps.length)\n            return a;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(t) {\n          const n = (r) => {\n            let s;\n            e = !((s = t.dom.parentElement) === null || s === void 0) && s.contains(r.target) ? t.dom.parentElement : null;\n          };\n          return window.addEventListener(\"dragstart\", n), {\n            destroy() {\n              window.removeEventListener(\"dragstart\", n);\n            }\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted` so we can do\n          // some checks before. However, `transformPasted` only runs when\n          // editor content is pasted - not external content.\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (t, n) => {\n              let r;\n              return e !== t.dom.parentElement || ((r = n.dataTransfer) === null || r === void 0 ? void 0 : r.effectAllowed) === \"copy\" ? o = !0 : o = !1, e = null, !1;\n            },\n            // always create new ids on pasted content\n            paste: () => (o = !0, !1)\n          },\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (t) => {\n            if (!o)\n              return t;\n            const { types: n, attributeName: r } = this.options, s = (i) => {\n              const a = [];\n              return i.forEach((c) => {\n                if (c.isText) {\n                  a.push(c);\n                  return;\n                }\n                if (!n.includes(c.type.name)) {\n                  a.push(c.copy(s(c.content)));\n                  return;\n                }\n                const l = c.type.create(\n                  {\n                    ...c.attrs,\n                    [r]: null\n                  },\n                  s(c.content),\n                  c.marks\n                );\n                a.push(l);\n              }), prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(a);\n            };\n            return o = !1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Slice(\n              s(t.content),\n              t.openStart,\n              t.openEnd\n            );\n          }\n        }\n      })\n    ];\n  }\n});\nfunction wt(e) {\n  return e.type === \"link\";\n}\nfunction it(e) {\n  return typeof e != \"string\" && e.type === \"link\";\n}\nfunction J(e) {\n  return typeof e != \"string\" && e.type === \"text\";\n}\nfunction Je(e) {\n  var o, t, n, r, s;\n  return at(e) ? { ...e } : me(e) ? {\n    type: \"tableCell\",\n    content: [].concat(e.content),\n    props: {\n      backgroundColor: ((o = e.props) == null ? void 0 : o.backgroundColor) ?? \"default\",\n      textColor: ((t = e.props) == null ? void 0 : t.textColor) ?? \"default\",\n      textAlignment: ((n = e.props) == null ? void 0 : n.textAlignment) ?? \"left\",\n      colspan: ((r = e.props) == null ? void 0 : r.colspan) ?? 1,\n      rowspan: ((s = e.props) == null ? void 0 : s.rowspan) ?? 1\n    }\n  } : {\n    type: \"tableCell\",\n    content: [].concat(e),\n    props: {\n      backgroundColor: \"default\",\n      textColor: \"default\",\n      textAlignment: \"left\",\n      colspan: 1,\n      rowspan: 1\n    }\n  };\n}\nfunction me(e) {\n  return e != null && typeof e != \"string\" && !Array.isArray(e) && e.type === \"tableCell\";\n}\nfunction at(e) {\n  return me(e) && e.props !== void 0 && e.content !== void 0;\n}\nfunction ge(e) {\n  return at(e) ? e.props.colspan ?? 1 : 1;\n}\nfunction Ye(e) {\n  return at(e) ? e.props.rowspan ?? 1 : 1;\n}\nconst _n = () => typeof navigator < \"u\" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent));\nfunction K(e, o = \"Ctrl\") {\n  return _n() ? e.replace(\"Mod\", \"⌘\") : e.replace(\"Mod\", o);\n}\nfunction Y(...e) {\n  return e.filter((o) => o).join(\" \");\n}\nconst oc = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nfunction z(e, o, t, n) {\n  const r = document.createElement(\"div\");\n  r.className = Y(\n    \"bn-block-content\",\n    t.class\n  ), r.setAttribute(\"data-content-type\", e);\n  for (const [i, a] of Object.entries(t))\n    i !== \"class\" && r.setAttribute(i, a);\n  const s = document.createElement(o);\n  s.className = Y(\n    \"bn-inline-content\",\n    n.class\n  );\n  for (const [i, a] of Object.entries(\n    n\n  ))\n    i !== \"class\" && s.setAttribute(i, a);\n  return r.appendChild(s), {\n    dom: r,\n    contentDOM: s\n  };\n}\nconst yt = (e, o) => {\n  let t = ie(e, o.pmSchema, o.schema.styleSchema);\n  t.type.name === \"blockContainer\" && (t = t.firstChild);\n  const n = o.pmSchema.nodes[t.type.name].spec.toDOM;\n  if (n === void 0)\n    throw new Error(\n      \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\"\n    );\n  const r = n(t);\n  if (typeof r != \"object\" || !(\"dom\" in r))\n    throw new Error(\n      \"Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property.\"\n    );\n  return r;\n}, S = {\n  backgroundColor: {\n    default: \"default\"\n  },\n  textColor: {\n    default: \"default\"\n  },\n  textAlignment: {\n    default: \"left\",\n    values: [\"left\", \"center\", \"right\", \"justify\"]\n  }\n}, qt = [\"backgroundColor\", \"textColor\"];\nfunction He(e) {\n  return \"data-\" + e.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction nc(e) {\n  const o = e.split(\"/\");\n  return !o.length || // invalid?\n  o[o.length - 1] === \"\" ? e : o[o.length - 1];\n}\nfunction Ee(e) {\n  const o = {};\n  return Object.entries(e).filter(([t, n]) => !qt.includes(t)).forEach(([t, n]) => {\n    o[t] = {\n      default: n.default,\n      keepOnSplit: !0,\n      // Props are displayed in kebab-case as HTML attributes. If a prop's\n      // value is the same as its default, we don't display an HTML\n      // attribute for it.\n      parseHTML: (r) => {\n        const s = r.getAttribute(He(t));\n        if (s === null)\n          return null;\n        if (n.default === void 0 && n.type === \"boolean\" || n.default !== void 0 && typeof n.default == \"boolean\")\n          return s === \"true\" ? !0 : s === \"false\" ? !1 : null;\n        if (n.default === void 0 && n.type === \"number\" || n.default !== void 0 && typeof n.default == \"number\") {\n          const i = parseFloat(s);\n          return !Number.isNaN(i) && Number.isFinite(i) ? i : null;\n        }\n        return s;\n      },\n      renderHTML: (r) => r[t] !== n.default ? {\n        [He(t)]: r[t]\n      } : {}\n    };\n  }), o;\n}\nfunction Rn(e, o, t, n) {\n  if (typeof e == \"boolean\")\n    throw new Error(\n      \"Cannot find node position as getPos is a boolean, not a function.\"\n    );\n  const r = e(), i = t.state.doc.resolve(r).node().attrs.id;\n  if (!i)\n    throw new Error(\"Block doesn't have id\");\n  const a = o.getBlock(i);\n  if (a.type !== n)\n    throw new Error(\"Block type does not match\");\n  return a;\n}\nfunction Te(e, o, t, n, r = !1, s) {\n  const i = document.createElement(\"div\");\n  if (s !== void 0)\n    for (const [a, c] of Object.entries(s))\n      a !== \"class\" && i.setAttribute(a, c);\n  i.className = Y(\n    \"bn-block-content\",\n    (s == null ? void 0 : s.class) || \"\"\n  ), i.setAttribute(\"data-content-type\", o);\n  for (const [a, c] of Object.entries(t)) {\n    const d = n[a].default;\n    !qt.includes(a) && c !== d && i.setAttribute(He(a), c);\n  }\n  return r && i.setAttribute(\"data-file-block\", \"\"), i.appendChild(e.dom), e.contentDOM !== void 0 && (e.contentDOM.className = Y(\n    \"bn-inline-content\",\n    e.contentDOM.className\n  ), e.contentDOM.setAttribute(\"data-editable\", \"\")), {\n    ...e,\n    dom: i\n  };\n}\nfunction W(e) {\n  return _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Node.create(e);\n}\nfunction Kt(e, o) {\n  return {\n    config: e,\n    implementation: o\n  };\n}\nfunction Z(e, o, t) {\n  return Kt(\n    {\n      type: e.name,\n      content: e.config.content === \"inline*\" ? \"inline\" : e.config.content === \"tableRow+\" ? \"table\" : \"none\",\n      propSchema: o\n    },\n    {\n      node: e,\n      requiredExtensions: t,\n      toInternalHTML: yt,\n      toExternalHTML: yt\n      // parse: () => undefined, // parse rules are in node already\n    }\n  );\n}\nfunction Xt(e) {\n  return Object.fromEntries(\n    Object.entries(e).map(([o, t]) => [o, t.config])\n  );\n}\nfunction Vn(e, o) {\n  e.stopEvent = (t) => (t.type === \"mousedown\" && setTimeout(() => {\n    o.view.dom.blur();\n  }, 10), !0);\n}\nfunction Un(e, o) {\n  const t = [\n    {\n      tag: \"[data-content-type=\" + e.type + \"]\",\n      contentElement: \"[data-editable]\"\n    }\n  ];\n  return o && t.push({\n    tag: \"*\",\n    getAttrs(n) {\n      if (typeof n == \"string\")\n        return !1;\n      const r = o == null ? void 0 : o(n);\n      return r === void 0 ? !1 : r;\n    }\n  }), t;\n}\nfunction Se(e, o) {\n  const t = W({\n    name: e.type,\n    content: e.content === \"inline\" ? \"inline*\" : \"\",\n    group: \"blockContent\",\n    selectable: e.isSelectable ?? !0,\n    isolating: !0,\n    addAttributes() {\n      return Ee(e.propSchema);\n    },\n    parseHTML() {\n      return Un(e, o.parse);\n    },\n    renderHTML({ HTMLAttributes: n }) {\n      const r = document.createElement(\"div\");\n      return Te(\n        {\n          dom: r,\n          contentDOM: e.content === \"inline\" ? r : void 0\n        },\n        e.type,\n        {},\n        e.propSchema,\n        e.isFileBlock,\n        n\n      );\n    },\n    addNodeView() {\n      return ({ getPos: n }) => {\n        var l;\n        const r = this.options.editor, s = Rn(\n          n,\n          r,\n          this.editor,\n          e.type\n        ), i = ((l = this.options.domAttributes) == null ? void 0 : l.blockContent) || {}, a = o.render(s, r), c = Te(\n          a,\n          s.type,\n          s.props,\n          e.propSchema,\n          i\n        );\n        return e.isSelectable === !1 && Vn(c, this.editor), c;\n      };\n    }\n  });\n  if (t.name !== e.type)\n    throw new Error(\n      \"Node name does not match block type. This is a bug in BlockNote.\"\n    );\n  return Kt(e, {\n    node: t,\n    toInternalHTML: (n, r) => {\n      var a;\n      const s = ((a = t.options.domAttributes) == null ? void 0 : a.blockContent) || {}, i = o.render(n, r);\n      return Te(\n        i,\n        n.type,\n        n.props,\n        e.propSchema,\n        e.isFileBlock,\n        s\n      );\n    },\n    // TODO: this should not have wrapInBlockStructure and generally be a lot simpler\n    // post-processing in externalHTMLExporter should not be necessary\n    toExternalHTML: (n, r) => {\n      var a, c;\n      const s = ((a = t.options.domAttributes) == null ? void 0 : a.blockContent) || {};\n      let i = (c = o.toExternalHTML) == null ? void 0 : c.call(\n        o,\n        n,\n        r\n      );\n      return i === void 0 && (i = o.render(n, r)), Te(\n        i,\n        n.type,\n        n.props,\n        e.propSchema,\n        s\n      );\n    }\n  });\n}\nfunction Jt(e, o, t) {\n  var s, i;\n  const n = {\n    type: \"tableContent\",\n    columnWidths: [],\n    headerRows: void 0,\n    headerCols: void 0,\n    rows: []\n  }, r = [];\n  e.content.forEach((a, c, l) => {\n    const d = {\n      cells: []\n    };\n    l === 0 && a.content.forEach((p) => {\n      let h = p.attrs.colwidth;\n      h == null && (h = new Array(p.attrs.colspan ?? 1).fill(void 0)), n.columnWidths.push(...h);\n    }), d.cells = a.content.content.map((p, h) => (r[l] || (r[l] = []), r[l][h] = p.type.name === \"tableHeader\", {\n      type: \"tableCell\",\n      content: p.content.content.map(\n        (m) => _e(m, o, t)\n      ).reduce((m, g) => {\n        if (!m.length)\n          return g;\n        const b = m[m.length - 1], k = g[0];\n        return k && J(b) && J(k) && JSON.stringify(b.styles) === JSON.stringify(k.styles) ? (b.text += `\n` + k.text, m.push(...g.slice(1)), m) : (m.push(...g), m);\n      }, []),\n      props: {\n        colspan: p.attrs.colspan,\n        rowspan: p.attrs.rowspan,\n        backgroundColor: p.attrs.backgroundColor,\n        textColor: p.attrs.textColor,\n        textAlignment: p.attrs.textAlignment\n      }\n    })), n.rows.push(d);\n  });\n  for (let a = 0; a < r.length; a++)\n    (s = r[a]) != null && s.every((c) => c) && (n.headerRows = (n.headerRows ?? 0) + 1);\n  for (let a = 0; a < ((i = r[0]) == null ? void 0 : i.length); a++)\n    r != null && r.every((c) => c[a]) && (n.headerCols = (n.headerCols ?? 0) + 1);\n  return n;\n}\nfunction _e(e, o, t) {\n  const n = [];\n  let r;\n  return e.content.forEach((s) => {\n    if (s.type.name === \"hardBreak\") {\n      if (r)\n        if (J(r))\n          r.text += `\n`;\n        else if (wt(r))\n          r.content[r.content.length - 1].text += `\n`;\n        else\n          throw new Error(\"unexpected\");\n      else\n        r = {\n          type: \"text\",\n          text: `\n`,\n          styles: {}\n        };\n      return;\n    }\n    if (s.type.name !== \"link\" && s.type.name !== \"text\") {\n      if (!o[s.type.name]) {\n        console.warn(\"unrecognized inline content type\", s.type.name);\n        return;\n      }\n      r && (n.push(r), r = void 0), n.push(\n        Ze(s, o, t)\n      );\n      return;\n    }\n    const i = {};\n    let a;\n    for (const c of s.marks)\n      if (c.type.name === \"link\")\n        a = c;\n      else {\n        const l = t[c.type.name];\n        if (!l) {\n          if (c.type.spec.blocknoteIgnore)\n            continue;\n          throw new Error(`style ${c.type.name} not found in styleSchema`);\n        }\n        if (l.propSchema === \"boolean\")\n          i[l.type] = !0;\n        else if (l.propSchema === \"string\")\n          i[l.type] = c.attrs.stringValue;\n        else\n          throw new $(l.propSchema);\n      }\n    r ? J(r) ? a ? (n.push(r), r = {\n      type: \"link\",\n      href: a.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: s.textContent,\n          styles: i\n        }\n      ]\n    }) : JSON.stringify(r.styles) === JSON.stringify(i) ? r.text += s.textContent : (n.push(r), r = {\n      type: \"text\",\n      text: s.textContent,\n      styles: i\n    }) : wt(r) && (a ? r.href === a.attrs.href ? JSON.stringify(\n      r.content[r.content.length - 1].styles\n    ) === JSON.stringify(i) ? r.content[r.content.length - 1].text += s.textContent : r.content.push({\n      type: \"text\",\n      text: s.textContent,\n      styles: i\n    }) : (n.push(r), r = {\n      type: \"link\",\n      href: a.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: s.textContent,\n          styles: i\n        }\n      ]\n    }) : (n.push(r), r = {\n      type: \"text\",\n      text: s.textContent,\n      styles: i\n    })) : a ? r = {\n      type: \"link\",\n      href: a.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: s.textContent,\n          styles: i\n        }\n      ]\n    } : r = {\n      type: \"text\",\n      text: s.textContent,\n      styles: i\n    };\n  }), r && n.push(r), n;\n}\nfunction Ze(e, o, t) {\n  if (e.type.name === \"text\" || e.type.name === \"link\")\n    throw new Error(\"unexpected\");\n  const n = {}, r = o[e.type.name];\n  for (const [a, c] of Object.entries(e.attrs)) {\n    if (!r)\n      throw Error(\"ic node is of an unrecognized type: \" + e.type.name);\n    const l = r.propSchema;\n    a in l && (n[a] = c);\n  }\n  let s;\n  return r.content === \"styled\" ? s = _e(\n    e,\n    o,\n    t\n  ) : s = void 0, {\n    type: e.type.name,\n    props: n,\n    content: s\n  };\n}\nfunction E(e, o, t, n, r) {\n  var m;\n  if (!e.type.isInGroup(\"bnBlock\"))\n    throw Error(\n      \"Node must be in bnBlock group, but is of type\" + e.type.name\n    );\n  const s = r == null ? void 0 : r.get(e);\n  if (s)\n    return s;\n  const i = st(e, 0);\n  let a = i.bnBlock.node.attrs.id;\n  a === null && (a = ve.options.generateID());\n  const c = o[i.blockNoteType];\n  if (!c)\n    throw Error(\"Block is of an unrecognized type: \" + i.blockNoteType);\n  const l = {};\n  for (const [g, b] of Object.entries({\n    ...e.attrs,\n    ...i.isBlockContainer ? i.blockContent.node.attrs : {}\n  })) {\n    const k = c.propSchema;\n    g in k && !(k[g].default === void 0 && b === void 0) && (l[g] = b);\n  }\n  const d = o[i.blockNoteType], p = [];\n  (m = i.childContainer) == null || m.node.forEach((g) => {\n    p.push(\n      E(\n        g,\n        o,\n        t,\n        n,\n        r\n      )\n    );\n  });\n  let h;\n  if (d.content === \"inline\") {\n    if (!i.isBlockContainer)\n      throw new Error(\"impossible\");\n    h = _e(\n      i.blockContent.node,\n      t,\n      n\n    );\n  } else if (d.content === \"table\") {\n    if (!i.isBlockContainer)\n      throw new Error(\"impossible\");\n    h = Jt(\n      i.blockContent.node,\n      t,\n      n\n    );\n  } else if (d.content === \"none\")\n    h = void 0;\n  else\n    throw new $(d.content);\n  const f = {\n    id: a,\n    type: d.type,\n    props: l,\n    content: h,\n    children: p\n  };\n  return r == null || r.set(e, f), f;\n}\nfunction Ct(e, o, t, n) {\n  return e.dom.setAttribute(\"data-inline-content-type\", o), Object.entries(t).filter(([r, s]) => {\n    const i = n[r];\n    return s !== i.default;\n  }).map(([r, s]) => [He(r), s]).forEach(([r, s]) => e.dom.setAttribute(r, s)), e.contentDOM !== void 0 && e.contentDOM.setAttribute(\"data-editable\", \"\"), e;\n}\nfunction $n(e) {\n  return {\n    Backspace: ({ editor: o }) => {\n      const t = o.state.selection.$from;\n      return o.state.selection.empty && t.node().type.name === e.type && t.parentOffset === 0;\n    }\n  };\n}\nfunction Fn(e, o) {\n  return {\n    config: e,\n    implementation: o\n  };\n}\nfunction zn(e, o) {\n  return Fn(\n    {\n      type: e.name,\n      propSchema: o,\n      content: e.config.content === \"inline*\" ? \"styled\" : \"none\"\n    },\n    {\n      node: e\n    }\n  );\n}\nfunction Yt(e) {\n  return Object.fromEntries(\n    Object.entries(e).map(([o, t]) => [o, t.config])\n  );\n}\nfunction Wn(e) {\n  return [\n    {\n      tag: `[data-inline-content-type=\"${e.type}\"]`,\n      contentElement: (o) => {\n        const t = o;\n        return t.matches(\"[data-editable]\") ? t : t.querySelector(\"[data-editable]\") || t;\n      }\n    }\n  ];\n}\nfunction rc(e, o) {\n  const t = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Node.create({\n    name: e.type,\n    inline: !0,\n    group: \"inline\",\n    selectable: e.content === \"styled\",\n    atom: e.content === \"none\",\n    content: e.content === \"styled\" ? \"inline*\" : \"\",\n    addAttributes() {\n      return Ee(e.propSchema);\n    },\n    addKeyboardShortcuts() {\n      return $n(e);\n    },\n    parseHTML() {\n      return Wn(e);\n    },\n    renderHTML({ node: n }) {\n      const r = this.options.editor, s = o.render(\n        Ze(\n          n,\n          r.schema.inlineContentSchema,\n          r.schema.styleSchema\n        ),\n        // TODO: fix cast\n        () => {\n        },\n        r\n      );\n      return Ct(\n        s,\n        e.type,\n        n.attrs,\n        e.propSchema\n      );\n    },\n    addNodeView() {\n      return ({ node: n, getPos: r }) => {\n        const s = this.options.editor, i = o.render(\n          Ze(\n            n,\n            s.schema.inlineContentSchema,\n            s.schema.styleSchema\n          ),\n          // TODO: fix cast\n          (a) => {\n            if (typeof r == \"boolean\")\n              return;\n            const c = O(\n              [a],\n              s._tiptapEditor.schema,\n              s.schema.styleSchema\n            );\n            s.dispatch(\n              s.prosemirrorView.state.tr.replaceWith(\n                r(),\n                r() + n.nodeSize,\n                c\n              )\n            );\n          },\n          s\n        );\n        return Ct(\n          i,\n          e.type,\n          n.attrs,\n          e.propSchema\n        );\n      };\n    }\n  });\n  return zn(\n    t,\n    e.propSchema\n  );\n}\nfunction jn(e) {\n  return e === \"boolean\" ? {} : {\n    stringValue: {\n      default: void 0,\n      keepOnSplit: !0,\n      parseHTML: (o) => o.getAttribute(\"data-value\"),\n      renderHTML: (o) => o.stringValue !== void 0 ? {\n        \"data-value\": o.stringValue\n      } : {}\n    }\n  };\n}\nfunction Gn(e, o, t, n) {\n  return e.dom.setAttribute(\"data-style-type\", o), n === \"string\" && e.dom.setAttribute(\"data-value\", t), e.contentDOM !== void 0 && e.contentDOM.setAttribute(\"data-editable\", \"\"), e;\n}\nfunction Zt(e, o) {\n  return {\n    config: e,\n    implementation: o\n  };\n}\nfunction ee(e, o) {\n  return Zt(\n    {\n      type: e.name,\n      propSchema: o\n    },\n    {\n      mark: e\n    }\n  );\n}\nfunction Qt(e) {\n  return Object.fromEntries(\n    Object.entries(e).map(([o, t]) => [o, t.config])\n  );\n}\nfunction qn(e) {\n  return [\n    {\n      tag: `[data-style-type=\"${e.type}\"]`,\n      contentElement: (o) => {\n        const t = o;\n        return t.matches(\"[data-editable]\") ? t : t.querySelector(\"[data-editable]\") || t;\n      }\n    }\n  ];\n}\nfunction sc(e, o) {\n  const t = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Mark.create({\n    name: e.type,\n    addAttributes() {\n      return jn(e.propSchema);\n    },\n    parseHTML() {\n      return qn(e);\n    },\n    renderHTML({ mark: n }) {\n      let r;\n      if (e.propSchema === \"boolean\")\n        r = o.render();\n      else if (e.propSchema === \"string\")\n        r = o.render(n.attrs.stringValue);\n      else\n        throw new $(e.propSchema);\n      return Gn(\n        r,\n        e.type,\n        n.attrs.stringValue,\n        e.propSchema\n      );\n    }\n  });\n  return Zt(e, {\n    mark: t\n  });\n}\nfunction Q(e) {\n  const { height: o, width: t } = ct(e), n = new Array(o).fill(!1).map(() => new Array(t).fill(null)), r = (s, i) => {\n    for (let a = s; a < o; a++)\n      for (let c = i; c < t; c++)\n        if (!n[a][c])\n          return { row: a, col: c };\n    throw new Error(\n      \"Unable to create occupancy grid for table, no more available cells\"\n    );\n  };\n  for (let s = 0; s < e.content.rows.length; s++)\n    for (let i = 0; i < e.content.rows[s].cells.length; i++) {\n      const a = Je(e.content.rows[s].cells[i]), c = Ye(a), l = ge(a), { row: d, col: p } = r(s, i);\n      for (let h = d; h < d + c; h++)\n        for (let f = p; f < p + l; f++) {\n          if (n[h][f])\n            throw new Error(\n              `Unable to create occupancy grid for table, cell at ${h},${f} is already occupied`\n            );\n          n[h][f] = {\n            row: s,\n            col: i,\n            rowspan: c,\n            colspan: l,\n            cell: a\n          };\n        }\n    }\n  return n;\n}\nfunction be(e) {\n  const o = /* @__PURE__ */ new Set();\n  return e.map((t) => ({\n    cells: t.map((n) => o.has(n.row + \":\" + n.col) ? !1 : (o.add(n.row + \":\" + n.col), n.cell)).filter((n) => n !== !1)\n  }));\n}\nfunction re(e, o, t = Q(o)) {\n  for (let n = 0; n < t.length; n++)\n    for (let r = 0; r < t[n].length; r++) {\n      const s = t[n][r];\n      if (s.row === e.row && s.col === e.col)\n        return { row: n, col: r, cell: s.cell };\n    }\n  throw new Error(\n    `Unable to resolve relative table cell indices for table, cell at ${e.row},${e.col} is not occupied`\n  );\n}\nfunction ct(e) {\n  const o = e.content.rows.length;\n  let t = 0;\n  return e.content.rows.forEach((n) => {\n    let r = 0;\n    n.cells.forEach((s) => {\n      r += ge(s);\n    }), t = Math.max(t, r);\n  }), { height: o, width: t };\n}\nfunction eo(e, o, t = Q(o)) {\n  var r;\n  const n = (r = t[e.row]) == null ? void 0 : r[e.col];\n  if (n)\n    return {\n      row: n.row,\n      col: n.col,\n      cell: n.cell\n    };\n}\nfunction Qe(e, o) {\n  var s;\n  const t = Q(e);\n  if (o < 0 || o >= t.length)\n    return [];\n  let n = 0;\n  for (let i = 0; i < o; i++) {\n    const a = (s = t[n]) == null ? void 0 : s[0];\n    if (!a)\n      return [];\n    n += a.rowspan;\n  }\n  const r = new Array(t[0].length).fill(!1).map((i, a) => eo(\n    { row: n, col: a },\n    e,\n    t\n  )).filter(\n    (i) => i !== void 0\n  );\n  return r.filter((i, a) => r.findIndex((c) => c.row === i.row && c.col === i.col) === a);\n}\nfunction et(e, o) {\n  var s;\n  const t = Q(e);\n  if (o < 0 || o >= t[0].length)\n    return [];\n  let n = 0;\n  for (let i = 0; i < o; i++) {\n    const a = (s = t[0]) == null ? void 0 : s[n];\n    if (!a)\n      return [];\n    n += a.colspan;\n  }\n  const r = new Array(t.length).fill(!1).map((i, a) => eo(\n    { row: a, col: n },\n    e,\n    t\n  )).filter(\n    (i) => i !== void 0\n  );\n  return r.filter((i, a) => r.findIndex((c) => c.row === i.row && c.col === i.col) === a);\n}\nfunction Kn(e, o, t, n = Q(e)) {\n  const { col: r } = re(\n    {\n      row: 0,\n      col: o\n    },\n    e,\n    n\n  ), { col: s } = re(\n    {\n      row: 0,\n      col: t\n    },\n    e,\n    n\n  );\n  return n.forEach((i) => {\n    const [a] = i.splice(r, 1);\n    i.splice(s, 0, a);\n  }), be(n);\n}\nfunction Xn(e, o, t, n = Q(e)) {\n  const { row: r } = re(\n    {\n      row: o,\n      col: 0\n    },\n    e,\n    n\n  ), { row: s } = re(\n    {\n      row: t,\n      col: 0\n    },\n    e,\n    n\n  ), [i] = n.splice(r, 1);\n  return n.splice(s, 0, i), be(n);\n}\nfunction tt(e) {\n  return e ? me(e) ? tt(e.content) : typeof e == \"string\" ? e.length === 0 : Array.isArray(e) ? e.every(\n    (o) => typeof o == \"string\" ? o.length === 0 : J(o) ? o.text.length === 0 : it(o) ? typeof o.content == \"string\" ? o.content.length === 0 : o.content.every((t) => t.text.length === 0) : !1\n  ) : !1 : !0;\n}\nfunction Jn(e, o, t = Q(e)) {\n  if (o === \"columns\") {\n    let s = 0;\n    for (let i = t[0].length - 1; i >= 0 && t.every(\n      (c) => tt(c[i].cell) && c[i].colspan === 1\n    ); i--)\n      s++;\n    for (let i = t.length - 1; i >= 0; i--) {\n      const a = Math.max(\n        t[i].length - s,\n        1\n      );\n      t[i] = t[i].slice(0, a);\n    }\n    return be(t);\n  }\n  let n = 0;\n  for (let s = t.length - 1; s >= 0 && t[s].every(\n    (a) => tt(a.cell) && a.rowspan === 1\n  ); s--)\n    n++;\n  const r = Math.min(n, t.length - 1);\n  return t.splice(t.length - r, r), be(t);\n}\nfunction Yn(e, o, t, n = Q(e)) {\n  const { width: r, height: s } = ct(e);\n  if (o === \"columns\")\n    n.forEach((i, a) => {\n      if (t >= 0)\n        for (let c = 0; c < t; c++)\n          i.push({\n            row: a,\n            col: Math.max(...i.map((l) => l.col)) + 1,\n            rowspan: 1,\n            colspan: 1,\n            cell: Je(\"\")\n          });\n      else\n        i.splice(r + t, -1 * t);\n    });\n  else if (t > 0)\n    for (let i = 0; i < t; i++) {\n      const a = new Array(r).fill(null).map((c, l) => ({\n        row: s + i,\n        col: l,\n        rowspan: 1,\n        colspan: 1,\n        cell: Je(\"\")\n      }));\n      n.push(a);\n    }\n  else t < 0 && n.splice(s + t, -1 * t);\n  return be(n);\n}\nfunction to(e, o, t) {\n  const n = Qe(e, t);\n  if (!n.some((c) => Ye(c.cell) > 1))\n    return !0;\n  let s = t, i = t;\n  return n.forEach((c) => {\n    const l = Ye(c.cell);\n    s = Math.max(s, c.row + l - 1), i = Math.min(i, c.row);\n  }), o < t ? t === s : t === i;\n}\nfunction oo(e, o, t) {\n  const n = et(e, t);\n  if (!n.some((c) => ge(c.cell) > 1))\n    return !0;\n  let s = t, i = t;\n  return n.forEach((c) => {\n    const l = ge(c.cell);\n    s = Math.max(s, c.col + l - 1), i = Math.min(i, c.col);\n  }), o < t ? t === s : t === i;\n}\nfunction Zn(e, o, t) {\n  const n = re(e, t), r = re(o, t);\n  return n.col === r.col;\n}\nfunction vt(e, o, t, n) {\n  const r = [];\n  for (const [i, a] of Object.entries(e.styles)) {\n    const c = t[i];\n    if (!c)\n      throw new Error(`style ${i} not found in styleSchema`);\n    if (c.propSchema === \"boolean\")\n      r.push(o.mark(i));\n    else if (c.propSchema === \"string\")\n      r.push(o.mark(i, { stringValue: a }));\n    else\n      throw new $(c.propSchema);\n  }\n  return !n || !o.nodes[n].spec.code ? e.text.split(/(\\n)/g).filter((i) => i.length > 0).map((i) => i === `\n` ? o.nodes.hardBreak.createChecked() : o.text(i, r)) : [o.text(e.text, r)];\n}\nfunction Qn(e, o, t) {\n  const n = o.marks.link.create({\n    href: e.href\n  });\n  return ot(e.content, o, t).map(\n    (r) => {\n      if (r.type.name === \"text\")\n        return r.mark([...r.marks, n]);\n      if (r.type.name === \"hardBreak\")\n        return r;\n      throw new Error(\"unexpected node type\");\n    }\n  );\n}\nfunction ot(e, o, t, n) {\n  const r = [];\n  if (typeof e == \"string\")\n    return r.push(\n      ...vt(\n        { text: e, styles: {} },\n        o,\n        t,\n        n\n      )\n    ), r;\n  for (const s of e)\n    r.push(\n      ...vt(s, o, t, n)\n    );\n  return r;\n}\nfunction O(e, o, t, n) {\n  const r = [];\n  for (const s of e)\n    typeof s == \"string\" ? r.push(\n      ...ot(s, o, t, n)\n    ) : it(s) ? r.push(...Qn(s, o, t)) : J(s) ? r.push(\n      ...ot([s], o, t, n)\n    ) : r.push(\n      no(s, o, t)\n    );\n  return r;\n}\nfunction Re(e, o, t) {\n  const n = [], r = new Array(e.headerRows ?? 0).fill(!0), s = new Array(e.headerCols ?? 0).fill(!0), i = e.columnWidths ?? [];\n  for (let a = 0; a < e.rows.length; a++) {\n    const c = e.rows[a], l = [], d = r[a];\n    for (let h = 0; h < c.cells.length; h++) {\n      const f = c.cells[h], m = s[h], g = void 0;\n      let b = null;\n      const k = re(\n        {\n          row: a,\n          col: h\n        },\n        { content: e }\n      );\n      let w = i[k.col] ? [i[k.col]] : null;\n      if (f) if (typeof f == \"string\")\n        b = o.text(f);\n      else if (me(f)) {\n        f.content && (b = O(f.content, o, t));\n        const T = ge(f);\n        T > 1 && (w = new Array(T).fill(!1).map((F, j) => i[k.col + j] ?? void 0));\n      } else\n        b = O(f, o, t);\n      const y = o.nodes[m || d ? \"tableHeader\" : \"tableCell\"].createChecked(\n        {\n          ...me(f) ? f.props : {},\n          colwidth: w\n        },\n        o.nodes.tableParagraph.createChecked(g, b)\n      );\n      l.push(y);\n    }\n    const p = o.nodes.tableRow.createChecked({}, l);\n    n.push(p);\n  }\n  return n;\n}\nfunction no(e, o, t) {\n  let n, r = e.type;\n  if (r === void 0 && (r = \"paragraph\"), !o.nodes[r])\n    throw new Error(`node type ${r} not found in schema`);\n  if (!e.content)\n    n = o.nodes[r].createChecked(e.props);\n  else if (typeof e.content == \"string\") {\n    const s = O(\n      [e.content],\n      o,\n      t,\n      r\n    );\n    n = o.nodes[r].createChecked(e.props, s);\n  } else if (Array.isArray(e.content)) {\n    const s = O(\n      e.content,\n      o,\n      t,\n      r\n    );\n    n = o.nodes[r].createChecked(e.props, s);\n  } else if (e.content.type === \"tableContent\") {\n    const s = Re(e.content, o, t);\n    n = o.nodes[r].createChecked(e.props, s);\n  } else\n    throw new $(e.content.type);\n  return n;\n}\nfunction ie(e, o, t) {\n  let n = e.id;\n  n === void 0 && (n = ve.options.generateID());\n  const r = [];\n  if (e.children)\n    for (const i of e.children)\n      r.push(ie(i, o, t));\n  if (!e.type || // can happen if block.type is not defined (this should create the default node)\n  o.nodes[e.type].isInGroup(\"blockContent\")) {\n    const i = no(\n      e,\n      o,\n      t\n    ), a = r.length > 0 ? o.nodes.blockGroup.createChecked({}, r) : void 0;\n    return o.nodes.blockContainer.createChecked(\n      {\n        id: n,\n        ...e.props\n      },\n      a ? [i, a] : i\n    );\n  } else {\n    if (o.nodes[e.type].isInGroup(\"bnBlock\"))\n      return o.nodes[e.type].createChecked(\n        {\n          id: n,\n          ...e.props\n        },\n        r\n      );\n    throw new Error(\n      `block type ${e.type} doesn't match blockContent or bnBlock group`\n    );\n  }\n}\nfunction D(e, o) {\n  let t, n;\n  if (o.firstChild.descendants((r, s) => t ? !1 : !r.type.isInGroup(\"bnBlock\") || r.attrs.id !== e ? !0 : (t = r, n = s + 1, !1)), !(t === void 0 || n === void 0))\n    return {\n      node: t,\n      posBeforeNode: n\n    };\n}\nconst x = (e, o, t) => ({\n  state: n,\n  dispatch: r\n}) => {\n  const s = Ce(\n    n.doc.resolve(o)\n  );\n  if (r) {\n    const i = n.schema.nodes[s.blockNoteType], a = n.schema.nodes[t.type || s.blockNoteType], c = a.isInGroup(\"bnBlock\") ? a : n.schema.nodes.blockContainer;\n    if (s.isBlockContainer && a.isInGroup(\"blockContent\"))\n      Et(t, n, e, s), er(\n        t,\n        n,\n        e,\n        i,\n        a,\n        s\n      );\n    else if (!s.isBlockContainer && a.isInGroup(\"bnBlock\"))\n      Et(t, n, e, s);\n    else {\n      const l = E(\n        s.bnBlock.node,\n        e.schema.blockSchema,\n        e.schema.inlineContentSchema,\n        e.schema.styleSchema,\n        e.blockCache\n      );\n      return n.tr.replaceWith(\n        s.bnBlock.beforePos,\n        s.bnBlock.afterPos,\n        ie(\n          {\n            children: l.children,\n            // if no children are passed in, use existing children\n            ...t\n          },\n          n.schema,\n          e.schema.styleSchema\n        )\n      ), !0;\n    }\n    n.tr.setNodeMarkup(s.bnBlock.beforePos, c, {\n      ...s.bnBlock.node.attrs,\n      ...t.props\n    });\n  }\n  return !0;\n};\nfunction er(e, o, t, n, r, s) {\n  let i = \"keep\";\n  if (e.content)\n    if (typeof e.content == \"string\")\n      i = O(\n        [e.content],\n        o.schema,\n        t.schema.styleSchema,\n        r.name\n      );\n    else if (Array.isArray(e.content))\n      i = O(\n        e.content,\n        o.schema,\n        t.schema.styleSchema,\n        r.name\n      );\n    else if (e.content.type === \"tableContent\")\n      i = Re(\n        e.content,\n        o.schema,\n        t.schema.styleSchema\n      );\n    else\n      throw new $(e.content.type);\n  else\n    n.spec.content === \"\" || r.spec.content !== n.spec.content && (i = []);\n  i === \"keep\" ? o.tr.setNodeMarkup(\n    s.blockContent.beforePos,\n    e.type === void 0 ? void 0 : o.schema.nodes[e.type],\n    {\n      ...s.blockContent.node.attrs,\n      ...e.props\n    }\n  ) : o.tr.replaceWith(\n    s.blockContent.beforePos,\n    s.blockContent.afterPos,\n    r.createChecked(\n      {\n        ...s.blockContent.node.attrs,\n        ...e.props\n      },\n      i\n    )\n  );\n}\nfunction Et(e, o, t, n) {\n  if (e.children !== void 0 && e.children.length > 0) {\n    const r = e.children.map((s) => ie(s, o.schema, t.schema.styleSchema));\n    if (n.childContainer)\n      o.tr.step(\n        new prosemirror_transform__WEBPACK_IMPORTED_MODULE_19__.ReplaceStep(\n          n.childContainer.beforePos + 1,\n          n.childContainer.afterPos - 1,\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(r), 0, 0)\n        )\n      );\n    else {\n      if (!n.isBlockContainer)\n        throw new Error(\"impossible\");\n      o.tr.insert(\n        n.blockContent.afterPos,\n        o.schema.nodes.blockGroup.createChecked({}, r)\n      );\n    }\n  }\n}\nfunction tr(e, o, t) {\n  const n = e._tiptapEditor, r = typeof o == \"string\" ? o : o.id, s = D(r, n.state.doc);\n  if (!s)\n    throw new Error(`Block with ID ${r} not found`);\n  n.commands.command(({ state: a, dispatch: c }) => (x(\n    e,\n    s.posBeforeNode,\n    t\n  )({ state: a, dispatch: c }), !0));\n  const i = n.state.doc.resolve(s.posBeforeNode + 1).node();\n  return E(\n    i,\n    e.schema.blockSchema,\n    e.schema.inlineContentSchema,\n    e.schema.styleSchema,\n    e.blockCache\n  );\n}\nfunction ro(e) {\n  const o = Array.from(e.classList).filter(\n    (t) => !t.startsWith(\"bn-\")\n  ) || [];\n  o.length > 0 ? e.className = o.join(\" \") : e.removeAttribute(\"class\");\n}\nfunction so(e, o, t, n) {\n  let r;\n  if (o)\n    if (typeof o == \"string\")\n      r = O(\n        [o],\n        e.pmSchema,\n        e.schema.styleSchema\n      );\n    else if (Array.isArray(o))\n      r = O(\n        o,\n        e.pmSchema,\n        e.schema.styleSchema\n      );\n    else if (o.type === \"tableContent\")\n      r = Re(\n        o,\n        e.pmSchema,\n        e.schema.styleSchema\n      );\n    else\n      throw new $(o.type);\n  else throw new Error(\"blockContent is required\");\n  const s = t.serializeFragment(prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(r), n);\n  return s.nodeType === 1 && ro(s), s;\n}\nfunction or(e, o, t, n, r, s, i) {\n  var g, b, k, w, y, T, F, j;\n  const a = (i == null ? void 0 : i.document) ?? document, c = o.pmSchema.nodes.blockContainer;\n  let l = t.props;\n  if (!t.props) {\n    l = {};\n    for (const [B, v] of Object.entries(\n      o.schema.blockSchema[t.type].propSchema\n    ))\n      v.default !== void 0 && (l[B] = v.default);\n  }\n  const d = (b = (g = c.spec) == null ? void 0 : g.toDOM) == null ? void 0 : b.call(\n    g,\n    c.create({\n      id: t.id,\n      ...l\n    })\n  ), p = Array.from(d.dom.attributes), h = o.blockImplementations[t.type].implementation.toExternalHTML({ ...t, props: l }, o), f = a.createDocumentFragment();\n  if (h.dom.classList.contains(\"bn-block-content\")) {\n    const B = [...p, ...Array.from(h.dom.attributes)].filter(\n      (v) => v.name.startsWith(\"data\") && v.name !== \"data-content-type\" && v.name !== \"data-file-block\" && v.name !== \"data-node-view-wrapper\" && v.name !== \"data-node-type\" && v.name !== \"data-id\" && v.name !== \"data-index\" && v.name !== \"data-editable\"\n    );\n    for (const v of B)\n      h.dom.firstChild.setAttribute(v.name, v.value);\n    ro(h.dom.firstChild), f.append(...Array.from(h.dom.childNodes));\n  } else\n    f.append(h.dom);\n  if (h.contentDOM && t.content) {\n    const B = so(\n      o,\n      t.content,\n      // TODO\n      n,\n      i\n    );\n    h.contentDOM.appendChild(B);\n  }\n  let m;\n  if (r.has(t.type) ? m = \"OL\" : s.has(t.type) && (m = \"UL\"), m) {\n    if (((k = e.lastChild) == null ? void 0 : k.nodeName) !== m) {\n      const v = a.createElement(m);\n      m === \"OL\" && (l != null && l.start) && (l == null ? void 0 : l.start) !== 1 && v.setAttribute(\"start\", l.start + \"\"), e.append(v);\n    }\n    const B = a.createElement(\"li\");\n    B.append(f), e.lastChild.appendChild(B);\n  } else\n    e.append(f);\n  if (t.children && t.children.length > 0) {\n    const B = a.createDocumentFragment();\n    if (io(\n      B,\n      o,\n      t.children,\n      n,\n      r,\n      s,\n      i\n    ), ((w = e.lastChild) == null ? void 0 : w.nodeName) === \"UL\" || ((y = e.lastChild) == null ? void 0 : y.nodeName) === \"OL\")\n      for (; ((T = B.firstChild) == null ? void 0 : T.nodeName) === \"UL\" || ((F = B.firstChild) == null ? void 0 : F.nodeName) === \"OL\"; )\n        e.lastChild.lastChild.appendChild(B.firstChild);\n    o.pmSchema.nodes[t.type].isInGroup(\"blockContent\") ? e.append(B) : (j = h.contentDOM) == null || j.append(B);\n  }\n}\nconst io = (e, o, t, n, r, s, i) => {\n  for (const a of t)\n    or(\n      e,\n      o,\n      a,\n      n,\n      r,\n      s,\n      i\n    );\n}, nr = (e, o, t, n, r, s) => {\n  const a = ((s == null ? void 0 : s.document) ?? document).createDocumentFragment();\n  return io(\n    a,\n    e,\n    o,\n    t,\n    n,\n    r,\n    s\n  ), a;\n}, Ve = (e, o) => {\n  const t = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.DOMSerializer.fromSchema(e);\n  return {\n    exportBlocks: (n, r) => {\n      const s = nr(\n        o,\n        n,\n        t,\n        /* @__PURE__ */ new Set([\"numberedListItem\"]),\n        /* @__PURE__ */ new Set([\"bulletListItem\", \"checkListItem\"]),\n        r\n      ), i = document.createElement(\"div\");\n      return i.append(s), i.innerHTML;\n    },\n    exportInlineContent: (n, r) => {\n      const s = so(\n        o,\n        n,\n        t,\n        r\n      ), i = document.createElement(\"div\");\n      return i.append(s.cloneNode(!0)), i.innerHTML;\n    }\n  };\n};\nfunction rr(e, o, t, n, r) {\n  let s;\n  if (o)\n    if (typeof o == \"string\")\n      s = O(\n        [o],\n        e.pmSchema,\n        e.schema.styleSchema,\n        n\n      );\n    else if (Array.isArray(o))\n      s = O(\n        o,\n        e.pmSchema,\n        e.schema.styleSchema,\n        n\n      );\n    else if (o.type === \"tableContent\")\n      s = Re(\n        o,\n        e.pmSchema,\n        e.schema.styleSchema\n      );\n    else\n      throw new $(o.type);\n  else throw new Error(\"blockContent is required\");\n  return t.serializeFragment(prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(s), r);\n}\nfunction sr(e, o, t, n, r) {\n  var p, h, f, m, g;\n  const s = e.pmSchema.nodes.blockContainer;\n  let i = o.props;\n  if (!o.props) {\n    i = {};\n    for (const [b, k] of Object.entries(\n      e.schema.blockSchema[o.type].propSchema\n    ))\n      k.default !== void 0 && (i[b] = k.default);\n  }\n  const c = e.blockImplementations[o.type].implementation.toInternalHTML({ ...o, props: i }, e);\n  if (o.type === \"numberedListItem\" && c.dom.setAttribute(\"data-index\", n.toString()), c.contentDOM && o.content) {\n    const b = rr(\n      e,\n      o.content,\n      // TODO\n      t,\n      o.type,\n      r\n    );\n    c.contentDOM.appendChild(b);\n  }\n  if (e.pmSchema.nodes[o.type].isInGroup(\"bnBlock\")) {\n    if (o.children && o.children.length > 0) {\n      const b = ao(\n        e,\n        o.children,\n        t,\n        r\n      );\n      (p = c.contentDOM) == null || p.append(b);\n    }\n    return c.dom;\n  }\n  const d = (f = (h = s.spec) == null ? void 0 : h.toDOM) == null ? void 0 : f.call(\n    h,\n    s.create({\n      id: o.id,\n      ...i\n    })\n  );\n  return (m = d.contentDOM) == null || m.appendChild(c.dom), o.children && o.children.length > 0 && ((g = d.contentDOM) == null || g.appendChild(\n    co(e, o.children, t, r)\n  )), d.dom;\n}\nfunction ao(e, o, t, n) {\n  const s = ((n == null ? void 0 : n.document) ?? document).createDocumentFragment();\n  let i = 0;\n  for (const a of o) {\n    a.type === \"numberedListItem\" ? i++ : i = 0;\n    const c = sr(\n      e,\n      a,\n      t,\n      i,\n      n\n    );\n    s.appendChild(c);\n  }\n  return s;\n}\nconst co = (e, o, t, n) => {\n  var a;\n  const r = e.pmSchema.nodes.blockGroup, s = r.spec.toDOM(r.create({})), i = ao(e, o, t, n);\n  return (a = s.contentDOM) == null || a.appendChild(i), s.dom;\n}, ir = (e, o) => {\n  const t = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.DOMSerializer.fromSchema(e);\n  return {\n    serializeBlocks: (n, r) => co(o, n, t, r).outerHTML\n  };\n}, Ue = (e, o) => {\n  const t = e.querySelector(\n    o\n  );\n  if (!t)\n    return;\n  const n = e.querySelector(\"figcaption\"), r = (n == null ? void 0 : n.textContent) ?? void 0;\n  return { targetElement: t, caption: r };\n}, ar = (e, o, t, n) => {\n  const r = document.createElement(\"div\");\n  r.className = \"bn-add-file-button\";\n  const s = document.createElement(\"div\");\n  s.className = \"bn-add-file-button-icon\", n ? s.appendChild(n) : s.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z\"></path></svg>', r.appendChild(s);\n  const i = document.createElement(\"p\");\n  i.className = \"bn-add-file-button-text\", i.innerHTML = t || o.dictionary.file_blocks.file.add_button_text, r.appendChild(i);\n  const a = (l) => {\n    l.preventDefault();\n  }, c = () => {\n    o.dispatch(\n      o._tiptapEditor.state.tr.setMeta(o.filePanel.plugin, {\n        block: e\n      })\n    );\n  };\n  return r.addEventListener(\n    \"mousedown\",\n    a,\n    !0\n  ), r.addEventListener(\"click\", c, !0), {\n    dom: r,\n    destroy: () => {\n      r.removeEventListener(\n        \"mousedown\",\n        a,\n        !0\n      ), r.removeEventListener(\n        \"click\",\n        c,\n        !0\n      );\n    }\n  };\n}, cr = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z\"></path></svg>', lr = (e) => {\n  const o = document.createElement(\"div\");\n  o.className = \"bn-file-name-with-icon\";\n  const t = document.createElement(\"div\");\n  t.className = \"bn-file-icon\", t.innerHTML = cr, o.appendChild(t);\n  const n = document.createElement(\"p\");\n  return n.className = \"bn-file-name\", n.textContent = e.props.name, o.appendChild(n), {\n    dom: o\n  };\n}, lt = (e, o, t, n, r) => {\n  const s = document.createElement(\"div\");\n  if (s.className = \"bn-file-block-content-wrapper\", e.props.url === \"\") {\n    const a = ar(\n      e,\n      o,\n      n,\n      r\n    );\n    s.appendChild(a.dom);\n    const c = o.onUploadStart((l) => {\n      if (l === e.id) {\n        s.removeChild(a.dom);\n        const d = document.createElement(\"div\");\n        d.className = \"bn-file-loading-preview\", d.textContent = \"Loading...\", s.appendChild(d);\n      }\n    });\n    return {\n      dom: s,\n      destroy: () => {\n        c(), a.destroy();\n      }\n    };\n  }\n  const i = { dom: s };\n  if (e.props.showPreview === !1 || !t) {\n    const a = lr(e);\n    s.appendChild(a.dom), i.destroy = () => {\n      var c;\n      (c = a.destroy) == null || c.call(a);\n    };\n  } else\n    s.appendChild(t.dom);\n  if (e.props.caption) {\n    const a = document.createElement(\"p\");\n    a.className = \"bn-file-caption\", a.textContent = e.props.caption, s.appendChild(a);\n  }\n  return i;\n}, dt = (e, o) => {\n  const t = document.createElement(\"figure\"), n = document.createElement(\"figcaption\");\n  return n.textContent = o, t.appendChild(e), t.appendChild(n), { dom: t };\n}, $e = (e, o) => {\n  const t = document.createElement(\"div\"), n = document.createElement(\"p\");\n  return n.textContent = o, t.appendChild(e), t.appendChild(n), {\n    dom: t\n  };\n}, St = (e) => ({ url: e.src || void 0 }), dr = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z\"></path></svg>', pr = {\n  backgroundColor: S.backgroundColor,\n  // File name.\n  name: {\n    default: \"\"\n  },\n  // File url.\n  url: {\n    default: \"\"\n  },\n  // File caption.\n  caption: {\n    default: \"\"\n  },\n  showPreview: {\n    default: !0\n  }\n}, ur = {\n  type: \"audio\",\n  propSchema: pr,\n  content: \"none\",\n  isFileBlock: !0,\n  fileBlockAccept: [\"audio/*\"]\n}, hr = (e, o) => {\n  const t = document.createElement(\"div\");\n  t.innerHTML = dr;\n  const n = document.createElement(\"audio\");\n  return n.className = \"bn-audio\", o.resolveFileUrl ? o.resolveFileUrl(e.props.url).then((r) => {\n    n.src = r;\n  }) : n.src = e.props.url, n.controls = !0, n.contentEditable = \"false\", n.draggable = !1, lt(\n    e,\n    o,\n    { dom: n },\n    o.dictionary.file_blocks.audio.add_button_text,\n    t.firstElementChild\n  );\n}, fr = (e) => {\n  if (e.tagName === \"AUDIO\")\n    return St(e);\n  if (e.tagName === \"FIGURE\") {\n    const o = Ue(e, \"audio\");\n    if (!o)\n      return;\n    const { targetElement: t, caption: n } = o;\n    return {\n      ...St(t),\n      caption: n\n    };\n  }\n}, mr = (e) => {\n  if (!e.props.url) {\n    const t = document.createElement(\"p\");\n    return t.textContent = \"Add audio\", {\n      dom: t\n    };\n  }\n  let o;\n  return e.props.showPreview ? (o = document.createElement(\"audio\"), o.src = e.props.url) : (o = document.createElement(\"a\"), o.href = e.props.url, o.textContent = e.props.name || e.props.url), e.props.caption ? e.props.showPreview ? dt(o, e.props.caption) : $e(o, e.props.caption) : {\n    dom: o\n  };\n}, gr = Se(ur, {\n  render: hr,\n  parse: fr,\n  toExternalHTML: mr\n}), Bt = Symbol.for(\"blocknote.shikiParser\"), We = Symbol.for(\n  \"blocknote.shikiHighlighterPromise\"\n), br = {\n  language: {\n    default: \"text\"\n  }\n}, kr = W({\n  name: \"codeBlock\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  marks: \"\",\n  code: !0,\n  defining: !0,\n  addOptions() {\n    return {\n      defaultLanguage: \"text\",\n      indentLineWithTab: !0,\n      supportedLanguages: {}\n    };\n  },\n  addAttributes() {\n    const e = this.options;\n    return {\n      language: {\n        default: e.editor.settings.codeBlock.defaultLanguage,\n        parseHTML: (o) => {\n          let t = o, n = null;\n          (t == null ? void 0 : t.tagName) === \"DIV\" && (t == null ? void 0 : t.dataset.contentType) === \"codeBlock\" && (t = t.children[0]), (t == null ? void 0 : t.tagName) === \"PRE\" && (t = t == null ? void 0 : t.children[0]);\n          const r = t == null ? void 0 : t.getAttribute(\"data-language\");\n          if (r)\n            n = r.toLowerCase();\n          else {\n            const i = [...(t == null ? void 0 : t.className.split(\" \")) || []].filter((a) => a.startsWith(\"language-\")).map((a) => a.replace(\"language-\", \"\"));\n            i.length > 0 && (n = i[0].toLowerCase());\n          }\n          return n ? Tt(e.editor.settings.codeBlock, n) : null;\n        },\n        renderHTML: (o) => o.language ? {\n          class: `language-${o.language}`,\n          \"data-language\": o.language\n        } : {}\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\",\n        contentElement: \"code\"\n      },\n      {\n        tag: \"pre\",\n        contentElement: \"code\",\n        preserveWhitespace: \"full\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var r, s;\n    const o = document.createElement(\"pre\"), { dom: t, contentDOM: n } = z(\n      this.name,\n      \"code\",\n      ((r = this.options.domAttributes) == null ? void 0 : r.blockContent) || {},\n      {\n        ...((s = this.options.domAttributes) == null ? void 0 : s.inlineContent) || {},\n        ...e\n      }\n    );\n    return t.removeChild(n), t.appendChild(o), o.appendChild(n), {\n      dom: t,\n      contentDOM: n\n    };\n  },\n  addNodeView() {\n    const e = this.options;\n    return ({ editor: o, node: t, getPos: n, HTMLAttributes: r }) => {\n      var p, h;\n      const s = document.createElement(\"pre\"), i = document.createElement(\"select\"), a = document.createElement(\"div\"), { dom: c, contentDOM: l } = z(\n        this.name,\n        \"code\",\n        {\n          ...((p = this.options.domAttributes) == null ? void 0 : p.blockContent) || {},\n          ...r\n        },\n        ((h = this.options.domAttributes) == null ? void 0 : h.inlineContent) || {}\n      ), d = (f) => {\n        const m = f.target.value;\n        o.commands.command(({ tr: g }) => (g.setNodeAttribute(n(), \"language\", m), !0));\n      };\n      return Object.entries(\n        e.editor.settings.codeBlock.supportedLanguages\n      ).forEach(([f, { name: m }]) => {\n        const g = document.createElement(\"option\");\n        g.value = f, g.text = m, i.appendChild(g);\n      }), a.contentEditable = \"false\", i.value = t.attrs.language || e.editor.settings.codeBlock.defaultLanguage, c.removeChild(l), c.appendChild(a), c.appendChild(s), s.appendChild(l), a.appendChild(i), i.addEventListener(\"change\", d), {\n        dom: c,\n        contentDOM: l,\n        update: (f) => f.type === this.type,\n        destroy: () => {\n          i.removeEventListener(\"change\", d);\n        }\n      };\n    };\n  },\n  addProseMirrorPlugins() {\n    const e = this.options, o = globalThis;\n    let t, n, r = !1;\n    return [(0,prosemirror_highlight__WEBPACK_IMPORTED_MODULE_20__.createHighlightPlugin)({\n      parser: (a) => {\n        if (!e.editor.settings.codeBlock.createHighlighter)\n          return  true && !r && (console.log(\n            \"For syntax highlighting of code blocks, you must provide a highlighter function\"\n          ), r = !0), [];\n        if (!t)\n          return o[We] = o[We] || e.editor.settings.codeBlock.createHighlighter(), o[We].then(\n            (l) => {\n              t = l;\n            }\n          );\n        const c = a.language;\n        return c && c !== \"text\" && !t.getLoadedLanguages().includes(c) && c in e.editor.settings.codeBlock.supportedLanguages ? t.loadLanguage(c) : (n || (n = o[Bt] || (0,prosemirror_highlight_shiki__WEBPACK_IMPORTED_MODULE_21__.createParser)(t), o[Bt] = n), n(a));\n      },\n      languageExtractor: (a) => a.attrs.language,\n      nodeTypes: [this.name]\n    })];\n  },\n  addInputRules() {\n    const e = this.options;\n    return [\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.InputRule({\n        find: /^```(.*?)\\s$/,\n        handler: ({ state: o, range: t, match: n }) => {\n          const r = o.doc.resolve(t.from), s = n[1].trim(), i = {\n            language: Tt(\n              e.editor.settings.codeBlock,\n              s\n            )\n          };\n          if (!r.node(-1).canReplaceWith(\n            r.index(-1),\n            r.indexAfter(-1),\n            this.type\n          ))\n            return null;\n          o.tr.delete(t.from, t.to).setBlockType(t.from, t.from, this.type, i).setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.create(o.tr.doc, t.from));\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor: e }) => {\n        const { selection: o } = e.state, { $from: t } = o;\n        if (e.isActive(this.name) && !t.parent.textContent && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.isTextSelection)(o)) {\n          const n = t.pos - t.parentOffset - 2;\n          return e.chain().setNodeSelection(n).deleteSelection().run(), !0;\n        }\n        return !1;\n      },\n      Tab: ({ editor: e }) => this.options.indentLineWithTab && e.isActive(this.name) ? (e.commands.insertContent(\"  \"), !0) : !1,\n      Enter: ({ editor: e }) => {\n        const { $from: o } = e.state.selection;\n        if (!e.isActive(this.name))\n          return !1;\n        const t = o.parentOffset === o.parent.nodeSize - 2, n = o.parent.textContent.endsWith(`\n\n`);\n        return !t || !n ? (e.commands.insertContent(`\n`), !0) : e.chain().command(({ tr: r }) => (r.delete(o.pos - 2, o.pos), !0)).exitCode().run();\n      },\n      \"Shift-Enter\": ({ editor: e }) => {\n        const { $from: o } = e.state.selection;\n        return e.isActive(this.name) ? (e.chain().insertContentAt(\n          o.pos - o.parentOffset + o.parent.nodeSize,\n          {\n            type: \"paragraph\"\n          }\n        ).run(), !0) : !1;\n      }\n    };\n  }\n}), wr = Z(\n  kr,\n  br\n);\nfunction Tt(e, o) {\n  var t;\n  return ((t = Object.entries(e.supportedLanguages).find(([n, { aliases: r }]) => (r == null ? void 0 : r.includes(o)) || n === o)) == null ? void 0 : t[0]) || o;\n}\nconst xt = (e) => ({ url: e.src || void 0 }), yr = {\n  backgroundColor: S.backgroundColor,\n  // File name.\n  name: {\n    default: \"\"\n  },\n  // File url.\n  url: {\n    default: \"\"\n  },\n  // File caption.\n  caption: {\n    default: \"\"\n  }\n}, Cr = {\n  type: \"file\",\n  propSchema: yr,\n  content: \"none\",\n  isFileBlock: !0\n}, vr = (e, o) => lt(e, o), Er = (e) => {\n  if (e.tagName === \"EMBED\")\n    return xt(e);\n  if (e.tagName === \"FIGURE\") {\n    const o = Ue(e, \"embed\");\n    if (!o)\n      return;\n    const { targetElement: t, caption: n } = o;\n    return {\n      ...xt(t),\n      caption: n\n    };\n  }\n}, Sr = (e) => {\n  if (!e.props.url) {\n    const t = document.createElement(\"p\");\n    return t.textContent = \"Add file\", {\n      dom: t\n    };\n  }\n  const o = document.createElement(\"a\");\n  return o.href = e.props.url, o.textContent = e.props.name || e.props.url, e.props.caption ? $e(o, e.props.caption) : {\n    dom: o\n  };\n}, Br = Se(Cr, {\n  render: vr,\n  parse: Er,\n  toExternalHTML: Sr\n}), lo = (e, o, t, n, r, s) => {\n  const { dom: i, destroy: a } = lt(\n    e,\n    o,\n    t,\n    r,\n    s\n  ), c = i;\n  e.props.url && e.props.showPreview && (c.style.width = `${e.props.previewWidth}px`);\n  const l = document.createElement(\"div\");\n  l.className = \"bn-resize-handle\", l.style.left = \"4px\";\n  const d = document.createElement(\"div\");\n  d.className = \"bn-resize-handle\", d.style.right = \"4px\";\n  let p, h = e.props.previewWidth;\n  const f = (y) => {\n    if (!p) {\n      !o.isEditable && n.contains(l) && n.contains(d) && (n.removeChild(l), n.removeChild(d));\n      return;\n    }\n    let T;\n    e.props.textAlignment === \"center\" ? p.handleUsed === \"left\" ? T = p.initialWidth + (p.initialClientX - y.clientX) * 2 : T = p.initialWidth + (y.clientX - p.initialClientX) * 2 : p.handleUsed === \"left\" ? T = p.initialWidth + p.initialClientX - y.clientX : T = p.initialWidth + y.clientX - p.initialClientX, h = Math.max(T, 64), c.style.width = `${h}px`;\n  }, m = (y) => {\n    (!y.target || !c.contains(y.target) || !o.isEditable) && n.contains(l) && n.contains(d) && (n.removeChild(l), n.removeChild(d)), p && (p = void 0, o.updateBlock(e, {\n      props: {\n        previewWidth: h\n      }\n    }));\n  }, g = () => {\n    o.isEditable && (n.appendChild(l), n.appendChild(d));\n  }, b = (y) => {\n    y.relatedTarget === l || y.relatedTarget === d || p || o.isEditable && n.contains(l) && n.contains(d) && (n.removeChild(l), n.removeChild(d));\n  }, k = (y) => {\n    y.preventDefault(), p = {\n      handleUsed: \"left\",\n      initialWidth: c.clientWidth,\n      initialClientX: y.clientX\n    };\n  }, w = (y) => {\n    y.preventDefault(), p = {\n      handleUsed: \"right\",\n      initialWidth: c.clientWidth,\n      initialClientX: y.clientX\n    };\n  };\n  return window.addEventListener(\"mousemove\", f), window.addEventListener(\"mouseup\", m), c.addEventListener(\"mouseenter\", g), c.addEventListener(\"mouseleave\", b), l.addEventListener(\n    \"mousedown\",\n    k\n  ), d.addEventListener(\n    \"mousedown\",\n    w\n  ), {\n    dom: c,\n    destroy: () => {\n      a == null || a(), window.removeEventListener(\"mousemove\", f), window.removeEventListener(\"mouseup\", m), c.removeEventListener(\"mouseenter\", g), c.removeEventListener(\"mouseleave\", b), l.removeEventListener(\n        \"mousedown\",\n        k\n      ), d.removeEventListener(\n        \"mousedown\",\n        w\n      );\n    }\n  };\n}, ic = async (e) => {\n  const o = new FormData();\n  return o.append(\"file\", e), (await (await fetch(\"https://tmpfiles.org/api/v1/upload\", {\n    method: \"POST\",\n    body: o\n  })).json()).data.url.replace(\n    \"tmpfiles.org/\",\n    \"tmpfiles.org/dl/\"\n  );\n}, Mt = (e) => {\n  const o = e.src || void 0, t = e.width || void 0;\n  return { url: o, previewWidth: t };\n}, Tr = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z\"></path></svg>', xr = {\n  textAlignment: S.textAlignment,\n  backgroundColor: S.backgroundColor,\n  // File name.\n  name: {\n    default: \"\"\n  },\n  // File url.\n  url: {\n    default: \"\"\n  },\n  // File caption.\n  caption: {\n    default: \"\"\n  },\n  showPreview: {\n    default: !0\n  },\n  // File preview width in px.\n  previewWidth: {\n    default: 512\n  }\n}, Mr = {\n  type: \"image\",\n  propSchema: xr,\n  content: \"none\",\n  isFileBlock: !0,\n  fileBlockAccept: [\"image/*\"]\n}, Pr = (e, o) => {\n  const t = document.createElement(\"div\");\n  t.innerHTML = Tr;\n  const n = document.createElement(\"div\");\n  n.className = \"bn-visual-media-wrapper\";\n  const r = document.createElement(\"img\");\n  return r.className = \"bn-visual-media\", o.resolveFileUrl ? o.resolveFileUrl(e.props.url).then((s) => {\n    r.src = s;\n  }) : r.src = e.props.url, r.alt = e.props.name || e.props.caption || \"BlockNote image\", r.contentEditable = \"false\", r.draggable = !1, n.appendChild(r), lo(\n    e,\n    o,\n    { dom: n },\n    n,\n    o.dictionary.file_blocks.image.add_button_text,\n    t.firstElementChild\n  );\n}, Ir = (e) => {\n  if (e.tagName === \"IMG\")\n    return Mt(e);\n  if (e.tagName === \"FIGURE\") {\n    const o = Ue(e, \"img\");\n    if (!o)\n      return;\n    const { targetElement: t, caption: n } = o;\n    return {\n      ...Mt(t),\n      caption: n\n    };\n  }\n}, Lr = (e) => {\n  if (!e.props.url) {\n    const t = document.createElement(\"p\");\n    return t.textContent = \"Add image\", {\n      dom: t\n    };\n  }\n  let o;\n  return e.props.showPreview ? (o = document.createElement(\"img\"), o.src = e.props.url, o.alt = e.props.name || e.props.caption || \"BlockNote image\", o.width = e.props.previewWidth) : (o = document.createElement(\"a\"), o.href = e.props.url, o.textContent = e.props.name || e.props.url), e.props.caption ? e.props.showPreview ? dt(o, e.props.caption) : $e(o, e.props.caption) : {\n    dom: o\n  };\n}, Ar = Se(Mr, {\n  render: Pr,\n  parse: Ir,\n  toExternalHTML: Lr\n}), Nr = {\n  type: \"pageBreak\",\n  propSchema: {},\n  content: \"none\",\n  isFileBlock: !1,\n  isSelectable: !1\n}, Hr = () => {\n  const e = document.createElement(\"div\");\n  return e.className = \"bn-page-break\", e.setAttribute(\"data-page-break\", \"\"), {\n    dom: e\n  };\n}, Dr = (e) => {\n  if (e.tagName === \"DIV\" && e.hasAttribute(\"data-page-break\"))\n    return {\n      type: \"pageBreak\"\n    };\n}, Or = () => {\n  const e = document.createElement(\"div\");\n  return e.setAttribute(\"data-page-break\", \"\"), {\n    dom: e\n  };\n}, _r = Se(Nr, {\n  render: Hr,\n  parse: Dr,\n  toExternalHTML: Or\n}), Rr = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Mark.create({\n  name: \"backgroundColor\",\n  addAttributes() {\n    return {\n      stringValue: {\n        default: void 0,\n        parseHTML: (e) => e.getAttribute(\"data-background-color\"),\n        renderHTML: (e) => ({\n          \"data-background-color\": e.stringValue\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (e) => typeof e == \"string\" ? !1 : e.hasAttribute(\"data-background-color\") ? {\n          stringValue: e.getAttribute(\"data-background-color\")\n        } : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    return [\"span\", e, 0];\n  }\n}), Vr = ee(\n  Rr,\n  \"string\"\n), Ur = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Mark.create({\n  name: \"textColor\",\n  addAttributes() {\n    return {\n      stringValue: {\n        default: void 0,\n        parseHTML: (e) => e.getAttribute(\"data-text-color\"),\n        renderHTML: (e) => ({\n          \"data-text-color\": e.stringValue\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (e) => typeof e == \"string\" ? !1 : e.hasAttribute(\"data-text-color\") ? { stringValue: e.getAttribute(\"data-text-color\") } : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    return [\"span\", e, 0];\n  }\n}), $r = ee(Ur, \"string\"), po = {\n  ...S,\n  level: { default: 1, values: [1, 2, 3] }\n}, Fr = W({\n  name: \"heading\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addAttributes() {\n    return Ee(po);\n  },\n  addInputRules() {\n    return [\n      ...[1, 2, 3].map((e) => new _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.InputRule({\n        find: new RegExp(`^(#{${e}})\\\\s$`),\n        handler: ({ state: o, chain: t, range: n }) => {\n          const r = C(o);\n          !r.isBlockContainer || r.blockContent.node.type.spec.content !== \"inline*\" || t().command(\n            x(\n              this.options.editor,\n              r.bnBlock.beforePos,\n              {\n                type: \"heading\",\n                props: {\n                  level: e\n                }\n              }\n            )\n          ).deleteRange({ from: n.from, to: n.to }).run();\n        }\n      }))\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-1\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"heading\",\n            props: {\n              level: 1\n            }\n          })\n        );\n      },\n      \"Mod-Alt-2\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"heading\",\n            props: {\n              level: 2\n            }\n          })\n        );\n      },\n      \"Mod-Alt-3\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"heading\",\n            props: {\n              level: 3\n            }\n          })\n        );\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\"\n      },\n      {\n        tag: \"h1\",\n        attrs: { level: 1 },\n        node: \"heading\"\n      },\n      {\n        tag: \"h2\",\n        attrs: { level: 2 },\n        node: \"heading\"\n      },\n      {\n        tag: \"h3\",\n        attrs: { level: 3 },\n        node: \"heading\"\n      }\n    ];\n  },\n  renderHTML({ node: e, HTMLAttributes: o }) {\n    var t, n;\n    return z(\n      this.name,\n      `h${e.attrs.level}`,\n      {\n        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},\n        ...o\n      },\n      ((n = this.options.domAttributes) == null ? void 0 : n.inlineContent) || {}\n    );\n  }\n}), zr = Z(\n  Fr,\n  po\n), uo = (e, o, t) => ({\n  state: n,\n  dispatch: r\n}) => {\n  const s = X(n.doc, e), i = ne(s);\n  if (!i.isBlockContainer)\n    throw new Error(\n      `BlockContainer expected when calling splitBlock, position ${e}`\n    );\n  const a = [\n    {\n      type: i.bnBlock.node.type,\n      // always keep blockcontainer type\n      attrs: t ? { ...i.bnBlock.node.attrs, id: void 0 } : {}\n    },\n    {\n      type: o ? i.blockContent.node.type : n.schema.nodes.paragraph,\n      attrs: t ? { ...i.blockContent.node.attrs } : {}\n    }\n  ];\n  return r && n.tr.split(e, 2, a), !0;\n}, pt = (e) => {\n  const o = e._tiptapEditor, t = C(o.state);\n  if (!t.isBlockContainer)\n    return !1;\n  const { bnBlock: n, blockContent: r } = t, s = o.state.selection.anchor === o.state.selection.head;\n  return !(r.node.type.name === \"bulletListItem\" || r.node.type.name === \"numberedListItem\" || r.node.type.name === \"checkListItem\") || !s ? !1 : o.commands.first(({ state: i, chain: a, commands: c }) => [\n    () => (\n      // Changes list item block to a paragraph block if the content is empty.\n      c.command(() => r.node.childCount === 0 ? c.command(\n        x(e, n.beforePos, {\n          type: \"paragraph\",\n          props: {}\n        })\n      ) : !1)\n    ),\n    () => (\n      // Splits the current block, moving content inside that's after the cursor\n      // to a new block of the same type below.\n      c.command(() => r.node.childCount > 0 ? (a().deleteSelection().command(uo(i.selection.from, !0)).run(), !0) : !1)\n    )\n  ]);\n}, Wr = {\n  ...S\n}, jr = W({\n  name: \"bulletListItem\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  // This is to make sure that check list parse rules run before, since they\n  // both parse `li` elements but check lists are more specific.\n  priority: 90,\n  addInputRules() {\n    return [\n      // Creates an unordered list when starting with \"-\", \"+\", or \"*\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.InputRule({\n        find: new RegExp(\"^[-+*]\\\\s$\"),\n        handler: ({ state: e, chain: o, range: t }) => {\n          const n = C(e);\n          !n.isBlockContainer || n.blockContent.node.type.spec.content !== \"inline*\" || o().command(\n            x(\n              this.options.editor,\n              n.bnBlock.beforePos,\n              {\n                type: \"bulletListItem\",\n                props: {}\n              }\n            )\n          ).deleteRange({ from: t.from, to: t.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => pt(this.options.editor),\n      \"Mod-Shift-8\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"bulletListItem\",\n            props: {}\n          })\n        );\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\"\n      },\n      {\n        tag: \"li\",\n        getAttrs: (e) => {\n          if (typeof e == \"string\")\n            return !1;\n          const o = e.parentElement;\n          return o === null ? !1 : o.tagName === \"UL\" || o.tagName === \"DIV\" && o.parentElement.tagName === \"UL\" ? {} : !1;\n        },\n        node: \"bulletListItem\"\n      },\n      // Case for BlockNote list structure.\n      {\n        tag: \"p\",\n        getAttrs: (e) => {\n          if (typeof e == \"string\")\n            return !1;\n          const o = e.parentElement;\n          return o === null ? !1 : o.getAttribute(\"data-content-type\") === \"bulletListItem\" ? {} : !1;\n        },\n        priority: 300,\n        node: \"bulletListItem\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var o, t;\n    return z(\n      this.name,\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      \"p\",\n      {\n        ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},\n        ...e\n      },\n      ((t = this.options.domAttributes) == null ? void 0 : t.inlineContent) || {}\n    );\n  }\n}), Gr = Z(\n  jr,\n  Wr\n), ho = {\n  ...S,\n  checked: {\n    default: !1\n  }\n}, qr = W({\n  name: \"checkListItem\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addAttributes() {\n    return Ee(ho);\n  },\n  addInputRules() {\n    return [\n      // Creates a checklist when starting with \"[]\" or \"[X]\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.InputRule({\n        find: new RegExp(\"\\\\[\\\\s*\\\\]\\\\s$\"),\n        handler: ({ state: e, chain: o, range: t }) => {\n          const n = C(e);\n          !n.isBlockContainer || n.blockContent.node.type.spec.content !== \"inline*\" || o().command(\n            x(\n              this.options.editor,\n              n.bnBlock.beforePos,\n              {\n                type: \"checkListItem\",\n                props: {\n                  checked: !1\n                }\n              }\n            )\n          ).deleteRange({ from: t.from, to: t.to });\n        }\n      }),\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.InputRule({\n        find: new RegExp(\"\\\\[[Xx]\\\\]\\\\s$\"),\n        handler: ({ state: e, chain: o, range: t }) => {\n          const n = C(e);\n          !n.isBlockContainer || n.blockContent.node.type.spec.content !== \"inline*\" || o().command(\n            x(\n              this.options.editor,\n              n.bnBlock.beforePos,\n              {\n                type: \"checkListItem\",\n                props: {\n                  checked: !0\n                }\n              }\n            )\n          ).deleteRange({ from: t.from, to: t.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => pt(this.options.editor),\n      \"Mod-Shift-9\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"checkListItem\",\n            props: {}\n          })\n        );\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\"\n      },\n      // Checkbox only.\n      {\n        tag: \"input\",\n        getAttrs: (e) => typeof e == \"string\" ? !1 : e.type === \"checkbox\" ? { checked: e.checked } : !1,\n        node: \"checkListItem\"\n      },\n      // Container element for checkbox + label.\n      {\n        tag: \"li\",\n        getAttrs: (e) => {\n          if (typeof e == \"string\")\n            return !1;\n          const o = e.parentElement;\n          if (o === null)\n            return !1;\n          if (o.tagName === \"UL\" || o.tagName === \"DIV\" && o.parentElement.tagName === \"UL\") {\n            const t = e.querySelector(\n              \"input[type=checkbox]\"\n            ) || null;\n            return t === null ? !1 : { checked: t.checked };\n          }\n          return !1;\n        },\n        node: \"checkListItem\"\n      }\n    ];\n  },\n  // Since there is no HTML checklist element, there isn't really any\n  // standardization for what checklists should look like in the DOM. GDocs'\n  // and Notion's aren't cross compatible, for example. This implementation\n  // has a semantically correct DOM structure (though missing a label for the\n  // checkbox) which is also converted correctly to Markdown by remark.\n  renderHTML({ node: e, HTMLAttributes: o }) {\n    var s, i;\n    const t = document.createElement(\"input\");\n    t.type = \"checkbox\", t.checked = e.attrs.checked, e.attrs.checked && t.setAttribute(\"checked\", \"\");\n    const { dom: n, contentDOM: r } = z(\n      this.name,\n      \"p\",\n      {\n        ...((s = this.options.domAttributes) == null ? void 0 : s.blockContent) || {},\n        ...o\n      },\n      ((i = this.options.domAttributes) == null ? void 0 : i.inlineContent) || {}\n    );\n    return n.insertBefore(t, r), { dom: n, contentDOM: r };\n  },\n  // Need to render node view since the checkbox needs to be able to update the\n  // node. This is only possible with a node view as it exposes `getPos`.\n  addNodeView() {\n    return ({ node: e, getPos: o, editor: t, HTMLAttributes: n }) => {\n      var d, p;\n      const r = document.createElement(\"div\"), s = document.createElement(\"div\");\n      s.contentEditable = \"false\";\n      const i = document.createElement(\"input\");\n      i.type = \"checkbox\", i.checked = e.attrs.checked, e.attrs.checked && i.setAttribute(\"checked\", \"\");\n      const a = () => {\n        if (!t.isEditable) {\n          i.checked = !i.checked;\n          return;\n        }\n        if (typeof o != \"boolean\") {\n          const h = X(\n            t.state.doc,\n            o()\n          );\n          if (h.node.type.name !== \"blockContainer\")\n            throw new Error(\n              `Expected blockContainer node, got ${h.node.type.name}`\n            );\n          this.editor.commands.command(\n            x(\n              this.options.editor,\n              h.posBeforeNode,\n              {\n                type: \"checkListItem\",\n                props: {\n                  checked: i.checked\n                }\n              }\n            )\n          );\n        }\n      };\n      i.addEventListener(\"change\", a);\n      const { dom: c, contentDOM: l } = z(\n        this.name,\n        \"p\",\n        {\n          ...((d = this.options.domAttributes) == null ? void 0 : d.blockContent) || {},\n          ...n\n        },\n        ((p = this.options.domAttributes) == null ? void 0 : p.inlineContent) || {}\n      );\n      if (typeof o != \"boolean\") {\n        const f = \"label-\" + this.editor.state.doc.resolve(o()).node().attrs.id;\n        i.setAttribute(\"aria-labelledby\", f), l.id = f;\n      }\n      return c.removeChild(l), c.appendChild(r), r.appendChild(s), r.appendChild(l), s.appendChild(i), {\n        dom: c,\n        contentDOM: l,\n        destroy: () => {\n          i.removeEventListener(\"change\", a);\n        }\n      };\n    };\n  }\n}), Kr = Z(\n  qr,\n  ho\n), Xr = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"numbered-list-indexing\"), Jr = () => new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n  key: Xr,\n  appendTransaction: (e, o, t) => {\n    const n = t.tr;\n    n.setMeta(\"numberedListIndexing\", !0);\n    let r = !1;\n    return t.doc.descendants((s, i) => {\n      var a;\n      if (s.type.name === \"blockContainer\" && s.firstChild.type.name === \"numberedListItem\") {\n        let c = `${s.firstChild.attrs.start || 1}`;\n        const l = ne({\n          posBeforeNode: i,\n          node: s\n        });\n        if (!l.isBlockContainer)\n          throw new Error(\"impossible\");\n        const d = n.doc.resolve(\n          l.bnBlock.beforePos\n        ).nodeBefore;\n        if (d) {\n          const m = ne({\n            posBeforeNode: l.bnBlock.beforePos - d.nodeSize,\n            node: d\n          });\n          if (m.blockNoteType === \"numberedListItem\") {\n            if (!m.isBlockContainer)\n              throw new Error(\"impossible\");\n            const b = m.blockContent.node.attrs.index;\n            c = (parseInt(b) + 1).toString();\n          }\n        }\n        const p = l.blockContent.node, h = p.attrs.index, f = ((a = d == null ? void 0 : d.firstChild) == null ? void 0 : a.type.name) !== \"numberedListItem\";\n        if (h !== c || p.attrs.start && !f) {\n          r = !0;\n          const { start: m, ...g } = p.attrs;\n          n.setNodeMarkup(l.blockContent.beforePos, void 0, {\n            ...g,\n            index: c,\n            ...typeof m == \"number\" && f && {\n              start: m\n            }\n          });\n        }\n      }\n    }), r ? n : null;\n  }\n}), fo = {\n  ...S,\n  start: { default: void 0, type: \"number\" }\n}, Yr = W({\n  name: \"numberedListItem\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  priority: 90,\n  addAttributes() {\n    return {\n      ...Ee(fo),\n      // the index attribute is only used internally (it's not part of the blocknote schema)\n      // that's why it's defined explicitly here, and not part of the prop schema\n      index: {\n        default: null,\n        parseHTML: (e) => e.getAttribute(\"data-index\"),\n        renderHTML: (e) => ({\n          \"data-index\": e.index\n        })\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      // Creates an ordered list when starting with \"1.\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.InputRule({\n        find: new RegExp(\"^(\\\\d+)\\\\.\\\\s$\"),\n        handler: ({ state: e, chain: o, range: t, match: n }) => {\n          const r = C(e);\n          if (!r.isBlockContainer || r.blockContent.node.type.spec.content !== \"inline*\" || r.blockNoteType === \"numberedListItem\")\n            return;\n          const s = parseInt(n[1]);\n          o().command(\n            x(\n              this.options.editor,\n              r.bnBlock.beforePos,\n              {\n                type: \"numberedListItem\",\n                props: s === 1 && {} || {\n                  start: s\n                }\n              }\n            )\n          ).deleteRange({ from: t.from, to: t.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => pt(this.options.editor),\n      \"Mod-Shift-7\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"numberedListItem\",\n            props: {}\n          })\n        );\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [Jr()];\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\"\n      },\n      // Case for regular HTML list structure.\n      // (e.g.: when pasting from other apps)\n      {\n        tag: \"li\",\n        getAttrs: (e) => {\n          if (typeof e == \"string\")\n            return !1;\n          const o = e.parentElement;\n          if (o === null)\n            return !1;\n          if (o.tagName === \"OL\" || o.tagName === \"DIV\" && o.parentElement.tagName === \"OL\") {\n            const t = parseInt(o.getAttribute(\"start\") || \"1\") || 1;\n            return e.previousSibling || t === 1 ? {} : {\n              start: t\n            };\n          }\n          return !1;\n        },\n        node: \"numberedListItem\"\n      },\n      // Case for BlockNote list structure.\n      // (e.g.: when pasting from blocknote)\n      {\n        tag: \"p\",\n        getAttrs: (e) => {\n          if (typeof e == \"string\")\n            return !1;\n          const o = e.parentElement;\n          return o === null ? !1 : o.getAttribute(\"data-content-type\") === \"numberedListItem\" ? {} : !1;\n        },\n        priority: 300,\n        node: \"numberedListItem\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var o, t;\n    return z(\n      this.name,\n      // We use a <p> tag, because for <li> tags we'd need an <ol> element to\n      // put them in to be semantically correct, which we can't have due to the\n      // schema.\n      \"p\",\n      {\n        ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},\n        ...e\n      },\n      ((t = this.options.domAttributes) == null ? void 0 : t.inlineContent) || {}\n    );\n  }\n}), Zr = Z(\n  Yr,\n  fo\n), Qr = {\n  ...S\n}, es = W({\n  name: \"paragraph\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-0\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"paragraph\",\n            props: {}\n          })\n        );\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      { tag: \"div[data-content-type=\" + this.name + \"]\" },\n      {\n        tag: \"p\",\n        priority: 200,\n        getAttrs: (e) => {\n          var o;\n          return typeof e == \"string\" || !((o = e.textContent) != null && o.trim()) ? !1 : {};\n        },\n        node: \"paragraph\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var o, t;\n    return z(\n      this.name,\n      \"p\",\n      {\n        ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},\n        ...e\n      },\n      ((t = this.options.domAttributes) == null ? void 0 : t.inlineContent) || {}\n    );\n  }\n}), ts = Z(\n  es,\n  Qr\n), os = {\n  ...S\n}, ns = W({\n  name: \"quote\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addInputRules() {\n    return [\n      // Creates a block quote when starting with \">\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.InputRule({\n        find: new RegExp(\"^>\\\\s$\"),\n        handler: ({ state: e, chain: o, range: t }) => {\n          const n = C(e);\n          !n.isBlockContainer || n.blockContent.node.type.spec.content !== \"inline*\" || o().command(\n            x(\n              this.options.editor,\n              n.bnBlock.beforePos,\n              {\n                type: \"quote\",\n                props: {}\n              }\n            )\n          ).deleteRange({ from: t.from, to: t.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-q\": () => {\n        const e = C(this.editor.state);\n        return !e.isBlockContainer || e.blockContent.node.type.spec.content !== \"inline*\" ? !0 : this.editor.commands.command(\n          x(this.options.editor, e.bnBlock.beforePos, {\n            type: \"quote\"\n          })\n        );\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      { tag: \"div[data-content-type=\" + this.name + \"]\" },\n      {\n        tag: \"blockquote\",\n        node: \"quote\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var o, t;\n    return z(\n      this.name,\n      \"blockquote\",\n      {\n        ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},\n        ...e\n      },\n      ((t = this.options.domAttributes) == null ? void 0 : t.inlineContent) || {}\n    );\n  }\n}), rs = Z(\n  ns,\n  os\n), ss = 35, mo = 120, ac = 31, is = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"BlockNoteTableExtension\",\n  addProseMirrorPlugins: () => [\n    (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.columnResizing)({\n      cellMinWidth: ss,\n      defaultCellMinWidth: mo,\n      // We set this to null as we implement our own node view in the table\n      // block content. This node view is the same as what's used by default,\n      // but is wrapped in a `blockContent` HTML element.\n      View: null\n    }),\n    (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.tableEditing)()\n  ],\n  addKeyboardShortcuts() {\n    return {\n      // Makes enter create a new line within the cell.\n      Enter: () => this.editor.state.selection.empty && this.editor.state.selection.$head.parent.type.name === \"tableParagraph\" ? (this.editor.commands.insertContent({ type: \"hardBreak\" }), !0) : !1,\n      // Ensures that backspace won't delete the table if the text cursor is at\n      // the start of a cell and the selection is empty.\n      Backspace: () => {\n        const e = this.editor.state.selection, o = e.empty, t = e.$head.parentOffset === 0, n = e.$head.node().type.name === \"tableParagraph\";\n        return o && t && n;\n      },\n      // Enables navigating cells using the tab key.\n      Tab: () => this.editor.commands.command(\n        ({ state: e, dispatch: o, view: t }) => (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.goToNextCell)(1)(e, o, t)\n      ),\n      \"Shift-Tab\": () => this.editor.commands.command(\n        ({ state: e, dispatch: o, view: t }) => (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.goToNextCell)(-1)(e, o, t)\n      )\n    };\n  },\n  extendNodeSchema(e) {\n    const o = {\n      name: e.name,\n      options: e.options,\n      storage: e.storage\n    };\n    return {\n      tableRole: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.callOrReturn)(\n        (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.getExtensionField)(e, \"tableRole\", o)\n      )\n    };\n  }\n}), as = {\n  textColor: S.textColor\n}, cs = W({\n  name: \"table\",\n  content: \"tableRow+\",\n  group: \"blockContent\",\n  tableRole: \"table\",\n  isolating: !0,\n  parseHTML() {\n    return [{ tag: \"table\" }];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var o, t;\n    return z(\n      this.name,\n      \"table\",\n      {\n        ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},\n        ...e\n      },\n      ((t = this.options.domAttributes) == null ? void 0 : t.inlineContent) || {}\n    );\n  },\n  // This node view is needed for the `columnResizing` plugin. By default, the\n  // plugin adds its own node view, which overrides how the node is rendered vs\n  // `renderHTML`. This means that the wrapping `blockContent` HTML element is\n  // no longer rendered. The `columnResizing` plugin uses the `TableView` as its\n  // default node view. `BlockNoteTableView` extends it by wrapping it in a\n  // `blockContent` element, so the DOM structure is consistent with other block\n  // types.\n  addNodeView() {\n    return ({ node: e, HTMLAttributes: o }) => {\n      var n;\n      class t extends prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.TableView {\n        constructor(s, i, a) {\n          super(s, i), this.node = s, this.cellMinWidth = i, this.blockContentHTMLAttributes = a;\n          const c = document.createElement(\"div\");\n          c.className = Y(\n            \"bn-block-content\",\n            a.class\n          ), c.setAttribute(\"data-content-type\", \"table\");\n          for (const [h, f] of Object.entries(\n            a\n          ))\n            h !== \"class\" && c.setAttribute(h, f);\n          const l = this.dom, d = document.createElement(\"div\");\n          d.className = \"tableWrapper-inner\", d.appendChild(l.firstChild), l.appendChild(d), c.appendChild(l);\n          const p = document.createElement(\"div\");\n          p.className = \"table-widgets-container\", p.style.position = \"relative\", l.appendChild(p), this.dom = c;\n        }\n        ignoreMutation(s) {\n          return !s.target.closest(\".tableWrapper-inner\") || super.ignoreMutation(s);\n        }\n      }\n      return new t(e, mo, {\n        ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},\n        ...o\n      });\n    };\n  }\n}), ls = W({\n  name: \"tableParagraph\",\n  group: \"tableContent\",\n  content: \"inline*\",\n  parseHTML() {\n    return [\n      {\n        preserveWhitespace: \"full\",\n        // set this rule as high priority so it takes precedence over the default paragraph rule,\n        // but only if we're in the tableContent context\n        priority: 210,\n        context: \"tableContent\",\n        tag: \"p\",\n        getAttrs: (e) => ({})\n      },\n      {\n        tag: \"p\",\n        getAttrs: (e) => {\n          if (typeof e == \"string\" || !e.textContent)\n            return !1;\n          const o = e.parentElement;\n          return o === null ? !1 : o.tagName === \"TD\" ? {} : !1;\n        }\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    return [\"p\", e, 0];\n  }\n}), ds = Z(\n  cs,\n  as,\n  [\n    is,\n    ls,\n    _tiptap_extension_table_header__WEBPACK_IMPORTED_MODULE_7__.TableHeader.extend({\n      /**\n       * We allow table headers and cells to have multiple tableContent nodes because\n       * when merging cells, prosemirror-tables will concat the contents of the cells naively.\n       * This would cause that content to overflow into other cells when prosemirror tries to enforce the cell structure.\n       *\n       * So, we manually fix this up when reading back in the `nodeToBlock` and only ever place a single tableContent back into the cell.\n       */\n      content: \"tableContent+\"\n    }),\n    _tiptap_extension_table_cell__WEBPACK_IMPORTED_MODULE_6__.TableCell.extend({\n      content: \"tableContent+\"\n    }),\n    _tiptap_extension_table_row__WEBPACK_IMPORTED_MODULE_8__.TableRow\n  ]\n), Pt = (e) => {\n  const o = e.src || void 0, t = e.width || void 0;\n  return { url: o, previewWidth: t };\n}, ps = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z\"></path></svg>', us = {\n  textAlignment: S.textAlignment,\n  backgroundColor: S.backgroundColor,\n  // File name.\n  name: {\n    default: \"\"\n  },\n  // File url.\n  url: {\n    default: \"\"\n  },\n  // File caption.\n  caption: {\n    default: \"\"\n  },\n  showPreview: {\n    default: !0\n  },\n  // File preview width in px.\n  previewWidth: {\n    default: 512\n  }\n}, hs = {\n  type: \"video\",\n  propSchema: us,\n  content: \"none\",\n  isFileBlock: !0,\n  fileBlockAccept: [\"video/*\"]\n}, fs = (e, o) => {\n  const t = document.createElement(\"div\");\n  t.innerHTML = ps;\n  const n = document.createElement(\"div\");\n  n.className = \"bn-visual-media-wrapper\";\n  const r = document.createElement(\"video\");\n  return r.className = \"bn-visual-media\", o.resolveFileUrl ? o.resolveFileUrl(e.props.url).then((s) => {\n    r.src = s;\n  }) : r.src = e.props.url, r.controls = !0, r.contentEditable = \"false\", r.draggable = !1, r.width = e.props.previewWidth, n.appendChild(r), lo(\n    e,\n    o,\n    { dom: n },\n    n,\n    o.dictionary.file_blocks.video.add_button_text,\n    t.firstElementChild\n  );\n}, ms = (e) => {\n  if (e.tagName === \"VIDEO\")\n    return Pt(e);\n  if (e.tagName === \"FIGURE\") {\n    const o = Ue(e, \"video\");\n    if (!o)\n      return;\n    const { targetElement: t, caption: n } = o;\n    return {\n      ...Pt(t),\n      caption: n\n    };\n  }\n}, gs = (e) => {\n  if (!e.props.url) {\n    const t = document.createElement(\"p\");\n    return t.textContent = \"Add video\", {\n      dom: t\n    };\n  }\n  let o;\n  return e.props.showPreview ? (o = document.createElement(\"video\"), o.src = e.props.url, o.width = e.props.previewWidth) : (o = document.createElement(\"a\"), o.href = e.props.url, o.textContent = e.props.name || e.props.url), e.props.caption ? e.props.showPreview ? dt(o, e.props.caption) : $e(o, e.props.caption) : {\n    dom: o\n  };\n}, bs = Se(hs, {\n  render: fs,\n  parse: ms,\n  toExternalHTML: gs\n}), go = {\n  paragraph: ts,\n  heading: zr,\n  quote: rs,\n  codeBlock: wr,\n  bulletListItem: Gr,\n  numberedListItem: Zr,\n  checkListItem: Kr,\n  table: ds,\n  file: Br,\n  image: Ar,\n  video: bs,\n  audio: gr\n}, ks = Xt(go), bo = {\n  bold: ee(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__[\"default\"], \"boolean\"),\n  italic: ee(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_3__[\"default\"], \"boolean\"),\n  underline: ee(_tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_5__[\"default\"], \"boolean\"),\n  strike: ee(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_4__[\"default\"], \"boolean\"),\n  code: ee(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__[\"default\"], \"boolean\"),\n  textColor: $r,\n  backgroundColor: Vr\n}, cc = Qt(bo), ko = {\n  text: { config: \"text\", implementation: {} },\n  link: { config: \"link\", implementation: {} }\n}, ws = Yt(\n  ko\n);\nfunction L(e, o) {\n  return e in o.schema.blockSchema && o.schema.blockSchema[e] === ks[e];\n}\nfunction ys(e, o) {\n  return e in o.schema.inlineContentSchema && o.schema.inlineContentSchema[e] === ws[e];\n}\nfunction Cs(e, o, t) {\n  return o.type === e && o.type in t.schema.blockSchema && L(o.type, t);\n}\nfunction lc(e, o) {\n  return e.type in o.schema.blockSchema && o.schema.blockSchema[e.type].isFileBlock || !1;\n}\nfunction dc(e, o) {\n  return e.type in o.schema.blockSchema && o.schema.blockSchema[e.type].isFileBlock && \"showPreview\" in o.schema.blockSchema[e.type].propSchema || !1;\n}\nfunction pc(e, o) {\n  return o.schema.blockSchema[e.type].isFileBlock && !e.props.url;\n}\nfunction vs(e, o, t) {\n  return o in t.schema.blockSchema && e in t.schema.blockSchema[o].propSchema && t.schema.blockSchema[o].propSchema[e] === S[e];\n}\nfunction uc(e, o, t) {\n  return vs(e, o.type, t);\n}\nfunction It(e) {\n  return e instanceof prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.CellSelection;\n}\nfunction Es(e) {\n  let o = e.getTextCursorPosition().block, t = e.schema.blockSchema[o.type].content;\n  for (; t === \"none\"; ) {\n    if (o = e.getTextCursorPosition().nextBlock, o === void 0)\n      return;\n    t = e.schema.blockSchema[o.type].content, e.setTextCursorPosition(o, \"end\");\n  }\n}\nfunction P(e, o) {\n  const t = e.getTextCursorPosition().block;\n  if (t.content === void 0)\n    throw new Error(\"Slash Menu open in a block that doesn't contain content.\");\n  let n;\n  return Array.isArray(t.content) && (t.content.length === 1 && J(t.content[0]) && t.content[0].type === \"text\" && t.content[0].text === \"/\" || t.content.length === 0) ? (n = e.updateBlock(t, o), e.setTextCursorPosition(n)) : (n = e.insertBlocks([o], t, \"after\")[0], e.setTextCursorPosition(e.getTextCursorPosition().nextBlock)), Es(e), n;\n}\nfunction hc(e) {\n  const o = [];\n  return L(\"heading\", e) && o.push(\n    {\n      onItemClick: () => {\n        P(e, {\n          type: \"heading\",\n          props: { level: 1 }\n        });\n      },\n      badge: K(\"Mod-Alt-1\"),\n      key: \"heading\",\n      ...e.dictionary.slash_menu.heading\n    },\n    {\n      onItemClick: () => {\n        P(e, {\n          type: \"heading\",\n          props: { level: 2 }\n        });\n      },\n      badge: K(\"Mod-Alt-2\"),\n      key: \"heading_2\",\n      ...e.dictionary.slash_menu.heading_2\n    },\n    {\n      onItemClick: () => {\n        P(e, {\n          type: \"heading\",\n          props: { level: 3 }\n        });\n      },\n      badge: K(\"Mod-Alt-3\"),\n      key: \"heading_3\",\n      ...e.dictionary.slash_menu.heading_3\n    }\n  ), L(\"quote\", e) && o.push({\n    onItemClick: () => {\n      P(e, {\n        type: \"quote\"\n      });\n    },\n    key: \"quote\",\n    ...e.dictionary.slash_menu.quote\n  }), L(\"numberedListItem\", e) && o.push({\n    onItemClick: () => {\n      P(e, {\n        type: \"numberedListItem\"\n      });\n    },\n    badge: K(\"Mod-Shift-7\"),\n    key: \"numbered_list\",\n    ...e.dictionary.slash_menu.numbered_list\n  }), L(\"bulletListItem\", e) && o.push({\n    onItemClick: () => {\n      P(e, {\n        type: \"bulletListItem\"\n      });\n    },\n    badge: K(\"Mod-Shift-8\"),\n    key: \"bullet_list\",\n    ...e.dictionary.slash_menu.bullet_list\n  }), L(\"checkListItem\", e) && o.push({\n    onItemClick: () => {\n      P(e, {\n        type: \"checkListItem\"\n      });\n    },\n    badge: K(\"Mod-Shift-9\"),\n    key: \"check_list\",\n    ...e.dictionary.slash_menu.check_list\n  }), L(\"paragraph\", e) && o.push({\n    onItemClick: () => {\n      P(e, {\n        type: \"paragraph\"\n      });\n    },\n    badge: K(\"Mod-Alt-0\"),\n    key: \"paragraph\",\n    ...e.dictionary.slash_menu.paragraph\n  }), L(\"codeBlock\", e) && o.push({\n    onItemClick: () => {\n      P(e, {\n        type: \"codeBlock\"\n      });\n    },\n    badge: K(\"Mod-Alt-c\"),\n    key: \"code_block\",\n    ...e.dictionary.slash_menu.code_block\n  }), L(\"table\", e) && o.push({\n    onItemClick: () => {\n      P(e, {\n        type: \"table\",\n        content: {\n          type: \"tableContent\",\n          rows: [\n            {\n              cells: [\"\", \"\", \"\"]\n            },\n            {\n              cells: [\"\", \"\", \"\"]\n            }\n          ]\n        }\n      });\n    },\n    badge: void 0,\n    key: \"table\",\n    ...e.dictionary.slash_menu.table\n  }), L(\"image\", e) && o.push({\n    onItemClick: () => {\n      const t = P(e, {\n        type: \"image\"\n      });\n      e.dispatch(\n        e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {\n          block: t\n        })\n      );\n    },\n    key: \"image\",\n    ...e.dictionary.slash_menu.image\n  }), L(\"video\", e) && o.push({\n    onItemClick: () => {\n      const t = P(e, {\n        type: \"video\"\n      });\n      e.dispatch(\n        e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {\n          block: t\n        })\n      );\n    },\n    key: \"video\",\n    ...e.dictionary.slash_menu.video\n  }), L(\"audio\", e) && o.push({\n    onItemClick: () => {\n      const t = P(e, {\n        type: \"audio\"\n      });\n      e.dispatch(\n        e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {\n          block: t\n        })\n      );\n    },\n    key: \"audio\",\n    ...e.dictionary.slash_menu.audio\n  }), L(\"file\", e) && o.push({\n    onItemClick: () => {\n      const t = P(e, {\n        type: \"file\"\n      });\n      e.dispatch(\n        e._tiptapEditor.state.tr.setMeta(e.filePanel.plugin, {\n          block: t\n        })\n      );\n    },\n    key: \"file\",\n    ...e.dictionary.slash_menu.file\n  }), o.push({\n    onItemClick: () => {\n      e.openSuggestionMenu(\":\", {\n        deleteTriggerCharacter: !0,\n        ignoreQueryLength: !0\n      });\n    },\n    key: \"emoji\",\n    ...e.dictionary.slash_menu.emoji\n  }), o;\n}\nfunction fc(e, o) {\n  return e.filter(\n    ({ title: t, aliases: n }) => t.toLowerCase().includes(o.toLowerCase()) || n && n.filter(\n      (r) => r.toLowerCase().includes(o.toLowerCase())\n    ).length !== 0\n  );\n}\nfunction je(e) {\n  return e && Object.fromEntries(\n    Object.entries(e).filter(([, o]) => o !== void 0)\n  );\n}\nclass Be {\n  constructor(o) {\n    u(this, \"blockSpecs\");\n    u(this, \"inlineContentSpecs\");\n    u(this, \"styleSpecs\");\n    u(this, \"blockSchema\");\n    u(this, \"inlineContentSchema\");\n    u(this, \"styleSchema\");\n    // Helper so that you can use typeof schema.BlockNoteEditor\n    u(this, \"BlockNoteEditor\", \"only for types\");\n    u(this, \"Block\", \"only for types\");\n    u(this, \"PartialBlock\", \"only for types\");\n    this.blockSpecs = je(o == null ? void 0 : o.blockSpecs) || go, this.inlineContentSpecs = je(o == null ? void 0 : o.inlineContentSpecs) || ko, this.styleSpecs = je(o == null ? void 0 : o.styleSpecs) || bo, this.blockSchema = Xt(this.blockSpecs), this.inlineContentSchema = Yt(\n      this.inlineContentSpecs\n    ), this.styleSchema = Qt(this.styleSpecs);\n  }\n  static create(o) {\n    return new Be(o);\n  }\n}\nconst wo = Be.create({\n  blockSpecs: {\n    pageBreak: _r\n  }\n}), mc = (e) => Be.create({\n  blockSpecs: {\n    ...e.blockSpecs,\n    ...wo.blockSpecs\n  },\n  inlineContentSpecs: e.inlineContentSpecs,\n  styleSpecs: e.styleSpecs\n});\nfunction Ss(e) {\n  return \"pageBreak\" in e.schema.blockSchema && e.schema.blockSchema.pageBreak === wo.blockSchema.pageBreak;\n}\nfunction gc(e) {\n  const o = [];\n  return Ss(e) && o.push({\n    ...e.dictionary.slash_menu.page_break,\n    onItemClick: () => {\n      P(e, {\n        type: \"pageBreak\"\n      });\n    },\n    key: \"page_break\"\n  }), o;\n}\nfunction Bs(e, o, t, n = \"before\") {\n  const r = typeof t == \"string\" ? t : t.id, s = [];\n  for (const c of o)\n    s.push(\n      ie(c, e.pmSchema, e.schema.styleSchema)\n    );\n  const i = D(r, e._tiptapEditor.state.doc);\n  if (!i)\n    throw new Error(`Block with ID ${r} not found`);\n  n === \"before\" && e.dispatch(\n    e._tiptapEditor.state.tr.insert(i.posBeforeNode, s)\n  ), n === \"after\" && e.dispatch(\n    e._tiptapEditor.state.tr.insert(\n      i.posBeforeNode + i.node.nodeSize,\n      s\n    )\n  );\n  const a = [];\n  for (const c of s)\n    a.push(\n      E(\n        c,\n        e.schema.blockSchema,\n        e.schema.inlineContentSchema,\n        e.schema.styleSchema,\n        e.blockCache\n      )\n    );\n  return a;\n}\nfunction Ts(e) {\n  const o = e._tiptapEditor.state, t = o.selection, n = X(o.doc, t.anchor);\n  if (t instanceof prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.CellSelection)\n    return {\n      type: \"cell\",\n      anchorBlockId: n.node.attrs.id,\n      anchorCellOffset: t.$anchorCell.pos - n.posBeforeNode,\n      headCellOffset: t.$headCell.pos - n.posBeforeNode\n    };\n  if (e._tiptapEditor.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.NodeSelection)\n    return {\n      type: \"node\",\n      anchorBlockId: n.node.attrs.id\n    };\n  {\n    const r = X(o.doc, t.head);\n    return {\n      type: \"text\",\n      anchorBlockId: n.node.attrs.id,\n      headBlockId: r.node.attrs.id,\n      anchorOffset: t.anchor - n.posBeforeNode,\n      headOffset: t.head - r.posBeforeNode\n    };\n  }\n}\nfunction xs(e, o) {\n  var r, s;\n  const t = (r = D(\n    o.anchorBlockId,\n    e._tiptapEditor.state.doc\n  )) == null ? void 0 : r.posBeforeNode;\n  if (t === void 0)\n    throw new Error(\n      `Could not find block with ID ${o.anchorBlockId} to update selection`\n    );\n  let n;\n  if (o.type === \"cell\")\n    n = prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.CellSelection.create(\n      e._tiptapEditor.state.doc,\n      t + o.anchorCellOffset,\n      t + o.headCellOffset\n    );\n  else if (o.type === \"node\")\n    n = prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.NodeSelection.create(\n      e._tiptapEditor.state.doc,\n      t + 1\n    );\n  else {\n    const i = (s = D(\n      o.headBlockId,\n      e._tiptapEditor.state.doc\n    )) == null ? void 0 : s.posBeforeNode;\n    if (i === void 0)\n      throw new Error(\n        `Could not find block with ID ${o.headBlockId} to update selection`\n      );\n    n = prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.create(\n      e._tiptapEditor.state.doc,\n      t + o.anchorOffset,\n      i + o.headOffset\n    );\n  }\n  e.dispatch(e._tiptapEditor.state.tr.setSelection(n));\n}\nfunction nt(e) {\n  return e.map((o) => o.type === \"columnList\" ? o.children.map((t) => nt(t.children)).flat() : {\n    ...o,\n    children: nt(o.children)\n  }).flat();\n}\nfunction yo(e, o, t) {\n  var s;\n  const n = ((s = e.getSelection()) == null ? void 0 : s.blocks) || [\n    e.getTextCursorPosition().block\n  ], r = Ts(e);\n  e.removeBlocks(n), e.insertBlocks(nt(n), o, t), xs(e, r);\n}\nfunction Co(e) {\n  return !e || e.type !== \"columnList\";\n}\nfunction vo(e, o, t) {\n  let n, r;\n  if (o ? o.children.length > 0 ? (n = o.children[o.children.length - 1], r = \"after\") : (n = o, r = \"before\") : t && (n = t, r = \"before\"), !n || !r)\n    return;\n  const s = e.getParentBlock(n);\n  return Co(s) ? { referenceBlock: n, placement: r } : vo(\n    e,\n    r === \"after\" ? n : e.getPrevBlock(n),\n    s\n  );\n}\nfunction Eo(e, o, t) {\n  let n, r;\n  if (o ? o.children.length > 0 ? (n = o.children[0], r = \"before\") : (n = o, r = \"after\") : t && (n = t, r = \"after\"), !n || !r)\n    return;\n  const s = e.getParentBlock(n);\n  return Co(s) ? { referenceBlock: n, placement: r } : Eo(\n    e,\n    r === \"before\" ? n : e.getNextBlock(n),\n    s\n  );\n}\nfunction Ms(e) {\n  const o = e.getSelection(), t = (o == null ? void 0 : o.blocks[0]) || e.getTextCursorPosition().block, n = vo(\n    e,\n    e.getPrevBlock(t),\n    e.getParentBlock(t)\n  );\n  n && yo(\n    e,\n    n.referenceBlock,\n    n.placement\n  );\n}\nfunction Ps(e) {\n  const o = e.getSelection(), t = (o == null ? void 0 : o.blocks[(o == null ? void 0 : o.blocks.length) - 1]) || e.getTextCursorPosition().block, n = Eo(\n    e,\n    e.getNextBlock(t),\n    e.getParentBlock(t)\n  );\n  n && yo(\n    e,\n    n.referenceBlock,\n    n.placement\n  );\n}\nfunction Is(e, o) {\n  return function({ state: t, dispatch: n }) {\n    const { $from: r, $to: s } = t.selection, i = r.blockRange(\n      s,\n      (d) => d.childCount > 0 && (d.type.name === \"blockGroup\" || d.type.name === \"column\")\n      // change necessary to not look at first item child type\n    );\n    if (!i)\n      return !1;\n    const a = i.startIndex;\n    if (a === 0)\n      return !1;\n    const l = i.parent.child(a - 1);\n    if (l.type !== e)\n      return !1;\n    if (n) {\n      const d = l.lastChild && l.lastChild.type === o, p = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(d ? e.create() : null), h = new prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Slice(\n        prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(\n          e.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(o.create(null, p)))\n          // change necessary to create \"groupType\" instead of parent.type\n        ),\n        d ? 3 : 1,\n        0\n      ), f = i.start, m = i.end;\n      n(\n        t.tr.step(\n          new prosemirror_transform__WEBPACK_IMPORTED_MODULE_19__.ReplaceAroundStep(\n            f - (d ? 3 : 1),\n            m,\n            f,\n            m,\n            h,\n            1,\n            !0\n          )\n        ).scrollIntoView()\n      );\n    }\n    return !0;\n  };\n}\nfunction So(e) {\n  return e._tiptapEditor.commands.command(\n    Is(\n      e._tiptapEditor.schema.nodes.blockContainer,\n      e._tiptapEditor.schema.nodes.blockGroup\n    )\n  );\n}\nfunction Ls(e) {\n  e._tiptapEditor.commands.liftListItem(\"blockContainer\");\n}\nfunction As(e) {\n  const { bnBlock: o } = C(\n    e._tiptapEditor.state\n  );\n  return e._tiptapEditor.state.doc.resolve(o.beforePos).nodeBefore !== null;\n}\nfunction Ns(e) {\n  const { bnBlock: o } = C(\n    e._tiptapEditor.state\n  );\n  return e._tiptapEditor.state.doc.resolve(o.beforePos).depth > 1;\n}\nfunction Bo(e, o, t) {\n  const n = e._tiptapEditor;\n  let r = n.state.tr;\n  const s = [];\n  for (const p of t)\n    s.push(\n      ie(p, e.pmSchema, e.schema.styleSchema)\n    );\n  const i = new Set(\n    o.map(\n      (p) => typeof p == \"string\" ? p : p.id\n    )\n  ), a = [], c = typeof o[0] == \"string\" ? o[0] : o[0].id;\n  let l = 0;\n  if (n.state.doc.descendants((p, h) => {\n    if (i.size === 0)\n      return !1;\n    if (!p.type.isInGroup(\"bnBlock\") || !i.has(p.attrs.id))\n      return !0;\n    if (a.push(\n      E(\n        p,\n        e.schema.blockSchema,\n        e.schema.inlineContentSchema,\n        e.schema.styleSchema,\n        e.blockCache\n      )\n    ), i.delete(p.attrs.id), t.length > 0 && p.attrs.id === c) {\n      const b = r.doc.nodeSize;\n      r = r.insert(h, s);\n      const k = r.doc.nodeSize;\n      l += b - k;\n    }\n    const f = r.doc.nodeSize, m = r.doc.resolve(h - l);\n    m.node().type.name === \"blockGroup\" && m.node(m.depth - 1).type.name !== \"doc\" && m.node().childCount === 1 ? r = r.delete(m.before(), m.after()) : r = r.delete(h - l, h - l + p.nodeSize);\n    const g = r.doc.nodeSize;\n    return l += f - g, !1;\n  }), i.size > 0) {\n    const p = [...i].join(`\n`);\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" + p\n    );\n  }\n  e.dispatch(r);\n  const d = [];\n  for (const p of s)\n    d.push(\n      E(\n        p,\n        e.schema.blockSchema,\n        e.schema.inlineContentSchema,\n        e.schema.styleSchema,\n        e.blockCache\n      )\n    );\n  return { insertedBlocks: d, removedBlocks: a };\n}\nfunction Hs(e, o, t) {\n  return Bo(e, o, t);\n}\nfunction Ds(e, o) {\n  return Bo(e, o, []).removedBlocks;\n}\nfunction Os(e, o) {\n  const t = typeof o == \"string\" ? o : o.id, n = D(t, e._tiptapEditor.state.doc);\n  if (n)\n    return E(\n      n.node,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    );\n}\nfunction _s(e, o) {\n  const t = typeof o == \"string\" ? o : o.id, n = D(t, e._tiptapEditor.state.doc);\n  if (!n)\n    return;\n  const s = e._tiptapEditor.state.doc.resolve(\n    n.posBeforeNode\n  ).nodeBefore;\n  if (s)\n    return E(\n      s,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    );\n}\nfunction Rs(e, o) {\n  const t = typeof o == \"string\" ? o : o.id, n = D(t, e._tiptapEditor.state.doc);\n  if (!n)\n    return;\n  const s = e._tiptapEditor.state.doc.resolve(\n    n.posBeforeNode + n.node.nodeSize\n  ).nodeAfter;\n  if (s)\n    return E(\n      s,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    );\n}\nfunction Vs(e, o) {\n  const t = typeof o == \"string\" ? o : o.id, n = D(t, e._tiptapEditor.state.doc);\n  if (!n)\n    return;\n  const r = e._tiptapEditor.state.doc.resolve(\n    n.posBeforeNode\n  ), s = r.node(), i = r.node(-1), a = i.type.name !== \"doc\" ? s.type.name === \"blockGroup\" ? i : s : void 0;\n  if (a)\n    return E(\n      a,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    );\n}\nfunction Us(e, o, t, n = { updateSelection: !0 }) {\n  const r = t._tiptapEditor.state.tr;\n  let { from: s, to: i } = typeof e == \"number\" ? { from: e, to: e } : { from: e.from, to: e.to }, a = !0, c = !0, l = \"\";\n  if (o.forEach((d) => {\n    d.check(), a && d.isText && d.marks.length === 0 ? l += d.text : a = !1, c = c ? d.isBlock : !1;\n  }), s === i && c) {\n    const { parent: d } = r.doc.resolve(s);\n    d.isTextblock && !d.type.spec.code && !d.childCount && (s -= 1, i += 1);\n  }\n  return a ? r.insertText(l, s, i) : r.replaceWith(s, i, o), n.updateSelection && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.selectionToInsertionEnd)(r, r.steps.length - 1, -1), t.dispatch(r), !0;\n}\nfunction $s(e) {\n  const o = e._tiptapEditor.state;\n  if (o.selection.empty || \"node\" in o.selection)\n    return;\n  const t = o.doc.resolve(\n    X(o.doc, o.selection.from).posBeforeNode\n  ), n = o.doc.resolve(\n    X(o.doc, o.selection.to).posBeforeNode\n  ), r = (l, d) => {\n    const p = t.posAtIndex(l, d), h = o.doc.resolve(p).nodeAfter;\n    if (!h)\n      throw new Error(\n        `Error getting selection - node not found at position ${p}`\n      );\n    return E(\n      h,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    );\n  }, s = [], i = t.sharedDepth(n.pos), a = t.index(i), c = n.index(i);\n  if (t.depth > i) {\n    s.push(\n      E(\n        t.nodeAfter,\n        e.schema.blockSchema,\n        e.schema.inlineContentSchema,\n        e.schema.styleSchema,\n        e.blockCache\n      )\n    );\n    for (let l = t.depth; l > i; l--)\n      if (t.node(l).type.isInGroup(\"childContainer\")) {\n        const p = t.index(l) + 1, h = t.node(l).childCount;\n        for (let f = p; f < h; f++)\n          s.push(r(f, l));\n      }\n  } else\n    s.push(r(a, i));\n  for (let l = a + 1; l <= c; l++)\n    s.push(r(l, i));\n  if (s.length === 0)\n    throw new Error(\n      `Error getting selection - selection doesn't span any blocks (${o.selection})`\n    );\n  return {\n    blocks: s\n  };\n}\nfunction Fs(e, o, t) {\n  const n = typeof o == \"string\" ? o : o.id, r = typeof t == \"string\" ? t : t.id;\n  if (n === r)\n    throw new Error(\n      `Attempting to set selection with the same anchor and head blocks (id ${n})`\n    );\n  const s = e._tiptapEditor.state.doc, i = D(n, s);\n  if (!i)\n    throw new Error(`Block with ID ${n} not found`);\n  const a = D(r, s);\n  if (!a)\n    throw new Error(`Block with ID ${r} not found`);\n  const c = ne(i), l = ne(a), d = e.schema.blockSchema[c.blockNoteType], p = e.schema.blockSchema[l.blockNoteType];\n  if (!c.isBlockContainer || d.content === \"none\")\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${n})`\n    );\n  if (!l.isBlockContainer || p.content === \"none\")\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${r})`\n    );\n  let h, f;\n  if (d.content === \"table\") {\n    const m = prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.TableMap.get(c.blockContent.node);\n    h = c.blockContent.beforePos + m.positionAt(0, 0, c.blockContent.node) + 1 + 2;\n  } else\n    h = c.blockContent.beforePos + 1;\n  if (p.content === \"table\") {\n    const m = prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.TableMap.get(l.blockContent.node), g = l.blockContent.beforePos + m.positionAt(\n      m.height - 1,\n      m.width - 1,\n      l.blockContent.node\n    ) + 1, b = s.resolve(g).nodeAfter.nodeSize;\n    f = g + b - 2;\n  } else\n    f = l.blockContent.afterPos - 1;\n  e._tiptapEditor.dispatch(\n    e._tiptapEditor.state.tr.setSelection(\n      prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.create(e._tiptapEditor.state.doc, h, f)\n    )\n  );\n}\nfunction zs(e) {\n  const { bnBlock: o } = C(e._tiptapEditor.state), t = e._tiptapEditor.state.doc.resolve(o.beforePos), n = t.nodeBefore, r = e._tiptapEditor.state.doc.resolve(\n    o.afterPos\n  ).nodeAfter;\n  let s;\n  return t.depth > 1 && (s = t.node(), s.type.isInGroup(\"bnBlock\") || (s = t.node(t.depth - 1))), {\n    block: E(\n      o.node,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    ),\n    prevBlock: n === null ? void 0 : E(\n      n,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    ),\n    nextBlock: r === null ? void 0 : E(\n      r,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    ),\n    parentBlock: s === void 0 ? void 0 : E(\n      s,\n      e.schema.blockSchema,\n      e.schema.inlineContentSchema,\n      e.schema.styleSchema,\n      e.blockCache\n    )\n  };\n}\nfunction To(e, o, t = \"start\") {\n  const n = typeof o == \"string\" ? o : o.id, r = D(n, e._tiptapEditor.state.doc);\n  if (!r)\n    throw new Error(`Block with ID ${n} not found`);\n  const s = ne(r), i = e.schema.blockSchema[s.blockNoteType].content;\n  if (s.isBlockContainer) {\n    const a = s.blockContent;\n    if (i === \"none\") {\n      e._tiptapEditor.commands.setNodeSelection(a.beforePos);\n      return;\n    }\n    if (i === \"inline\")\n      t === \"start\" ? e._tiptapEditor.commands.setTextSelection(\n        a.beforePos + 1\n      ) : e._tiptapEditor.commands.setTextSelection(\n        a.afterPos - 1\n      );\n    else if (i === \"table\")\n      t === \"start\" ? e._tiptapEditor.commands.setTextSelection(\n        a.beforePos + 4\n      ) : e._tiptapEditor.commands.setTextSelection(\n        a.afterPos - 4\n      );\n    else\n      throw new $(i);\n  } else {\n    const a = t === \"start\" ? s.childContainer.node.firstChild : s.childContainer.node.lastChild;\n    To(e, a.attrs.id, t);\n  }\n}\nlet ce;\nasync function ut() {\n  if (ce)\n    return ce;\n  const e = await Promise.all([\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_rehype-parse_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! rehype-parse */ \"(app-pages-browser)/./node_modules/rehype-parse/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_rehype-stringify_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! rehype-stringify */ \"(app-pages-browser)/./node_modules/rehype-stringify/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_unified_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! unified */ \"(app-pages-browser)/./node_modules/unified/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_hast-util-from-dom_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! hast-util-from-dom */ \"(app-pages-browser)/./node_modules/hast-util-from-dom/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_rehype-remark_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! rehype-remark */ \"(app-pages-browser)/./node_modules/rehype-remark/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_remark-gfm_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! remark-gfm */ \"(app-pages-browser)/./node_modules/remark-gfm/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_remark-stringify_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! remark-stringify */ \"(app-pages-browser)/./node_modules/remark-stringify/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_remark-parse_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! remark-parse */ \"(app-pages-browser)/./node_modules/remark-parse/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_remark-rehype_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! remark-rehype */ \"(app-pages-browser)/./node_modules/remark-rehype/index.js\")),\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_rehype-format_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! rehype-format */ \"(app-pages-browser)/./node_modules/rehype-format/index.js\"))\n  ]);\n  return ce = {\n    rehypeParse: e[0],\n    rehypeStringify: e[1],\n    unified: e[2],\n    hastUtilFromDom: e[3],\n    rehypeRemark: e[4],\n    remarkGfm: e[5],\n    remarkStringify: e[6],\n    remarkParse: e[7],\n    remarkRehype: e[8],\n    rehypeFormat: e[9]\n  }, ce;\n}\nfunction Ws() {\n  const e = (o) => {\n    let t = o.children.length;\n    for (let n = 0; n < t; n++) {\n      const r = o.children[n];\n      if (r.type === \"element\" && (e(r), r.tagName === \"u\"))\n        if (r.children.length > 0) {\n          o.children.splice(n, 1, ...r.children);\n          const s = r.children.length - 1;\n          t += s, n += s;\n        } else\n          o.children.splice(n, 1), t--, n--;\n    }\n  };\n  return e;\n}\nfunction js() {\n  const e = ce;\n  if (!e)\n    throw new Error(\n      \"addSpacesToCheckboxes requires ESM dependencies to be initialized\"\n    );\n  const o = (t) => {\n    var n;\n    if (t.children && \"length\" in t.children && t.children.length)\n      for (let r = t.children.length - 1; r >= 0; r--) {\n        const s = t.children[r], i = r + 1 < t.children.length ? t.children[r + 1] : void 0;\n        s.type === \"element\" && s.tagName === \"input\" && ((n = s.properties) == null ? void 0 : n.type) === \"checkbox\" && (i == null ? void 0 : i.type) === \"element\" && i.tagName === \"p\" ? (i.tagName = \"span\", i.children.splice(\n          0,\n          0,\n          e.hastUtilFromDom.fromDom(\n            document.createTextNode(\" \")\n          )\n        )) : o(s);\n      }\n  };\n  return o;\n}\nfunction ht(e) {\n  const o = ce;\n  if (!o)\n    throw new Error(\n      \"cleanHTMLToMarkdown requires ESM dependencies to be initialized\"\n    );\n  return o.unified.unified().use(o.rehypeParse.default, { fragment: !0 }).use(Ws).use(js).use(o.rehypeRemark.default).use(o.remarkGfm.default).use(o.remarkStringify.default, {\n    handlers: { text: (n) => n.value }\n  }).processSync(e).value;\n}\nasync function Gs(e, o, t, n) {\n  await ut();\n  const s = Ve(o, t).exportBlocks(e, n);\n  return ht(s);\n}\nfunction qs(e) {\n  return Array.prototype.indexOf.call(e.parentElement.childNodes, e);\n}\nfunction Ks(e) {\n  return e.nodeType === 3 && !/\\S/.test(e.nodeValue || \"\");\n}\nfunction Xs(e) {\n  e.querySelectorAll(\"li > ul, li > ol\").forEach((o) => {\n    const t = qs(o), n = o.parentElement, r = Array.from(n.childNodes).slice(\n      t + 1\n    );\n    o.remove(), r.forEach((s) => {\n      s.remove();\n    }), n.insertAdjacentElement(\"afterend\", o), r.reverse().forEach((s) => {\n      if (Ks(s))\n        return;\n      const i = document.createElement(\"li\");\n      i.append(s), o.insertAdjacentElement(\"afterend\", i);\n    }), n.childNodes.length === 0 && n.remove();\n  });\n}\nfunction Js(e) {\n  e.querySelectorAll(\"li + ul, li + ol\").forEach((o) => {\n    var s, i;\n    const t = o.previousElementSibling, n = document.createElement(\"div\");\n    t.insertAdjacentElement(\"afterend\", n), n.append(t);\n    const r = document.createElement(\"div\");\n    for (r.setAttribute(\"data-node-type\", \"blockGroup\"), n.append(r); ((s = n.nextElementSibling) == null ? void 0 : s.nodeName) === \"UL\" || ((i = n.nextElementSibling) == null ? void 0 : i.nodeName) === \"OL\"; )\n      r.append(n.nextElementSibling);\n  });\n}\nlet Lt = null;\nfunction Ys() {\n  return Lt || (Lt = document.implementation.createHTMLDocument(\"title\"));\n}\nfunction xo(e) {\n  if (typeof e == \"string\") {\n    const o = Ys().createElement(\"div\");\n    o.innerHTML = e, e = o;\n  }\n  return Xs(e), Js(e), e;\n}\nasync function Mo(e, o, t, n, r) {\n  const s = xo(e), a = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.DOMParser.fromSchema(r).parse(s, {\n    topNode: r.nodes.blockGroup.create()\n  }), c = [];\n  for (let l = 0; l < a.childCount; l++)\n    c.push(\n      E(a.child(l), o, t, n)\n    );\n  return c;\n}\nfunction Zs(e, o) {\n  const t = o.value ? o.value : \"\", n = {};\n  o.lang && (n[\"data-language\"] = o.lang);\n  let r = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: n,\n    children: [{ type: \"text\", value: t }]\n  };\n  return o.meta && (r.data = { meta: o.meta }), e.patch(o, r), r = e.applyData(o, r), r = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {},\n    children: [r]\n  }, e.patch(o, r), r;\n}\nasync function Po(e) {\n  const o = await ut();\n  return o.unified.unified().use(o.remarkParse.default).use(o.remarkGfm.default).use(o.remarkRehype.default, {\n    handlers: {\n      ...o.remarkRehype.defaultHandlers,\n      code: Zs\n    }\n  }).use(o.rehypeStringify.default).processSync(e).value;\n}\nasync function Qs(e, o, t, n, r) {\n  const s = await Po(e);\n  return Mo(s, o, t, n, r);\n}\nconst ft = [\n  \"vscode-editor-data\",\n  \"blocknote/html\",\n  \"text/markdown\",\n  \"text/html\",\n  \"text/plain\",\n  \"Files\"\n];\nfunction ei(e, o) {\n  if (!e.startsWith(\".\") || !o.startsWith(\".\"))\n    throw new Error(\"The strings provided are not valid file extensions.\");\n  return e === o;\n}\nfunction ti(e, o) {\n  const t = e.split(\"/\"), n = o.split(\"/\");\n  if (t.length !== 2)\n    throw new Error(`The string ${e} is not a valid MIME type.`);\n  if (n.length !== 2)\n    throw new Error(`The string ${o} is not a valid MIME type.`);\n  return t[1] === \"*\" || n[1] === \"*\" ? t[0] === n[0] : (t[0] === \"*\" || n[0] === \"*\" || t[0] === n[0]) && t[1] === n[1];\n}\nfunction At(e, o, t) {\n  let n;\n  return Array.isArray(o.content) && o.content.length === 0 ? n = e.updateBlock(o, t).id : n = e.insertBlocks(\n    [t],\n    o,\n    \"after\"\n  )[0].id, n;\n}\nasync function Io(e, o) {\n  var i;\n  if (!o.uploadFile) {\n    console.warn(\n      \"Attempted ot insert file, but uploadFile is not set in the BlockNote editor options\"\n    );\n    return;\n  }\n  const t = \"dataTransfer\" in e ? e.dataTransfer : e.clipboardData;\n  if (t === null)\n    return;\n  let n = null;\n  for (const a of ft)\n    if (t.types.includes(a)) {\n      n = a;\n      break;\n    }\n  if (n !== \"Files\")\n    return;\n  const r = t.items;\n  if (!r)\n    return;\n  e.preventDefault();\n  const s = Object.values(o.schema.blockSchema).filter(\n    (a) => a.isFileBlock\n  );\n  for (let a = 0; a < r.length; a++) {\n    let c = \"file\";\n    for (const d of s)\n      for (const p of d.fileBlockAccept || []) {\n        const h = p.startsWith(\".\"), f = r[a].getAsFile();\n        if (f && (!h && f.type && ti(r[a].type, p) || h && ei(\n          \".\" + f.name.split(\".\").pop(),\n          p\n        ))) {\n          c = d.type;\n          break;\n        }\n      }\n    const l = r[a].getAsFile();\n    if (l) {\n      const d = {\n        type: c,\n        props: {\n          name: l.name\n        }\n      };\n      let p;\n      if (e.type === \"paste\") {\n        const m = o.getTextCursorPosition().block;\n        p = At(o, m, d);\n      } else if (e.type === \"drop\") {\n        const m = {\n          left: e.clientX,\n          top: e.clientY\n        }, g = (i = o.prosemirrorView) == null ? void 0 : i.posAtCoords(m);\n        if (!g)\n          return;\n        const b = X(\n          o._tiptapEditor.state.doc,\n          g.pos\n        );\n        p = At(\n          o,\n          o.getBlock(b.node.attrs.id),\n          d\n        );\n      } else\n        return;\n      const h = await o.uploadFile(l, p), f = typeof h == \"string\" ? {\n        props: {\n          url: h\n        }\n      } : { ...h };\n      o.updateBlock(p, f);\n    }\n  }\n}\nconst oi = (e) => _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"dropFile\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n        props: {\n          handleDOMEvents: {\n            drop(o, t) {\n              if (!e.isEditable)\n                return;\n              let n = null;\n              for (const r of ft)\n                if (t.dataTransfer.types.includes(r)) {\n                  n = r;\n                  break;\n                }\n              return n === null ? !0 : n === \"Files\" ? (Io(t, e), !0) : !1;\n            }\n          }\n        }\n      })\n    ];\n  }\n});\nasync function ni(e, o) {\n  const { schema: t } = o.state;\n  if (!e.clipboardData)\n    return !1;\n  const n = e.clipboardData.getData(\"text/plain\");\n  if (!n)\n    return !1;\n  if (!t.nodes.codeBlock)\n    return o.pasteText(n), !0;\n  const r = e.clipboardData.getData(\"vscode-editor-data\"), s = r ? JSON.parse(r) : void 0, i = s == null ? void 0 : s.mode;\n  return i ? (o.pasteHTML(\n    `<pre><code class=\"language-${i}\">${n.replace(\n      /\\r\\n?/g,\n      `\n`\n    )}</code></pre>`\n  ), !0) : !1;\n}\nconst ri = /(^|\\n) {0,3}#{1,6} {1,8}[^\\n]{1,64}\\r?\\n\\r?\\n\\s{0,32}\\S/, si = new RegExp(\"(?:\\\\s|^)(_|__|\\\\*|\\\\*\\\\*|~~|==|\\\\+\\\\+)(?!\\\\s).{1,64}(?<!\\\\s)(?=\\\\1)\"), ii = /\\[[^\\]]{1,128}\\]\\(https?:\\/\\/\\S{1,999}\\)/, ai = new RegExp(\"(?:\\\\s|^)`(?!\\\\s)[^`]{1,48}(?<!\\\\s)`([^\\\\w]|$)\"), ci = /(?:^|\\n)\\s{0,5}-\\s{1}[^\\n]+\\n\\s{0,15}-\\s/, li = /(?:^|\\n)\\s{0,5}\\d+\\.\\s{1}[^\\n]+\\n\\s{0,15}\\d+\\.\\s/, di = /\\n{2} {0,3}-{2,48}\\n{2}/, pi = /(?:\\n|^)(```|~~~|\\$\\$)(?!`|~)[^\\s]{0,64} {0,64}[^\\n]{0,64}\\n[\\s\\S]{0,9999}?\\s*\\1 {0,64}(?:\\n+|$)/, ui = /(?:\\n|^)(?!\\s)\\w[^\\n]{0,64}\\r?\\n(-|=)\\1{0,64}\\n\\n\\s{0,64}(\\w|$)/, hi = /(?:^|(\\r?\\n\\r?\\n))( {0,3}>[^\\n]{1,333}\\n){1,999}($|(\\r?\\n))/, fi = /^\\s*\\|(.+\\|)+\\s*$/m, mi = /^\\s*\\|(\\s*[-:]+[-:]\\s*\\|)+\\s*$/m, gi = /^\\s*\\|(.+\\|)+\\s*$/m, bi = (e) => ri.test(e) || si.test(e) || ii.test(e) || ai.test(e) || ci.test(e) || li.test(e) || di.test(e) || pi.test(e) || ui.test(e) || hi.test(e) || fi.test(e) || mi.test(e) || gi.test(e);\nfunction ki({\n  event: e,\n  editor: o,\n  prioritizeMarkdownOverHTML: t,\n  plainTextAsMarkdown: n\n}) {\n  let r;\n  for (const i of ft)\n    if (e.clipboardData.types.includes(i)) {\n      r = i;\n      break;\n    }\n  if (!r)\n    return !0;\n  if (r === \"vscode-editor-data\")\n    return ni(e, o.prosemirrorView), !0;\n  if (r === \"Files\")\n    return Io(e, o), !0;\n  const s = e.clipboardData.getData(r);\n  if (r === \"blocknote/html\")\n    return o.pasteHTML(s, !0), !0;\n  if (r === \"text/markdown\")\n    return o.pasteMarkdown(s), !0;\n  if (t) {\n    const i = e.clipboardData.getData(\"text/plain\");\n    if (bi(i))\n      return o.pasteMarkdown(i), !0;\n  }\n  return r === \"text/html\" ? (o.pasteHTML(s), !0) : n ? (o.pasteMarkdown(s), !0) : (o.pasteText(s), !0);\n}\nconst wi = (e, o) => _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"pasteFromClipboard\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n        props: {\n          handleDOMEvents: {\n            paste(t, n) {\n              if (n.preventDefault(), !!e.isEditable)\n                return o({\n                  event: n,\n                  editor: e,\n                  defaultPasteHandler: ({\n                    prioritizeMarkdownOverHTML: r = !0,\n                    plainTextAsMarkdown: s = !0\n                  } = {}) => ki({\n                    event: n,\n                    editor: e,\n                    prioritizeMarkdownOverHTML: r,\n                    plainTextAsMarkdown: s\n                  })\n                });\n            }\n          }\n        }\n      })\n    ];\n  }\n});\nfunction Lo(e, o) {\n  const t = [];\n  return e.descendants((n) => {\n    var r, s;\n    return n.type.name === \"blockContainer\" && ((r = n.firstChild) == null ? void 0 : r.type.name) === \"blockGroup\" ? !0 : n.type.name === \"columnList\" && n.childCount === 1 ? ((s = n.firstChild) == null || s.forEach((i) => {\n      t.push(\n        E(\n          i,\n          o.blockSchema,\n          o.inlineContentSchema,\n          o.styleSchema\n        )\n      );\n    }), !1) : n.type.isInGroup(\"bnBlock\") ? (t.push(\n      E(\n        n,\n        o.blockSchema,\n        o.inlineContentSchema,\n        o.styleSchema\n      )\n    ), !1) : !0;\n  }), t;\n}\nfunction yi(e, o, t) {\n  var a;\n  let n = !1;\n  const r = e.state.selection instanceof prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.CellSelection;\n  if (!r) {\n    const c = e.state.doc.slice(\n      e.state.selection.from,\n      e.state.selection.to,\n      !1\n    ).content, l = [];\n    for (let d = 0; d < c.childCount; d++)\n      l.push(c.child(d));\n    n = l.find(\n      (d) => d.type.isInGroup(\"bnBlock\") || d.type.name === \"blockGroup\" || d.type.spec.group === \"blockContent\"\n    ) === void 0, n && (o = c);\n  }\n  let s;\n  const i = Ve(\n    e.state.schema,\n    t\n  );\n  if (r) {\n    ((a = o.firstChild) == null ? void 0 : a.type.name) === \"table\" && (o = o.firstChild.content);\n    const c = Jt(\n      o,\n      t.schema.inlineContentSchema,\n      t.schema.styleSchema\n    );\n    s = `<table>${i.exportInlineContent(\n      c,\n      {}\n    )}</table>`;\n  } else if (n) {\n    const c = _e(\n      o,\n      t.schema.inlineContentSchema,\n      t.schema.styleSchema\n    );\n    s = i.exportInlineContent(c, {});\n  } else {\n    const c = Lo(o, t.schema);\n    s = i.exportBlocks(c, {});\n  }\n  return s;\n}\nfunction Ao(e, o) {\n  \"node\" in e.state.selection && e.state.selection.node.type.spec.group === \"blockContent\" && o.dispatch(\n    o._tiptapEditor.state.tr.setSelection(\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.NodeSelection(e.state.doc.resolve(e.state.selection.from - 1))\n    )\n  );\n  const t = e.serializeForClipboard(\n    e.state.selection.content()\n  ).dom.innerHTML, n = e.state.selection.content().content, r = yi(\n    e,\n    n,\n    o\n  ), s = ht(r);\n  return { clipboardHTML: t, externalHTML: r, markdown: s };\n}\nconst Nt = () => {\n  const e = window.getSelection();\n  if (!e || e.isCollapsed)\n    return !0;\n  let o = e.focusNode;\n  for (; o; ) {\n    if (o instanceof HTMLElement && o.getAttribute(\"contenteditable\") === \"false\")\n      return !0;\n    o = o.parentElement;\n  }\n  return !1;\n}, Ht = (e, o, t) => {\n  t.preventDefault(), t.clipboardData.clearData();\n  const { clipboardHTML: n, externalHTML: r, markdown: s } = Ao(\n    o,\n    e\n  );\n  t.clipboardData.setData(\"blocknote/html\", n), t.clipboardData.setData(\"text/html\", r), t.clipboardData.setData(\"text/plain\", s);\n}, Ci = (e) => _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"copyToClipboard\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n        props: {\n          handleDOMEvents: {\n            copy(o, t) {\n              return Nt() || Ht(e, o, t), !0;\n            },\n            cut(o, t) {\n              return Nt() || (Ht(e, o, t), o.editable && o.dispatch(o.state.tr.deleteSelection())), !0;\n            },\n            // This is for the use-case in which only a block without content\n            // is selected, e.g. an image block, and dragged (not using the\n            // drag handle).\n            dragstart(o, t) {\n              if (!(\"node\" in o.state.selection) || o.state.selection.node.type.spec.group !== \"blockContent\")\n                return;\n              e.dispatch(\n                e._tiptapEditor.state.tr.setSelection(\n                  new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.NodeSelection(\n                    o.state.doc.resolve(o.state.selection.from - 1)\n                  )\n                )\n              ), t.preventDefault(), t.dataTransfer.clearData();\n              const { clipboardHTML: n, externalHTML: r, markdown: s } = Ao(o, e);\n              return t.dataTransfer.setData(\"blocknote/html\", n), t.dataTransfer.setData(\"text/html\", r), t.dataTransfer.setData(\"text/plain\", s), !0;\n            }\n          }\n        }\n      })\n    ];\n  }\n}), vi = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"blockBackgroundColor\",\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\", \"tableCell\", \"tableHeader\"],\n        attributes: {\n          backgroundColor: {\n            default: S.backgroundColor.default,\n            parseHTML: (e) => e.hasAttribute(\"data-background-color\") ? e.getAttribute(\"data-background-color\") : S.backgroundColor.default,\n            renderHTML: (e) => e.backgroundColor === S.backgroundColor.default ? {} : {\n              \"data-background-color\": e.backgroundColor\n            }\n          }\n        }\n      }\n    ];\n  }\n}), Ei = (e) => {\n  var n;\n  const o = [];\n  o.push(\n    _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_13__[\"default\"].configure({\n      fragment: e.fragment\n    })\n  );\n  const t = (n = e.provider) == null ? void 0 : n.awareness;\n  if (t) {\n    const r = /* @__PURE__ */ new Map();\n    e.showCursorLabels !== \"always\" && t.on(\n      \"change\",\n      ({\n        updated: a\n      }) => {\n        for (const c of a) {\n          const l = r.get(c);\n          l && (l.element.setAttribute(\"data-active\", \"\"), l.hideTimeout && clearTimeout(l.hideTimeout), r.set(c, {\n            element: l.element,\n            hideTimeout: setTimeout(() => {\n              l.element.removeAttribute(\"data-active\");\n            }, 2e3)\n          }));\n        }\n      }\n    );\n    const s = (a) => {\n      const c = document.createElement(\"span\");\n      c.classList.add(\"bn-collaboration-cursor__base\");\n      const l = document.createElement(\"span\");\n      l.setAttribute(\"contentedEditable\", \"false\"), l.classList.add(\"bn-collaboration-cursor__caret\"), l.setAttribute(\"style\", `background-color: ${a.color}`);\n      const d = document.createElement(\"span\");\n      return d.classList.add(\"bn-collaboration-cursor__label\"), d.setAttribute(\"style\", `background-color: ${a.color}`), d.insertBefore(document.createTextNode(a.name), null), l.insertBefore(d, null), c.insertBefore(document.createTextNode(\"⁠\"), null), c.insertBefore(l, null), c.insertBefore(document.createTextNode(\"⁠\"), null), c;\n    }, i = (a, c) => {\n      var d;\n      let l = r.get(c);\n      if (!l) {\n        const p = ((d = e == null ? void 0 : e.renderCursor) == null ? void 0 : d.call(e, a)) || s(a);\n        (e == null ? void 0 : e.showCursorLabels) !== \"always\" && (p.addEventListener(\"mouseenter\", () => {\n          const h = r.get(c);\n          h.element.setAttribute(\"data-active\", \"\"), h.hideTimeout && (clearTimeout(h.hideTimeout), r.set(c, {\n            element: h.element,\n            hideTimeout: void 0\n          }));\n        }), p.addEventListener(\"mouseleave\", () => {\n          const h = r.get(c);\n          r.set(c, {\n            element: h.element,\n            hideTimeout: setTimeout(() => {\n              h.element.removeAttribute(\"data-active\");\n            }, 2e3)\n          });\n        })), l = {\n          element: p,\n          hideTimeout: void 0\n        }, r.set(c, l);\n      }\n      return l.element;\n    };\n    o.push(\n      _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_14__[\"default\"].configure({\n        user: e.user,\n        render: i,\n        // tiptap type not compatible with latest y-prosemirror\n        provider: e.provider\n      })\n    );\n  }\n  return o;\n}, No = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Mark.create({\n  name: \"comment\",\n  excludes: \"\",\n  inclusive: !1,\n  keepOnSplit: !0,\n  addAttributes() {\n    return {\n      // orphans are marks that currently don't have an active thread. It could be\n      // that users have resolved the thread. Resolved threads by default are not shown in the document,\n      // but we need to keep the mark (positioning) data so we can still \"revive\" it when the thread is unresolved\n      // or we enter a \"comments\" view that includes resolved threads.\n      orphan: {\n        parseHTML: (e) => !!e.getAttribute(\"data-orphan\"),\n        renderHTML: (e) => e.orphan ? {\n          \"data-orphan\": \"true\"\n        } : {},\n        default: !1\n      },\n      threadId: {\n        parseHTML: (e) => e.getAttribute(\"data-bn-thread-id\"),\n        renderHTML: (e) => ({\n          \"data-bn-thread-id\": e.threadId\n        }),\n        default: \"\"\n      }\n    };\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    return [\n      \"span\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.mergeAttributes)(e, {\n        class: \"bn-thread-mark\"\n      })\n    ];\n  },\n  parseHTML() {\n    return [{ tag: \"span.bn-thread-mark\" }];\n  },\n  extendMarkSchema(e) {\n    return e.name === \"comment\" ? {\n      blocknoteIgnore: !0\n    } : {};\n  }\n});\nclass q {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    u(this, \"callbacks\", {});\n  }\n  on(o, t) {\n    return this.callbacks[o] || (this.callbacks[o] = []), this.callbacks[o].push(t), () => this.off(o, t);\n  }\n  emit(o, ...t) {\n    const n = this.callbacks[o];\n    n && n.forEach((r) => r.apply(this, t));\n  }\n  off(o, t) {\n    const n = this.callbacks[o];\n    n && (t ? this.callbacks[o] = n.filter((r) => r !== t) : delete this.callbacks[o]);\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nclass Si extends q {\n  constructor(t) {\n    super();\n    u(this, \"userCache\", /* @__PURE__ */ new Map());\n    // avoid duplicate loads\n    u(this, \"loadingUsers\", /* @__PURE__ */ new Set());\n    this.resolveUsers = t;\n  }\n  /**\n   * Load information about users based on an array of user ids.\n   */\n  async loadUsers(t) {\n    const n = t.filter(\n      (r) => !this.userCache.has(r) && !this.loadingUsers.has(r)\n    );\n    if (n.length !== 0) {\n      for (const r of n)\n        this.loadingUsers.add(r);\n      try {\n        const r = await this.resolveUsers(n);\n        for (const s of r)\n          this.userCache.set(s.id, s);\n        this.emit(\"update\", this.userCache);\n      } finally {\n        for (const r of n)\n          this.loadingUsers.delete(r);\n      }\n    }\n  }\n  /**\n   * Retrieve information about a user based on their id, if cached.\n   *\n   * The user will have to be loaded via `loadUsers` first\n   */\n  getUser(t) {\n    return this.userCache.get(t);\n  }\n  /**\n   * Subscribe to changes in the user store.\n   *\n   * @param cb - The callback to call when the user store changes.\n   * @returns A function to unsubscribe from the user store.\n   */\n  subscribe(t) {\n    return this.on(\"update\", t);\n  }\n}\nconst xe = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"blocknote-comments\"), Bi = \"SET_SELECTED_THREAD_ID\";\nfunction Ti(e, o) {\n  const t = /* @__PURE__ */ new Map();\n  return e.descendants((n, r) => {\n    n.marks.forEach((s) => {\n      if (s.type.name === o) {\n        const i = s.attrs.threadId;\n        if (!i)\n          return;\n        const a = r, c = a + n.nodeSize, l = t.get(i) ?? {\n          from: 1 / 0,\n          to: 0\n        };\n        t.set(i, {\n          from: Math.min(a, l.from),\n          to: Math.max(c, l.to)\n        });\n      }\n    });\n  }), t;\n}\nclass xi extends q {\n  constructor(t, n, r) {\n    super();\n    u(this, \"plugin\");\n    u(this, \"userStore\");\n    /**\n     * Whether a comment is currently being composed\n     */\n    u(this, \"pendingComment\", !1);\n    /**\n     * The currently selected thread id\n     */\n    u(this, \"selectedThreadId\");\n    /**\n     * Store the positions of all threads in the document.\n     * this can be used later to implement a floating sidebar\n     */\n    u(this, \"threadPositions\", /* @__PURE__ */ new Map());\n    /**\n     * when a thread is resolved or deleted, we need to update the marks to reflect the new state\n     */\n    u(this, \"updateMarksFromThreads\", (t) => {\n      const n = this.editor._tiptapEditor;\n      n.state.doc.descendants((r, s) => {\n        r.marks.forEach((i) => {\n          if (i.type.name === this.markType) {\n            const a = i.type, c = i.attrs.threadId, l = t.get(c), d = !!(!l || l.resolved || l.deletedAt);\n            if (d !== i.attrs.orphan) {\n              const { tr: p } = n.state, h = Math.max(s, 0), f = Math.min(\n                s + r.nodeSize,\n                n.state.doc.content.size - 1\n              );\n              p.removeMark(h, f, i), p.addMark(\n                h,\n                f,\n                a.create({\n                  ...i.attrs,\n                  orphan: d\n                })\n              ), n.dispatch(p), d && this.selectedThreadId === c && (this.selectedThreadId = void 0, this.emitStateUpdate());\n            }\n          }\n        });\n      });\n    });\n    if (this.editor = t, this.threadStore = n, this.markType = r, !t.resolveUsers)\n      throw new Error(\"resolveUsers is required for comments\");\n    this.userStore = new Si(t.resolveUsers), this.threadStore.subscribe(this.updateMarksFromThreads), t.onCreate(() => {\n      this.updateMarksFromThreads(this.threadStore.getThreads()), t.onSelectionChange(() => {\n        this.pendingComment && (this.pendingComment = !1, this.emitStateUpdate());\n      });\n    });\n    const s = this;\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: xe,\n      state: {\n        init() {\n          return {\n            decorations: prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.empty\n          };\n        },\n        apply(i, a) {\n          const c = i.getMeta(xe);\n          if (!i.docChanged && !c)\n            return a;\n          const l = i.docChanged ? Ti(i.doc, s.markType) : s.threadPositions;\n          (l.size > 0 || s.threadPositions.size > 0) && (s.threadPositions = l, s.emitStateUpdate());\n          const d = [];\n          if (s.selectedThreadId) {\n            const p = l.get(\n              s.selectedThreadId\n            );\n            p && d.push(\n              prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.inline(\n                p.from,\n                p.to,\n                {\n                  class: \"bn-thread-mark-selected\"\n                }\n              )\n            );\n          }\n          return {\n            decorations: prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(i.doc, d)\n          };\n        }\n      },\n      props: {\n        decorations(i) {\n          var a;\n          return ((a = xe.getState(i)) == null ? void 0 : a.decorations) ?? prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.empty;\n        },\n        /**\n         * Handle click on a thread mark and mark it as selected\n         */\n        handleClick: (i, a, c) => {\n          if (c.button !== 0)\n            return;\n          const l = i.state.doc.nodeAt(a);\n          if (!l) {\n            s.selectThread(void 0);\n            return;\n          }\n          const d = l.marks.find(\n            (h) => h.type.name === r && h.attrs.orphan !== !0\n          ), p = d == null ? void 0 : d.attrs.threadId;\n          s.selectThread(p, !1);\n        }\n      }\n    });\n  }\n  emitStateUpdate() {\n    this.emit(\"update\", {\n      selectedThreadId: this.selectedThreadId,\n      pendingComment: this.pendingComment,\n      threadPositions: this.threadPositions\n    });\n  }\n  /**\n   * Subscribe to state updates\n   */\n  onUpdate(t) {\n    return this.on(\"update\", t);\n  }\n  /**\n   * Set the selected thread\n   */\n  selectThread(t, n = !0) {\n    var r, s;\n    if (this.selectedThreadId !== t && (this.selectedThreadId = t, this.emitStateUpdate(), this.editor.dispatch(\n      this.editor.prosemirrorView.state.tr.setMeta(xe, {\n        name: Bi\n      })\n    ), t && n)) {\n      const i = this.threadPositions.get(t);\n      if (!i)\n        return;\n      (s = (r = this.editor.prosemirrorView) == null ? void 0 : r.domAtPos(i.from).node) == null || s.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"center\"\n      });\n    }\n  }\n  /**\n   * Start a pending comment (e.g.: when clicking the \"Add comment\" button)\n   */\n  startPendingComment() {\n    this.pendingComment = !0, this.emitStateUpdate();\n  }\n  /**\n   * Stop a pending comment (e.g.: user closes the comment composer)\n   */\n  stopPendingComment() {\n    this.pendingComment = !1, this.emitStateUpdate();\n  }\n  /**\n   * Create a thread at the current selection\n   */\n  async createThread(t) {\n    const n = await this.threadStore.createThread(t);\n    if (this.threadStore.addThreadToDocument) {\n      const r = this.editor.prosemirrorView, s = r.state.selection, i = y_prosemirror__WEBPACK_IMPORTED_MODULE_23__.ySyncPluginKey.getState(r.state), a = {\n        prosemirror: {\n          head: s.head,\n          anchor: s.anchor\n        },\n        yjs: i ? (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_24__.getRelativeSelection)(i.binding, r.state) : void 0\n        // if we're not using yjs\n      };\n      await this.threadStore.addThreadToDocument({\n        threadId: n.id,\n        selection: a\n      });\n    } else\n      this.editor._tiptapEditor.commands.setMark(this.markType, {\n        orphan: !1,\n        threadId: n.id\n      });\n  }\n}\nclass Mi {\n  constructor(o, t, n, r) {\n    u(this, \"state\");\n    u(this, \"emitUpdate\");\n    u(this, \"mouseDownHandler\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    // For dragging the whole editor.\n    u(this, \"dragstartHandler\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    u(this, \"scrollHandler\", () => {\n      var o;\n      if ((o = this.state) != null && o.show) {\n        const t = this.pmView.root.querySelector(\n          `[data-node-type=\"blockContainer\"][data-id=\"${this.state.block.id}\"]`\n        );\n        if (!t)\n          return;\n        this.state.referencePos = t.getBoundingClientRect(), this.emitUpdate();\n      }\n    });\n    u(this, \"closeMenu\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    this.editor = o, this.pluginKey = t, this.pmView = n, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized file panel\");\n      r(this.state);\n    }, n.dom.addEventListener(\"mousedown\", this.mouseDownHandler), n.dom.addEventListener(\"dragstart\", this.dragstartHandler), n.root.addEventListener(\"scroll\", this.scrollHandler, !0);\n  }\n  update(o, t) {\n    var r, s;\n    const n = this.pluginKey.getState(o.state);\n    if (!((r = this.state) != null && r.show) && n.block && this.editor.isEditable) {\n      const i = this.pmView.root.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${n.block.id}\"]`\n      );\n      if (!i)\n        return;\n      this.state = {\n        show: !0,\n        referencePos: i.getBoundingClientRect(),\n        block: n.block\n      }, this.emitUpdate();\n      return;\n    }\n    (!o.state.selection.eq(t.selection) || !o.state.doc.eq(t.doc) || !this.editor.isEditable) && (s = this.state) != null && s.show && (this.state.show = !1, this.emitUpdate());\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.mouseDownHandler), this.pmView.dom.removeEventListener(\"dragstart\", this.dragstartHandler), this.pmView.root.removeEventListener(\"scroll\", this.scrollHandler, !0);\n  }\n}\nconst Ge = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"FilePanelPlugin\");\nclass Pi extends q {\n  constructor(t) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    u(this, \"closeMenu\", () => {\n      var t;\n      return (t = this.view) == null ? void 0 : t.closeMenu();\n    });\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: Ge,\n      view: (n) => (this.view = new Mi(\n        t,\n        Ge,\n        n,\n        (r) => {\n          this.emit(\"update\", r);\n        }\n      ), this.view),\n      props: {\n        handleKeyDown: (n, r) => {\n          var s;\n          return r.key === \"Escape\" && this.shown ? ((s = this.view) == null || s.closeMenu(), !0) : !1;\n        }\n      },\n      state: {\n        init: () => ({\n          block: void 0\n        }),\n        apply: (n) => {\n          var s;\n          return {\n            block: (s = n.getMeta(Ge)) == null ? void 0 : s.block\n          };\n        }\n      }\n    });\n  }\n  get shown() {\n    var t, n;\n    return ((n = (t = this.view) == null ? void 0 : t.state) == null ? void 0 : n.show) || !1;\n  }\n  onUpdate(t) {\n    return this.on(\"update\", t);\n  }\n}\nclass Ii {\n  constructor(o, t, n) {\n    u(this, \"state\");\n    u(this, \"emitUpdate\");\n    u(this, \"preventHide\", !1);\n    u(this, \"preventShow\", !1);\n    u(this, \"shouldShow\", ({ state: o, from: t, to: n }) => {\n      const { doc: r, selection: s } = o, { empty: i } = s, a = !r.textBetween(t, n).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.isTextSelection)(o.selection);\n      return s.$from.parent.type.spec.code || (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.isNodeSelection)(s) && s.node.type.spec.code ? !1 : !(i || a);\n    });\n    u(this, \"blurHandler\", (o) => {\n      var n;\n      if (this.preventHide) {\n        this.preventHide = !1;\n        return;\n      }\n      const t = this.pmView.dom.parentElement;\n      // An element is clicked.\n      o && o.relatedTarget && // Element is inside the editor.\n      (t === o.relatedTarget || t.contains(o.relatedTarget) || o.relatedTarget.matches(\n        \".bn-ui-container, .bn-ui-container *\"\n      )) || (n = this.state) != null && n.show && (this.state.show = !1, this.emitUpdate());\n    });\n    u(this, \"viewMousedownHandler\", () => {\n      this.preventShow = !0;\n    });\n    u(this, \"mouseupHandler\", () => {\n      this.preventShow && (this.preventShow = !1, setTimeout(() => this.update(this.pmView)));\n    });\n    // For dragging the whole editor.\n    u(this, \"dragHandler\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    u(this, \"scrollHandler\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.referencePos = this.getSelectionBoundingBox(), this.emitUpdate());\n    });\n    u(this, \"closeMenu\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    this.editor = o, this.pmView = t, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\n          \"Attempting to update uninitialized formatting toolbar\"\n        );\n      n(this.state);\n    }, t.dom.addEventListener(\"mousedown\", this.viewMousedownHandler), t.root.addEventListener(\"mouseup\", this.mouseupHandler), t.dom.addEventListener(\"dragstart\", this.dragHandler), t.dom.addEventListener(\"dragover\", this.dragHandler), t.dom.addEventListener(\"blur\", this.blurHandler), t.root.addEventListener(\"scroll\", this.scrollHandler, !0);\n  }\n  update(o, t) {\n    var h;\n    const { state: n, composing: r } = o, { selection: s } = n, i = t && t.selection.from === n.selection.from && t.selection.to === n.selection.to;\n    if (r || i)\n      return;\n    const { ranges: a } = s, c = Math.min(...a.map((f) => f.$from.pos)), l = Math.max(...a.map((f) => f.$to.pos)), d = this.shouldShow({\n      view: o,\n      state: n,\n      from: c,\n      to: l\n    }), p = typeof Range.prototype.getClientRects > \"u\";\n    if (!this.preventShow && (d || this.preventHide) && !p) {\n      this.state = {\n        show: !0,\n        referencePos: this.getSelectionBoundingBox()\n      }, this.emitUpdate();\n      return;\n    }\n    if ((h = this.state) != null && h.show && !this.preventHide && (!d || this.preventShow || !this.editor.isEditable)) {\n      this.state.show = !1, this.emitUpdate();\n      return;\n    }\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler), this.pmView.root.removeEventListener(\"mouseup\", this.mouseupHandler), this.pmView.dom.removeEventListener(\"dragstart\", this.dragHandler), this.pmView.dom.removeEventListener(\"dragover\", this.dragHandler), this.pmView.dom.removeEventListener(\"blur\", this.blurHandler), this.pmView.root.removeEventListener(\"scroll\", this.scrollHandler, !0);\n  }\n  getSelectionBoundingBox() {\n    const { state: o } = this.pmView, { selection: t } = o, { ranges: n } = t, r = Math.min(...n.map((i) => i.$from.pos)), s = Math.max(...n.map((i) => i.$to.pos));\n    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.isNodeSelection)(t)) {\n      const i = this.pmView.nodeDOM(r);\n      if (i)\n        return i.getBoundingClientRect();\n    }\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.posToDOMRect)(this.pmView, r, s);\n  }\n}\nconst Li = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\n  \"FormattingToolbarPlugin\"\n);\nclass Ai extends q {\n  constructor(t) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    u(this, \"closeMenu\", () => this.view.closeMenu());\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: Li,\n      view: (n) => (this.view = new Ii(t, n, (r) => {\n        this.emit(\"update\", r);\n      }), this.view),\n      props: {\n        handleKeyDown: (n, r) => r.key === \"Escape\" && this.shown ? (this.view.closeMenu(), !0) : !1\n      }\n    });\n  }\n  get shown() {\n    var t, n;\n    return ((n = (t = this.view) == null ? void 0 : t.state) == null ? void 0 : n.show) || !1;\n  }\n  onUpdate(t) {\n    return this.on(\"update\", t);\n  }\n}\nconst Ni = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Node.create({\n  name: \"hardBreak\",\n  inline: !0,\n  group: \"inline\",\n  selectable: !1,\n  linebreakReplacement: !0,\n  priority: 10,\n  parseHTML() {\n    return [{ tag: \"br\" }];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    return [\"br\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.mergeAttributes)(this.options.HTMLAttributes, e)];\n  },\n  renderText() {\n    return `\n`;\n  }\n}), Dt = (e, o) => {\n  const t = e.resolve(o);\n  if (t.depth <= 1)\n    return;\n  const n = t.posAtIndex(\n    t.index(t.depth - 1),\n    t.depth - 1\n  );\n  return Ce(\n    e.resolve(n)\n  );\n}, Le = (e, o) => {\n  const t = e.resolve(o), n = t.index();\n  if (n === 0)\n    return;\n  const r = t.posAtIndex(n - 1);\n  return Ce(\n    e.resolve(r)\n  );\n}, Ho = (e, o) => {\n  for (; o.childContainer; ) {\n    const t = o.childContainer.node, n = e.resolve(o.childContainer.beforePos + 1).posAtIndex(t.childCount - 1);\n    o = Ce(e.resolve(n));\n  }\n  return o;\n}, Hi = (e, o) => e.isBlockContainer && e.blockContent.node.type.spec.content === \"inline*\" && e.blockContent.node.childCount > 0 && o.isBlockContainer && o.blockContent.node.type.spec.content === \"inline*\", Di = (e, o, t, n) => {\n  if (!n.isBlockContainer)\n    throw new Error(\n      `Attempted to merge block at position ${n.bnBlock.beforePos} into previous block at position ${t.bnBlock.beforePos}, but next block is not a block container`\n    );\n  if (n.childContainer) {\n    const r = e.doc.resolve(\n      n.childContainer.beforePos + 1\n    ), s = e.doc.resolve(\n      n.childContainer.afterPos - 1\n    ), i = r.blockRange(s);\n    if (o) {\n      const a = e.doc.resolve(n.bnBlock.beforePos);\n      e.tr.lift(i, a.depth);\n    }\n  }\n  if (o) {\n    if (!t.isBlockContainer)\n      throw new Error(\n        `Attempted to merge block at position ${n.bnBlock.beforePos} into previous block at position ${t.bnBlock.beforePos}, but previous block is not a block container`\n      );\n    o(\n      e.tr.delete(\n        t.blockContent.afterPos - 1,\n        n.blockContent.beforePos + 1\n      )\n    );\n  }\n  return !0;\n}, Ot = (e) => ({\n  state: o,\n  dispatch: t\n}) => {\n  const n = o.doc.resolve(e), r = Ce(n), s = Le(\n    o.doc,\n    r.bnBlock.beforePos\n  );\n  if (!s)\n    return !1;\n  const i = Ho(\n    o.doc,\n    s\n  );\n  return Hi(i, r) ? Di(o, t, i, r) : !1;\n}, Oi = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  priority: 50,\n  // TODO: The shortcuts need a refactor. Do we want to use a command priority\n  //  design as there is now, or clump the logic into a single function?\n  addKeyboardShortcuts() {\n    const e = () => this.editor.commands.first(({ chain: n, commands: r }) => [\n      // Deletes the selection if it's not empty.\n      () => r.deleteSelection(),\n      // Undoes an input rule if one was triggered in the last editor state change.\n      () => r.undoInputRule(),\n      // Reverts block content type to a paragraph if the selection is at the start of the block.\n      () => r.command(({ state: s }) => {\n        const i = C(s);\n        if (!i.isBlockContainer)\n          return !1;\n        const a = s.selection.from === i.blockContent.beforePos + 1, c = i.blockContent.node.type.name === \"paragraph\";\n        return a && !c ? r.command(\n          x(\n            this.options.editor,\n            i.bnBlock.beforePos,\n            {\n              type: \"paragraph\",\n              props: {}\n            }\n          )\n        ) : !1;\n      }),\n      // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n      () => r.command(({ state: s }) => {\n        const i = C(s);\n        if (!i.isBlockContainer)\n          return !1;\n        const { blockContent: a } = i;\n        return s.selection.from === a.beforePos + 1 ? r.liftListItem(\"blockContainer\") : !1;\n      }),\n      // Merges block with the previous one if it isn't indented, and the selection is at the start of the\n      // block. The target block for merging must contain inline content.\n      () => r.command(({ state: s }) => {\n        const i = C(s);\n        if (!i.isBlockContainer)\n          return !1;\n        const { bnBlock: a, blockContent: c } = i, l = s.selection.from === c.beforePos + 1, d = s.selection.empty, p = a.beforePos;\n        return l && d ? n().command(Ot(p)).scrollIntoView().run() : !1;\n      }),\n      () => r.command(({ state: s, dispatch: i }) => {\n        const a = C(s);\n        if (!a.isBlockContainer || !(s.selection.from === a.blockContent.beforePos + 1) || Le(\n          s.doc,\n          a.bnBlock.beforePos\n        ))\n          return !1;\n        const d = Dt(\n          s.doc,\n          a.bnBlock.beforePos\n        );\n        if ((d == null ? void 0 : d.blockNoteType) !== \"column\")\n          return !1;\n        const p = d, h = Dt(\n          s.doc,\n          p.bnBlock.beforePos\n        );\n        if ((h == null ? void 0 : h.blockNoteType) !== \"columnList\")\n          throw new Error(\"parent of column is not a column list\");\n        const f = p.childContainer.node.childCount === 1, m = f && h.childContainer.node.childCount === 2, g = h.childContainer.node.firstChild === p.bnBlock.node;\n        if (i) {\n          const b = s.doc.slice(\n            a.bnBlock.beforePos,\n            a.bnBlock.afterPos,\n            !1\n          );\n          if (m)\n            if (g) {\n              s.tr.step(\n                new prosemirror_transform__WEBPACK_IMPORTED_MODULE_19__.ReplaceAroundStep(\n                  // replace entire column list\n                  h.bnBlock.beforePos,\n                  h.bnBlock.afterPos,\n                  // select content of remaining column:\n                  p.bnBlock.afterPos + 1,\n                  h.bnBlock.afterPos - 2,\n                  b,\n                  b.size,\n                  // append existing content to blockToMove\n                  !1\n                )\n              );\n              const k = s.tr.doc.resolve(p.bnBlock.beforePos);\n              s.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.between(k, k));\n            } else {\n              s.tr.step(\n                new prosemirror_transform__WEBPACK_IMPORTED_MODULE_19__.ReplaceAroundStep(\n                  // replace entire column list\n                  h.bnBlock.beforePos,\n                  h.bnBlock.afterPos,\n                  // select content of existing column:\n                  h.bnBlock.beforePos + 2,\n                  p.bnBlock.beforePos - 1,\n                  b,\n                  0,\n                  // prepend existing content to blockToMove\n                  !1\n                )\n              );\n              const k = s.tr.doc.resolve(\n                s.tr.mapping.map(p.bnBlock.beforePos - 1)\n              );\n              s.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.between(k, k));\n            }\n          else if (f)\n            if (g) {\n              s.tr.delete(\n                p.bnBlock.beforePos,\n                p.bnBlock.afterPos\n              ), s.tr.insert(\n                h.bnBlock.beforePos,\n                b.content\n              );\n              const k = s.tr.doc.resolve(\n                h.bnBlock.beforePos\n              );\n              s.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.between(k, k));\n            } else\n              s.tr.delete(\n                p.bnBlock.beforePos - 1,\n                p.bnBlock.beforePos + 1\n              );\n          else {\n            s.tr.delete(\n              a.bnBlock.beforePos,\n              a.bnBlock.afterPos\n            ), g ? s.tr.insert(\n              h.bnBlock.beforePos - 1,\n              b.content\n            ) : s.tr.insert(\n              p.bnBlock.beforePos - 1,\n              b.content\n            );\n            const k = s.tr.doc.resolve(p.bnBlock.beforePos - 1);\n            s.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.between(k, k));\n          }\n        }\n        return !0;\n      }),\n      // Deletes the current block if it's an empty block with inline content,\n      // and moves the selection to the previous block.\n      () => r.command(({ state: s }) => {\n        const i = C(s);\n        if (!i.isBlockContainer)\n          return !1;\n        if (i.blockContent.node.childCount === 0 && i.blockContent.node.type.spec.content === \"inline*\") {\n          const c = Le(\n            s.doc,\n            i.bnBlock.beforePos\n          );\n          if (!c || !c.isBlockContainer)\n            return !1;\n          let l = n();\n          if (c.blockContent.node.type.spec.content === \"tableRow+\") {\n            const m = i.bnBlock.beforePos - 1 - 1 - 1 - 1 - 1;\n            l = l.setTextSelection(\n              m\n            );\n          } else if (c.blockContent.node.type.spec.content === \"\") {\n            const d = c.blockContent.afterPos - c.blockContent.node.nodeSize;\n            l = l.setNodeSelection(\n              d\n            );\n          } else {\n            const d = c.blockContent.afterPos - c.blockContent.node.nodeSize;\n            l = l.setTextSelection(d);\n          }\n          return l.deleteRange({\n            from: i.bnBlock.beforePos,\n            to: i.bnBlock.afterPos\n          }).scrollIntoView().run();\n        }\n        return !1;\n      }),\n      // Deletes previous block if it contains no content and isn't a table,\n      // when the selection is empty and at the start of the block. Moves the\n      // current block into the deleted block's place.\n      () => r.command(({ state: s }) => {\n        const i = C(s);\n        if (!i.isBlockContainer)\n          throw new Error(\"todo\");\n        const a = s.selection.from === i.blockContent.beforePos + 1, c = s.selection.empty, l = Le(\n          s.doc,\n          i.bnBlock.beforePos\n        );\n        if (l && a && c) {\n          const d = Ho(\n            s.doc,\n            l\n          );\n          if (!d.isBlockContainer)\n            throw new Error(\"todo\");\n          if (d.blockContent.node.type.spec.content === \"\" || d.blockContent.node.type.spec.content === \"inline*\" && d.blockContent.node.childCount === 0)\n            return n().cut(\n              {\n                from: i.bnBlock.beforePos,\n                to: i.bnBlock.afterPos\n              },\n              d.bnBlock.afterPos\n            ).deleteRange({\n              from: d.bnBlock.beforePos,\n              to: d.bnBlock.afterPos\n            }).run();\n        }\n        return !1;\n      })\n    ]), o = () => this.editor.commands.first(({ commands: n }) => [\n      // Deletes the selection if it's not empty.\n      () => n.deleteSelection(),\n      // Merges block with the next one (at the same nesting level or lower),\n      // if one exists, the block has no children, and the selection is at the\n      // end of the block.\n      () => n.command(({ state: r }) => {\n        const s = C(r);\n        if (!s.isBlockContainer)\n          return !1;\n        const {\n          bnBlock: i,\n          blockContent: a,\n          childContainer: c\n        } = s, { depth: l } = r.doc.resolve(i.beforePos), d = i.afterPos === r.doc.nodeSize - 3, p = r.selection.from === a.afterPos - 1, h = r.selection.empty;\n        if (!d && p && h && !(c !== void 0)) {\n          let m = l, g = i.afterPos + 1, b = r.doc.resolve(g).depth;\n          for (; b < m; )\n            m = b, g += 2, b = r.doc.resolve(g).depth;\n          return n.command(Ot(g - 1));\n        }\n        return !1;\n      })\n    ]), t = (n = !1) => this.editor.commands.first(({ commands: r }) => [\n      // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n      // of the block.\n      () => r.command(({ state: s }) => {\n        const i = C(s);\n        if (!i.isBlockContainer)\n          return !1;\n        const { bnBlock: a, blockContent: c } = i, { depth: l } = s.doc.resolve(a.beforePos), d = s.selection.$anchor.parentOffset === 0, p = s.selection.anchor === s.selection.head, h = c.node.childCount === 0, f = l > 1;\n        return d && p && h && f ? r.liftListItem(\"blockContainer\") : !1;\n      }),\n      // Creates a hard break if block is configured to do so.\n      () => r.command(({ state: s }) => {\n        const i = C(s), a = this.options.editor.schema.blockSchema[i.blockNoteType].hardBreakShortcut ?? \"shift+enter\";\n        return a === \"none\" ? !1 : (\n          // If shortcut is not configured, or is configured as \"shift+enter\",\n          // create a hard break for shift+enter, but not for enter.\n          a === \"shift+enter\" && n || // If shortcut is configured as \"enter\", create a hard break for\n          // both enter and shift+enter.\n          a === \"enter\" ? r.insertContent({\n            type: \"hardBreak\"\n          }) : !1\n        );\n      }),\n      // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n      // empty & at the start of the block.\n      () => r.command(({ state: s, dispatch: i }) => {\n        const a = C(s);\n        if (!a.isBlockContainer)\n          return !1;\n        const { bnBlock: c, blockContent: l } = a, d = s.selection.$anchor.parentOffset === 0, p = s.selection.anchor === s.selection.head, h = l.node.childCount === 0;\n        if (d && p && h) {\n          const f = c.afterPos, m = f + 2;\n          if (i) {\n            const g = s.schema.nodes.blockContainer.createAndFill();\n            s.tr.insert(f, g).scrollIntoView(), s.tr.setSelection(\n              new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection(s.doc.resolve(m))\n            );\n          }\n          return !0;\n        }\n        return !1;\n      }),\n      // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n      // deletes the selection beforehand, if it's not empty.\n      () => r.command(({ state: s, chain: i }) => {\n        const a = C(s);\n        if (!a.isBlockContainer)\n          return !1;\n        const { blockContent: c } = a, l = s.selection.$anchor.parentOffset === 0;\n        return c.node.childCount === 0 ? !1 : (i().deleteSelection().command(\n          uo(\n            s.selection.from,\n            l,\n            l\n          )\n        ).run(), !0);\n      })\n    ]);\n    return {\n      Backspace: e,\n      Delete: o,\n      Enter: () => t(),\n      \"Shift-Enter\": () => t(!0),\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => {\n        var n, r, s;\n        return this.options.tabBehavior !== \"prefer-indent\" && ((n = this.options.editor.formattingToolbar) != null && n.shown || (r = this.options.editor.linkToolbar) != null && r.shown || (s = this.options.editor.filePanel) != null && s.shown) ? !1 : So(this.options.editor);\n      },\n      \"Shift-Tab\": () => {\n        var n, r, s;\n        return this.options.tabBehavior !== \"prefer-indent\" && ((n = this.options.editor.formattingToolbar) != null && n.shown || (r = this.options.editor.linkToolbar) != null && r.shown || (s = this.options.editor.filePanel) != null && s.shown) ? !1 : (this.editor.commands.liftListItem(\"blockContainer\"), !0);\n      },\n      \"Shift-Mod-ArrowUp\": () => (this.options.editor.moveBlocksUp(), !0),\n      \"Shift-Mod-ArrowDown\": () => (this.options.editor.moveBlocksDown(), !0)\n    };\n  }\n});\nclass _i {\n  constructor(o, t, n) {\n    u(this, \"state\");\n    u(this, \"emitUpdate\");\n    u(this, \"menuUpdateTimer\");\n    u(this, \"startMenuUpdateTimer\");\n    u(this, \"stopMenuUpdateTimer\");\n    u(this, \"mouseHoveredLinkMark\");\n    u(this, \"mouseHoveredLinkMarkRange\");\n    u(this, \"keyboardHoveredLinkMark\");\n    u(this, \"keyboardHoveredLinkMarkRange\");\n    u(this, \"linkMark\");\n    u(this, \"linkMarkRange\");\n    u(this, \"mouseOverHandler\", (o) => {\n      if (this.mouseHoveredLinkMark = void 0, this.mouseHoveredLinkMarkRange = void 0, this.stopMenuUpdateTimer(), o.target instanceof HTMLAnchorElement && o.target.nodeName === \"A\") {\n        const t = o.target, n = this.pmView.posAtDOM(t, 0) + 1, r = this.pmView.state.doc.resolve(n), s = r.marks();\n        for (const i of s)\n          if (i.type.name === this.pmView.state.schema.mark(\"link\").type.name) {\n            this.mouseHoveredLinkMark = i, this.mouseHoveredLinkMarkRange = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.getMarkRange)(r, i.type, i.attrs) || void 0;\n            break;\n          }\n      }\n      return this.startMenuUpdateTimer(), !1;\n    });\n    u(this, \"clickHandler\", (o) => {\n      var n;\n      const t = this.pmView.dom.parentElement;\n      // Toolbar is open.\n      this.linkMark && // An element is clicked.\n      o && o.target && // The clicked element is not the editor.\n      !(t === o.target || t.contains(o.target)) && (n = this.state) != null && n.show && (this.state.show = !1, this.emitUpdate());\n    });\n    u(this, \"scrollHandler\", () => {\n      var o;\n      this.linkMark !== void 0 && (o = this.state) != null && o.show && (this.state.referencePos = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.posToDOMRect)(\n        this.pmView,\n        this.linkMarkRange.from,\n        this.linkMarkRange.to\n      ), this.emitUpdate());\n    });\n    u(this, \"closeMenu\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    this.editor = o, this.pmView = t, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized link toolbar\");\n      n(this.state);\n    }, this.startMenuUpdateTimer = () => {\n      this.menuUpdateTimer = setTimeout(() => {\n        this.update(this.pmView, void 0, !0);\n      }, 250);\n    }, this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer), this.menuUpdateTimer = void 0), !1), this.pmView.dom.addEventListener(\"mouseover\", this.mouseOverHandler), this.pmView.root.addEventListener(\n      \"click\",\n      this.clickHandler,\n      !0\n    ), this.pmView.root.addEventListener(\"scroll\", this.scrollHandler, !0);\n  }\n  editLink(o, t) {\n    var r;\n    const n = this.pmView.state.tr.insertText(\n      t,\n      this.linkMarkRange.from,\n      this.linkMarkRange.to\n    );\n    n.addMark(\n      this.linkMarkRange.from,\n      this.linkMarkRange.from + t.length,\n      this.pmView.state.schema.mark(\"link\", { href: o })\n    ), this.editor.dispatch(n), this.pmView.focus(), (r = this.state) != null && r.show && (this.state.show = !1, this.emitUpdate());\n  }\n  deleteLink() {\n    var o;\n    this.editor.dispatch(\n      this.pmView.state.tr.removeMark(\n        this.linkMarkRange.from,\n        this.linkMarkRange.to,\n        this.linkMark.type\n      ).setMeta(\"preventAutolink\", !0)\n    ), this.pmView.focus(), (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n  }\n  update(o, t, n = !1) {\n    var a;\n    const { state: r } = o;\n    if (t && t.selection.from === r.selection.from && t.selection.to === r.selection.to || !this.pmView.hasFocus())\n      return;\n    const i = this.linkMark;\n    if (this.linkMark = void 0, this.linkMarkRange = void 0, this.keyboardHoveredLinkMark = void 0, this.keyboardHoveredLinkMarkRange = void 0, this.pmView.state.selection.empty) {\n      const c = this.pmView.state.selection.$from.marks();\n      for (const l of c)\n        if (l.type.name === this.pmView.state.schema.mark(\"link\").type.name) {\n          this.keyboardHoveredLinkMark = l, this.keyboardHoveredLinkMarkRange = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.getMarkRange)(\n            this.pmView.state.selection.$from,\n            l.type,\n            l.attrs\n          ) || void 0;\n          break;\n        }\n    }\n    if (this.mouseHoveredLinkMark && n && (this.linkMark = this.mouseHoveredLinkMark, this.linkMarkRange = this.mouseHoveredLinkMarkRange), this.keyboardHoveredLinkMark && (this.linkMark = this.keyboardHoveredLinkMark, this.linkMarkRange = this.keyboardHoveredLinkMarkRange), this.linkMark && this.editor.isEditable) {\n      this.state = {\n        show: !0,\n        referencePos: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.posToDOMRect)(\n          this.pmView,\n          this.linkMarkRange.from,\n          this.linkMarkRange.to\n        ),\n        url: this.linkMark.attrs.href,\n        text: this.pmView.state.doc.textBetween(\n          this.linkMarkRange.from,\n          this.linkMarkRange.to\n        )\n      }, this.emitUpdate();\n      return;\n    }\n    if ((a = this.state) != null && a.show && i && (!this.linkMark || !this.editor.isEditable)) {\n      this.state.show = !1, this.emitUpdate();\n      return;\n    }\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mouseover\", this.mouseOverHandler), this.pmView.root.removeEventListener(\"scroll\", this.scrollHandler, !0), this.pmView.root.removeEventListener(\n      \"click\",\n      this.clickHandler,\n      !0\n    );\n  }\n}\nconst Ri = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"LinkToolbarPlugin\");\nclass Vi extends q {\n  constructor(t) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    /**\n     * Edit the currently hovered link.\n     */\n    u(this, \"editLink\", (t, n) => {\n      this.view.editLink(t, n);\n    });\n    /**\n     * Delete the currently hovered link.\n     */\n    u(this, \"deleteLink\", () => {\n      this.view.deleteLink();\n    });\n    /**\n     * When hovering on/off links using the mouse cursor, the link toolbar will\n     * open & close with a delay.\n     *\n     * This function starts the delay timer, and should be used for when the mouse\n     * cursor enters the link toolbar.\n     */\n    u(this, \"startHideTimer\", () => {\n      this.view.startMenuUpdateTimer();\n    });\n    /**\n     * When hovering on/off links using the mouse cursor, the link toolbar will\n     * open & close with a delay.\n     *\n     * This function stops the delay timer, and should be used for when the mouse\n     * cursor exits the link toolbar.\n     */\n    u(this, \"stopHideTimer\", () => {\n      this.view.stopMenuUpdateTimer();\n    });\n    u(this, \"closeMenu\", () => this.view.closeMenu());\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: Ri,\n      view: (n) => (this.view = new _i(t, n, (r) => {\n        this.emit(\"update\", r);\n      }), this.view),\n      props: {\n        handleKeyDown: (n, r) => r.key === \"Escape\" && this.shown ? (this.view.closeMenu(), !0) : !1\n      }\n    });\n  }\n  onUpdate(t) {\n    return this.on(\"update\", t);\n  }\n  get shown() {\n    var t, n;\n    return ((n = (t = this.view) == null ? void 0 : t.state) == null ? void 0 : n.show) || !1;\n  }\n}\nconst Ui = [\n  \"http\",\n  \"https\",\n  \"ftp\",\n  \"ftps\",\n  \"mailto\",\n  \"tel\",\n  \"callto\",\n  \"sms\",\n  \"cid\",\n  \"xmpp\"\n], $i = \"https\", Fi = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"node-selection-keyboard\");\nclass zi {\n  constructor() {\n    u(this, \"plugin\");\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: Fi,\n      props: {\n        handleKeyDown: (o, t) => {\n          if (\"node\" in o.state.selection) {\n            if (t.ctrlKey || t.metaKey)\n              return !1;\n            if (t.key.length === 1)\n              return t.preventDefault(), !0;\n            if (t.key === \"Enter\" && !t.shiftKey && !t.altKey && !t.ctrlKey && !t.metaKey) {\n              const n = o.state.tr;\n              return o.dispatch(\n                n.insert(\n                  o.state.tr.selection.$to.after(),\n                  o.state.schema.nodes.paragraph.createChecked()\n                ).setSelection(\n                  new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection(\n                    n.doc.resolve(o.state.tr.selection.$to.after() + 1)\n                  )\n                )\n              ), !0;\n            }\n          }\n          return !1;\n        }\n      }\n    });\n  }\n}\nconst Wi = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"blocknote-placeholder\");\nclass ji {\n  constructor(o, t) {\n    u(this, \"plugin\");\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: Wi,\n      view: (n) => {\n        var l, d;\n        const r = `placeholder-selector-${(0,uuid__WEBPACK_IMPORTED_MODULE_16__[\"default\"])()}`;\n        n.dom.classList.add(r);\n        const s = document.createElement(\"style\"), i = o._tiptapEditor.options.injectNonce;\n        i && s.setAttribute(\"nonce\", i), ((l = o.prosemirrorView) == null ? void 0 : l.root) instanceof ShadowRoot ? o.prosemirrorView.root.append(s) : (d = o.prosemirrorView) == null || d.root.head.appendChild(s);\n        const a = s.sheet, c = (p = \"\") => `.${r} .bn-block-content${p} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`;\n        try {\n          const {\n            default: p,\n            emptyDocument: h,\n            ...f\n          } = t;\n          for (const [b, k] of Object.entries(f)) {\n            const w = `[data-content-type=\"${b}\"]`;\n            a.insertRule(\n              `${c(w)} { content: ${JSON.stringify(\n                k\n              )}; }`\n            );\n          }\n          const m = \"[data-is-only-empty-block]\", g = \"[data-is-empty-and-focused]\";\n          a.insertRule(\n            `${c(m)} { content: ${JSON.stringify(\n              h\n            )}; }`\n          ), a.insertRule(\n            `${c(g)} { content: ${JSON.stringify(\n              p\n            )}; }`\n          );\n        } catch (p) {\n          console.warn(\n            \"Failed to insert placeholder CSS rule - this is likely due to the browser not supporting certain CSS pseudo-element selectors (:has, :only-child:, or :before)\",\n            p\n          );\n        }\n        return {\n          destroy: () => {\n            var p, h;\n            ((p = o.prosemirrorView) == null ? void 0 : p.root) instanceof ShadowRoot ? o.prosemirrorView.root.removeChild(s) : (h = o.prosemirrorView) == null || h.root.head.removeChild(s);\n          }\n        };\n      },\n      props: {\n        decorations: (n) => {\n          const { doc: r, selection: s } = n;\n          if (!o.isEditable || !s.empty || s.$from.parent.type.spec.code)\n            return;\n          const i = [];\n          n.doc.content.size === 6 && i.push(\n            prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.node(2, 4, {\n              \"data-is-only-empty-block\": \"true\"\n            })\n          );\n          const a = s.$anchor, c = a.parent;\n          if (c.content.size === 0) {\n            const l = a.before();\n            i.push(\n              prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.node(l, l + c.nodeSize, {\n                \"data-is-empty-and-focused\": \"true\"\n              })\n            );\n          }\n          return prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(r, i);\n        }\n      }\n    });\n  }\n}\nconst _t = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"previous-blocks\"), Gi = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\"\n};\nclass qi {\n  constructor() {\n    u(this, \"plugin\");\n    let o;\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: _t,\n      view(t) {\n        return {\n          update: async (n, r) => {\n            var s;\n            ((s = this.key) == null ? void 0 : s.getState(n.state).updatedBlocks.size) > 0 && (o = setTimeout(() => {\n              n.dispatch(\n                n.state.tr.setMeta(_t, { clearUpdate: !0 })\n              );\n            }, 0));\n          },\n          destroy: () => {\n            o && clearTimeout(o);\n          }\n        };\n      },\n      state: {\n        init() {\n          return {\n            // Block attributes, by block ID, from just before the previous transaction.\n            prevTransactionOldBlockAttrs: {},\n            // Block attributes, by block ID, from just before the current transaction.\n            currentTransactionOldBlockAttrs: {},\n            // Set of IDs of blocks whose attributes changed from the current transaction.\n            updatedBlocks: /* @__PURE__ */ new Set()\n          };\n        },\n        apply(t, n, r, s) {\n          if (n.currentTransactionOldBlockAttrs = {}, n.updatedBlocks.clear(), !t.docChanged || r.doc.eq(s.doc))\n            return n;\n          const i = {}, a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.findChildren)(r.doc, (d) => d.attrs.id), c = new Map(\n            a.map((d) => [d.node.attrs.id, d])\n          ), l = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.findChildren)(s.doc, (d) => d.attrs.id);\n          for (const d of l) {\n            const p = c.get(d.node.attrs.id), h = p == null ? void 0 : p.node.firstChild, f = d.node.firstChild;\n            if (p && h && f) {\n              const m = {\n                index: f.attrs.index,\n                level: f.attrs.level,\n                type: f.type.name,\n                depth: s.doc.resolve(d.pos).depth\n              };\n              let g = {\n                index: h.attrs.index,\n                level: h.attrs.level,\n                type: h.type.name,\n                depth: r.doc.resolve(p.pos).depth\n              };\n              i[d.node.attrs.id] = g, t.getMeta(\"numberedListIndexing\") && (d.node.attrs.id in n.prevTransactionOldBlockAttrs && (g = n.prevTransactionOldBlockAttrs[d.node.attrs.id]), m.type === \"numberedListItem\" && (g.index = m.index)), n.currentTransactionOldBlockAttrs[d.node.attrs.id] = g, JSON.stringify(g) !== JSON.stringify(m) && (g[\"depth-change\"] = g.depth - m.depth, n.updatedBlocks.add(d.node.attrs.id));\n            }\n          }\n          return n.prevTransactionOldBlockAttrs = i, n;\n        }\n      },\n      props: {\n        decorations(t) {\n          const n = this.getState(t);\n          if (n.updatedBlocks.size === 0)\n            return;\n          const r = [];\n          return t.doc.descendants((s, i) => {\n            if (!s.attrs.id || !n.updatedBlocks.has(s.attrs.id))\n              return;\n            const a = n.currentTransactionOldBlockAttrs[s.attrs.id], c = {};\n            for (const [d, p] of Object.entries(a))\n              c[\"data-prev-\" + Gi[d]] = p || \"none\";\n            const l = prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.node(i, i + s.nodeSize, {\n              ...c\n            });\n            r.push(l);\n          }), prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(t.doc, r);\n        }\n      }\n    });\n  }\n}\nconst Rt = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"blocknote-show-selection\");\nclass Ki {\n  constructor(o) {\n    u(this, \"plugin\");\n    u(this, \"enabled\", !1);\n    this.editor = o, this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: Rt,\n      props: {\n        decorations: (t) => {\n          const { doc: n, selection: r } = t;\n          if (!this.enabled)\n            return prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.empty;\n          const s = prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.inline(r.from, r.to, {\n            \"data-show-selection\": \"true\"\n          });\n          return prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(n, [s]);\n        }\n      }\n    });\n  }\n  setEnabled(o) {\n    var t, n;\n    this.enabled !== o && (this.enabled = o, (n = this.editor.prosemirrorView) == null || n.dispatch(\n      (t = this.editor.prosemirrorView) == null ? void 0 : t.state.tr.setMeta(Rt, {})\n    ));\n  }\n  getEnabled() {\n    return this.enabled;\n  }\n}\nfunction Do(e, o) {\n  var t, n;\n  for (; e && e.parentElement && e.parentElement !== o.dom && ((t = e.getAttribute) == null ? void 0 : t.call(e, \"data-node-type\")) !== \"blockContainer\"; )\n    e = e.parentElement;\n  if (((n = e.getAttribute) == null ? void 0 : n.call(e, \"data-node-type\")) === \"blockContainer\")\n    return { node: e, id: e.getAttribute(\"data-id\") };\n}\nclass le extends prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Selection {\n  constructor(t, n) {\n    super(t, n);\n    u(this, \"nodes\");\n    const r = t.node();\n    this.nodes = [], t.doc.nodesBetween(t.pos, n.pos, (s, i, a) => {\n      if (a !== null && a.eq(r))\n        return this.nodes.push(s), !1;\n    });\n  }\n  static create(t, n, r = n) {\n    return new le(t.resolve(n), t.resolve(r));\n  }\n  content() {\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(this.nodes), 0, 0);\n  }\n  eq(t) {\n    if (!(t instanceof le) || this.nodes.length !== t.nodes.length || this.from !== t.from || this.to !== t.to)\n      return !1;\n    for (let n = 0; n < this.nodes.length; n++)\n      if (!this.nodes[n].eq(t.nodes[n]))\n        return !1;\n    return !0;\n  }\n  map(t, n) {\n    const r = n.mapResult(this.from), s = n.mapResult(this.to);\n    return s.deleted ? prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Selection.near(t.resolve(r.pos)) : r.deleted ? prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Selection.near(t.resolve(s.pos)) : new le(\n      t.resolve(r.pos),\n      t.resolve(s.pos)\n    );\n  }\n  toJSON() {\n    return { type: \"node\", anchor: this.anchor, head: this.head };\n  }\n}\nlet _;\nfunction Xi(e, o) {\n  let t, n;\n  const r = o.resolve(e.from).node().type.spec.group === \"blockContent\", s = o.resolve(e.to).node().type.spec.group === \"blockContent\", i = Math.min(e.$anchor.depth, e.$head.depth);\n  if (r && s) {\n    const a = e.$from.start(i - 1), c = e.$to.end(i - 1);\n    t = o.resolve(a - 1).pos, n = o.resolve(c + 1).pos;\n  } else\n    t = e.from, n = e.to;\n  return { from: t, to: n };\n}\nfunction Vt(e, o, t = o) {\n  o === t && (t += e.state.doc.resolve(o + 1).node().nodeSize);\n  const n = e.domAtPos(o).node.cloneNode(!0), r = e.domAtPos(o).node, s = (p, h) => Array.prototype.indexOf.call(p.children, h), i = s(\n    r,\n    // Expects from position to be just before the first selected block.\n    e.domAtPos(o + 1).node.parentElement\n  ), a = s(\n    r,\n    // Expects to position to be just after the last selected block.\n    e.domAtPos(t - 1).node.parentElement\n  );\n  for (let p = r.childElementCount - 1; p >= 0; p--)\n    (p > a || p < i) && n.removeChild(n.children[p]);\n  Oo(e.root), _ = n;\n  const c = _.getElementsByTagName(\"iframe\");\n  for (let p = 0; p < c.length; p++) {\n    const h = c[p], f = h.parentElement;\n    f && f.removeChild(h);\n  }\n  const d = e.dom.className.split(\" \").filter(\n    (p) => p !== \"ProseMirror\" && p !== \"bn-root\" && p !== \"bn-editor\"\n  ).join(\" \");\n  _.className = _.className + \" bn-drag-preview \" + d, e.root instanceof ShadowRoot ? e.root.appendChild(_) : e.root.body.appendChild(_);\n}\nfunction Oo(e) {\n  _ !== void 0 && (e instanceof ShadowRoot ? e.removeChild(_) : e.body.removeChild(_), _ = void 0);\n}\nfunction Ji(e, o, t) {\n  if (!e.dataTransfer)\n    return;\n  const n = t.prosemirrorView;\n  if (!n)\n    return;\n  const r = D(o.id, n.state.doc);\n  if (!r)\n    throw new Error(`Block with ID ${o.id} not found`);\n  const s = r.posBeforeNode;\n  if (s != null) {\n    const i = n.state.selection, a = n.state.doc, { from: c, to: l } = Xi(i, a), d = c <= s && s < l, p = i.$anchor.node() !== i.$head.node() || i instanceof le;\n    d && p ? (n.dispatch(\n      n.state.tr.setSelection(le.create(a, c, l))\n    ), Vt(n, c, l)) : (n.dispatch(\n      n.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.NodeSelection.create(n.state.doc, s))\n    ), Vt(n, s));\n    const h = n.state.selection.content(), f = t.pmSchema, m = n.serializeForClipboard(h).dom.innerHTML, g = Ve(f, t), b = Lo(h.content, t.schema), k = g.exportBlocks(b, {}), w = ht(k);\n    e.dataTransfer.clearData(), e.dataTransfer.setData(\"blocknote/html\", m), e.dataTransfer.setData(\"text/html\", k), e.dataTransfer.setData(\"text/plain\", w), e.dataTransfer.effectAllowed = \"move\", e.dataTransfer.setDragImage(_, 0, 0);\n  }\n}\nconst he = 0.1;\nfunction rt(e, o, t, n = !0) {\n  const r = e.root.elementsFromPoint(\n    // bit hacky - offset x position to right to account for the width of sidemenu itself\n    o.left + (t === \"editor\" ? 50 : 0),\n    o.top\n  );\n  for (const s of r)\n    if (e.dom.contains(s))\n      return n && s.closest(\"[data-node-type=columnList]\") ? rt(\n        e,\n        {\n          left: o.left + 50,\n          // bit hacky, but if we're inside a column, offset x position to right to account for the width of sidemenu itself\n          top: o.top\n        },\n        t,\n        !1\n      ) : Do(s, e);\n}\nfunction Yi(e, o, t) {\n  if (!o.dom.firstChild)\n    return;\n  const n = o.dom.firstChild.getBoundingClientRect(), r = {\n    left: e.x,\n    top: e.y\n  }, s = r.left < n.left, i = r.left > n.right;\n  t === \"viewport\" && (s && (r.left = n.left + 10), i && (r.left = n.right - 10));\n  let a = rt(o, r, t);\n  if (!i && a) {\n    const c = a.node.getBoundingClientRect();\n    r.left = c.right - 10, a = rt(o, r, \"viewport\", !1);\n  }\n  return a;\n}\nclass Zi {\n  constructor(o, t, n, r) {\n    u(this, \"state\");\n    u(this, \"emitUpdate\");\n    u(this, \"mousePos\");\n    u(this, \"hoveredBlock\");\n    u(this, \"menuFrozen\", !1);\n    u(this, \"isDragOrigin\", !1);\n    u(this, \"updateState\", (o) => {\n      this.state = o, this.emitUpdate(this.state);\n    });\n    u(this, \"updateStateFromMousePos\", () => {\n      var n, r, s, i;\n      if (this.menuFrozen || !this.mousePos)\n        return;\n      const o = Yi(\n        this.mousePos,\n        this.pmView,\n        this.sideMenuDetection\n      );\n      if (!o || !this.editor.isEditable) {\n        (n = this.state) != null && n.show && (this.state.show = !1, this.updateState(this.state));\n        return;\n      }\n      if ((r = this.state) != null && r.show && ((s = this.hoveredBlock) != null && s.hasAttribute(\"data-id\")) && ((i = this.hoveredBlock) == null ? void 0 : i.getAttribute(\"data-id\")) === o.id)\n        return;\n      this.hoveredBlock = o.node;\n      const t = o.node.firstChild;\n      if (t && this.editor.isEditable) {\n        const a = t.getBoundingClientRect(), c = o.node.closest(\"[data-node-type=column]\");\n        this.updateState({\n          show: !0,\n          referencePos: new DOMRect(\n            c ? (\n              // We take the first child as column elements have some default\n              // padding. This is a little weird since this child element will\n              // be the first block, but since it's always non-nested and we\n              // only take the x coordinate, it's ok.\n              c.firstElementChild.getBoundingClientRect().x\n            ) : this.pmView.dom.firstChild.getBoundingClientRect().x,\n            a.y,\n            a.width,\n            a.height\n          ),\n          block: this.editor.getBlock(\n            this.hoveredBlock.getAttribute(\"data-id\")\n          )\n        });\n      }\n    });\n    u(this, \"onDrop\", (o) => {\n      var r, s;\n      if (this.pmView.dragging === null)\n        return;\n      this.editor._tiptapEditor.commands.blur();\n      const t = o.target instanceof Node && ((r = o.target instanceof HTMLElement ? o.target : o.target.parentElement) == null ? void 0 : r.closest(\".bn-editor\")) || null;\n      if (t && (!this.isDragOrigin && this.pmView.dom === t ? this.pmView.dispatch(\n        this.pmView.state.tr.setSelection(\n          prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.create(\n            this.pmView.state.tr.doc,\n            this.pmView.state.tr.selection.to\n          )\n        )\n      ) : this.isDragOrigin && this.pmView.dom !== t && setTimeout(\n        () => this.pmView.dispatch(this.pmView.state.tr.deleteSelection()),\n        0\n      )), this.sideMenuDetection === \"editor\" || o.synthetic || !((s = o.dataTransfer) != null && s.types.includes(\"blocknote/html\")))\n        return;\n      const n = this.pmView.posAtCoords({\n        left: o.clientX,\n        top: o.clientY\n      });\n      if (!n || n.inside === -1) {\n        const i = this.createSyntheticEvent(o);\n        this.pmView.dom.dispatchEvent(i);\n      }\n    });\n    u(this, \"onDragEnd\", () => {\n      this.pmView.dragging = null;\n    });\n    /**\n     * If a block is being dragged, ProseMirror usually gets the context of what's\n     * being dragged from `view.dragging`, which is automatically set when a\n     * `dragstart` event fires in the editor. However, if the user tries to drag\n     * and drop blocks between multiple editors, only the one in which the drag\n     * began has that context, so we need to set it on the others manually. This\n     * ensures that PM always drops the blocks in between other blocks, and not\n     * inside them.\n     *\n     * After the `dragstart` event fires on the drag handle, it sets\n     * `blocknote/html` data on the clipboard. This handler fires right after,\n     * parsing the `blocknote/html` data into nodes and setting them on\n     * `view.dragging`.\n     *\n     * Note: Setting `view.dragging` on `dragover` would be better as the user\n     * could then drag between editors in different windows, but you can only\n     * access `dataTransfer` contents on `dragstart` and `drop` events.\n     */\n    u(this, \"onDragStart\", (o) => {\n      var i;\n      const t = (i = o.dataTransfer) == null ? void 0 : i.getData(\"blocknote/html\");\n      if (!t)\n        return;\n      if (this.pmView.dragging)\n        throw new Error(\"New drag was started while an existing drag is ongoing\");\n      const n = document.createElement(\"div\");\n      n.innerHTML = t;\n      const s = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.DOMParser.fromSchema(this.pmView.state.schema).parse(n, {\n        topNode: this.pmView.state.schema.nodes.blockGroup.create()\n      });\n      this.pmView.dragging = {\n        slice: new prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Slice(s.content, 0, 0),\n        move: !0\n      };\n    });\n    /**\n     * If the event is outside the editor contents,\n     * we dispatch a fake event, so that we can still drop the content\n     * when dragging / dropping to the side of the editor\n     */\n    u(this, \"onDragOver\", (o) => {\n      var n;\n      if (this.sideMenuDetection === \"editor\" || o.synthetic || !((n = o.dataTransfer) != null && n.types.includes(\"blocknote/html\")))\n        return;\n      const t = this.pmView.posAtCoords({\n        left: o.clientX,\n        top: o.clientY\n      });\n      if (!t || t.inside === -1 && this.pmView.dom.firstChild) {\n        const r = this.createSyntheticEvent(o);\n        this.pmView.dom.dispatchEvent(r);\n      }\n    });\n    u(this, \"onKeyDown\", (o) => {\n      var t;\n      (t = this.state) != null && t.show && this.editor.isFocused() && (this.state.show = !1, this.emitUpdate(this.state));\n    });\n    u(this, \"onMouseMove\", (o) => {\n      var s;\n      if (this.menuFrozen)\n        return;\n      this.mousePos = { x: o.clientX, y: o.clientY };\n      const t = this.pmView.dom.getBoundingClientRect(), n = this.mousePos.x > t.left && this.mousePos.x < t.right && this.mousePos.y > t.top && this.mousePos.y < t.bottom, r = this.pmView.dom.parentElement;\n      if (\n        // Cursor is within the editor area\n        n && // An element is hovered\n        o && o.target && // Element is outside the editor\n        !(r === o.target || r.contains(o.target))\n      ) {\n        (s = this.state) != null && s.show && (this.state.show = !1, this.emitUpdate(this.state));\n        return;\n      }\n      this.updateStateFromMousePos();\n    });\n    u(this, \"onScroll\", () => {\n      var o;\n      (o = this.state) != null && o.show && (this.state.referencePos = this.hoveredBlock.getBoundingClientRect(), this.emitUpdate(this.state));\n    });\n    this.editor = o, this.sideMenuDetection = t, this.pmView = n, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized side menu\");\n      r(this.state);\n    }, this.pmView.root.addEventListener(\n      \"dragstart\",\n      this.onDragStart\n    ), this.pmView.root.addEventListener(\n      \"dragover\",\n      this.onDragOver\n    ), this.pmView.root.addEventListener(\n      \"drop\",\n      this.onDrop,\n      !0\n    ), this.pmView.root.addEventListener(\n      \"dragend\",\n      this.onDragEnd,\n      !0\n    ), ut(), this.pmView.root.addEventListener(\n      \"mousemove\",\n      this.onMouseMove,\n      !0\n    ), this.pmView.root.addEventListener(\n      \"keydown\",\n      this.onKeyDown,\n      !0\n    ), n.root.addEventListener(\"scroll\", this.onScroll, !0);\n  }\n  createSyntheticEvent(o) {\n    const t = new Event(o.type, o), n = this.pmView.dom.firstChild.getBoundingClientRect();\n    return t.clientX = o.clientX, t.clientY = o.clientY, o.clientX < n.left && o.clientX > n.left - n.width * he ? t.clientX = n.left + n.width * he / 2 : o.clientX > n.right && o.clientX < n.right + n.width * he ? t.clientX = n.right - n.width * he / 2 : (o.clientX < n.left || o.clientX > n.right) && (t.clientX = n.left + he * n.width * 2), t.clientY = Math.min(\n      Math.max(o.clientY, n.top),\n      n.top + n.height\n    ), t.dataTransfer = o.dataTransfer, t.preventDefault = () => o.preventDefault(), t.synthetic = !0, t;\n  }\n  // Needed in cases where the editor state updates without the mouse cursor\n  // moving, as some state updates can require a side menu update. For example,\n  // adding a button to the side menu which removes the block can cause the\n  // block below to jump up into the place of the removed block when clicked,\n  // allowing the user to click the button again without moving the cursor. This\n  // would otherwise not update the side menu, and so clicking the button again\n  // would attempt to remove the same block again, causing an error.\n  update(o, t) {\n    var r;\n    !t.doc.eq(this.pmView.state.doc) && ((r = this.state) != null && r.show) && this.updateStateFromMousePos();\n  }\n  destroy() {\n    var o;\n    (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate(this.state)), this.pmView.root.removeEventListener(\n      \"mousemove\",\n      this.onMouseMove,\n      !0\n    ), this.pmView.root.removeEventListener(\n      \"dragstart\",\n      this.onDragStart\n    ), this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.onDragOver\n    ), this.pmView.root.removeEventListener(\n      \"drop\",\n      this.onDrop,\n      !0\n    ), this.pmView.root.removeEventListener(\n      \"dragend\",\n      this.onDragEnd,\n      !0\n    ), this.pmView.root.removeEventListener(\n      \"keydown\",\n      this.onKeyDown,\n      !0\n    ), this.pmView.root.removeEventListener(\"scroll\", this.onScroll, !0);\n  }\n}\nconst Qi = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"SideMenuPlugin\");\nclass ea extends q {\n  constructor(t, n) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    u(this, \"blockDragStart\", (t, n) => {\n      this.view && (this.view.isDragOrigin = !0), Ji(t, n, this.editor);\n    });\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    u(this, \"blockDragEnd\", () => {\n      this.editor.prosemirrorView && Oo(this.editor.prosemirrorView.root), this.view && (this.view.isDragOrigin = !1);\n    });\n    /**\n     * Freezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    u(this, \"freezeMenu\", () => {\n      this.view.menuFrozen = !0, this.view.state.show = !0, this.view.emitUpdate(this.view.state);\n    });\n    /**\n     * Unfreezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    u(this, \"unfreezeMenu\", () => {\n      this.view.menuFrozen = !1, this.view.state.show = !1, this.view.emitUpdate(this.view.state);\n    });\n    this.editor = t, this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: Qi,\n      view: (r) => (this.view = new Zi(\n        t,\n        n,\n        r,\n        (s) => {\n          this.emit(\"update\", s);\n        }\n      ), this.view)\n    });\n  }\n  onUpdate(t) {\n    return this.on(\"update\", t);\n  }\n}\nconst Me = /* @__PURE__ */ new Map();\nfunction ta(e) {\n  if (Me.has(e))\n    return Me.get(e);\n  const o = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_19__.Mapping();\n  return e._tiptapEditor.on(\"transaction\", ({ transaction: t }) => {\n    o.appendMapping(t.mapping);\n  }), e._tiptapEditor.on(\"destroy\", () => {\n    Me.delete(e);\n  }), Me.set(e, o), o;\n}\nfunction oa(e, o, t = \"left\") {\n  const n = y_prosemirror__WEBPACK_IMPORTED_MODULE_23__.ySyncPluginKey.getState(e.prosemirrorState);\n  if (!n) {\n    const s = ta(e), i = s.maps.length;\n    return () => s.slice(i).map(o, t === \"left\" ? -1 : 1);\n  }\n  const r = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_25__.absolutePositionToRelativePosition)(\n    // Track the position after the position if we are on the right side\n    o + (t === \"right\" ? 1 : 0),\n    n.binding.type,\n    n.binding.mapping\n  );\n  return () => {\n    const s = y_prosemirror__WEBPACK_IMPORTED_MODULE_23__.ySyncPluginKey.getState(\n      e.prosemirrorState\n    ), i = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_25__.relativePositionToAbsolutePosition)(\n      s.doc,\n      s.binding.type,\n      r,\n      s.binding.mapping\n    );\n    if (i === null)\n      throw new Error(\"Position not found, cannot track positions\");\n    return i + (t === \"right\" ? -1 : 0);\n  };\n}\nconst na = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.findParentNode)((e) => e.type.name === \"blockContainer\");\nclass ra {\n  constructor(o, t) {\n    u(this, \"state\");\n    u(this, \"emitUpdate\");\n    u(this, \"rootEl\");\n    u(this, \"pluginState\");\n    u(this, \"handleScroll\", () => {\n      var o, t;\n      if ((o = this.state) != null && o.show) {\n        const n = (t = this.rootEl) == null ? void 0 : t.querySelector(\n          `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n        );\n        if (!n)\n          return;\n        this.state.referencePos = n.getBoundingClientRect(), this.emitUpdate(this.pluginState.triggerCharacter);\n      }\n    });\n    u(this, \"closeMenu\", () => {\n      this.editor.dispatch(\n        this.editor._tiptapEditor.state.tr.setMeta(de, null)\n      );\n    });\n    u(this, \"clearQuery\", () => {\n      this.pluginState !== void 0 && this.editor._tiptapEditor.chain().focus().deleteRange({\n        from: this.pluginState.queryStartPos() - (this.pluginState.deleteTriggerCharacter ? this.pluginState.triggerCharacter.length : 0),\n        to: this.editor._tiptapEditor.state.selection.from\n      }).run();\n    });\n    var n, r;\n    this.editor = o, this.pluginState = void 0, this.emitUpdate = (s) => {\n      var i;\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized suggestions menu\");\n      t(s, {\n        ...this.state,\n        ignoreQueryLength: (i = this.pluginState) == null ? void 0 : i.ignoreQueryLength\n      });\n    }, this.rootEl = (n = this.editor.prosemirrorView) == null ? void 0 : n.root, (r = this.rootEl) == null || r.addEventListener(\"scroll\", this.handleScroll, !0);\n  }\n  update(o, t) {\n    var l;\n    const n = de.getState(t), r = de.getState(\n      o.state\n    ), s = n === void 0 && r !== void 0, i = n !== void 0 && r === void 0;\n    if (!s && !(n !== void 0 && r !== void 0) && !i)\n      return;\n    if (this.pluginState = i ? n : r, i || !this.editor.isEditable) {\n      this.state && (this.state.show = !1), this.emitUpdate(this.pluginState.triggerCharacter);\n      return;\n    }\n    const c = (l = this.rootEl) == null ? void 0 : l.querySelector(\n      `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n    );\n    this.editor.isEditable && c && (this.state = {\n      show: !0,\n      referencePos: c.getBoundingClientRect(),\n      query: this.pluginState.query\n    }, this.emitUpdate(this.pluginState.triggerCharacter));\n  }\n  destroy() {\n    var o;\n    (o = this.rootEl) == null || o.removeEventListener(\"scroll\", this.handleScroll, !0);\n  }\n}\nconst de = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"SuggestionMenuPlugin\");\nclass sa extends q {\n  constructor(t) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    u(this, \"triggerCharacters\", []);\n    u(this, \"addTriggerCharacter\", (t) => {\n      this.triggerCharacters.push(t);\n    });\n    // TODO: Should this be called automatically when listeners are removed?\n    u(this, \"removeTriggerCharacter\", (t) => {\n      this.triggerCharacters = this.triggerCharacters.filter(\n        (n) => n !== t\n      );\n    });\n    u(this, \"closeMenu\", () => this.view.closeMenu());\n    u(this, \"clearQuery\", () => this.view.clearQuery());\n    const n = this.triggerCharacters;\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: de,\n      view: () => (this.view = new ra(\n        t,\n        (r, s) => {\n          this.emit(`update ${r}`, s);\n        }\n      ), this.view),\n      state: {\n        // Initialize the plugin's internal state.\n        init() {\n        },\n        // Apply changes to the plugin state from an editor transaction.\n        apply(r, s, i, a) {\n          if (r.getMeta(\"orderedListIndexing\") !== void 0 || r.selection.$from.parent.type.spec.code)\n            return s;\n          const c = r.getMeta(de);\n          if (typeof c == \"object\" && c !== null && s === void 0) {\n            const d = oa(\n              t,\n              a.selection.from - // Need to account for the trigger char that was inserted, so we offset the position by the length of the trigger character.\n              c.triggerCharacter.length\n            );\n            return {\n              triggerCharacter: c.triggerCharacter,\n              deleteTriggerCharacter: c.deleteTriggerCharacter !== !1,\n              // When reading the queryStartPos, we offset the result by the length of the trigger character, to make it easy on the caller\n              queryStartPos: () => d() + c.triggerCharacter.length,\n              query: \"\",\n              decorationId: `id_${Math.floor(Math.random() * 4294967295)}`,\n              ignoreQueryLength: c == null ? void 0 : c.ignoreQueryLength\n            };\n          }\n          if (s === void 0)\n            return s;\n          if (\n            // Highlighting text should hide the menu.\n            a.selection.from !== a.selection.to || // Transactions with plugin metadata should hide the menu.\n            c === null || // Certain mouse events should hide the menu.\n            // TODO: Change to global mousedown listener.\n            r.getMeta(\"focus\") || r.getMeta(\"blur\") || r.getMeta(\"pointer\") || // Moving the caret before the character which triggered the menu should hide it.\n            s.triggerCharacter !== void 0 && a.selection.from < s.queryStartPos()\n          )\n            return;\n          const l = { ...s };\n          return l.query = a.doc.textBetween(\n            s.queryStartPos(),\n            a.selection.from\n          ), l;\n        }\n      },\n      props: {\n        handleTextInput(r, s, i, a) {\n          const c = this.getState(r.state);\n          return n.includes(a) && c === void 0 ? (r.dispatch(\n            r.state.tr.insertText(a).scrollIntoView().setMeta(de, {\n              triggerCharacter: a\n            })\n          ), !0) : !1;\n        },\n        // Setup decorator on the currently active suggestion.\n        decorations(r) {\n          const s = this.getState(r);\n          if (s === void 0)\n            return null;\n          if (!s.deleteTriggerCharacter) {\n            const i = na(r.selection);\n            if (i)\n              return prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(r.doc, [\n                prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.node(\n                  i.pos,\n                  i.pos + i.node.nodeSize,\n                  {\n                    nodeName: \"span\",\n                    class: \"bn-suggestion-decorator\",\n                    \"data-decoration-id\": s.decorationId\n                  }\n                )\n              ]);\n          }\n          return prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(r.doc, [\n            prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.inline(\n              s.queryStartPos() - s.triggerCharacter.length,\n              s.queryStartPos(),\n              {\n                nodeName: \"span\",\n                class: \"bn-suggestion-decorator\",\n                \"data-decoration-id\": s.decorationId\n              }\n            )\n          ]);\n        }\n      }\n    });\n  }\n  onUpdate(t, n) {\n    return this.triggerCharacters.includes(t) || this.addTriggerCharacter(t), this.on(`update ${t}`, n);\n  }\n  get shown() {\n    var t, n;\n    return ((n = (t = this.view) == null ? void 0 : t.state) == null ? void 0 : n.show) || !1;\n  }\n}\nfunction bc(e, o) {\n  e.suggestionMenus.addTriggerCharacter(o);\n}\nlet A;\nfunction Ut(e) {\n  A || (A = document.createElement(\"div\"), A.innerHTML = \"_\", A.style.opacity = \"0\", A.style.height = \"1px\", A.style.width = \"1px\", e instanceof Document ? e.body.appendChild(A) : e.appendChild(A));\n}\nfunction ia(e) {\n  A && (e instanceof Document ? e.body.removeChild(A) : e.removeChild(A), A = void 0);\n}\nfunction Pe(e) {\n  return Array.prototype.indexOf.call(e.parentElement.childNodes, e);\n}\nfunction aa(e) {\n  let o = e;\n  for (; o && o.nodeName !== \"TD\" && o.nodeName !== \"TH\" && !o.classList.contains(\"tableWrapper\"); ) {\n    if (o.classList.contains(\"ProseMirror\"))\n      return;\n    const t = o.parentNode;\n    if (!t || !(t instanceof Element))\n      return;\n    o = t;\n  }\n  return o.nodeName === \"TD\" || o.nodeName === \"TH\" ? {\n    type: \"cell\",\n    domNode: o,\n    tbodyNode: o.closest(\"tbody\")\n  } : {\n    type: \"wrapper\",\n    domNode: o,\n    tbodyNode: o.querySelector(\"tbody\")\n  };\n}\nfunction ca(e, o) {\n  const t = o.querySelectorAll(e);\n  for (let n = 0; n < t.length; n++)\n    t[n].style.visibility = \"hidden\";\n}\nclass la {\n  constructor(o, t, n) {\n    u(this, \"state\");\n    u(this, \"emitUpdate\");\n    u(this, \"tableId\");\n    u(this, \"tablePos\");\n    u(this, \"tableElement\");\n    u(this, \"menuFrozen\", !1);\n    u(this, \"mouseState\", \"up\");\n    u(this, \"prevWasEditable\", null);\n    u(this, \"viewMousedownHandler\", () => {\n      this.mouseState = \"down\";\n    });\n    u(this, \"mouseUpHandler\", (o) => {\n      this.mouseState = \"up\", this.mouseMoveHandler(o);\n    });\n    u(this, \"mouseMoveHandler\", (o) => {\n      var l, d, p, h, f, m, g;\n      if (this.menuFrozen || this.mouseState === \"selecting\" || !(o.target instanceof Element) || !this.pmView.dom.contains(o.target))\n        return;\n      const t = aa(o.target);\n      if ((t == null ? void 0 : t.type) === \"cell\" && this.mouseState === \"down\" && !((l = this.state) != null && l.draggingState)) {\n        this.mouseState = \"selecting\", (d = this.state) != null && d.show && (this.state.show = !1, this.state.showAddOrRemoveRowsButton = !1, this.state.showAddOrRemoveColumnsButton = !1, this.emitUpdate());\n        return;\n      }\n      if (!t || !this.editor.isEditable) {\n        (p = this.state) != null && p.show && (this.state.show = !1, this.state.showAddOrRemoveRowsButton = !1, this.state.showAddOrRemoveColumnsButton = !1, this.emitUpdate());\n        return;\n      }\n      if (!t.tbodyNode)\n        return;\n      const n = t.tbodyNode.getBoundingClientRect(), r = Do(t.domNode, this.pmView);\n      if (!r)\n        return;\n      this.tableElement = r.node;\n      let s;\n      const i = D(\n        r.id,\n        this.editor._tiptapEditor.state.doc\n      );\n      if (!i)\n        throw new Error(`Block with ID ${r.id} not found`);\n      const a = E(\n        i.node,\n        this.editor.schema.blockSchema,\n        this.editor.schema.inlineContentSchema,\n        this.editor.schema.styleSchema,\n        this.editor.blockCache\n      );\n      if (Cs(\"table\", a, this.editor) && (this.tablePos = i.posBeforeNode + 1, s = a), !s)\n        return;\n      this.tableId = r.id;\n      const c = (h = t.domNode.closest(\".tableWrapper\")) == null ? void 0 : h.querySelector(\".table-widgets-container\");\n      if ((t == null ? void 0 : t.type) === \"wrapper\") {\n        const b = o.clientY >= n.bottom - 1 && // -1 to account for fractions of pixels in \"bottom\"\n        o.clientY < n.bottom + 20, k = o.clientX >= n.right - 1 && o.clientX < n.right + 20, w = o.clientX > n.right || o.clientY > n.bottom;\n        this.state = {\n          ...this.state,\n          show: !0,\n          showAddOrRemoveRowsButton: b,\n          showAddOrRemoveColumnsButton: k,\n          referencePosTable: n,\n          block: s,\n          widgetContainer: c,\n          colIndex: w || (f = this.state) == null ? void 0 : f.colIndex,\n          rowIndex: w || (m = this.state) == null ? void 0 : m.rowIndex,\n          referencePosCell: w || (g = this.state) == null ? void 0 : g.referencePosCell\n        };\n      } else {\n        const b = Pe(t.domNode), k = Pe(t.domNode.parentElement), w = t.domNode.getBoundingClientRect();\n        if (this.state !== void 0 && this.state.show && this.tableId === r.id && this.state.rowIndex === k && this.state.colIndex === b)\n          return;\n        this.state = {\n          show: !0,\n          showAddOrRemoveColumnsButton: b === s.content.rows[0].cells.length - 1,\n          showAddOrRemoveRowsButton: k === s.content.rows.length - 1,\n          referencePosTable: n,\n          block: s,\n          draggingState: void 0,\n          referencePosCell: w,\n          colIndex: b,\n          rowIndex: k,\n          widgetContainer: c\n        };\n      }\n      return this.emitUpdate(), !1;\n    });\n    u(this, \"dragOverHandler\", (o) => {\n      var h;\n      if (((h = this.state) == null ? void 0 : h.draggingState) === void 0)\n        return;\n      o.preventDefault(), o.dataTransfer.dropEffect = \"move\", ca(\n        \".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline\",\n        this.pmView.root\n      );\n      const t = {\n        left: Math.min(\n          Math.max(o.clientX, this.state.referencePosTable.left + 1),\n          this.state.referencePosTable.right - 1\n        ),\n        top: Math.min(\n          Math.max(o.clientY, this.state.referencePosTable.top + 1),\n          this.state.referencePosTable.bottom - 1\n        )\n      }, n = this.pmView.root.elementsFromPoint(t.left, t.top).filter(\n        (f) => f.tagName === \"TD\" || f.tagName === \"TH\"\n      );\n      if (n.length === 0)\n        return;\n      const r = n[0];\n      let s = !1;\n      const i = Pe(r.parentElement), a = Pe(r), c = this.state.draggingState.draggedCellOrientation === \"row\" ? this.state.rowIndex : this.state.colIndex, d = (this.state.draggingState.draggedCellOrientation === \"row\" ? i : a) !== c;\n      (this.state.rowIndex !== i || this.state.colIndex !== a) && (this.state.rowIndex = i, this.state.colIndex = a, this.state.referencePosCell = r.getBoundingClientRect(), s = !0);\n      const p = this.state.draggingState.draggedCellOrientation === \"row\" ? t.top : t.left;\n      this.state.draggingState.mousePos !== p && (this.state.draggingState.mousePos = p, s = !0), s && this.emitUpdate(), d && this.editor.dispatch(\n        this.pmView.state.tr.setMeta(fe, !0)\n      );\n    });\n    u(this, \"dropHandler\", (o) => {\n      if (this.mouseState = \"up\", this.state === void 0 || this.state.draggingState === void 0)\n        return !1;\n      if (this.state.rowIndex === void 0 || this.state.colIndex === void 0)\n        throw new Error(\n          \"Attempted to drop table row or column, but no table block was hovered prior.\"\n        );\n      o.preventDefault();\n      const { draggingState: t, colIndex: n, rowIndex: r } = this.state, s = this.state.block.content.columnWidths;\n      if (t.draggedCellOrientation === \"row\") {\n        if (!to(\n          this.state.block,\n          t.originalIndex,\n          r\n        ))\n          return !1;\n        const i = Xn(\n          this.state.block,\n          t.originalIndex,\n          r\n        );\n        this.editor.updateBlock(this.state.block, {\n          type: \"table\",\n          content: {\n            ...this.state.block.content,\n            rows: i\n          }\n        });\n      } else {\n        if (!oo(\n          this.state.block,\n          t.originalIndex,\n          n\n        ))\n          return !1;\n        const i = Kn(\n          this.state.block,\n          t.originalIndex,\n          n\n        ), [a] = s.splice(t.originalIndex, 1);\n        s.splice(n, 0, a), this.editor.updateBlock(this.state.block, {\n          type: \"table\",\n          content: {\n            ...this.state.block.content,\n            columnWidths: s,\n            rows: i\n          }\n        });\n      }\n      return this.editor.setTextCursorPosition(this.state.block.id), !0;\n    });\n    this.editor = o, this.pmView = t, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      n(this.state);\n    }, t.dom.addEventListener(\"mousemove\", this.mouseMoveHandler), t.dom.addEventListener(\"mousedown\", this.viewMousedownHandler), window.addEventListener(\"mouseup\", this.mouseUpHandler), t.root.addEventListener(\n      \"dragover\",\n      this.dragOverHandler\n    ), t.root.addEventListener(\n      \"drop\",\n      this.dropHandler\n    );\n  }\n  // Updates drag handles when the table is modified or removed.\n  update() {\n    var r;\n    if (!this.state || !this.state.show)\n      return;\n    if (this.state.block = this.editor.getBlock(this.state.block.id), !this.state.block || // when collaborating, the table element might be replaced and out of date\n    // because yjs replaces the element when for example you change the color via the side menu\n    !((r = this.tableElement) != null && r.isConnected)) {\n      this.state.show = !1, this.state.showAddOrRemoveRowsButton = !1, this.state.showAddOrRemoveColumnsButton = !1, this.emitUpdate();\n      return;\n    }\n    const { height: o, width: t } = ct(\n      this.state.block\n    );\n    this.state.rowIndex !== void 0 && this.state.colIndex !== void 0 && (this.state.rowIndex >= o && (this.state.rowIndex = o - 1), this.state.colIndex >= t && (this.state.colIndex = t - 1));\n    const n = this.tableElement.querySelector(\"tbody\");\n    if (!n)\n      throw new Error(\n        \"Table block does not contain a 'tbody' HTML element. This should never happen.\"\n      );\n    if (this.state.rowIndex !== void 0 && this.state.colIndex !== void 0) {\n      const i = n.children[this.state.rowIndex].children[this.state.colIndex];\n      i ? this.state.referencePosCell = i.getBoundingClientRect() : (this.state.rowIndex = void 0, this.state.colIndex = void 0);\n    }\n    this.state.referencePosTable = n.getBoundingClientRect(), this.emitUpdate();\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousemove\", this.mouseMoveHandler), window.removeEventListener(\"mouseup\", this.mouseUpHandler), this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler), this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.dragOverHandler\n    ), this.pmView.root.removeEventListener(\n      \"drop\",\n      this.dropHandler\n    );\n  }\n}\nconst fe = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(\"TableHandlesPlugin\");\nclass da extends q {\n  constructor(t) {\n    super();\n    u(this, \"view\");\n    u(this, \"plugin\");\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the column drag handle.\n     */\n    u(this, \"colDragStart\", (t) => {\n      if (this.view.state === void 0 || this.view.state.colIndex === void 0)\n        throw new Error(\n          \"Attempted to drag table column, but no table block was hovered prior.\"\n        );\n      if (this.view.state.draggingState = {\n        draggedCellOrientation: \"col\",\n        originalIndex: this.view.state.colIndex,\n        mousePos: t.clientX\n      }, this.view.emitUpdate(), this.editor.dispatch(\n        this.editor._tiptapEditor.state.tr.setMeta(fe, {\n          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,\n          originalIndex: this.view.state.colIndex,\n          newIndex: this.view.state.colIndex,\n          tablePos: this.view.tablePos\n        })\n      ), !this.editor.prosemirrorView)\n        throw new Error(\"Editor view not initialized.\");\n      Ut(this.editor.prosemirrorView.root), t.dataTransfer.setDragImage(A, 0, 0), t.dataTransfer.effectAllowed = \"move\";\n    });\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the row drag handle.\n     */\n    u(this, \"rowDragStart\", (t) => {\n      if (this.view.state === void 0 || this.view.state.rowIndex === void 0)\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\"\n        );\n      if (this.view.state.draggingState = {\n        draggedCellOrientation: \"row\",\n        originalIndex: this.view.state.rowIndex,\n        mousePos: t.clientY\n      }, this.view.emitUpdate(), this.editor.dispatch(\n        this.editor._tiptapEditor.state.tr.setMeta(fe, {\n          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,\n          originalIndex: this.view.state.rowIndex,\n          newIndex: this.view.state.rowIndex,\n          tablePos: this.view.tablePos\n        })\n      ), !this.editor.prosemirrorView)\n        throw new Error(\"Editor view not initialized.\");\n      Ut(this.editor.prosemirrorView.root), t.dataTransfer.setDragImage(A, 0, 0), t.dataTransfer.effectAllowed = \"copyMove\";\n    });\n    /**\n     * Callback that should be set on the `dragEnd` event for both the element\n     * used as the row drag handle, and the one used as the column drag handle.\n     */\n    u(this, \"dragEnd\", () => {\n      if (this.view.state === void 0)\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\"\n        );\n      if (this.view.state.draggingState = void 0, this.view.emitUpdate(), this.editor.dispatch(\n        this.editor._tiptapEditor.state.tr.setMeta(fe, null)\n      ), !this.editor.prosemirrorView)\n        throw new Error(\"Editor view not initialized.\");\n      ia(this.editor.prosemirrorView.root);\n    });\n    /**\n     * Freezes the drag handles. When frozen, they will stay attached to the same\n     * cell regardless of which cell is hovered by the mouse cursor.\n     */\n    u(this, \"freezeHandles\", () => {\n      this.view.menuFrozen = !0;\n    });\n    /**\n     * Unfreezes the drag handles. When frozen, they will stay attached to the\n     * same cell regardless of which cell is hovered by the mouse cursor.\n     */\n    u(this, \"unfreezeHandles\", () => {\n      this.view.menuFrozen = !1;\n    });\n    u(this, \"getCellsAtRowHandle\", (t, n) => Qe(t, n));\n    /**\n     * Get all the cells in a column of the table block.\n     */\n    u(this, \"getCellsAtColumnHandle\", (t, n) => et(t, n));\n    /**\n     * Sets the selection to the given cell or a range of cells.\n     * @returns The new state after the selection has been set.\n     */\n    u(this, \"setCellSelection\", (t, n = t) => {\n      const r = this.view;\n      if (!r)\n        throw new Error(\"Table handles view not initialized\");\n      const s = this.editor.prosemirrorState, i = s.doc.resolve(r.tablePos + 1), a = s.doc.resolve(\n        i.posAtIndex(t.row) + 1\n      ), c = s.doc.resolve(\n        // No need for +1, since CellSelection expects the position before the cell\n        a.posAtIndex(t.col)\n      ), l = s.doc.resolve(\n        i.posAtIndex(n.row) + 1\n      ), d = s.doc.resolve(\n        // No need for +1, since CellSelection expects the position before the cell\n        l.posAtIndex(n.col)\n      ), p = s.tr;\n      return p.setSelection(\n        new prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.CellSelection(c, d)\n      ), s.apply(p);\n    });\n    /**\n     * Adds a row or column to the table using prosemirror-table commands\n     */\n    u(this, \"addRowOrColumn\", (t, n) => {\n      const r = this.setCellSelection(\n        n.orientation === \"row\" ? { row: t, col: 0 } : { row: 0, col: t }\n      );\n      return n.orientation === \"row\" ? n.side === \"above\" ? (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.addRowBefore)(r, this.editor.dispatch) : (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.addRowAfter)(r, this.editor.dispatch) : n.side === \"left\" ? (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.addColumnBefore)(r, this.editor.dispatch) : (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.addColumnAfter)(r, this.editor.dispatch);\n    });\n    /**\n     * Removes a row or column from the table using prosemirror-table commands\n     */\n    u(this, \"removeRowOrColumn\", (t, n) => {\n      const r = this.setCellSelection(\n        n === \"row\" ? { row: t, col: 0 } : { row: 0, col: t }\n      );\n      return n === \"row\" ? (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.deleteRow)(r, this.editor.dispatch) : (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.deleteColumn)(r, this.editor.dispatch);\n    });\n    /**\n     * Merges the cells in the table block.\n     */\n    u(this, \"mergeCells\", (t) => {\n      const n = t ? this.setCellSelection(\n        t.relativeStartCell,\n        t.relativeEndCell\n      ) : this.editor.prosemirrorState;\n      return (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.mergeCells)(n, this.editor.dispatch);\n    });\n    /**\n     * Splits the cell in the table block.\n     * If no cell is provided, the current cell selected will be split.\n     */\n    u(this, \"splitCell\", (t) => {\n      const n = t ? this.setCellSelection(t) : this.editor.prosemirrorState;\n      return (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_0__.splitCell)(n, this.editor.dispatch);\n    });\n    /**\n     * Gets the start and end cells of the current cell selection.\n     * @returns The start and end cells of the current cell selection.\n     */\n    u(this, \"getCellSelection\", () => {\n      const t = this.editor.prosemirrorState, n = t.selection;\n      let r = n.$from, s = n.$to;\n      if (It(n)) {\n        const { ranges: m } = n;\n        m.forEach((g) => {\n          r = g.$from.min(r ?? g.$from), s = g.$to.max(s ?? g.$to);\n        });\n      } else if (r = t.doc.resolve(\n        n.$from.pos - n.$from.parentOffset - 1\n      ), s = t.doc.resolve(\n        n.$to.pos - n.$to.parentOffset - 1\n      ), r.pos === 0 || s.pos === 0)\n        return;\n      const i = t.doc.resolve(\n        r.pos - r.parentOffset - 1\n      ), a = t.doc.resolve(s.pos - s.parentOffset - 1), c = t.doc.resolve(i.pos - i.parentOffset - 1), l = r.index(i.depth), d = i.index(c.depth), p = s.index(a.depth), h = a.index(c.depth), f = [];\n      for (let m = d; m <= h; m++)\n        for (let g = l; g <= p; g++)\n          f.push({ row: m, col: g });\n      return {\n        from: {\n          row: d,\n          col: l\n        },\n        to: {\n          row: h,\n          col: p\n        },\n        cells: f\n      };\n    });\n    /**\n     * Gets the direction of the merge based on the current cell selection.\n     *\n     * Returns undefined when there is no cell selection, or the selection is not within a table.\n     */\n    u(this, \"getMergeDirection\", (t) => {\n      const n = It(\n        this.editor.prosemirrorState.selection\n      ) ? this.editor.prosemirrorState.selection : void 0;\n      if (!n || !t || // Only offer the merge button if there is more than one cell selected.\n      n.ranges.length <= 1)\n        return;\n      const r = this.getCellSelection();\n      if (r)\n        return Zn(r.from, r.to, t) ? \"vertical\" : \"horizontal\";\n    });\n    u(this, \"cropEmptyRowsOrColumns\", (t, n) => Jn(t, n));\n    u(this, \"addRowsOrColumns\", (t, n, r) => Yn(t, n, r));\n    this.editor = t, this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n      key: fe,\n      view: (n) => (this.view = new la(t, n, (r) => {\n        this.emit(\"update\", r);\n      }), this.view),\n      // We use decorations to render the drop cursor when dragging a table row\n      // or column. The decorations are updated in the `dragOverHandler` method.\n      props: {\n        decorations: (n) => {\n          if (this.view === void 0 || this.view.state === void 0 || this.view.state.draggingState === void 0 || this.view.tablePos === void 0)\n            return;\n          const r = this.view.state.draggingState.draggedCellOrientation === \"row\" ? this.view.state.rowIndex : this.view.state.colIndex;\n          if (r === void 0)\n            return;\n          const s = [], { block: i, draggingState: a } = this.view.state, { originalIndex: c, draggedCellOrientation: l } = a;\n          if (r === c || !i || l === \"row\" && !to(i, c, r) || l === \"col\" && !oo(i, c, r))\n            return prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(n.doc, s);\n          const d = n.doc.resolve(this.view.tablePos + 1);\n          return this.view.state.draggingState.draggedCellOrientation === \"row\" ? Qe(\n            this.view.state.block,\n            r\n          ).forEach(({ row: h, col: f }) => {\n            const m = n.doc.resolve(\n              d.posAtIndex(h) + 1\n            ), g = n.doc.resolve(\n              m.posAtIndex(f) + 1\n            ), b = g.node(), k = g.pos + (r > c ? b.nodeSize - 2 : 0);\n            s.push(\n              // The widget is a small bar which spans the width of the cell.\n              prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.widget(k, () => {\n                const w = document.createElement(\"div\");\n                return w.className = \"bn-table-drop-cursor\", w.style.left = \"0\", w.style.right = \"0\", r > c ? w.style.bottom = \"-2px\" : w.style.top = \"-3px\", w.style.height = \"4px\", w;\n              })\n            );\n          }) : et(\n            this.view.state.block,\n            r\n          ).forEach(({ row: h, col: f }) => {\n            const m = n.doc.resolve(\n              d.posAtIndex(h) + 1\n            ), g = n.doc.resolve(\n              m.posAtIndex(f) + 1\n            ), b = g.node(), k = g.pos + (r > c ? b.nodeSize - 2 : 0);\n            s.push(\n              // The widget is a small bar which spans the height of the cell.\n              prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.Decoration.widget(k, () => {\n                const w = document.createElement(\"div\");\n                return w.className = \"bn-table-drop-cursor\", w.style.top = \"0\", w.style.bottom = \"0\", r > c ? w.style.right = \"-2px\" : w.style.left = \"-3px\", w.style.width = \"4px\", w;\n              })\n            );\n          }), prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.DecorationSet.create(n.doc, s);\n        }\n      }\n    });\n  }\n  onUpdate(t) {\n    return this.on(\"update\", t);\n  }\n}\nconst pa = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"textAlignment\",\n  addGlobalAttributes() {\n    return [\n      {\n        // Attribute is applied to block content instead of container so that child blocks don't inherit the text\n        // alignment styling.\n        types: [\n          \"paragraph\",\n          \"heading\",\n          \"bulletListItem\",\n          \"numberedListItem\",\n          \"checkListItem\",\n          \"tableCell\",\n          \"tableHeader\"\n        ],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (e) => e.getAttribute(\"data-text-alignment\"),\n            renderHTML: (e) => e.textAlignment === \"left\" ? {} : {\n              \"data-text-alignment\": e.textAlignment\n            }\n          }\n        }\n      }\n    ];\n  }\n}), ua = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"blockTextColor\",\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\", \"tableCell\", \"tableHeader\"],\n        attributes: {\n          textColor: {\n            default: S.textColor.default,\n            parseHTML: (e) => e.hasAttribute(\"data-text-color\") ? e.getAttribute(\"data-text-color\") : S.textColor.default,\n            renderHTML: (e) => e.textColor === S.textColor.default ? {} : {\n              \"data-text-color\": e.textColor\n            }\n          }\n        }\n      }\n    ];\n  }\n}), ha = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n  name: \"trailingNode\",\n  addProseMirrorPlugins() {\n    const e = new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.PluginKey(this.name);\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.Plugin({\n        key: e,\n        appendTransaction: (o, t, n) => {\n          const { doc: r, tr: s, schema: i } = n, a = e.getState(n), c = r.content.size - 2, l = i.nodes.blockContainer, d = i.nodes.paragraph;\n          if (a)\n            return s.insert(\n              c,\n              l.create(void 0, d.create())\n            );\n        },\n        state: {\n          init: (o, t) => {\n          },\n          apply: (o, t) => {\n            if (!o.docChanged)\n              return t;\n            let n = o.doc.lastChild;\n            if (!n || n.type.name !== \"blockGroup\")\n              throw new Error(\"Expected blockGroup\");\n            if (n = n.lastChild, !n || n.type.name !== \"blockContainer\")\n              return !0;\n            const r = n.firstChild;\n            if (!r)\n              throw new Error(\"Expected blockContent\");\n            return n.nodeSize > 4 || r.type.spec.content !== \"inline*\";\n          }\n        }\n      })\n    ];\n  }\n}), fa = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\"\n}, ma = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Node.create({\n  name: \"blockContainer\",\n  group: \"blockGroupChild bnBlock\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: !0,\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (e) => {\n          if (typeof e == \"string\")\n            return !1;\n          const o = {};\n          for (const [t, n] of Object.entries(fa))\n            e.getAttribute(n) && (o[t] = e.getAttribute(n));\n          return e.getAttribute(\"data-node-type\") === \"blockContainer\" ? o : !1;\n        }\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var r;\n    const o = document.createElement(\"div\");\n    o.className = \"bn-block-outer\", o.setAttribute(\"data-node-type\", \"blockOuter\");\n    for (const [s, i] of Object.entries(e))\n      s !== \"class\" && o.setAttribute(s, i);\n    const t = {\n      ...((r = this.options.domAttributes) == null ? void 0 : r.block) || {},\n      ...e\n    }, n = document.createElement(\"div\");\n    n.className = Y(\"bn-block\", t.class), n.setAttribute(\"data-node-type\", this.name);\n    for (const [s, i] of Object.entries(t))\n      s !== \"class\" && n.setAttribute(s, i);\n    return o.appendChild(n), {\n      dom: o,\n      contentDOM: n\n    };\n  }\n}), ga = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Node.create({\n  name: \"blockGroup\",\n  group: \"childContainer\",\n  content: \"blockGroupChild+\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (e) => typeof e == \"string\" ? !1 : e.getAttribute(\"data-node-type\") === \"blockGroup\" ? null : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: e }) {\n    var n;\n    const o = {\n      ...((n = this.options.domAttributes) == null ? void 0 : n.blockGroup) || {},\n      ...e\n    }, t = document.createElement(\"div\");\n    t.className = Y(\n      \"bn-block-group\",\n      o.class\n    ), t.setAttribute(\"data-node-type\", \"blockGroup\");\n    for (const [r, s] of Object.entries(o))\n      r !== \"class\" && t.setAttribute(r, s);\n    return {\n      dom: t,\n      contentDOM: t\n    };\n  }\n}), ba = _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Node.create({\n  name: \"doc\",\n  topNode: !0,\n  content: \"blockGroup\"\n}), ka = (e) => {\n  const o = {}, t = wa(e);\n  for (const r of t)\n    o[r.name] = r;\n  o.formattingToolbar = new Ai(\n    e.editor\n  ), o.linkToolbar = new Vi(e.editor), o.sideMenu = new ea(\n    e.editor,\n    e.sideMenuDetection\n  ), o.suggestionMenus = new sa(e.editor), o.filePanel = new Pi(e.editor), o.placeholder = new ji(e.editor, e.placeholders), (e.animations ?? !0) && (o.animations = new qi()), e.tableHandles && (o.tableHandles = new da(e.editor)), o.dropCursor = {\n    plugin: e.dropCursor({\n      width: 5,\n      color: \"#ddeeff\",\n      editor: e.editor\n    })\n  }, o.nodeSelectionKeyboard = new zi(), o.showSelection = new Ki(e.editor), e.comments && (o.comments = new xi(\n    e.editor,\n    e.comments.threadStore,\n    No.name\n  ));\n  const n = e.disableExtensions || [];\n  for (const r of n)\n    delete o[r];\n  return o;\n};\nlet $t = !1;\nconst wa = (e) => {\n  const o = [\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.extensions.ClipboardTextSerializer,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.extensions.Commands,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.extensions.Editable,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.extensions.FocusEvents,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.extensions.Tabindex,\n    // DevTools,\n    _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_9__.Gapcursor,\n    // DropCursor,\n    ve.configure({\n      // everything from bnBlock group (nodes that represent a BlockNote block should have an id)\n      types: [\"blockContainer\", \"columnList\", \"column\"],\n      setIdAttribute: e.setIdAttribute\n    }),\n    Ni,\n    // Comments,\n    // basics:\n    _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_12__.Text,\n    // marks:\n    _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_11__.Link.extend({\n      inclusive: !1\n    }).configure({\n      defaultProtocol: $i,\n      // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450\n      protocols: $t ? [] : Ui\n    }),\n    ...Object.values(e.styleSpecs).map((t) => t.implementation.mark.configure({\n      editor: e.editor\n    })),\n    ua,\n    vi,\n    pa,\n    // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n      name: \"OverrideEscape\",\n      addKeyboardShortcuts() {\n        return {\n          Escape: () => e.editor.suggestionMenus.shown ? !1 : this.editor.commands.blur()\n        };\n      }\n    }),\n    // nodes\n    ba,\n    ma.configure({\n      editor: e.editor,\n      domAttributes: e.domAttributes\n    }),\n    Oi.configure({\n      editor: e.editor,\n      tabBehavior: e.tabBehavior\n    }),\n    ga.configure({\n      domAttributes: e.domAttributes\n    }),\n    ...Object.values(e.inlineContentSpecs).filter((t) => t.config !== \"link\" && t.config !== \"text\").map((t) => t.implementation.node.configure({\n      editor: e.editor\n    })),\n    ...Object.values(e.blockSpecs).flatMap((t) => [\n      // dependent nodes (e.g.: tablecell / row)\n      ...(t.implementation.requiredExtensions || []).map(\n        (n) => n.configure({\n          editor: e.editor,\n          domAttributes: e.domAttributes\n        })\n      ),\n      // the actual node itself\n      t.implementation.node.configure({\n        editor: e.editor,\n        domAttributes: e.domAttributes\n      })\n    ]),\n    Ci(e.editor),\n    wi(\n      e.editor,\n      e.pasteHandler || ((t) => t.defaultPasteHandler())\n    ),\n    oi(e.editor),\n    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),\n    // should be handled before Enter handlers in other components like splitListItem\n    ...e.trailingBlock === void 0 || e.trailingBlock ? [ha] : [],\n    ...e.comments ? [No] : []\n  ];\n  return $t = !0, e.collaboration ? o.push(...Ei(e.collaboration)) : o.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History), o;\n};\nfunction ya(e, o) {\n  const t = [];\n  return e.forEach((n, r, s) => {\n    s !== o && t.push(n);\n  }), prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(t);\n}\nfunction Ca(e, o) {\n  const t = [];\n  for (let n = 0; n < e.childCount; n++)\n    if (e.child(n).type.name === \"tableRow\")\n      if (t.length > 0 && t[t.length - 1].type.name === \"table\") {\n        const r = t[t.length - 1], s = r.copy(r.content.addToEnd(e.child(n)));\n        t[t.length - 1] = s;\n      } else {\n        const r = o.nodes.table.createChecked(\n          void 0,\n          e.child(n)\n        );\n        t.push(r);\n      }\n    else\n      t.push(e.child(n));\n  return e = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(t), e;\n}\nfunction va(e, o) {\n  let t = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Fragment.from(e.content);\n  if (t = Ca(t, o.state.schema), !Ea(t, o))\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Slice(t, e.openStart, e.openEnd);\n  for (let n = 0; n < t.childCount; n++)\n    if (t.child(n).type.spec.group === \"blockContent\") {\n      const r = [t.child(n)];\n      if (n + 1 < t.childCount && t.child(n + 1).type.name === \"blockGroup\") {\n        const i = t.child(n + 1).child(0).child(0);\n        (i.type.name === \"bulletListItem\" || i.type.name === \"numberedListItem\" || i.type.name === \"checkListItem\") && (r.push(t.child(n + 1)), t = ya(t, n + 1));\n      }\n      const s = o.state.schema.nodes.blockContainer.createChecked(\n        void 0,\n        r\n      );\n      t = t.replaceChild(n, s);\n    }\n  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Slice(t, e.openStart, e.openEnd);\n}\nfunction Ea(e, o) {\n  var s, i;\n  const t = e.childCount === 1, n = ((s = e.firstChild) == null ? void 0 : s.type.spec.content) === \"inline*\", r = ((i = e.firstChild) == null ? void 0 : i.type.spec.content) === \"tableRow+\";\n  if (t) {\n    if (n)\n      return !1;\n    if (r) {\n      const a = C(o.state);\n      if (a.isBlockContainer)\n        return !(a.blockContent.node.type.spec.content === \"tableRow+\");\n    }\n  }\n  return !0;\n}\nconst Oe = class Oe extends _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Editor {\n  constructor(t, n) {\n    super({ ...t, content: void 0 });\n    u(this, \"_state\");\n    /**\n     * Mounts / unmounts the editor to a dom element\n     *\n     * @param element DOM element to mount to, ur null / undefined to destroy\n     */\n    u(this, \"mount\", (t, n, r) => {\n      n ? (this.options.element = n, this.createViewAlternative(t, r)) : this.destroy();\n    });\n    const r = this.schema;\n    let s;\n    const i = r.nodes.doc.createAndFill;\n    r.nodes.doc.createAndFill = (...c) => {\n      if (s)\n        return s;\n      const l = i.apply(r.nodes.doc, c), d = JSON.parse(JSON.stringify(l.toJSON()));\n      return d.content[0].content[0].attrs.id = \"initialBlockId\", s = prosemirror_model__WEBPACK_IMPORTED_MODULE_18__.Node.fromJSON(r, d), s;\n    };\n    let a;\n    try {\n      const c = t == null ? void 0 : t.content.map(\n        (l) => ie(l, this.schema, n).toJSON()\n      );\n      a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.createDocument)(\n        {\n          type: \"doc\",\n          content: [\n            {\n              type: \"blockGroup\",\n              content: c\n            }\n          ]\n        },\n        this.schema,\n        this.options.parseOptions\n      );\n    } catch (c) {\n      throw console.error(\n        \"Error creating document from blocks passed as `initialContent`. Caused by exception: \",\n        c\n      ), new Error(\n        \"Error creating document from blocks passed as `initialContent`:\\n\" + +JSON.stringify(t.content)\n      );\n    }\n    this._state = prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.EditorState.create({\n      doc: a,\n      schema: this.schema\n      // selection: selection || undefined,\n    });\n  }\n  get state() {\n    return this.view && (this._state = this.view.state), this._state;\n  }\n  dispatch(t) {\n    this.view ? this.view.dispatch(t) : this._state = this.state.apply(t);\n  }\n  /**\n   * Replace the default `createView` method with a custom one - which we call on mount\n   */\n  createViewAlternative(t, n) {\n    this.contentComponent = n;\n    const r = {};\n    this.extensionManager.extensions.forEach((i) => {\n      i.type === \"mark\" && i.config.addMarkView && (r[i.name] = i.config.addMarkView(t));\n    }), this.view = new prosemirror_view__WEBPACK_IMPORTED_MODULE_22__.EditorView(\n      { mount: this.options.element },\n      // use mount option so that we reuse the existing element instead of creating a new one\n      {\n        ...this.options.editorProps,\n        // @ts-ignore\n        dispatchTransaction: this.dispatchTransaction.bind(this),\n        state: this.state,\n        markViews: r,\n        nodeViews: this.extensionManager.nodeViews\n      }\n    );\n    const s = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(s), this.commands.focus(\n      this.options.autofocus || this.options.element.getAttribute(\"data-bn-autofocus\") === \"true\",\n      { scrollIntoView: !1 }\n    ), this.emit(\"create\", { editor: this }), this.isInitialized = !0;\n  }\n};\nu(Oe, \"create\", (t, n) => {\n  var s, i;\n  const r = (s = globalThis == null ? void 0 : globalThis.window) == null ? void 0 : s.setTimeout;\n  typeof ((i = globalThis == null ? void 0 : globalThis.window) == null ? void 0 : i.setTimeout) < \"u\" && (globalThis.window.setTimeout = () => 0);\n  try {\n    return new Oe(t, n);\n  } finally {\n    r && (globalThis.window.setTimeout = r);\n  }\n});\nlet De = Oe;\nDe.prototype.createView = function() {\n  this.options.onPaste = this.options.onDrop = void 0;\n};\nconst Sa = {\n  enableInputRules: !0,\n  enablePasteRules: !0,\n  enableCoreExtensions: !1\n};\nclass _o extends q {\n  constructor(t) {\n    var l, d, p, h, f, m, g, b, k, w, y, T, F, j, B;\n    super();\n    /**\n     * The underlying prosemirror schema\n     */\n    u(this, \"pmSchema\");\n    /**\n     * extensions that are added to the editor, can be tiptap extensions or prosemirror plugins\n     */\n    u(this, \"extensions\", {});\n    /**\n     * Boolean indicating whether the editor is in headless mode.\n     * Headless mode means we can use features like importing / exporting blocks,\n     * but there's no underlying editor (UI) instantiated.\n     *\n     * You probably don't need to set this manually, but use the `server-util` package instead that uses this option internally\n     */\n    u(this, \"headless\", !1);\n    u(this, \"_tiptapEditor\");\n    // TODO: Type should actually reflect that it can be `undefined` in headless mode\n    /**\n     * Used by React to store a reference to an `ElementRenderer` helper utility to make sure we can render React elements\n     * in the correct context (used by `ReactRenderUtil`)\n     */\n    u(this, \"elementRenderer\", null);\n    /**\n     * Cache of all blocks. This makes sure we don't have to \"recompute\" blocks if underlying Prosemirror Nodes haven't changed.\n     * This is especially useful when we want to keep track of the same block across multiple operations,\n     * with this cache, blocks stay the same object reference (referential equality with ===).\n     */\n    u(this, \"blockCache\", /* @__PURE__ */ new WeakMap());\n    /**\n     * The dictionary contains translations for the editor.\n     */\n    u(this, \"dictionary\");\n    /**\n     * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.\n     */\n    u(this, \"schema\");\n    u(this, \"blockImplementations\");\n    u(this, \"inlineContentImplementations\");\n    u(this, \"styleImplementations\");\n    u(this, \"formattingToolbar\");\n    u(this, \"linkToolbar\");\n    u(this, \"sideMenu\");\n    u(this, \"suggestionMenus\");\n    u(this, \"filePanel\");\n    u(this, \"tableHandles\");\n    u(this, \"comments\");\n    u(this, \"showSelectionPlugin\");\n    /**\n     * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).\n     * This method should set when creating the editor as this is application-specific.\n     *\n     * `undefined` means the application doesn't support file uploads.\n     *\n     * @param file The file that should be uploaded.\n     * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)\n     */\n    u(this, \"uploadFile\");\n    u(this, \"onUploadStartCallbacks\", []);\n    u(this, \"onUploadEndCallbacks\", []);\n    u(this, \"resolveFileUrl\");\n    u(this, \"resolveUsers\");\n    /**\n     * Editor settings\n     */\n    u(this, \"settings\");\n    u(this, \"dispatch\", (t) => {\n      this._tiptapEditor.dispatch(t);\n    });\n    /**\n     * Mount the editor to a parent DOM element. Call mount(undefined) to clean up\n     *\n     * @warning Not needed to call manually when using React, use BlockNoteView to take care of mounting\n     */\n    u(this, \"mount\", (t, n) => {\n      this._tiptapEditor.mount(this, t, n);\n    });\n    this.options = t;\n    const n = t;\n    if (n.onEditorContentChange)\n      throw new Error(\n        \"onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)\"\n      );\n    if (n.onTextCursorPositionChange)\n      throw new Error(\n        \"onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)\"\n      );\n    if (n.onEditorReady)\n      throw new Error(\n        \"onEditorReady is deprecated. Editor is immediately ready for use after creation.\"\n      );\n    if (n.editable)\n      throw new Error(\n        \"editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false\"\n      );\n    this.dictionary = t.dictionary || _en_B7ycW7c8_js__WEBPACK_IMPORTED_MODULE_26__.e, this.settings = {\n      tables: {\n        splitCells: ((l = t == null ? void 0 : t.tables) == null ? void 0 : l.splitCells) ?? !1,\n        cellBackgroundColor: ((d = t == null ? void 0 : t.tables) == null ? void 0 : d.cellBackgroundColor) ?? !1,\n        cellTextColor: ((p = t == null ? void 0 : t.tables) == null ? void 0 : p.cellTextColor) ?? !1,\n        headers: ((h = t == null ? void 0 : t.tables) == null ? void 0 : h.headers) ?? !1\n      },\n      codeBlock: {\n        indentLineWithTab: ((f = t == null ? void 0 : t.codeBlock) == null ? void 0 : f.indentLineWithTab) ?? !0,\n        defaultLanguage: ((m = t == null ? void 0 : t.codeBlock) == null ? void 0 : m.defaultLanguage) ?? \"text\",\n        supportedLanguages: ((g = t == null ? void 0 : t.codeBlock) == null ? void 0 : g.supportedLanguages) ?? {},\n        createHighlighter: ((b = t == null ? void 0 : t.codeBlock) == null ? void 0 : b.createHighlighter) ?? void 0\n      }\n    };\n    const r = {\n      defaultStyles: !0,\n      schema: t.schema || Be.create(),\n      _headless: !1,\n      ...t,\n      placeholders: {\n        ...this.dictionary.placeholders,\n        ...t.placeholders\n      }\n    };\n    if (r.comments && !r.resolveUsers)\n      throw new Error(\"resolveUsers is required when using comments\");\n    if (this.resolveUsers = r.resolveUsers, this.schema = r.schema, this.blockImplementations = r.schema.blockSpecs, this.inlineContentImplementations = r.schema.inlineContentSpecs, this.styleImplementations = r.schema.styleSpecs, this.extensions = ka({\n      editor: this,\n      domAttributes: r.domAttributes || {},\n      blockSpecs: this.schema.blockSpecs,\n      styleSpecs: this.schema.styleSpecs,\n      inlineContentSpecs: this.schema.inlineContentSpecs,\n      collaboration: r.collaboration,\n      trailingBlock: r.trailingBlock,\n      disableExtensions: r.disableExtensions,\n      setIdAttribute: r.setIdAttribute,\n      animations: r.animations ?? !0,\n      tableHandles: L(\"table\", this),\n      dropCursor: this.options.dropCursor ?? prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_27__.dropCursor,\n      placeholders: r.placeholders,\n      tabBehavior: r.tabBehavior,\n      sideMenuDetection: r.sideMenuDetection || \"viewport\",\n      comments: r.comments,\n      pasteHandler: r.pasteHandler\n    }), (((k = r._tiptapOptions) == null ? void 0 : k.extensions) || []).forEach((v) => {\n      this.extensions[v.name] = v;\n    }), Object.entries(r._extensions || {}).forEach(([v, I]) => {\n      typeof I == \"function\" && (I = I(this)), this.extensions[v] = I;\n    }), this.formattingToolbar = this.extensions.formattingToolbar, this.linkToolbar = this.extensions.linkToolbar, this.sideMenu = this.extensions.sideMenu, this.suggestionMenus = this.extensions.suggestionMenus, this.filePanel = this.extensions.filePanel, this.tableHandles = this.extensions.tableHandles, this.comments = this.extensions.comments, this.showSelectionPlugin = this.extensions.showSelection, r.uploadFile) {\n      const v = r.uploadFile;\n      this.uploadFile = async (I, ae) => {\n        this.onUploadStartCallbacks.forEach(\n          (Fe) => Fe.apply(this, [ae])\n        );\n        try {\n          return await v(I, ae);\n        } finally {\n          this.onUploadEndCallbacks.forEach(\n            (Fe) => Fe.apply(this, [ae])\n          );\n        }\n      };\n    }\n    this.resolveFileUrl = r.resolveFileUrl, this.headless = r._headless;\n    const s = \"collaboration\" in this.extensions || \"liveblocksExtension\" in this.extensions;\n    s && r.initialContent && console.warn(\n      \"When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider\"\n    );\n    const i = r.initialContent || (s ? [\n      {\n        type: \"paragraph\",\n        id: \"initialBlockId\"\n      }\n    ] : [\n      {\n        type: \"paragraph\",\n        id: ve.options.generateID()\n      }\n    ]);\n    if (!Array.isArray(i) || i.length === 0)\n      throw new Error(\n        \"initialContent must be a non-empty array of blocks, received: \" + i\n      );\n    const a = [\n      ...Object.entries(this.extensions).map(([v, I]) => {\n        if (I instanceof _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension || I instanceof _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Node || I instanceof _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Mark)\n          return I;\n        if (!I.plugin)\n          throw new Error(\n            \"Extension should either be a TipTap extension or a ProseMirror plugin in a plugin property\"\n          );\n        return _tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({\n          name: v,\n          addProseMirrorPlugins: () => [I.plugin]\n        });\n      })\n    ], c = {\n      ...Sa,\n      ...r._tiptapOptions,\n      content: i,\n      extensions: a,\n      editorProps: {\n        ...(w = r._tiptapOptions) == null ? void 0 : w.editorProps,\n        attributes: {\n          // As of TipTap v2.5.0 the tabIndex is removed when the editor is not\n          // editable, so you can't focus it. We want to revert this as we have\n          // UI behaviour that relies on it.\n          tabIndex: \"0\",\n          ...(T = (y = r._tiptapOptions) == null ? void 0 : y.editorProps) == null ? void 0 : T.attributes,\n          ...(F = r.domAttributes) == null ? void 0 : F.editor,\n          class: Y(\n            \"bn-editor\",\n            r.defaultStyles ? \"bn-default-styles\" : \"\",\n            ((B = (j = r.domAttributes) == null ? void 0 : j.editor) == null ? void 0 : B.class) || \"\"\n          )\n        },\n        transformPasted: va\n      }\n    };\n    this.headless ? this.pmSchema = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.getSchema)(c.extensions) : (this._tiptapEditor = De.create(\n      c,\n      this.schema.styleSchema\n    ), this.pmSchema = this._tiptapEditor.schema), this.emit(\"create\");\n  }\n  static create(t = {}) {\n    return new _o(t);\n  }\n  /**\n   * Get the underlying prosemirror view\n   */\n  get prosemirrorView() {\n    return this._tiptapEditor.view;\n  }\n  /**\n   * Get the underlying prosemirror state\n   */\n  get prosemirrorState() {\n    return this._tiptapEditor.state;\n  }\n  get domElement() {\n    var t;\n    return (t = this.prosemirrorView) == null ? void 0 : t.dom;\n  }\n  isFocused() {\n    var t;\n    return ((t = this.prosemirrorView) == null ? void 0 : t.hasFocus()) || !1;\n  }\n  focus() {\n    var t;\n    (t = this.prosemirrorView) == null || t.focus();\n  }\n  onUploadStart(t) {\n    return this.onUploadStartCallbacks.push(t), () => {\n      const n = this.onUploadStartCallbacks.indexOf(t);\n      n > -1 && this.onUploadStartCallbacks.splice(n, 1);\n    };\n  }\n  onUploadEnd(t) {\n    return this.onUploadEndCallbacks.push(t), () => {\n      const n = this.onUploadEndCallbacks.indexOf(t);\n      n > -1 && this.onUploadEndCallbacks.splice(n, 1);\n    };\n  }\n  /**\n   * @deprecated, use `editor.document` instead\n   */\n  get topLevelBlocks() {\n    return this.document;\n  }\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  get document() {\n    const t = [];\n    return this.prosemirrorState.doc.firstChild.descendants((n) => (t.push(\n      E(\n        n,\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      )\n    ), !1)), t;\n  }\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be\n   * retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no\n   * matching block was found.\n   */\n  getBlock(t) {\n    return Os(this, t);\n  }\n  /**\n   * Gets a snapshot of the previous sibling of an existing block from the\n   * editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * previous sibling should be retrieved.\n   * @returns The previous sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the first child/block\n   * in the document.\n   */\n  getPrevBlock(t) {\n    return _s(this, t);\n  }\n  /**\n   * Gets a snapshot of the next sibling of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * next sibling should be retrieved.\n   * @returns The next sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the last child/block in\n   * the document.\n   */\n  getNextBlock(t) {\n    return Rs(this, t);\n  }\n  /**\n   * Gets a snapshot of the parent of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * parent should be retrieved.\n   * @returns The parent of the block that matches the identifier. `undefined`\n   * if no matching block was found, or the block isn't nested.\n   */\n  getParentBlock(t) {\n    return Vs(this, t);\n  }\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  forEachBlock(t, n = !1) {\n    const r = this.document.slice();\n    n && r.reverse();\n    function s(i) {\n      for (const a of i) {\n        if (t(a) === !1)\n          return !1;\n        const c = n ? a.children.slice().reverse() : a.children;\n        if (!s(c))\n          return !1;\n      }\n      return !0;\n    }\n    s(r);\n  }\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use `onChange` instead\n   */\n  onEditorContentChange(t) {\n    this._tiptapEditor.on(\"update\", t);\n  }\n  /**\n   * Executes a callback whenever the editor's selection changes.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use `onSelectionChange` instead\n   */\n  onEditorSelectionChange(t) {\n    this._tiptapEditor.on(\"selectionUpdate\", t);\n  }\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  getTextCursorPosition() {\n    return zs(this);\n  }\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  setTextCursorPosition(t, n = \"start\") {\n    To(this, t, n);\n  }\n  /**\n   * Gets a snapshot of the current selection.\n   */\n  getSelection() {\n    return $s(this);\n  }\n  setSelection(t, n) {\n    Fs(this, t, n);\n  }\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  get isEditable() {\n    if (!this._tiptapEditor) {\n      if (!this.headless)\n        throw new Error(\"no editor, but also not headless?\");\n      return !1;\n    }\n    return this._tiptapEditor.isEditable === void 0 ? !0 : this._tiptapEditor.isEditable;\n  }\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  set isEditable(t) {\n    if (!this._tiptapEditor) {\n      if (!this.headless)\n        throw new Error(\"no editor, but also not headless?\");\n      return;\n    }\n    this._tiptapEditor.options.editable !== t && this._tiptapEditor.setEditable(t);\n  }\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`.\n   */\n  insertBlocks(t, n, r = \"before\") {\n    return Bs(this, t, n, r);\n  }\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  updateBlock(t, n) {\n    return tr(this, t, n);\n  }\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  removeBlocks(t) {\n    return Ds(this, t);\n  }\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  replaceBlocks(t, n) {\n    return Hs(this, t, n);\n  }\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  insertInlineContent(t) {\n    const n = O(\n      t,\n      this.pmSchema,\n      this.schema.styleSchema\n    );\n    Us(\n      {\n        from: this._tiptapEditor.state.selection.from,\n        to: this._tiptapEditor.state.selection.to\n      },\n      n,\n      this\n    );\n  }\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  getActiveStyles() {\n    const t = {}, n = this._tiptapEditor.state.selection.$to.marks();\n    for (const r of n) {\n      const s = this.schema.styleSchema[r.type.name];\n      if (!s) {\n        // Links are not considered styles in blocknote\n        r.type.name !== \"link\" && // \"blocknoteIgnore\" tagged marks (such as comments) are also not considered BlockNote \"styles\"\n        !r.type.spec.blocknoteIgnore && console.warn(\"mark not found in styleschema\", r.type.name);\n        continue;\n      }\n      s.propSchema === \"boolean\" ? t[s.type] = !0 : t[s.type] = r.attrs.stringValue;\n    }\n    return t;\n  }\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  addStyles(t) {\n    for (const [n, r] of Object.entries(t)) {\n      const s = this.schema.styleSchema[n];\n      if (!s)\n        throw new Error(`style ${n} not found in styleSchema`);\n      if (s.propSchema === \"boolean\")\n        this._tiptapEditor.commands.setMark(n);\n      else if (s.propSchema === \"string\")\n        this._tiptapEditor.commands.setMark(n, { stringValue: r });\n      else\n        throw new $(s.propSchema);\n    }\n  }\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  removeStyles(t) {\n    for (const n of Object.keys(t))\n      this._tiptapEditor.commands.unsetMark(n);\n  }\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  toggleStyles(t) {\n    for (const [n, r] of Object.entries(t)) {\n      const s = this.schema.styleSchema[n];\n      if (!s)\n        throw new Error(`style ${n} not found in styleSchema`);\n      if (s.propSchema === \"boolean\")\n        this._tiptapEditor.commands.toggleMark(n);\n      else if (s.propSchema === \"string\")\n        this._tiptapEditor.commands.toggleMark(n, { stringValue: r });\n      else\n        throw new $(s.propSchema);\n    }\n  }\n  /**\n   * Gets the currently selected text.\n   */\n  getSelectedText() {\n    return this._tiptapEditor.state.doc.textBetween(\n      this._tiptapEditor.state.selection.from,\n      this._tiptapEditor.state.selection.to\n    );\n  }\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  getSelectedLinkUrl() {\n    return this._tiptapEditor.getAttributes(\"link\").href;\n  }\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  createLink(t, n) {\n    if (t === \"\")\n      return;\n    const { from: r, to: s } = this._tiptapEditor.state.selection, i = this.pmSchema.mark(\"link\", { href: t });\n    this.dispatch(\n      n ? this._tiptapEditor.state.tr.insertText(n, r, s).addMark(r, r + n.length, i) : this._tiptapEditor.state.tr.setSelection(\n        prosemirror_state__WEBPACK_IMPORTED_MODULE_17__.TextSelection.create(this._tiptapEditor.state.tr.doc, s)\n      ).addMark(r, s, i)\n    );\n  }\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  canNestBlock() {\n    return As(this);\n  }\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  nestBlock() {\n    So(this);\n  }\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  canUnnestBlock() {\n    return Ns(this);\n  }\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  unnestBlock() {\n    Ls(this);\n  }\n  /**\n   * Moves the selected blocks up. If the previous block has children, moves\n   * them to the end of its children. If there is no previous block, but the\n   * current blocks share a common parent, moves them out of & before it.\n   */\n  moveBlocksUp() {\n    Ms(this);\n  }\n  /**\n   * Moves the selected blocks down. If the next block has children, moves\n   * them to the start of its children. If there is no next block, but the\n   * current blocks share a common parent, moves them out of & after it.\n   */\n  moveBlocksDown() {\n    Ps(this);\n  }\n  /**\n   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  async blocksToHTMLLossy(t = this.document) {\n    return Ve(this.pmSchema, this).exportBlocks(t, {});\n  }\n  /**\n   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.\n   *\n   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)\n   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  async blocksToFullHTML(t) {\n    return ir(this.pmSchema, this).serializeBlocks(t, {});\n  }\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  async tryParseHTMLToBlocks(t) {\n    return Mo(\n      t,\n      this.schema.blockSchema,\n      this.schema.inlineContentSchema,\n      this.schema.styleSchema,\n      this.pmSchema\n    );\n  }\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  async blocksToMarkdownLossy(t = this.document) {\n    return Gs(t, this.pmSchema, this, {});\n  }\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  async tryParseMarkdownToBlocks(t) {\n    return Qs(\n      t,\n      this.schema.blockSchema,\n      this.schema.inlineContentSchema,\n      this.schema.styleSchema,\n      this.pmSchema\n    );\n  }\n  /**\n   * Updates the user info for the current user that's shown to other collaborators.\n   */\n  updateCollaborationUserInfo(t) {\n    if (!this.options.collaboration)\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\"\n      );\n    this._tiptapEditor.commands.updateUser(t);\n  }\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  onChange(t) {\n    if (this.headless)\n      return;\n    const n = () => {\n      t(this);\n    };\n    return this._tiptapEditor.on(\"update\", n), () => {\n      this._tiptapEditor.off(\"update\", n);\n    };\n  }\n  /**\n   * A callback function that runs whenever the text cursor position or selection changes.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  onSelectionChange(t, n) {\n    if (this.headless)\n      return;\n    const r = (s) => {\n      s.transaction.getMeta(y_prosemirror__WEBPACK_IMPORTED_MODULE_23__.ySyncPluginKey) && !n || t(this);\n    };\n    return this._tiptapEditor.on(\"selectionUpdate\", r), () => {\n      this._tiptapEditor.off(\"selectionUpdate\", r);\n    };\n  }\n  /**\n   * A callback function that runs when the editor has been initialized.\n   *\n   * This can be useful for plugins to initialize themselves after the editor has been initialized.\n   */\n  onCreate(t) {\n    return this.on(\"create\", t), () => {\n      this.off(\"create\", t);\n    };\n  }\n  getSelectionBoundingBox() {\n    var a;\n    if (!this.prosemirrorView)\n      return;\n    const t = (a = this.prosemirrorView) == null ? void 0 : a.state, { selection: n } = t, { ranges: r } = n, s = Math.min(...r.map((c) => c.$from.pos)), i = Math.max(...r.map((c) => c.$to.pos));\n    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.isNodeSelection)(n)) {\n      const c = this.prosemirrorView.nodeDOM(s);\n      if (c)\n        return c.getBoundingClientRect();\n    }\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.posToDOMRect)(this.prosemirrorView, s, i);\n  }\n  get isEmpty() {\n    const t = this.document;\n    return t.length === 0 || t.length === 1 && t[0].type === \"paragraph\" && t[0].content.length === 0;\n  }\n  openSuggestionMenu(t, n) {\n    var i;\n    const r = (i = this.prosemirrorView) == null ? void 0 : i.state.tr;\n    if (!r)\n      return;\n    const s = n && n.deleteTriggerCharacter ? r.insertText(t) : r;\n    this.prosemirrorView.focus(), this.prosemirrorView.dispatch(\n      s.scrollIntoView().setMeta(this.suggestionMenus.plugin, {\n        triggerCharacter: t,\n        deleteTriggerCharacter: (n == null ? void 0 : n.deleteTriggerCharacter) || !1,\n        ignoreQueryLength: (n == null ? void 0 : n.ignoreQueryLength) || !1\n      })\n    );\n  }\n  // `forceSelectionVisible` determines whether the editor selection is shows\n  // even when the editor is not focused. This is useful for e.g. creating new\n  // links, so the user still sees the affected content when an input field is\n  // focused.\n  // TODO: Reconsider naming?\n  getForceSelectionVisible() {\n    return this.showSelectionPlugin.getEnabled();\n  }\n  setForceSelectionVisible(t) {\n    this.showSelectionPlugin.setEnabled(t);\n  }\n  /**\n   * This will convert HTML into a format that is compatible with BlockNote.\n   */\n  convertHtmlToBlockNoteHtml(t) {\n    return xo(t.trim()).innerHTML;\n  }\n  /**\n   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.\n   * @param html The HTML to paste.\n   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.\n   */\n  pasteHTML(t, n = !1) {\n    var s;\n    let r = t;\n    n || (r = this.convertHtmlToBlockNoteHtml(t)), r && ((s = this.prosemirrorView) == null || s.pasteHTML(r));\n  }\n  /**\n   * Paste text into the editor. Defaults to interpreting text as markdown.\n   * @param text The text to paste.\n   */\n  pasteText(t) {\n    var n;\n    return (n = this.prosemirrorView) == null ? void 0 : n.pasteText(t);\n  }\n  /**\n   * Paste markdown into the editor.\n   * @param markdown The markdown to paste.\n   */\n  async pasteMarkdown(t) {\n    return this.pasteHTML(await Po(t));\n  }\n}\nconst kc = {\n  gray: {\n    text: \"#9b9a97\",\n    background: \"#ebeced\"\n  },\n  brown: {\n    text: \"#64473a\",\n    background: \"#e9e5e3\"\n  },\n  red: {\n    text: \"#e03e3e\",\n    background: \"#fbe4e4\"\n  },\n  orange: {\n    text: \"#d9730d\",\n    background: \"#f6e9d9\"\n  },\n  yellow: {\n    text: \"#dfab01\",\n    background: \"#fbf3db\"\n  },\n  green: {\n    text: \"#4d6461\",\n    background: \"#ddedea\"\n  },\n  blue: {\n    text: \"#0b6e99\",\n    background: \"#ddebf1\"\n  },\n  purple: {\n    text: \"#6940a5\",\n    background: \"#eae4f2\"\n  },\n  pink: {\n    text: \"#ad1a72\",\n    background: \"#f4dfeb\"\n  }\n}, wc = {\n  gray: {\n    text: \"#bebdb8\",\n    background: \"#9b9a97\"\n  },\n  brown: {\n    text: \"#8e6552\",\n    background: \"#64473a\"\n  },\n  red: {\n    text: \"#ec4040\",\n    background: \"#be3434\"\n  },\n  orange: {\n    text: \"#e3790d\",\n    background: \"#b7600a\"\n  },\n  yellow: {\n    text: \"#dfab01\",\n    background: \"#b58b00\"\n  },\n  green: {\n    text: \"#6b8b87\",\n    background: \"#4d6461\"\n  },\n  blue: {\n    text: \"#0e87bc\",\n    background: \"#0b6e99\"\n  },\n  purple: {\n    text: \"#8552d7\",\n    background: \"#6940a5\"\n  },\n  pink: {\n    text: \"#da208f\",\n    background: \"#ad1a72\"\n  }\n};\nclass yc {\n  constructor(o, t, n) {\n    this.mappings = t, this.options = n;\n  }\n  async resolveFile(o) {\n    var n;\n    if (!((n = this.options) != null && n.resolveFileUrl))\n      return (await fetch(o)).blob();\n    const t = await this.options.resolveFileUrl(o);\n    return t instanceof Blob ? t : (await fetch(t)).blob();\n  }\n  mapStyles(o) {\n    return Object.entries(o).map(([n, r]) => this.mappings.styleMapping[n](r, this));\n  }\n  mapInlineContent(o) {\n    return this.mappings.inlineContentMapping[o.type](\n      o,\n      this\n    );\n  }\n  transformInlineContent(o) {\n    return o.map((t) => this.mapInlineContent(t));\n  }\n  async mapBlock(o, t, n) {\n    return this.mappings.blockMapping[o.type](\n      o,\n      this,\n      t,\n      n\n    );\n  }\n}\nfunction Cc(e) {\n  return {\n    createBlockMapping: (o) => o,\n    createInlineContentMapping: (o) => o,\n    createStyleMapping: (o) => o\n  };\n}\nlet Ie;\nasync function Ba() {\n  return Ie || (Ie = (async () => {\n    const [e, o] = await Promise.all([\n      __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_emoji-mart_dist_module_js\").then(__webpack_require__.bind(__webpack_require__, /*! emoji-mart */ \"(app-pages-browser)/./node_modules/emoji-mart/dist/module.js\")),\n      // use a dynamic import to encourage bundle-splitting\n      // and a smaller initial client bundle size\n      __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_emoji-mart_data_sets_15_native_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @emoji-mart/data */ \"(app-pages-browser)/./node_modules/@emoji-mart/data/sets/15/native.json\", 17))\n    ]), t = \"default\" in e ? e.default : e, n = \"default\" in o ? o.default : o;\n    return await t.init({ data: n }), { emojiMart: t, emojiData: n };\n  })(), Ie);\n}\nasync function vc(e, o) {\n  if (!ys(\"text\", e))\n    return [];\n  const { emojiData: t, emojiMart: n } = await Ba();\n  return (o.trim() === \"\" ? Object.values(t.emojis) : await n.SearchIndex.search(o)).map((s) => ({\n    id: s.skins[0].native,\n    onItemClick: () => e.insertInlineContent(s.skins[0].native + \" \")\n  }));\n}\nfunction Ec(e, ...o) {\n  const t = [...e];\n  for (const n of o)\n    for (const r of n) {\n      const s = t.findLastIndex(\n        (i) => i.group === r.group\n      );\n      s === -1 ? t.push(r) : t.splice(s + 1, 0, r);\n    }\n  return t;\n}\nfunction qe(e = \"\") {\n  return typeof e == \"string\" ? [\n    {\n      type: \"text\",\n      text: e,\n      styles: {}\n    }\n  ] : e;\n}\nfunction pe(e) {\n  var o, t, n, r, s;\n  return typeof e == \"string\" ? qe(e) : Array.isArray(e) ? e.flatMap((i) => typeof i == \"string\" ? qe(i) : it(i) ? {\n    ...i,\n    content: qe(i.content)\n  } : J(i) ? i : {\n    props: {},\n    ...i,\n    content: pe(i.content)\n  }) : (e == null ? void 0 : e.type) === \"tableContent\" ? {\n    type: \"tableContent\",\n    columnWidths: e.columnWidths,\n    headerRows: e.headerRows,\n    headerCols: e.headerCols,\n    rows: e.rows.map((i) => ({\n      ...i,\n      cells: i.cells.map(\n        (a) => pe(a)\n      )\n    }))\n  } : (e == null ? void 0 : e.type) === \"tableCell\" ? {\n    type: \"tableCell\",\n    content: pe(e.content),\n    props: {\n      backgroundColor: ((o = e.props) == null ? void 0 : o.backgroundColor) ?? \"default\",\n      textColor: ((t = e.props) == null ? void 0 : t.textColor) ?? \"default\",\n      textAlignment: ((n = e.props) == null ? void 0 : n.textAlignment) ?? \"left\",\n      colspan: ((r = e.props) == null ? void 0 : r.colspan) ?? 1,\n      rowspan: ((s = e.props) == null ? void 0 : s.rowspan) ?? 1\n    }\n  } : e;\n}\nfunction Sc(e, o) {\n  return o.map(\n    (t) => Ro(e.blockSchema, t)\n  );\n}\nfunction Ro(e, o) {\n  var r;\n  const t = e[o.type].content, n = {\n    id: \"\",\n    type: o.type,\n    props: {},\n    content: t === \"inline\" ? [] : t === \"table\" ? {\n      type: \"tableContent\",\n      columnWidths: void 0,\n      headerRows: void 0,\n      headerCols: void 0,\n      rows: []\n    } : void 0,\n    children: [],\n    ...o\n  };\n  if (Object.entries(e[o.type].propSchema).forEach(\n    ([s, i]) => {\n      n.props[s] === void 0 && i.default !== void 0 && (n.props[s] = i.default);\n    }\n  ), t === \"inline\") {\n    const s = n.content;\n    n.content = pe(s);\n  } else if (t === \"table\") {\n    const s = n.content;\n    n.content = {\n      type: \"tableContent\",\n      columnWidths: (s == null ? void 0 : s.columnWidths) || ((r = s == null ? void 0 : s.rows[0]) == null ? void 0 : r.cells.map(() => {\n      })) || [],\n      headerRows: (s == null ? void 0 : s.headerRows) || void 0,\n      headerCols: (s == null ? void 0 : s.headerCols) || void 0,\n      rows: (s == null ? void 0 : s.rows.map((i) => ({\n        cells: i.cells.map((a) => pe(a))\n      }))) || []\n    };\n  }\n  return {\n    ...n,\n    content: pe(n.content),\n    children: n.children.map((s) => Ro(e, s))\n  };\n}\nfunction Ta(e) {\n  e.id || (e.id = ve.options.generateID()), e.children && xa(e.children);\n}\nfunction xa(e) {\n  for (const o of e)\n    Ta(o);\n}\n\n//# sourceMappingURL=blocknote.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmxvY2tub3RlL2NvcmUvZGlzdC9ibG9ja25vdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDaUg7QUFDZjtBQUNpWDtBQUN0VTtBQUM3RztBQUNvQztBQUNIO0FBQ21QO0FBQzVRO0FBQ0E7QUFDRTtBQUNBO0FBQ0c7QUFDa0I7QUFDSTtBQUNOO0FBQ0M7QUFDSjtBQUNOO0FBQ0E7QUFDSDtBQUNPO0FBQ2lDO0FBQzRFO0FBQzNHO0FBQ2Y7QUFDM0M7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRCQUE0QixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsT0FBTztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFG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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQ0FBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxrQkFBa0IsOENBQThDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQUM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0EsQ0FBQztBQUNELFlBQVksNkRBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsV0FBVztBQUNYLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxRQUFRLCtDQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Es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O0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzQkFBc0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2REFBQztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBRTtBQUNsQjtBQUNBLE9BQU87QUFDUDtBQUNBLG1CQUFtQixxREFBRTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUMsc0RBQUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBRTtBQUNsQiw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQix1RUFBdUUsU0FBUztBQUM3RztBQUNBO0FBQ0EsUUFBUSw2REFBQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGVBQWUsT0FBTyxZQUFZO0FBQ3pHLFFBQVEsOERBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdPQUFvQjtBQUMxQjtBQUNBO0FBQ0EsTUFBTSx5UUFBMEI7QUFDaEM7QUFDQSwwQkFBMEIsU0FBUyxLQUFLO0FBQ3hDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTJLRTtBQUNGIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQGJsb2Nrbm90ZVxcY29yZVxcZGlzdFxcYmxvY2tub3RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBWbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBVbyA9IChlLCBvLCB0KSA9PiBvIGluIGUgPyBWbyhlLCBvLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogZVtvXSA9IHQ7XG52YXIgdSA9IChlLCBvLCB0KSA9PiBVbyhlLCB0eXBlb2YgbyAhPSBcInN5bWJvbFwiID8gbyArIFwiXCIgOiBvLCB0KTtcbmltcG9ydCB7IFNsaWNlIGFzIHRlLCBGcmFnbWVudCBhcyBWLCBET01TZXJpYWxpemVyIGFzIEZ0LCBET01QYXJzZXIgYXMgenQsIE5vZGUgYXMgJG8gfSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCB7IFJlcGxhY2VTdGVwIGFzIEZvLCBSZXBsYWNlQXJvdW5kU3RlcCBhcyBLZSwgTWFwcGluZyBhcyB6byB9IGZyb20gXCJwcm9zZW1pcnJvci10cmFuc2Zvcm1cIjtcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBILCBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyBhcyBXbywgZ2V0Q2hhbmdlZFJhbmdlcyBhcyBqbywgZmluZENoaWxkcmVuSW5SYW5nZSBhcyBHbywgTm9kZSBhcyBzZSwgTWFyayBhcyBrZSwgaXNUZXh0U2VsZWN0aW9uIGFzIFd0LCBJbnB1dFJ1bGUgYXMgb2UsIGNhbGxPclJldHVybiBhcyBxbywgZ2V0RXh0ZW5zaW9uRmllbGQgYXMgS28sIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kIGFzIFhvLCBtZXJnZUF0dHJpYnV0ZXMgYXMganQsIGlzTm9kZVNlbGVjdGlvbiBhcyBYZSwgcG9zVG9ET01SZWN0IGFzIEFlLCBnZXRNYXJrUmFuZ2UgYXMgbXQsIGZpbmRDaGlsZHJlbiBhcyBndCwgZmluZFBhcmVudE5vZGUgYXMgSm8sIGV4dGVuc2lvbnMgYXMgdWUsIEVkaXRvciBhcyBZbywgY3JlYXRlRG9jdW1lbnQgYXMgWm8sIGdldFNjaGVtYSBhcyBRbyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiBhcyBNLCBQbHVnaW5LZXkgYXMgTiwgVGV4dFNlbGVjdGlvbiBhcyBSLCBOb2RlU2VsZWN0aW9uIGFzIHdlLCBTZWxlY3Rpb24gYXMgemUsIEVkaXRvclN0YXRlIGFzIGVuIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5pbXBvcnQgeyB2NCBhcyBHdCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBjcmVhdGVIaWdobGlnaHRQbHVnaW4gYXMgdG4gfSBmcm9tIFwicHJvc2VtaXJyb3ItaGlnaGxpZ2h0XCI7XG5pbXBvcnQgeyBjcmVhdGVQYXJzZXIgYXMgb24gfSBmcm9tIFwicHJvc2VtaXJyb3ItaGlnaGxpZ2h0L3NoaWtpXCI7XG5pbXBvcnQgeyBnb1RvTmV4dENlbGwgYXMgYnQsIGNvbHVtblJlc2l6aW5nIGFzIG5uLCB0YWJsZUVkaXRpbmcgYXMgcm4sIFRhYmxlVmlldyBhcyBzbiwgQ2VsbFNlbGVjdGlvbiBhcyB5ZSwgVGFibGVNYXAgYXMga3QsIGFkZFJvd0JlZm9yZSBhcyBhbiwgYWRkUm93QWZ0ZXIgYXMgY24sIGFkZENvbHVtbkJlZm9yZSBhcyBsbiwgYWRkQ29sdW1uQWZ0ZXIgYXMgZG4sIGRlbGV0ZVJvdyBhcyBwbiwgZGVsZXRlQ29sdW1uIGFzIHVuLCBtZXJnZUNlbGxzIGFzIGhuLCBzcGxpdENlbGwgYXMgZm4gfSBmcm9tIFwicHJvc2VtaXJyb3ItdGFibGVzXCI7XG5pbXBvcnQgbW4gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWJvbGRcIjtcbmltcG9ydCBnbiBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tY29kZVwiO1xuaW1wb3J0IGJuIGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWNcIjtcbmltcG9ydCBrbiBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlXCI7XG5pbXBvcnQgd24gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXVuZGVybGluZVwiO1xuaW1wb3J0IHsgVGFibGVDZWxsIGFzIHluIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlLWNlbGxcIjtcbmltcG9ydCB7IFRhYmxlSGVhZGVyIGFzIENuIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlLWhlYWRlclwiO1xuaW1wb3J0IHsgVGFibGVSb3cgYXMgdm4gfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdGFibGUtcm93XCI7XG5pbXBvcnQgeyBHYXBjdXJzb3IgYXMgRW4gfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yXCI7XG5pbXBvcnQgeyBIaXN0b3J5IGFzIFNuIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWhpc3RvcnlcIjtcbmltcG9ydCB7IExpbmsgYXMgQm4gfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tbGlua1wiO1xuaW1wb3J0IHsgVGV4dCBhcyBUbiB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi10ZXh0XCI7XG5pbXBvcnQgeG4gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWNvbGxhYm9yYXRpb25cIjtcbmltcG9ydCBNbiBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbi1jdXJzb3JcIjtcbmltcG9ydCB7IERlY29yYXRpb25TZXQgYXMgVSwgRGVjb3JhdGlvbiBhcyBHLCBFZGl0b3JWaWV3IGFzIFBuIH0gZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjtcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5IGFzIE5lLCBnZXRSZWxhdGl2ZVNlbGVjdGlvbiBhcyBJbiwgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiBhcyBMbiwgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbiBhcyBBbiB9IGZyb20gXCJ5LXByb3NlbWlycm9yXCI7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIGFzIE5uIH0gZnJvbSBcInByb3NlbWlycm9yLWRyb3BjdXJzb3JcIjtcbmltcG9ydCB7IGUgYXMgSG4gfSBmcm9tIFwiLi9lbi1CN3ljVzdjOC5qc1wiO1xuY2xhc3MgJCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iobykge1xuICAgIHN1cGVyKGBVbnJlYWNoYWJsZSBjYXNlOiAke299YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRjKGUsIG8gPSAhMCkge1xuICBjb25zdCB7IFwiZGF0YS10ZXN0XCI6IHQsIC4uLm4gfSA9IGU7XG4gIGlmIChPYmplY3Qua2V5cyhuKS5sZW5ndGggPiAwICYmIG8pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG11c3QgYmUgZW1wdHkgXCIgKyBKU09OLnN0cmluZ2lmeShlKSk7XG59XG5mdW5jdGlvbiBYKGUsIG8pIHtcbiAgY29uc3QgdCA9IGUucmVzb2x2ZShvKTtcbiAgaWYgKHQubm9kZUFmdGVyICYmIHQubm9kZUFmdGVyLnR5cGUuaXNJbkdyb3VwKFwiYm5CbG9ja1wiKSlcbiAgICByZXR1cm4ge1xuICAgICAgcG9zQmVmb3JlTm9kZTogdC5wb3MsXG4gICAgICBub2RlOiB0Lm5vZGVBZnRlclxuICAgIH07XG4gIGxldCBuID0gdC5kZXB0aCwgciA9IHQubm9kZShuKTtcbiAgZm9yICg7IG4gPiAwOyApIHtcbiAgICBpZiAoci50eXBlLmlzSW5Hcm91cChcImJuQmxvY2tcIikpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NCZWZvcmVOb2RlOiB0LmJlZm9yZShuKSxcbiAgICAgICAgbm9kZTogclxuICAgICAgfTtcbiAgICBuLS0sIHIgPSB0Lm5vZGUobik7XG4gIH1cbiAgY29uc3QgcyA9IFtdO1xuICBlLmRlc2NlbmRhbnRzKChhLCBjKSA9PiB7XG4gICAgYS50eXBlLmlzSW5Hcm91cChcImJuQmxvY2tcIikgJiYgcy5wdXNoKGMpO1xuICB9KSwgY29uc29sZS53YXJuKGBQb3NpdGlvbiAke299IGlzIG5vdCB3aXRoaW4gYSBibG9ja0NvbnRhaW5lciBub2RlLmApO1xuICBjb25zdCBpID0gZS5yZXNvbHZlKFxuICAgIHMuZmluZCgoYSkgPT4gYSA+PSBvKSB8fCBzW3MubGVuZ3RoIC0gMV1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NCZWZvcmVOb2RlOiBpLnBvcyxcbiAgICBub2RlOiBpLm5vZGVBZnRlclxuICB9O1xufVxuZnVuY3Rpb24gc3QoZSwgbykge1xuICBpZiAoIWUudHlwZS5pc0luR3JvdXAoXCJibkJsb2NrXCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gZ2V0IGJuQmxvY2sgbm9kZSBhdCBwb3NpdGlvbiBidXQgZm91bmQgbm9kZSBvZiBkaWZmZXJlbnQgdHlwZSAke2UudHlwZX1gXG4gICAgKTtcbiAgY29uc3QgdCA9IGUsIG4gPSBvLCByID0gbiArIHQubm9kZVNpemUsIHMgPSB7XG4gICAgbm9kZTogdCxcbiAgICBiZWZvcmVQb3M6IG4sXG4gICAgYWZ0ZXJQb3M6IHJcbiAgfTtcbiAgaWYgKHQudHlwZS5uYW1lID09PSBcImJsb2NrQ29udGFpbmVyXCIpIHtcbiAgICBsZXQgaSwgYTtcbiAgICBpZiAodC5mb3JFYWNoKChjLCBsKSA9PiB7XG4gICAgICBpZiAoYy50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCIpIHtcbiAgICAgICAgY29uc3QgZCA9IGMsIHAgPSBuICsgbCArIDEsIGggPSBwICsgYy5ub2RlU2l6ZTtcbiAgICAgICAgaSA9IHtcbiAgICAgICAgICBub2RlOiBkLFxuICAgICAgICAgIGJlZm9yZVBvczogcCxcbiAgICAgICAgICBhZnRlclBvczogaFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjLnR5cGUubmFtZSA9PT0gXCJibG9ja0dyb3VwXCIpIHtcbiAgICAgICAgY29uc3QgZCA9IGMsIHAgPSBuICsgbCArIDEsIGggPSBwICsgYy5ub2RlU2l6ZTtcbiAgICAgICAgYSA9IHtcbiAgICAgICAgICBub2RlOiBkLFxuICAgICAgICAgIGJlZm9yZVBvczogcCxcbiAgICAgICAgICBhZnRlclBvczogaFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pLCAhaSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGJsb2NrQ29udGFpbmVyIG5vZGUgZG9lcyBub3QgY29udGFpbiBhIGJsb2NrQ29udGVudCBub2RlIGluIGl0cyBjaGlsZHJlbjogJHt0fWBcbiAgICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQmxvY2tDb250YWluZXI6ICEwLFxuICAgICAgYm5CbG9jazogcyxcbiAgICAgIGJsb2NrQ29udGVudDogaSxcbiAgICAgIGNoaWxkQ29udGFpbmVyOiBhLFxuICAgICAgYmxvY2tOb3RlVHlwZTogaS5ub2RlLnR5cGUubmFtZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzLm5vZGUudHlwZS5pc0luR3JvdXAoXCJjaGlsZENvbnRhaW5lclwiKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGJuQmxvY2sgbm9kZSBpcyBub3QgaW4gdGhlIGNoaWxkQ29udGFpbmVyIGdyb3VwOiAke3Mubm9kZX1gXG4gICAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBpc0Jsb2NrQ29udGFpbmVyOiAhMSxcbiAgICAgIGJuQmxvY2s6IHMsXG4gICAgICBjaGlsZENvbnRhaW5lcjogcyxcbiAgICAgIGJsb2NrTm90ZVR5cGU6IHMubm9kZS50eXBlLm5hbWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBuZShlKSB7XG4gIHJldHVybiBzdChlLm5vZGUsIGUucG9zQmVmb3JlTm9kZSk7XG59XG5mdW5jdGlvbiBDZShlKSB7XG4gIGlmICghZS5ub2RlQWZ0ZXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byBnZXQgYmxvY2tDb250YWluZXIgbm9kZSBhdCBwb3NpdGlvbiAke2UucG9zfSBidXQgYSBub2RlIGF0IHRoaXMgcG9zaXRpb24gZG9lcyBub3QgZXhpc3RgXG4gICAgKTtcbiAgcmV0dXJuIHN0KGUubm9kZUFmdGVyLCBlLnBvcyk7XG59XG5mdW5jdGlvbiBDKGUpIHtcbiAgY29uc3QgbyA9IFgoZS5kb2MsIGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gIHJldHVybiBuZShvKTtcbn1cbmZ1bmN0aW9uIERuKGUsIG8gPSBKU09OLnN0cmluZ2lmeSkge1xuICBjb25zdCB0ID0ge307XG4gIHJldHVybiBlLmZpbHRlcigobikgPT4ge1xuICAgIGNvbnN0IHIgPSBvKG4pO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgPyAhMSA6IHRbcl0gPSAhMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBPbihlKSB7XG4gIGNvbnN0IG8gPSBlLmZpbHRlcihcbiAgICAobiwgcikgPT4gZS5pbmRleE9mKG4pICE9PSByXG4gICk7XG4gIHJldHVybiBEbihvKTtcbn1cbmNvbnN0IHZlID0gSC5jcmVhdGUoe1xuICBuYW1lOiBcInVuaXF1ZUlEXCIsXG4gIC8vIHdl4oCZbGwgc2V0IGEgdmVyeSBoaWdoIHByaW9yaXR5IHRvIG1ha2Ugc3VyZSB0aGlzIHJ1bnMgZmlyc3RcbiAgLy8gYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBgYXBwZW5kVHJhbnNhY3Rpb25gIGhvb2tzIG9mIG90aGVyIGV4dGVuc2lvbnNcbiAgcHJpb3JpdHk6IDFlNCxcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cmlidXRlTmFtZTogXCJpZFwiLFxuICAgICAgdHlwZXM6IFtdLFxuICAgICAgc2V0SWRBdHRyaWJ1dGU6ICExLFxuICAgICAgZ2VuZXJhdGVJRDogKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5fX1RFU1RfT1BUSU9OUykge1xuICAgICAgICAgIGNvbnN0IGUgPSB3aW5kb3cuX19URVNUX09QVElPTlM7XG4gICAgICAgICAgcmV0dXJuIGUubW9ja0lEID09PSB2b2lkIDAgPyBlLm1vY2tJRCA9IDAgOiBlLm1vY2tJRCsrLCBlLm1vY2tJRC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBHdCgpO1xuICAgICAgfSxcbiAgICAgIGZpbHRlclRyYW5zYWN0aW9uOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlczogdGhpcy5vcHRpb25zLnR5cGVzLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgW3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lXToge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHBhcnNlSFRNTDogKGUpID0+IGUuZ2V0QXR0cmlidXRlKGBkYXRhLSR7dGhpcy5vcHRpb25zLmF0dHJpYnV0ZU5hbWV9YCksXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAoZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBvID0ge1xuICAgICAgICAgICAgICAgIFtgZGF0YS0ke3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lfWBdOiBlW3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNldElkQXR0cmlidXRlID8ge1xuICAgICAgICAgICAgICAgIC4uLm8sXG4gICAgICAgICAgICAgICAgaWQ6IGVbdGhpcy5vcHRpb25zLmF0dHJpYnV0ZU5hbWVdXG4gICAgICAgICAgICAgIH0gOiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIC8vIGNoZWNrIGluaXRpYWwgY29udGVudCBmb3IgbWlzc2luZyBpZHNcbiAgLy8gb25DcmVhdGUoKSB7XG4gIC8vICAgLy8gRG9u4oCZdCBkbyB0aGlzIHdoZW4gdGhlIGNvbGxhYm9yYXRpb24gZXh0ZW5zaW9uIGlzIGFjdGl2ZVxuICAvLyAgIC8vIGJlY2F1c2UgdGhpcyBtYXkgdXBkYXRlIHRoZSBjb250ZW50LCBzbyBZLmpzIHRyaWVzIHRvIG1lcmdlIHRoZXNlIGNoYW5nZXMuXG4gIC8vICAgLy8gVGhpcyBsZWFkcyB0byBlbXB0eSBibG9jayBub2Rlcy5cbiAgLy8gICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjQwMFxuICAvLyAgIGlmIChcbiAgLy8gICAgIHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuZXh0ZW5zaW9ucy5maW5kKFxuICAvLyAgICAgICAoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ubmFtZSA9PT0gXCJjb2xsYWJvcmF0aW9uXCJcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIHJldHVybjtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgeyB2aWV3LCBzdGF0ZSB9ID0gdGhpcy5lZGl0b3I7XG4gIC8vICAgY29uc3QgeyB0ciwgZG9jIH0gPSBzdGF0ZTtcbiAgLy8gICBjb25zdCB7IHR5cGVzLCBhdHRyaWJ1dGVOYW1lLCBnZW5lcmF0ZUlEIH0gPSB0aGlzLm9wdGlvbnM7XG4gIC8vICAgY29uc3Qgbm9kZXNXaXRob3V0SWQgPSBmaW5kQ2hpbGRyZW4oZG9jLCAobm9kZSkgPT4ge1xuICAvLyAgICAgcmV0dXJuIChcbiAgLy8gICAgICAgdHlwZXMuaW5jbHVkZXMobm9kZS50eXBlLm5hbWUpICYmIG5vZGUuYXR0cnNbYXR0cmlidXRlTmFtZV0gPT09IG51bGxcbiAgLy8gICAgICk7XG4gIC8vICAgfSk7XG4gIC8vICAgbm9kZXNXaXRob3V0SWQuZm9yRWFjaCgoeyBub2RlLCBwb3MgfSkgPT4ge1xuICAvLyAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAvLyAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAvLyAgICAgICBbYXR0cmlidXRlTmFtZV06IGdlbmVyYXRlSUQoKSxcbiAgLy8gICAgIH0pO1xuICAvLyAgIH0pO1xuICAvLyAgIHRyLnNldE1ldGEoXCJhZGRUb0hpc3RvcnlcIiwgZmFsc2UpO1xuICAvLyAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAvLyB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgbGV0IGUgPSBudWxsLCBvID0gITE7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBNKHtcbiAgICAgICAga2V5OiBuZXcgTihcInVuaXF1ZUlEXCIpLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHQsIG4sIHIpID0+IHtcbiAgICAgICAgICBjb25zdCBzID0gdC5zb21lKChtKSA9PiBtLmRvY0NoYW5nZWQpICYmICFuLmRvYy5lcShyLmRvYyksIGkgPSB0aGlzLm9wdGlvbnMuZmlsdGVyVHJhbnNhY3Rpb24gJiYgdC5zb21lKChtKSA9PiB7XG4gICAgICAgICAgICBsZXQgZywgYjtcbiAgICAgICAgICAgIHJldHVybiAhKCEoKGIgPSAoZyA9IHRoaXMub3B0aW9ucykuZmlsdGVyVHJhbnNhY3Rpb24pID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCkgJiYgYi5jYWxsKGcsIG0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXMgfHwgaSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCB7IHRyOiBhIH0gPSByLCB7IHR5cGVzOiBjLCBhdHRyaWJ1dGVOYW1lOiBsLCBnZW5lcmF0ZUlEOiBkIH0gPSB0aGlzLm9wdGlvbnMsIHAgPSBXbyhcbiAgICAgICAgICAgIG4uZG9jLFxuICAgICAgICAgICAgdFxuICAgICAgICAgICksIHsgbWFwcGluZzogaCB9ID0gcDtcbiAgICAgICAgICBpZiAoam8ocCkuZm9yRWFjaCgoeyBuZXdSYW5nZTogbSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnID0gR28oXG4gICAgICAgICAgICAgIHIuZG9jLFxuICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAodykgPT4gYy5pbmNsdWRlcyh3LnR5cGUubmFtZSlcbiAgICAgICAgICAgICksIGIgPSBnLm1hcCgoeyBub2RlOiB3IH0pID0+IHcuYXR0cnNbbF0pLmZpbHRlcigodykgPT4gdyAhPT0gbnVsbCksIGsgPSBPbihiKTtcbiAgICAgICAgICAgIGcuZm9yRWFjaCgoeyBub2RlOiB3LCBwb3M6IHkgfSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgVDtcbiAgICAgICAgICAgICAgY29uc3QgRiA9IChUID0gYS5kb2Mubm9kZUF0KHkpKSA9PT0gbnVsbCB8fCBUID09PSB2b2lkIDAgPyB2b2lkIDAgOiBULmF0dHJzW2xdO1xuICAgICAgICAgICAgICBpZiAoRiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBuLmRvYy50eXBlLmNyZWF0ZUFuZEZpbGwoKS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGlmIChuLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQodikgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFlID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoci5kb2MudG9KU09OKCkpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKGFlLmNvbnRlbnRbMF0uY29udGVudFswXS5hdHRycy5pZCA9IFwiaW5pdGlhbEJsb2NrSWRcIiwgSlNPTi5zdHJpbmdpZnkoYWUuY29udGVudCkgPT09IEpTT04uc3RyaW5naWZ5KHYudG9KU09OKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGEuc2V0Tm9kZU1hcmt1cCh5LCB2b2lkIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi53LmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgIFtsXTogXCJpbml0aWFsQmxvY2tJZFwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuc2V0Tm9kZU1hcmt1cCh5LCB2b2lkIDAsIHtcbiAgICAgICAgICAgICAgICAgIC4uLncuYXR0cnMsXG4gICAgICAgICAgICAgICAgICBbbF06IGQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB7IGRlbGV0ZWQ6IGogfSA9IGguaW52ZXJ0KCkubWFwUmVzdWx0KHkpO1xuICAgICAgICAgICAgICBqICYmIGsuaW5jbHVkZXMoRikgJiYgYS5zZXROb2RlTWFya3VwKHksIHZvaWQgMCwge1xuICAgICAgICAgICAgICAgIC4uLncuYXR0cnMsXG4gICAgICAgICAgICAgICAgW2xdOiBkKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgISFhLnN0ZXBzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LFxuICAgICAgICAvLyB3ZSByZWdpc3RlciBhIGdsb2JhbCBkcmFnIGhhbmRsZXIgdG8gdHJhY2sgdGhlIGN1cnJlbnQgZHJhZyBzb3VyY2UgZWxlbWVudFxuICAgICAgICB2aWV3KHQpIHtcbiAgICAgICAgICBjb25zdCBuID0gKHIpID0+IHtcbiAgICAgICAgICAgIGxldCBzO1xuICAgICAgICAgICAgZSA9ICEoKHMgPSB0LmRvbS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDApICYmIHMuY29udGFpbnMoci50YXJnZXQpID8gdC5kb20ucGFyZW50RWxlbWVudCA6IG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgbiksIHtcbiAgICAgICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgLy8gYGhhbmRsZURPTUV2ZW50c2AgaXMgY2FsbGVkIGJlZm9yZSBgdHJhbnNmb3JtUGFzdGVkYCBzbyB3ZSBjYW4gZG9cbiAgICAgICAgICAvLyBzb21lIGNoZWNrcyBiZWZvcmUuIEhvd2V2ZXIsIGB0cmFuc2Zvcm1QYXN0ZWRgIG9ubHkgcnVucyB3aGVuXG4gICAgICAgICAgLy8gZWRpdG9yIGNvbnRlbnQgaXMgcGFzdGVkIC0gbm90IGV4dGVybmFsIGNvbnRlbnQuXG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAvLyBvbmx5IGNyZWF0ZSBuZXcgaWRzIGZvciBkcm9wcGVkIGNvbnRlbnQgd2hpbGUgaG9sZGluZyBgYWx0YFxuICAgICAgICAgICAgLy8gb3IgY29udGVudCBpcyBkcmFnZ2VkIGZyb20gYW5vdGhlciBlZGl0b3JcbiAgICAgICAgICAgIGRyb3A6ICh0LCBuKSA9PiB7XG4gICAgICAgICAgICAgIGxldCByO1xuICAgICAgICAgICAgICByZXR1cm4gZSAhPT0gdC5kb20ucGFyZW50RWxlbWVudCB8fCAoKHIgPSBuLmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5lZmZlY3RBbGxvd2VkKSA9PT0gXCJjb3B5XCIgPyBvID0gITAgOiBvID0gITEsIGUgPSBudWxsLCAhMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIG5ldyBpZHMgb24gcGFzdGVkIGNvbnRlbnRcbiAgICAgICAgICAgIHBhc3RlOiAoKSA9PiAobyA9ICEwLCAhMSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIHdl4oCZbGwgcmVtb3ZlIGlkcyBmb3IgZXZlcnkgcGFzdGVkIG5vZGVcbiAgICAgICAgICAvLyBzbyB3ZSBjYW4gY3JlYXRlIGEgbmV3IG9uZSB3aXRoaW4gYGFwcGVuZFRyYW5zYWN0aW9uYFxuICAgICAgICAgIHRyYW5zZm9ybVBhc3RlZDogKHQpID0+IHtcbiAgICAgICAgICAgIGlmICghbylcbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGVzOiBuLCBhdHRyaWJ1dGVOYW1lOiByIH0gPSB0aGlzLm9wdGlvbnMsIHMgPSAoaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICAgIHJldHVybiBpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYy5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgIGEucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuLmluY2x1ZGVzKGMudHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgYS5wdXNoKGMuY29weShzKGMuY29udGVudCkpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IGMudHlwZS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIFtyXTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHMoYy5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAgIGMubWFya3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGEucHVzaChsKTtcbiAgICAgICAgICAgICAgfSksIFYuZnJvbShhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbyA9ICExLCBuZXcgdGUoXG4gICAgICAgICAgICAgIHModC5jb250ZW50KSxcbiAgICAgICAgICAgICAgdC5vcGVuU3RhcnQsXG4gICAgICAgICAgICAgIHQub3BlbkVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5mdW5jdGlvbiB3dChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwibGlua1wiO1xufVxuZnVuY3Rpb24gaXQoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgIT0gXCJzdHJpbmdcIiAmJiBlLnR5cGUgPT09IFwibGlua1wiO1xufVxuZnVuY3Rpb24gSihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiICYmIGUudHlwZSA9PT0gXCJ0ZXh0XCI7XG59XG5mdW5jdGlvbiBKZShlKSB7XG4gIHZhciBvLCB0LCBuLCByLCBzO1xuICByZXR1cm4gYXQoZSkgPyB7IC4uLmUgfSA6IG1lKGUpID8ge1xuICAgIHR5cGU6IFwidGFibGVDZWxsXCIsXG4gICAgY29udGVudDogW10uY29uY2F0KGUuY29udGVudCksXG4gICAgcHJvcHM6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogKChvID0gZS5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IG8uYmFja2dyb3VuZENvbG9yKSA/PyBcImRlZmF1bHRcIixcbiAgICAgIHRleHRDb2xvcjogKCh0ID0gZS5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQudGV4dENvbG9yKSA/PyBcImRlZmF1bHRcIixcbiAgICAgIHRleHRBbGlnbm1lbnQ6ICgobiA9IGUucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBuLnRleHRBbGlnbm1lbnQpID8/IFwibGVmdFwiLFxuICAgICAgY29sc3BhbjogKChyID0gZS5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY29sc3BhbikgPz8gMSxcbiAgICAgIHJvd3NwYW46ICgocyA9IGUucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBzLnJvd3NwYW4pID8/IDFcbiAgICB9XG4gIH0gOiB7XG4gICAgdHlwZTogXCJ0YWJsZUNlbGxcIixcbiAgICBjb250ZW50OiBbXS5jb25jYXQoZSksXG4gICAgcHJvcHM6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCJkZWZhdWx0XCIsXG4gICAgICB0ZXh0Q29sb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgdGV4dEFsaWdubWVudDogXCJsZWZ0XCIsXG4gICAgICBjb2xzcGFuOiAxLFxuICAgICAgcm93c3BhbjogMVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lKGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KGUpICYmIGUudHlwZSA9PT0gXCJ0YWJsZUNlbGxcIjtcbn1cbmZ1bmN0aW9uIGF0KGUpIHtcbiAgcmV0dXJuIG1lKGUpICYmIGUucHJvcHMgIT09IHZvaWQgMCAmJiBlLmNvbnRlbnQgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdlKGUpIHtcbiAgcmV0dXJuIGF0KGUpID8gZS5wcm9wcy5jb2xzcGFuID8/IDEgOiAxO1xufVxuZnVuY3Rpb24gWWUoZSkge1xuICByZXR1cm4gYXQoZSkgPyBlLnByb3BzLnJvd3NwYW4gPz8gMSA6IDE7XG59XG5jb25zdCBfbiA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAoL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIHx8IC9BcHBsZVdlYktpdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvTW9iaWxlXFwvXFx3Ky8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG5mdW5jdGlvbiBLKGUsIG8gPSBcIkN0cmxcIikge1xuICByZXR1cm4gX24oKSA/IGUucmVwbGFjZShcIk1vZFwiLCBcIuKMmFwiKSA6IGUucmVwbGFjZShcIk1vZFwiLCBvKTtcbn1cbmZ1bmN0aW9uIFkoLi4uZSkge1xuICByZXR1cm4gZS5maWx0ZXIoKG8pID0+IG8pLmpvaW4oXCIgXCIpO1xufVxuY29uc3Qgb2MgPSAoKSA9PiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZnVuY3Rpb24geihlLCBvLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByLmNsYXNzTmFtZSA9IFkoXG4gICAgXCJibi1ibG9jay1jb250ZW50XCIsXG4gICAgdC5jbGFzc1xuICApLCByLnNldEF0dHJpYnV0ZShcImRhdGEtY29udGVudC10eXBlXCIsIGUpO1xuICBmb3IgKGNvbnN0IFtpLCBhXSBvZiBPYmplY3QuZW50cmllcyh0KSlcbiAgICBpICE9PSBcImNsYXNzXCIgJiYgci5zZXRBdHRyaWJ1dGUoaSwgYSk7XG4gIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG8pO1xuICBzLmNsYXNzTmFtZSA9IFkoXG4gICAgXCJibi1pbmxpbmUtY29udGVudFwiLFxuICAgIG4uY2xhc3NcbiAgKTtcbiAgZm9yIChjb25zdCBbaSwgYV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgblxuICApKVxuICAgIGkgIT09IFwiY2xhc3NcIiAmJiBzLnNldEF0dHJpYnV0ZShpLCBhKTtcbiAgcmV0dXJuIHIuYXBwZW5kQ2hpbGQocyksIHtcbiAgICBkb206IHIsXG4gICAgY29udGVudERPTTogc1xuICB9O1xufVxuY29uc3QgeXQgPSAoZSwgbykgPT4ge1xuICBsZXQgdCA9IGllKGUsIG8ucG1TY2hlbWEsIG8uc2NoZW1hLnN0eWxlU2NoZW1hKTtcbiAgdC50eXBlLm5hbWUgPT09IFwiYmxvY2tDb250YWluZXJcIiAmJiAodCA9IHQuZmlyc3RDaGlsZCk7XG4gIGNvbnN0IG4gPSBvLnBtU2NoZW1hLm5vZGVzW3QudHlwZS5uYW1lXS5zcGVjLnRvRE9NO1xuICBpZiAobiA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhpcyBibG9jayBoYXMgbm8gZGVmYXVsdCBIVE1MIHNlcmlhbGl6YXRpb24gYXMgaXRzIGNvcnJlc3BvbmRpbmcgVGlwVGFwIG5vZGUgZG9lc24ndCBpbXBsZW1lbnQgYHJlbmRlckhUTUxgLlwiXG4gICAgKTtcbiAgY29uc3QgciA9IG4odCk7XG4gIGlmICh0eXBlb2YgciAhPSBcIm9iamVjdFwiIHx8ICEoXCJkb21cIiBpbiByKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbm5vdCB1c2UgdGhpcyBibG9jaydzIGRlZmF1bHQgSFRNTCBzZXJpYWxpemF0aW9uIGFzIGl0cyBjb3JyZXNwb25kaW5nIFRpcFRhcCBub2RlJ3MgYHJlbmRlckhUTUxgIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgYGRvbWAgcHJvcGVydHkuXCJcbiAgICApO1xuICByZXR1cm4gcjtcbn0sIFMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjoge1xuICAgIGRlZmF1bHQ6IFwiZGVmYXVsdFwiXG4gIH0sXG4gIHRleHRDb2xvcjoge1xuICAgIGRlZmF1bHQ6IFwiZGVmYXVsdFwiXG4gIH0sXG4gIHRleHRBbGlnbm1lbnQ6IHtcbiAgICBkZWZhdWx0OiBcImxlZnRcIixcbiAgICB2YWx1ZXM6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIl1cbiAgfVxufSwgcXQgPSBbXCJiYWNrZ3JvdW5kQ29sb3JcIiwgXCJ0ZXh0Q29sb3JcIl07XG5mdW5jdGlvbiBIZShlKSB7XG4gIHJldHVybiBcImRhdGEtXCIgKyBlLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG5jKGUpIHtcbiAgY29uc3QgbyA9IGUuc3BsaXQoXCIvXCIpO1xuICByZXR1cm4gIW8ubGVuZ3RoIHx8IC8vIGludmFsaWQ/XG4gIG9bby5sZW5ndGggLSAxXSA9PT0gXCJcIiA/IGUgOiBvW28ubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBFZShlKSB7XG4gIGNvbnN0IG8gPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZpbHRlcigoW3QsIG5dKSA9PiAhcXQuaW5jbHVkZXModCkpLmZvckVhY2goKFt0LCBuXSkgPT4ge1xuICAgIG9bdF0gPSB7XG4gICAgICBkZWZhdWx0OiBuLmRlZmF1bHQsXG4gICAgICBrZWVwT25TcGxpdDogITAsXG4gICAgICAvLyBQcm9wcyBhcmUgZGlzcGxheWVkIGluIGtlYmFiLWNhc2UgYXMgSFRNTCBhdHRyaWJ1dGVzLiBJZiBhIHByb3Anc1xuICAgICAgLy8gdmFsdWUgaXMgdGhlIHNhbWUgYXMgaXRzIGRlZmF1bHQsIHdlIGRvbid0IGRpc3BsYXkgYW4gSFRNTFxuICAgICAgLy8gYXR0cmlidXRlIGZvciBpdC5cbiAgICAgIHBhcnNlSFRNTDogKHIpID0+IHtcbiAgICAgICAgY29uc3QgcyA9IHIuZ2V0QXR0cmlidXRlKEhlKHQpKTtcbiAgICAgICAgaWYgKHMgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChuLmRlZmF1bHQgPT09IHZvaWQgMCAmJiBuLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IG4uZGVmYXVsdCAhPT0gdm9pZCAwICYmIHR5cGVvZiBuLmRlZmF1bHQgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgcmV0dXJuIHMgPT09IFwidHJ1ZVwiID8gITAgOiBzID09PSBcImZhbHNlXCIgPyAhMSA6IG51bGw7XG4gICAgICAgIGlmIChuLmRlZmF1bHQgPT09IHZvaWQgMCAmJiBuLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbi5kZWZhdWx0ICE9PSB2b2lkIDAgJiYgdHlwZW9mIG4uZGVmYXVsdCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc3QgaSA9IHBhcnNlRmxvYXQocyk7XG4gICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oaSkgJiYgTnVtYmVyLmlzRmluaXRlKGkpID8gaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuICAgICAgcmVuZGVySFRNTDogKHIpID0+IHJbdF0gIT09IG4uZGVmYXVsdCA/IHtcbiAgICAgICAgW0hlKHQpXTogclt0XVxuICAgICAgfSA6IHt9XG4gICAgfTtcbiAgfSksIG87XG59XG5mdW5jdGlvbiBSbihlLCBvLCB0LCBuKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbm5vdCBmaW5kIG5vZGUgcG9zaXRpb24gYXMgZ2V0UG9zIGlzIGEgYm9vbGVhbiwgbm90IGEgZnVuY3Rpb24uXCJcbiAgICApO1xuICBjb25zdCByID0gZSgpLCBpID0gdC5zdGF0ZS5kb2MucmVzb2x2ZShyKS5ub2RlKCkuYXR0cnMuaWQ7XG4gIGlmICghaSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBkb2Vzbid0IGhhdmUgaWRcIik7XG4gIGNvbnN0IGEgPSBvLmdldEJsb2NrKGkpO1xuICBpZiAoYS50eXBlICE9PSBuKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIHR5cGUgZG9lcyBub3QgbWF0Y2hcIik7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gVGUoZSwgbywgdCwgbiwgciA9ICExLCBzKSB7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBpZiAocyAhPT0gdm9pZCAwKVxuICAgIGZvciAoY29uc3QgW2EsIGNdIG9mIE9iamVjdC5lbnRyaWVzKHMpKVxuICAgICAgYSAhPT0gXCJjbGFzc1wiICYmIGkuc2V0QXR0cmlidXRlKGEsIGMpO1xuICBpLmNsYXNzTmFtZSA9IFkoXG4gICAgXCJibi1ibG9jay1jb250ZW50XCIsXG4gICAgKHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY2xhc3MpIHx8IFwiXCJcbiAgKSwgaS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbnRlbnQtdHlwZVwiLCBvKTtcbiAgZm9yIChjb25zdCBbYSwgY10gb2YgT2JqZWN0LmVudHJpZXModCkpIHtcbiAgICBjb25zdCBkID0gblthXS5kZWZhdWx0O1xuICAgICFxdC5pbmNsdWRlcyhhKSAmJiBjICE9PSBkICYmIGkuc2V0QXR0cmlidXRlKEhlKGEpLCBjKTtcbiAgfVxuICByZXR1cm4gciAmJiBpLnNldEF0dHJpYnV0ZShcImRhdGEtZmlsZS1ibG9ja1wiLCBcIlwiKSwgaS5hcHBlbmRDaGlsZChlLmRvbSksIGUuY29udGVudERPTSAhPT0gdm9pZCAwICYmIChlLmNvbnRlbnRET00uY2xhc3NOYW1lID0gWShcbiAgICBcImJuLWlubGluZS1jb250ZW50XCIsXG4gICAgZS5jb250ZW50RE9NLmNsYXNzTmFtZVxuICApLCBlLmNvbnRlbnRET00uc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0YWJsZVwiLCBcIlwiKSksIHtcbiAgICAuLi5lLFxuICAgIGRvbTogaVxuICB9O1xufVxuZnVuY3Rpb24gVyhlKSB7XG4gIHJldHVybiBzZS5jcmVhdGUoZSk7XG59XG5mdW5jdGlvbiBLdChlLCBvKSB7XG4gIHJldHVybiB7XG4gICAgY29uZmlnOiBlLFxuICAgIGltcGxlbWVudGF0aW9uOiBvXG4gIH07XG59XG5mdW5jdGlvbiBaKGUsIG8sIHQpIHtcbiAgcmV0dXJuIEt0KFxuICAgIHtcbiAgICAgIHR5cGU6IGUubmFtZSxcbiAgICAgIGNvbnRlbnQ6IGUuY29uZmlnLmNvbnRlbnQgPT09IFwiaW5saW5lKlwiID8gXCJpbmxpbmVcIiA6IGUuY29uZmlnLmNvbnRlbnQgPT09IFwidGFibGVSb3crXCIgPyBcInRhYmxlXCIgOiBcIm5vbmVcIixcbiAgICAgIHByb3BTY2hlbWE6IG9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vZGU6IGUsXG4gICAgICByZXF1aXJlZEV4dGVuc2lvbnM6IHQsXG4gICAgICB0b0ludGVybmFsSFRNTDogeXQsXG4gICAgICB0b0V4dGVybmFsSFRNTDogeXRcbiAgICAgIC8vIHBhcnNlOiAoKSA9PiB1bmRlZmluZWQsIC8vIHBhcnNlIHJ1bGVzIGFyZSBpbiBub2RlIGFscmVhZHlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBYdChlKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoZSkubWFwKChbbywgdF0pID0+IFtvLCB0LmNvbmZpZ10pXG4gICk7XG59XG5mdW5jdGlvbiBWbihlLCBvKSB7XG4gIGUuc3RvcEV2ZW50ID0gKHQpID0+ICh0LnR5cGUgPT09IFwibW91c2Vkb3duXCIgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgby52aWV3LmRvbS5ibHVyKCk7XG4gIH0sIDEwKSwgITApO1xufVxuZnVuY3Rpb24gVW4oZSwgbykge1xuICBjb25zdCB0ID0gW1xuICAgIHtcbiAgICAgIHRhZzogXCJbZGF0YS1jb250ZW50LXR5cGU9XCIgKyBlLnR5cGUgKyBcIl1cIixcbiAgICAgIGNvbnRlbnRFbGVtZW50OiBcIltkYXRhLWVkaXRhYmxlXVwiXG4gICAgfVxuICBdO1xuICByZXR1cm4gbyAmJiB0LnB1c2goe1xuICAgIHRhZzogXCIqXCIsXG4gICAgZ2V0QXR0cnMobikge1xuICAgICAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHIgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvKG4pO1xuICAgICAgcmV0dXJuIHIgPT09IHZvaWQgMCA/ICExIDogcjtcbiAgICB9XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gU2UoZSwgbykge1xuICBjb25zdCB0ID0gVyh7XG4gICAgbmFtZTogZS50eXBlLFxuICAgIGNvbnRlbnQ6IGUuY29udGVudCA9PT0gXCJpbmxpbmVcIiA/IFwiaW5saW5lKlwiIDogXCJcIixcbiAgICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgICBzZWxlY3RhYmxlOiBlLmlzU2VsZWN0YWJsZSA/PyAhMCxcbiAgICBpc29sYXRpbmc6ICEwLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gRWUoZS5wcm9wU2NoZW1hKTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgIHJldHVybiBVbihlLCBvLnBhcnNlKTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogbiB9KSB7XG4gICAgICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHJldHVybiBUZShcbiAgICAgICAge1xuICAgICAgICAgIGRvbTogcixcbiAgICAgICAgICBjb250ZW50RE9NOiBlLmNvbnRlbnQgPT09IFwiaW5saW5lXCIgPyByIDogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIGUudHlwZSxcbiAgICAgICAge30sXG4gICAgICAgIGUucHJvcFNjaGVtYSxcbiAgICAgICAgZS5pc0ZpbGVCbG9jayxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICB9LFxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgcmV0dXJuICh7IGdldFBvczogbiB9KSA9PiB7XG4gICAgICAgIHZhciBsO1xuICAgICAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmVkaXRvciwgcyA9IFJuKFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcixcbiAgICAgICAgICB0aGlzLmVkaXRvcixcbiAgICAgICAgICBlLnR5cGVcbiAgICAgICAgKSwgaSA9ICgobCA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogbC5ibG9ja0NvbnRlbnQpIHx8IHt9LCBhID0gby5yZW5kZXIocywgciksIGMgPSBUZShcbiAgICAgICAgICBhLFxuICAgICAgICAgIHMudHlwZSxcbiAgICAgICAgICBzLnByb3BzLFxuICAgICAgICAgIGUucHJvcFNjaGVtYSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlLmlzU2VsZWN0YWJsZSA9PT0gITEgJiYgVm4oYywgdGhpcy5lZGl0b3IpLCBjO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodC5uYW1lICE9PSBlLnR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJOb2RlIG5hbWUgZG9lcyBub3QgbWF0Y2ggYmxvY2sgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBCbG9ja05vdGUuXCJcbiAgICApO1xuICByZXR1cm4gS3QoZSwge1xuICAgIG5vZGU6IHQsXG4gICAgdG9JbnRlcm5hbEhUTUw6IChuLCByKSA9PiB7XG4gICAgICB2YXIgYTtcbiAgICAgIGNvbnN0IHMgPSAoKGEgPSB0Lm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuYmxvY2tDb250ZW50KSB8fCB7fSwgaSA9IG8ucmVuZGVyKG4sIHIpO1xuICAgICAgcmV0dXJuIFRlKFxuICAgICAgICBpLFxuICAgICAgICBuLnR5cGUsXG4gICAgICAgIG4ucHJvcHMsXG4gICAgICAgIGUucHJvcFNjaGVtYSxcbiAgICAgICAgZS5pc0ZpbGVCbG9jayxcbiAgICAgICAgc1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIG5vdCBoYXZlIHdyYXBJbkJsb2NrU3RydWN0dXJlIGFuZCBnZW5lcmFsbHkgYmUgYSBsb3Qgc2ltcGxlclxuICAgIC8vIHBvc3QtcHJvY2Vzc2luZyBpbiBleHRlcm5hbEhUTUxFeHBvcnRlciBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeVxuICAgIHRvRXh0ZXJuYWxIVE1MOiAobiwgcikgPT4ge1xuICAgICAgdmFyIGEsIGM7XG4gICAgICBjb25zdCBzID0gKChhID0gdC5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBhLmJsb2NrQ29udGVudCkgfHwge307XG4gICAgICBsZXQgaSA9IChjID0gby50b0V4dGVybmFsSFRNTCkgPT0gbnVsbCA/IHZvaWQgMCA6IGMuY2FsbChcbiAgICAgICAgbyxcbiAgICAgICAgbixcbiAgICAgICAgclxuICAgICAgKTtcbiAgICAgIHJldHVybiBpID09PSB2b2lkIDAgJiYgKGkgPSBvLnJlbmRlcihuLCByKSksIFRlKFxuICAgICAgICBpLFxuICAgICAgICBuLnR5cGUsXG4gICAgICAgIG4ucHJvcHMsXG4gICAgICAgIGUucHJvcFNjaGVtYSxcbiAgICAgICAgc1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSnQoZSwgbywgdCkge1xuICB2YXIgcywgaTtcbiAgY29uc3QgbiA9IHtcbiAgICB0eXBlOiBcInRhYmxlQ29udGVudFwiLFxuICAgIGNvbHVtbldpZHRoczogW10sXG4gICAgaGVhZGVyUm93czogdm9pZCAwLFxuICAgIGhlYWRlckNvbHM6IHZvaWQgMCxcbiAgICByb3dzOiBbXVxuICB9LCByID0gW107XG4gIGUuY29udGVudC5mb3JFYWNoKChhLCBjLCBsKSA9PiB7XG4gICAgY29uc3QgZCA9IHtcbiAgICAgIGNlbGxzOiBbXVxuICAgIH07XG4gICAgbCA9PT0gMCAmJiBhLmNvbnRlbnQuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgbGV0IGggPSBwLmF0dHJzLmNvbHdpZHRoO1xuICAgICAgaCA9PSBudWxsICYmIChoID0gbmV3IEFycmF5KHAuYXR0cnMuY29sc3BhbiA/PyAxKS5maWxsKHZvaWQgMCkpLCBuLmNvbHVtbldpZHRocy5wdXNoKC4uLmgpO1xuICAgIH0pLCBkLmNlbGxzID0gYS5jb250ZW50LmNvbnRlbnQubWFwKChwLCBoKSA9PiAocltsXSB8fCAocltsXSA9IFtdKSwgcltsXVtoXSA9IHAudHlwZS5uYW1lID09PSBcInRhYmxlSGVhZGVyXCIsIHtcbiAgICAgIHR5cGU6IFwidGFibGVDZWxsXCIsXG4gICAgICBjb250ZW50OiBwLmNvbnRlbnQuY29udGVudC5tYXAoXG4gICAgICAgIChtKSA9PiBfZShtLCBvLCB0KVxuICAgICAgKS5yZWR1Y2UoKG0sIGcpID0+IHtcbiAgICAgICAgaWYgKCFtLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgY29uc3QgYiA9IG1bbS5sZW5ndGggLSAxXSwgayA9IGdbMF07XG4gICAgICAgIHJldHVybiBrICYmIEooYikgJiYgSihrKSAmJiBKU09OLnN0cmluZ2lmeShiLnN0eWxlcykgPT09IEpTT04uc3RyaW5naWZ5KGsuc3R5bGVzKSA/IChiLnRleHQgKz0gYFxuYCArIGsudGV4dCwgbS5wdXNoKC4uLmcuc2xpY2UoMSkpLCBtKSA6IChtLnB1c2goLi4uZyksIG0pO1xuICAgICAgfSwgW10pLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29sc3BhbjogcC5hdHRycy5jb2xzcGFuLFxuICAgICAgICByb3dzcGFuOiBwLmF0dHJzLnJvd3NwYW4sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcC5hdHRycy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIHRleHRDb2xvcjogcC5hdHRycy50ZXh0Q29sb3IsXG4gICAgICAgIHRleHRBbGlnbm1lbnQ6IHAuYXR0cnMudGV4dEFsaWdubWVudFxuICAgICAgfVxuICAgIH0pKSwgbi5yb3dzLnB1c2goZCk7XG4gIH0pO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IHIubGVuZ3RoOyBhKyspXG4gICAgKHMgPSByW2FdKSAhPSBudWxsICYmIHMuZXZlcnkoKGMpID0+IGMpICYmIChuLmhlYWRlclJvd3MgPSAobi5oZWFkZXJSb3dzID8/IDApICsgMSk7XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgKChpID0gclswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkubGVuZ3RoKTsgYSsrKVxuICAgIHIgIT0gbnVsbCAmJiByLmV2ZXJ5KChjKSA9PiBjW2FdKSAmJiAobi5oZWFkZXJDb2xzID0gKG4uaGVhZGVyQ29scyA/PyAwKSArIDEpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9lKGUsIG8sIHQpIHtcbiAgY29uc3QgbiA9IFtdO1xuICBsZXQgcjtcbiAgcmV0dXJuIGUuY29udGVudC5mb3JFYWNoKChzKSA9PiB7XG4gICAgaWYgKHMudHlwZS5uYW1lID09PSBcImhhcmRCcmVha1wiKSB7XG4gICAgICBpZiAocilcbiAgICAgICAgaWYgKEoocikpXG4gICAgICAgICAgci50ZXh0ICs9IGBcbmA7XG4gICAgICAgIGVsc2UgaWYgKHd0KHIpKVxuICAgICAgICAgIHIuY29udGVudFtyLmNvbnRlbnQubGVuZ3RoIC0gMV0udGV4dCArPSBgXG5gO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgciA9IHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiBgXG5gLFxuICAgICAgICAgIHN0eWxlczoge31cbiAgICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHMudHlwZS5uYW1lICE9PSBcImxpbmtcIiAmJiBzLnR5cGUubmFtZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmICghb1tzLnR5cGUubmFtZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidW5yZWNvZ25pemVkIGlubGluZSBjb250ZW50IHR5cGVcIiwgcy50eXBlLm5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByICYmIChuLnB1c2gociksIHIgPSB2b2lkIDApLCBuLnB1c2goXG4gICAgICAgIFplKHMsIG8sIHQpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0ge307XG4gICAgbGV0IGE7XG4gICAgZm9yIChjb25zdCBjIG9mIHMubWFya3MpXG4gICAgICBpZiAoYy50eXBlLm5hbWUgPT09IFwibGlua1wiKVxuICAgICAgICBhID0gYztcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsID0gdFtjLnR5cGUubmFtZV07XG4gICAgICAgIGlmICghbCkge1xuICAgICAgICAgIGlmIChjLnR5cGUuc3BlYy5ibG9ja25vdGVJZ25vcmUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0eWxlICR7Yy50eXBlLm5hbWV9IG5vdCBmb3VuZCBpbiBzdHlsZVNjaGVtYWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsLnByb3BTY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgIGlbbC50eXBlXSA9ICEwO1xuICAgICAgICBlbHNlIGlmIChsLnByb3BTY2hlbWEgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgaVtsLnR5cGVdID0gYy5hdHRycy5zdHJpbmdWYWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyAkKGwucHJvcFNjaGVtYSk7XG4gICAgICB9XG4gICAgciA/IEoocikgPyBhID8gKG4ucHVzaChyKSwgciA9IHtcbiAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgaHJlZjogYS5hdHRycy5ocmVmLFxuICAgICAgY29udGVudDogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogcy50ZXh0Q29udGVudCxcbiAgICAgICAgICBzdHlsZXM6IGlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pIDogSlNPTi5zdHJpbmdpZnkoci5zdHlsZXMpID09PSBKU09OLnN0cmluZ2lmeShpKSA/IHIudGV4dCArPSBzLnRleHRDb250ZW50IDogKG4ucHVzaChyKSwgciA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcy50ZXh0Q29udGVudCxcbiAgICAgIHN0eWxlczogaVxuICAgIH0pIDogd3QocikgJiYgKGEgPyByLmhyZWYgPT09IGEuYXR0cnMuaHJlZiA/IEpTT04uc3RyaW5naWZ5KFxuICAgICAgci5jb250ZW50W3IuY29udGVudC5sZW5ndGggLSAxXS5zdHlsZXNcbiAgICApID09PSBKU09OLnN0cmluZ2lmeShpKSA/IHIuY29udGVudFtyLmNvbnRlbnQubGVuZ3RoIC0gMV0udGV4dCArPSBzLnRleHRDb250ZW50IDogci5jb250ZW50LnB1c2goe1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBzLnRleHRDb250ZW50LFxuICAgICAgc3R5bGVzOiBpXG4gICAgfSkgOiAobi5wdXNoKHIpLCByID0ge1xuICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICBocmVmOiBhLmF0dHJzLmhyZWYsXG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiBzLnRleHRDb250ZW50LFxuICAgICAgICAgIHN0eWxlczogaVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSkgOiAobi5wdXNoKHIpLCByID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBzLnRleHRDb250ZW50LFxuICAgICAgc3R5bGVzOiBpXG4gICAgfSkpIDogYSA/IHIgPSB7XG4gICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgIGhyZWY6IGEuYXR0cnMuaHJlZixcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IHMudGV4dENvbnRlbnQsXG4gICAgICAgICAgc3R5bGVzOiBpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9IDogciA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcy50ZXh0Q29udGVudCxcbiAgICAgIHN0eWxlczogaVxuICAgIH07XG4gIH0pLCByICYmIG4ucHVzaChyKSwgbjtcbn1cbmZ1bmN0aW9uIFplKGUsIG8sIHQpIHtcbiAgaWYgKGUudHlwZS5uYW1lID09PSBcInRleHRcIiB8fCBlLnR5cGUubmFtZSA9PT0gXCJsaW5rXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcbiAgY29uc3QgbiA9IHt9LCByID0gb1tlLnR5cGUubmFtZV07XG4gIGZvciAoY29uc3QgW2EsIGNdIG9mIE9iamVjdC5lbnRyaWVzKGUuYXR0cnMpKSB7XG4gICAgaWYgKCFyKVxuICAgICAgdGhyb3cgRXJyb3IoXCJpYyBub2RlIGlzIG9mIGFuIHVucmVjb2duaXplZCB0eXBlOiBcIiArIGUudHlwZS5uYW1lKTtcbiAgICBjb25zdCBsID0gci5wcm9wU2NoZW1hO1xuICAgIGEgaW4gbCAmJiAoblthXSA9IGMpO1xuICB9XG4gIGxldCBzO1xuICByZXR1cm4gci5jb250ZW50ID09PSBcInN0eWxlZFwiID8gcyA9IF9lKFxuICAgIGUsXG4gICAgbyxcbiAgICB0XG4gICkgOiBzID0gdm9pZCAwLCB7XG4gICAgdHlwZTogZS50eXBlLm5hbWUsXG4gICAgcHJvcHM6IG4sXG4gICAgY29udGVudDogc1xuICB9O1xufVxuZnVuY3Rpb24gRShlLCBvLCB0LCBuLCByKSB7XG4gIHZhciBtO1xuICBpZiAoIWUudHlwZS5pc0luR3JvdXAoXCJibkJsb2NrXCIpKVxuICAgIHRocm93IEVycm9yKFxuICAgICAgXCJOb2RlIG11c3QgYmUgaW4gYm5CbG9jayBncm91cCwgYnV0IGlzIG9mIHR5cGVcIiArIGUudHlwZS5uYW1lXG4gICAgKTtcbiAgY29uc3QgcyA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZ2V0KGUpO1xuICBpZiAocylcbiAgICByZXR1cm4gcztcbiAgY29uc3QgaSA9IHN0KGUsIDApO1xuICBsZXQgYSA9IGkuYm5CbG9jay5ub2RlLmF0dHJzLmlkO1xuICBhID09PSBudWxsICYmIChhID0gdmUub3B0aW9ucy5nZW5lcmF0ZUlEKCkpO1xuICBjb25zdCBjID0gb1tpLmJsb2NrTm90ZVR5cGVdO1xuICBpZiAoIWMpXG4gICAgdGhyb3cgRXJyb3IoXCJCbG9jayBpcyBvZiBhbiB1bnJlY29nbml6ZWQgdHlwZTogXCIgKyBpLmJsb2NrTm90ZVR5cGUpO1xuICBjb25zdCBsID0ge307XG4gIGZvciAoY29uc3QgW2csIGJdIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAuLi5lLmF0dHJzLFxuICAgIC4uLmkuaXNCbG9ja0NvbnRhaW5lciA/IGkuYmxvY2tDb250ZW50Lm5vZGUuYXR0cnMgOiB7fVxuICB9KSkge1xuICAgIGNvbnN0IGsgPSBjLnByb3BTY2hlbWE7XG4gICAgZyBpbiBrICYmICEoa1tnXS5kZWZhdWx0ID09PSB2b2lkIDAgJiYgYiA9PT0gdm9pZCAwKSAmJiAobFtnXSA9IGIpO1xuICB9XG4gIGNvbnN0IGQgPSBvW2kuYmxvY2tOb3RlVHlwZV0sIHAgPSBbXTtcbiAgKG0gPSBpLmNoaWxkQ29udGFpbmVyKSA9PSBudWxsIHx8IG0ubm9kZS5mb3JFYWNoKChnKSA9PiB7XG4gICAgcC5wdXNoKFxuICAgICAgRShcbiAgICAgICAgZyxcbiAgICAgICAgbyxcbiAgICAgICAgdCxcbiAgICAgICAgbixcbiAgICAgICAgclxuICAgICAgKVxuICAgICk7XG4gIH0pO1xuICBsZXQgaDtcbiAgaWYgKGQuY29udGVudCA9PT0gXCJpbmxpbmVcIikge1xuICAgIGlmICghaS5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wb3NzaWJsZVwiKTtcbiAgICBoID0gX2UoXG4gICAgICBpLmJsb2NrQ29udGVudC5ub2RlLFxuICAgICAgdCxcbiAgICAgIG5cbiAgICApO1xuICB9IGVsc2UgaWYgKGQuY29udGVudCA9PT0gXCJ0YWJsZVwiKSB7XG4gICAgaWYgKCFpLmlzQmxvY2tDb250YWluZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvc3NpYmxlXCIpO1xuICAgIGggPSBKdChcbiAgICAgIGkuYmxvY2tDb250ZW50Lm5vZGUsXG4gICAgICB0LFxuICAgICAgblxuICAgICk7XG4gIH0gZWxzZSBpZiAoZC5jb250ZW50ID09PSBcIm5vbmVcIilcbiAgICBoID0gdm9pZCAwO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3ICQoZC5jb250ZW50KTtcbiAgY29uc3QgZiA9IHtcbiAgICBpZDogYSxcbiAgICB0eXBlOiBkLnR5cGUsXG4gICAgcHJvcHM6IGwsXG4gICAgY29udGVudDogaCxcbiAgICBjaGlsZHJlbjogcFxuICB9O1xuICByZXR1cm4gciA9PSBudWxsIHx8IHIuc2V0KGUsIGYpLCBmO1xufVxuZnVuY3Rpb24gQ3QoZSwgbywgdCwgbikge1xuICByZXR1cm4gZS5kb20uc2V0QXR0cmlidXRlKFwiZGF0YS1pbmxpbmUtY29udGVudC10eXBlXCIsIG8pLCBPYmplY3QuZW50cmllcyh0KS5maWx0ZXIoKFtyLCBzXSkgPT4ge1xuICAgIGNvbnN0IGkgPSBuW3JdO1xuICAgIHJldHVybiBzICE9PSBpLmRlZmF1bHQ7XG4gIH0pLm1hcCgoW3IsIHNdKSA9PiBbSGUociksIHNdKS5mb3JFYWNoKChbciwgc10pID0+IGUuZG9tLnNldEF0dHJpYnV0ZShyLCBzKSksIGUuY29udGVudERPTSAhPT0gdm9pZCAwICYmIGUuY29udGVudERPTS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRhYmxlXCIsIFwiXCIpLCBlO1xufVxuZnVuY3Rpb24gJG4oZSkge1xuICByZXR1cm4ge1xuICAgIEJhY2tzcGFjZTogKHsgZWRpdG9yOiBvIH0pID0+IHtcbiAgICAgIGNvbnN0IHQgPSBvLnN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICAgIHJldHVybiBvLnN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiB0Lm5vZGUoKS50eXBlLm5hbWUgPT09IGUudHlwZSAmJiB0LnBhcmVudE9mZnNldCA9PT0gMDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBGbihlLCBvKSB7XG4gIHJldHVybiB7XG4gICAgY29uZmlnOiBlLFxuICAgIGltcGxlbWVudGF0aW9uOiBvXG4gIH07XG59XG5mdW5jdGlvbiB6bihlLCBvKSB7XG4gIHJldHVybiBGbihcbiAgICB7XG4gICAgICB0eXBlOiBlLm5hbWUsXG4gICAgICBwcm9wU2NoZW1hOiBvLFxuICAgICAgY29udGVudDogZS5jb25maWcuY29udGVudCA9PT0gXCJpbmxpbmUqXCIgPyBcInN0eWxlZFwiIDogXCJub25lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5vZGU6IGVcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBZdChlKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoZSkubWFwKChbbywgdF0pID0+IFtvLCB0LmNvbmZpZ10pXG4gICk7XG59XG5mdW5jdGlvbiBXbihlKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgdGFnOiBgW2RhdGEtaW5saW5lLWNvbnRlbnQtdHlwZT1cIiR7ZS50eXBlfVwiXWAsXG4gICAgICBjb250ZW50RWxlbWVudDogKG8pID0+IHtcbiAgICAgICAgY29uc3QgdCA9IG87XG4gICAgICAgIHJldHVybiB0Lm1hdGNoZXMoXCJbZGF0YS1lZGl0YWJsZV1cIikgPyB0IDogdC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZWRpdGFibGVdXCIpIHx8IHQ7XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gcmMoZSwgbykge1xuICBjb25zdCB0ID0gc2UuY3JlYXRlKHtcbiAgICBuYW1lOiBlLnR5cGUsXG4gICAgaW5saW5lOiAhMCxcbiAgICBncm91cDogXCJpbmxpbmVcIixcbiAgICBzZWxlY3RhYmxlOiBlLmNvbnRlbnQgPT09IFwic3R5bGVkXCIsXG4gICAgYXRvbTogZS5jb250ZW50ID09PSBcIm5vbmVcIixcbiAgICBjb250ZW50OiBlLmNvbnRlbnQgPT09IFwic3R5bGVkXCIgPyBcImlubGluZSpcIiA6IFwiXCIsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBFZShlLnByb3BTY2hlbWEpO1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICByZXR1cm4gJG4oZSk7XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICByZXR1cm4gV24oZSk7XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbm9kZTogbiB9KSB7XG4gICAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmVkaXRvciwgcyA9IG8ucmVuZGVyKFxuICAgICAgICBaZShcbiAgICAgICAgICBuLFxuICAgICAgICAgIHIuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICAgICAgci5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgICAgICAgKSxcbiAgICAgICAgLy8gVE9ETzogZml4IGNhc3RcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICByXG4gICAgICApO1xuICAgICAgcmV0dXJuIEN0KFxuICAgICAgICBzLFxuICAgICAgICBlLnR5cGUsXG4gICAgICAgIG4uYXR0cnMsXG4gICAgICAgIGUucHJvcFNjaGVtYVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgcmV0dXJuICh7IG5vZGU6IG4sIGdldFBvczogciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLm9wdGlvbnMuZWRpdG9yLCBpID0gby5yZW5kZXIoXG4gICAgICAgICAgWmUoXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgcy5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgICAgIHMuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBUT0RPOiBmaXggY2FzdFxuICAgICAgICAgIChhKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBPKFxuICAgICAgICAgICAgICBbYV0sXG4gICAgICAgICAgICAgIHMuX3RpcHRhcEVkaXRvci5zY2hlbWEsXG4gICAgICAgICAgICAgIHMuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcy5kaXNwYXRjaChcbiAgICAgICAgICAgICAgcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUudHIucmVwbGFjZVdpdGgoXG4gICAgICAgICAgICAgICAgcigpLFxuICAgICAgICAgICAgICAgIHIoKSArIG4ubm9kZVNpemUsXG4gICAgICAgICAgICAgICAgY1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gQ3QoXG4gICAgICAgICAgaSxcbiAgICAgICAgICBlLnR5cGUsXG4gICAgICAgICAgbi5hdHRycyxcbiAgICAgICAgICBlLnByb3BTY2hlbWFcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHpuKFxuICAgIHQsXG4gICAgZS5wcm9wU2NoZW1hXG4gICk7XG59XG5mdW5jdGlvbiBqbihlKSB7XG4gIHJldHVybiBlID09PSBcImJvb2xlYW5cIiA/IHt9IDoge1xuICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICBkZWZhdWx0OiB2b2lkIDAsXG4gICAgICBrZWVwT25TcGxpdDogITAsXG4gICAgICBwYXJzZUhUTUw6IChvKSA9PiBvLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiksXG4gICAgICByZW5kZXJIVE1MOiAobykgPT4gby5zdHJpbmdWYWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICBcImRhdGEtdmFsdWVcIjogby5zdHJpbmdWYWx1ZVxuICAgICAgfSA6IHt9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gR24oZSwgbywgdCwgbikge1xuICByZXR1cm4gZS5kb20uc2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZS10eXBlXCIsIG8pLCBuID09PSBcInN0cmluZ1wiICYmIGUuZG9tLnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgdCksIGUuY29udGVudERPTSAhPT0gdm9pZCAwICYmIGUuY29udGVudERPTS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRhYmxlXCIsIFwiXCIpLCBlO1xufVxuZnVuY3Rpb24gWnQoZSwgbykge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZzogZSxcbiAgICBpbXBsZW1lbnRhdGlvbjogb1xuICB9O1xufVxuZnVuY3Rpb24gZWUoZSwgbykge1xuICByZXR1cm4gWnQoXG4gICAge1xuICAgICAgdHlwZTogZS5uYW1lLFxuICAgICAgcHJvcFNjaGVtYTogb1xuICAgIH0sXG4gICAge1xuICAgICAgbWFyazogZVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIFF0KGUpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhlKS5tYXAoKFtvLCB0XSkgPT4gW28sIHQuY29uZmlnXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHFuKGUpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0YWc6IGBbZGF0YS1zdHlsZS10eXBlPVwiJHtlLnR5cGV9XCJdYCxcbiAgICAgIGNvbnRlbnRFbGVtZW50OiAobykgPT4ge1xuICAgICAgICBjb25zdCB0ID0gbztcbiAgICAgICAgcmV0dXJuIHQubWF0Y2hlcyhcIltkYXRhLWVkaXRhYmxlXVwiKSA/IHQgOiB0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1lZGl0YWJsZV1cIikgfHwgdDtcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBzYyhlLCBvKSB7XG4gIGNvbnN0IHQgPSBrZS5jcmVhdGUoe1xuICAgIG5hbWU6IGUudHlwZSxcbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgcmV0dXJuIGpuKGUucHJvcFNjaGVtYSk7XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICByZXR1cm4gcW4oZSk7XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbWFyazogbiB9KSB7XG4gICAgICBsZXQgcjtcbiAgICAgIGlmIChlLnByb3BTY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByID0gby5yZW5kZXIoKTtcbiAgICAgIGVsc2UgaWYgKGUucHJvcFNjaGVtYSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgciA9IG8ucmVuZGVyKG4uYXR0cnMuc3RyaW5nVmFsdWUpO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgJChlLnByb3BTY2hlbWEpO1xuICAgICAgcmV0dXJuIEduKFxuICAgICAgICByLFxuICAgICAgICBlLnR5cGUsXG4gICAgICAgIG4uYXR0cnMuc3RyaW5nVmFsdWUsXG4gICAgICAgIGUucHJvcFNjaGVtYVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gWnQoZSwge1xuICAgIG1hcms6IHRcbiAgfSk7XG59XG5mdW5jdGlvbiBRKGUpIHtcbiAgY29uc3QgeyBoZWlnaHQ6IG8sIHdpZHRoOiB0IH0gPSBjdChlKSwgbiA9IG5ldyBBcnJheShvKS5maWxsKCExKS5tYXAoKCkgPT4gbmV3IEFycmF5KHQpLmZpbGwobnVsbCkpLCByID0gKHMsIGkpID0+IHtcbiAgICBmb3IgKGxldCBhID0gczsgYSA8IG87IGErKylcbiAgICAgIGZvciAobGV0IGMgPSBpOyBjIDwgdDsgYysrKVxuICAgICAgICBpZiAoIW5bYV1bY10pXG4gICAgICAgICAgcmV0dXJuIHsgcm93OiBhLCBjb2w6IGMgfTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuYWJsZSB0byBjcmVhdGUgb2NjdXBhbmN5IGdyaWQgZm9yIHRhYmxlLCBubyBtb3JlIGF2YWlsYWJsZSBjZWxsc1wiXG4gICAgKTtcbiAgfTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmNvbnRlbnQucm93cy5sZW5ndGg7IHMrKylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGUuY29udGVudC5yb3dzW3NdLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gSmUoZS5jb250ZW50LnJvd3Nbc10uY2VsbHNbaV0pLCBjID0gWWUoYSksIGwgPSBnZShhKSwgeyByb3c6IGQsIGNvbDogcCB9ID0gcihzLCBpKTtcbiAgICAgIGZvciAobGV0IGggPSBkOyBoIDwgZCArIGM7IGgrKylcbiAgICAgICAgZm9yIChsZXQgZiA9IHA7IGYgPCBwICsgbDsgZisrKSB7XG4gICAgICAgICAgaWYgKG5baF1bZl0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmFibGUgdG8gY3JlYXRlIG9jY3VwYW5jeSBncmlkIGZvciB0YWJsZSwgY2VsbCBhdCAke2h9LCR7Zn0gaXMgYWxyZWFkeSBvY2N1cGllZGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbltoXVtmXSA9IHtcbiAgICAgICAgICAgIHJvdzogcyxcbiAgICAgICAgICAgIGNvbDogaSxcbiAgICAgICAgICAgIHJvd3NwYW46IGMsXG4gICAgICAgICAgICBjb2xzcGFuOiBsLFxuICAgICAgICAgICAgY2VsbDogYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gYmUoZSkge1xuICBjb25zdCBvID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIGUubWFwKCh0KSA9PiAoe1xuICAgIGNlbGxzOiB0Lm1hcCgobikgPT4gby5oYXMobi5yb3cgKyBcIjpcIiArIG4uY29sKSA/ICExIDogKG8uYWRkKG4ucm93ICsgXCI6XCIgKyBuLmNvbCksIG4uY2VsbCkpLmZpbHRlcigobikgPT4gbiAhPT0gITEpXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHJlKGUsIG8sIHQgPSBRKG8pKSB7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKylcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHRbbl0ubGVuZ3RoOyByKyspIHtcbiAgICAgIGNvbnN0IHMgPSB0W25dW3JdO1xuICAgICAgaWYgKHMucm93ID09PSBlLnJvdyAmJiBzLmNvbCA9PT0gZS5jb2wpXG4gICAgICAgIHJldHVybiB7IHJvdzogbiwgY29sOiByLCBjZWxsOiBzLmNlbGwgfTtcbiAgICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVW5hYmxlIHRvIHJlc29sdmUgcmVsYXRpdmUgdGFibGUgY2VsbCBpbmRpY2VzIGZvciB0YWJsZSwgY2VsbCBhdCAke2Uucm93fSwke2UuY29sfSBpcyBub3Qgb2NjdXBpZWRgXG4gICk7XG59XG5mdW5jdGlvbiBjdChlKSB7XG4gIGNvbnN0IG8gPSBlLmNvbnRlbnQucm93cy5sZW5ndGg7XG4gIGxldCB0ID0gMDtcbiAgcmV0dXJuIGUuY29udGVudC5yb3dzLmZvckVhY2goKG4pID0+IHtcbiAgICBsZXQgciA9IDA7XG4gICAgbi5jZWxscy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICByICs9IGdlKHMpO1xuICAgIH0pLCB0ID0gTWF0aC5tYXgodCwgcik7XG4gIH0pLCB7IGhlaWdodDogbywgd2lkdGg6IHQgfTtcbn1cbmZ1bmN0aW9uIGVvKGUsIG8sIHQgPSBRKG8pKSB7XG4gIHZhciByO1xuICBjb25zdCBuID0gKHIgPSB0W2Uucm93XSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJbZS5jb2xdO1xuICBpZiAobilcbiAgICByZXR1cm4ge1xuICAgICAgcm93OiBuLnJvdyxcbiAgICAgIGNvbDogbi5jb2wsXG4gICAgICBjZWxsOiBuLmNlbGxcbiAgICB9O1xufVxuZnVuY3Rpb24gUWUoZSwgbykge1xuICB2YXIgcztcbiAgY29uc3QgdCA9IFEoZSk7XG4gIGlmIChvIDwgMCB8fCBvID49IHQubGVuZ3RoKVxuICAgIHJldHVybiBbXTtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG87IGkrKykge1xuICAgIGNvbnN0IGEgPSAocyA9IHRbbl0pID09IG51bGwgPyB2b2lkIDAgOiBzWzBdO1xuICAgIGlmICghYSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBuICs9IGEucm93c3BhbjtcbiAgfVxuICBjb25zdCByID0gbmV3IEFycmF5KHRbMF0ubGVuZ3RoKS5maWxsKCExKS5tYXAoKGksIGEpID0+IGVvKFxuICAgIHsgcm93OiBuLCBjb2w6IGEgfSxcbiAgICBlLFxuICAgIHRcbiAgKSkuZmlsdGVyKFxuICAgIChpKSA9PiBpICE9PSB2b2lkIDBcbiAgKTtcbiAgcmV0dXJuIHIuZmlsdGVyKChpLCBhKSA9PiByLmZpbmRJbmRleCgoYykgPT4gYy5yb3cgPT09IGkucm93ICYmIGMuY29sID09PSBpLmNvbCkgPT09IGEpO1xufVxuZnVuY3Rpb24gZXQoZSwgbykge1xuICB2YXIgcztcbiAgY29uc3QgdCA9IFEoZSk7XG4gIGlmIChvIDwgMCB8fCBvID49IHRbMF0ubGVuZ3RoKVxuICAgIHJldHVybiBbXTtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG87IGkrKykge1xuICAgIGNvbnN0IGEgPSAocyA9IHRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBzW25dO1xuICAgIGlmICghYSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBuICs9IGEuY29sc3BhbjtcbiAgfVxuICBjb25zdCByID0gbmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKCExKS5tYXAoKGksIGEpID0+IGVvKFxuICAgIHsgcm93OiBhLCBjb2w6IG4gfSxcbiAgICBlLFxuICAgIHRcbiAgKSkuZmlsdGVyKFxuICAgIChpKSA9PiBpICE9PSB2b2lkIDBcbiAgKTtcbiAgcmV0dXJuIHIuZmlsdGVyKChpLCBhKSA9PiByLmZpbmRJbmRleCgoYykgPT4gYy5yb3cgPT09IGkucm93ICYmIGMuY29sID09PSBpLmNvbCkgPT09IGEpO1xufVxuZnVuY3Rpb24gS24oZSwgbywgdCwgbiA9IFEoZSkpIHtcbiAgY29uc3QgeyBjb2w6IHIgfSA9IHJlKFxuICAgIHtcbiAgICAgIHJvdzogMCxcbiAgICAgIGNvbDogb1xuICAgIH0sXG4gICAgZSxcbiAgICBuXG4gICksIHsgY29sOiBzIH0gPSByZShcbiAgICB7XG4gICAgICByb3c6IDAsXG4gICAgICBjb2w6IHRcbiAgICB9LFxuICAgIGUsXG4gICAgblxuICApO1xuICByZXR1cm4gbi5mb3JFYWNoKChpKSA9PiB7XG4gICAgY29uc3QgW2FdID0gaS5zcGxpY2UociwgMSk7XG4gICAgaS5zcGxpY2UocywgMCwgYSk7XG4gIH0pLCBiZShuKTtcbn1cbmZ1bmN0aW9uIFhuKGUsIG8sIHQsIG4gPSBRKGUpKSB7XG4gIGNvbnN0IHsgcm93OiByIH0gPSByZShcbiAgICB7XG4gICAgICByb3c6IG8sXG4gICAgICBjb2w6IDBcbiAgICB9LFxuICAgIGUsXG4gICAgblxuICApLCB7IHJvdzogcyB9ID0gcmUoXG4gICAge1xuICAgICAgcm93OiB0LFxuICAgICAgY29sOiAwXG4gICAgfSxcbiAgICBlLFxuICAgIG5cbiAgKSwgW2ldID0gbi5zcGxpY2UociwgMSk7XG4gIHJldHVybiBuLnNwbGljZShzLCAwLCBpKSwgYmUobik7XG59XG5mdW5jdGlvbiB0dChlKSB7XG4gIHJldHVybiBlID8gbWUoZSkgPyB0dChlLmNvbnRlbnQpIDogdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUubGVuZ3RoID09PSAwIDogQXJyYXkuaXNBcnJheShlKSA/IGUuZXZlcnkoXG4gICAgKG8pID0+IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyBvLmxlbmd0aCA9PT0gMCA6IEoobykgPyBvLnRleHQubGVuZ3RoID09PSAwIDogaXQobykgPyB0eXBlb2Ygby5jb250ZW50ID09IFwic3RyaW5nXCIgPyBvLmNvbnRlbnQubGVuZ3RoID09PSAwIDogby5jb250ZW50LmV2ZXJ5KCh0KSA9PiB0LnRleHQubGVuZ3RoID09PSAwKSA6ICExXG4gICkgOiAhMSA6ICEwO1xufVxuZnVuY3Rpb24gSm4oZSwgbywgdCA9IFEoZSkpIHtcbiAgaWYgKG8gPT09IFwiY29sdW1uc1wiKSB7XG4gICAgbGV0IHMgPSAwO1xuICAgIGZvciAobGV0IGkgPSB0WzBdLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0LmV2ZXJ5KFxuICAgICAgKGMpID0+IHR0KGNbaV0uY2VsbCkgJiYgY1tpXS5jb2xzcGFuID09PSAxXG4gICAgKTsgaS0tKVxuICAgICAgcysrO1xuICAgIGZvciAobGV0IGkgPSB0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5tYXgoXG4gICAgICAgIHRbaV0ubGVuZ3RoIC0gcyxcbiAgICAgICAgMVxuICAgICAgKTtcbiAgICAgIHRbaV0gPSB0W2ldLnNsaWNlKDAsIGEpO1xuICAgIH1cbiAgICByZXR1cm4gYmUodCk7XG4gIH1cbiAgbGV0IG4gPSAwO1xuICBmb3IgKGxldCBzID0gdC5sZW5ndGggLSAxOyBzID49IDAgJiYgdFtzXS5ldmVyeShcbiAgICAoYSkgPT4gdHQoYS5jZWxsKSAmJiBhLnJvd3NwYW4gPT09IDFcbiAgKTsgcy0tKVxuICAgIG4rKztcbiAgY29uc3QgciA9IE1hdGgubWluKG4sIHQubGVuZ3RoIC0gMSk7XG4gIHJldHVybiB0LnNwbGljZSh0Lmxlbmd0aCAtIHIsIHIpLCBiZSh0KTtcbn1cbmZ1bmN0aW9uIFluKGUsIG8sIHQsIG4gPSBRKGUpKSB7XG4gIGNvbnN0IHsgd2lkdGg6IHIsIGhlaWdodDogcyB9ID0gY3QoZSk7XG4gIGlmIChvID09PSBcImNvbHVtbnNcIilcbiAgICBuLmZvckVhY2goKGksIGEpID0+IHtcbiAgICAgIGlmICh0ID49IDApXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdDsgYysrKVxuICAgICAgICAgIGkucHVzaCh7XG4gICAgICAgICAgICByb3c6IGEsXG4gICAgICAgICAgICBjb2w6IE1hdGgubWF4KC4uLmkubWFwKChsKSA9PiBsLmNvbCkpICsgMSxcbiAgICAgICAgICAgIHJvd3NwYW46IDEsXG4gICAgICAgICAgICBjb2xzcGFuOiAxLFxuICAgICAgICAgICAgY2VsbDogSmUoXCJcIilcbiAgICAgICAgICB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgaS5zcGxpY2UociArIHQsIC0xICogdCk7XG4gICAgfSk7XG4gIGVsc2UgaWYgKHQgPiAwKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gbmV3IEFycmF5KHIpLmZpbGwobnVsbCkubWFwKChjLCBsKSA9PiAoe1xuICAgICAgICByb3c6IHMgKyBpLFxuICAgICAgICBjb2w6IGwsXG4gICAgICAgIHJvd3NwYW46IDEsXG4gICAgICAgIGNvbHNwYW46IDEsXG4gICAgICAgIGNlbGw6IEplKFwiXCIpXG4gICAgICB9KSk7XG4gICAgICBuLnB1c2goYSk7XG4gICAgfVxuICBlbHNlIHQgPCAwICYmIG4uc3BsaWNlKHMgKyB0LCAtMSAqIHQpO1xuICByZXR1cm4gYmUobik7XG59XG5mdW5jdGlvbiB0byhlLCBvLCB0KSB7XG4gIGNvbnN0IG4gPSBRZShlLCB0KTtcbiAgaWYgKCFuLnNvbWUoKGMpID0+IFllKGMuY2VsbCkgPiAxKSlcbiAgICByZXR1cm4gITA7XG4gIGxldCBzID0gdCwgaSA9IHQ7XG4gIHJldHVybiBuLmZvckVhY2goKGMpID0+IHtcbiAgICBjb25zdCBsID0gWWUoYy5jZWxsKTtcbiAgICBzID0gTWF0aC5tYXgocywgYy5yb3cgKyBsIC0gMSksIGkgPSBNYXRoLm1pbihpLCBjLnJvdyk7XG4gIH0pLCBvIDwgdCA/IHQgPT09IHMgOiB0ID09PSBpO1xufVxuZnVuY3Rpb24gb28oZSwgbywgdCkge1xuICBjb25zdCBuID0gZXQoZSwgdCk7XG4gIGlmICghbi5zb21lKChjKSA9PiBnZShjLmNlbGwpID4gMSkpXG4gICAgcmV0dXJuICEwO1xuICBsZXQgcyA9IHQsIGkgPSB0O1xuICByZXR1cm4gbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgY29uc3QgbCA9IGdlKGMuY2VsbCk7XG4gICAgcyA9IE1hdGgubWF4KHMsIGMuY29sICsgbCAtIDEpLCBpID0gTWF0aC5taW4oaSwgYy5jb2wpO1xuICB9KSwgbyA8IHQgPyB0ID09PSBzIDogdCA9PT0gaTtcbn1cbmZ1bmN0aW9uIFpuKGUsIG8sIHQpIHtcbiAgY29uc3QgbiA9IHJlKGUsIHQpLCByID0gcmUobywgdCk7XG4gIHJldHVybiBuLmNvbCA9PT0gci5jb2w7XG59XG5mdW5jdGlvbiB2dChlLCBvLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBbXTtcbiAgZm9yIChjb25zdCBbaSwgYV0gb2YgT2JqZWN0LmVudHJpZXMoZS5zdHlsZXMpKSB7XG4gICAgY29uc3QgYyA9IHRbaV07XG4gICAgaWYgKCFjKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHlsZSAke2l9IG5vdCBmb3VuZCBpbiBzdHlsZVNjaGVtYWApO1xuICAgIGlmIChjLnByb3BTY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgci5wdXNoKG8ubWFyayhpKSk7XG4gICAgZWxzZSBpZiAoYy5wcm9wU2NoZW1hID09PSBcInN0cmluZ1wiKVxuICAgICAgci5wdXNoKG8ubWFyayhpLCB7IHN0cmluZ1ZhbHVlOiBhIH0pKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgJChjLnByb3BTY2hlbWEpO1xuICB9XG4gIHJldHVybiAhbiB8fCAhby5ub2Rlc1tuXS5zcGVjLmNvZGUgPyBlLnRleHQuc3BsaXQoLyhcXG4pL2cpLmZpbHRlcigoaSkgPT4gaS5sZW5ndGggPiAwKS5tYXAoKGkpID0+IGkgPT09IGBcbmAgPyBvLm5vZGVzLmhhcmRCcmVhay5jcmVhdGVDaGVja2VkKCkgOiBvLnRleHQoaSwgcikpIDogW28udGV4dChlLnRleHQsIHIpXTtcbn1cbmZ1bmN0aW9uIFFuKGUsIG8sIHQpIHtcbiAgY29uc3QgbiA9IG8ubWFya3MubGluay5jcmVhdGUoe1xuICAgIGhyZWY6IGUuaHJlZlxuICB9KTtcbiAgcmV0dXJuIG90KGUuY29udGVudCwgbywgdCkubWFwKFxuICAgIChyKSA9PiB7XG4gICAgICBpZiAoci50eXBlLm5hbWUgPT09IFwidGV4dFwiKVxuICAgICAgICByZXR1cm4gci5tYXJrKFsuLi5yLm1hcmtzLCBuXSk7XG4gICAgICBpZiAoci50eXBlLm5hbWUgPT09IFwiaGFyZEJyZWFrXCIpXG4gICAgICAgIHJldHVybiByO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBub2RlIHR5cGVcIik7XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gb3QoZSwgbywgdCwgbikge1xuICBjb25zdCByID0gW107XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiByLnB1c2goXG4gICAgICAuLi52dChcbiAgICAgICAgeyB0ZXh0OiBlLCBzdHlsZXM6IHt9IH0sXG4gICAgICAgIG8sXG4gICAgICAgIHQsXG4gICAgICAgIG5cbiAgICAgIClcbiAgICApLCByO1xuICBmb3IgKGNvbnN0IHMgb2YgZSlcbiAgICByLnB1c2goXG4gICAgICAuLi52dChzLCBvLCB0LCBuKVxuICAgICk7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gTyhlLCBvLCB0LCBuKSB7XG4gIGNvbnN0IHIgPSBbXTtcbiAgZm9yIChjb25zdCBzIG9mIGUpXG4gICAgdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHIucHVzaChcbiAgICAgIC4uLm90KHMsIG8sIHQsIG4pXG4gICAgKSA6IGl0KHMpID8gci5wdXNoKC4uLlFuKHMsIG8sIHQpKSA6IEoocykgPyByLnB1c2goXG4gICAgICAuLi5vdChbc10sIG8sIHQsIG4pXG4gICAgKSA6IHIucHVzaChcbiAgICAgIG5vKHMsIG8sIHQpXG4gICAgKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBSZShlLCBvLCB0KSB7XG4gIGNvbnN0IG4gPSBbXSwgciA9IG5ldyBBcnJheShlLmhlYWRlclJvd3MgPz8gMCkuZmlsbCghMCksIHMgPSBuZXcgQXJyYXkoZS5oZWFkZXJDb2xzID8/IDApLmZpbGwoITApLCBpID0gZS5jb2x1bW5XaWR0aHMgPz8gW107XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgZS5yb3dzLmxlbmd0aDsgYSsrKSB7XG4gICAgY29uc3QgYyA9IGUucm93c1thXSwgbCA9IFtdLCBkID0gclthXTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IGMuY2VsbHMubGVuZ3RoOyBoKyspIHtcbiAgICAgIGNvbnN0IGYgPSBjLmNlbGxzW2hdLCBtID0gc1toXSwgZyA9IHZvaWQgMDtcbiAgICAgIGxldCBiID0gbnVsbDtcbiAgICAgIGNvbnN0IGsgPSByZShcbiAgICAgICAge1xuICAgICAgICAgIHJvdzogYSxcbiAgICAgICAgICBjb2w6IGhcbiAgICAgICAgfSxcbiAgICAgICAgeyBjb250ZW50OiBlIH1cbiAgICAgICk7XG4gICAgICBsZXQgdyA9IGlbay5jb2xdID8gW2lbay5jb2xdXSA6IG51bGw7XG4gICAgICBpZiAoZikgaWYgKHR5cGVvZiBmID09IFwic3RyaW5nXCIpXG4gICAgICAgIGIgPSBvLnRleHQoZik7XG4gICAgICBlbHNlIGlmIChtZShmKSkge1xuICAgICAgICBmLmNvbnRlbnQgJiYgKGIgPSBPKGYuY29udGVudCwgbywgdCkpO1xuICAgICAgICBjb25zdCBUID0gZ2UoZik7XG4gICAgICAgIFQgPiAxICYmICh3ID0gbmV3IEFycmF5KFQpLmZpbGwoITEpLm1hcCgoRiwgaikgPT4gaVtrLmNvbCArIGpdID8/IHZvaWQgMCkpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGIgPSBPKGYsIG8sIHQpO1xuICAgICAgY29uc3QgeSA9IG8ubm9kZXNbbSB8fCBkID8gXCJ0YWJsZUhlYWRlclwiIDogXCJ0YWJsZUNlbGxcIl0uY3JlYXRlQ2hlY2tlZChcbiAgICAgICAge1xuICAgICAgICAgIC4uLm1lKGYpID8gZi5wcm9wcyA6IHt9LFxuICAgICAgICAgIGNvbHdpZHRoOiB3XG4gICAgICAgIH0sXG4gICAgICAgIG8ubm9kZXMudGFibGVQYXJhZ3JhcGguY3JlYXRlQ2hlY2tlZChnLCBiKVxuICAgICAgKTtcbiAgICAgIGwucHVzaCh5KTtcbiAgICB9XG4gICAgY29uc3QgcCA9IG8ubm9kZXMudGFibGVSb3cuY3JlYXRlQ2hlY2tlZCh7fSwgbCk7XG4gICAgbi5wdXNoKHApO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gbm8oZSwgbywgdCkge1xuICBsZXQgbiwgciA9IGUudHlwZTtcbiAgaWYgKHIgPT09IHZvaWQgMCAmJiAociA9IFwicGFyYWdyYXBoXCIpLCAhby5ub2Rlc1tyXSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vZGUgdHlwZSAke3J9IG5vdCBmb3VuZCBpbiBzY2hlbWFgKTtcbiAgaWYgKCFlLmNvbnRlbnQpXG4gICAgbiA9IG8ubm9kZXNbcl0uY3JlYXRlQ2hlY2tlZChlLnByb3BzKTtcbiAgZWxzZSBpZiAodHlwZW9mIGUuY29udGVudCA9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcyA9IE8oXG4gICAgICBbZS5jb250ZW50XSxcbiAgICAgIG8sXG4gICAgICB0LFxuICAgICAgclxuICAgICk7XG4gICAgbiA9IG8ubm9kZXNbcl0uY3JlYXRlQ2hlY2tlZChlLnByb3BzLCBzKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGUuY29udGVudCkpIHtcbiAgICBjb25zdCBzID0gTyhcbiAgICAgIGUuY29udGVudCxcbiAgICAgIG8sXG4gICAgICB0LFxuICAgICAgclxuICAgICk7XG4gICAgbiA9IG8ubm9kZXNbcl0uY3JlYXRlQ2hlY2tlZChlLnByb3BzLCBzKTtcbiAgfSBlbHNlIGlmIChlLmNvbnRlbnQudHlwZSA9PT0gXCJ0YWJsZUNvbnRlbnRcIikge1xuICAgIGNvbnN0IHMgPSBSZShlLmNvbnRlbnQsIG8sIHQpO1xuICAgIG4gPSBvLm5vZGVzW3JdLmNyZWF0ZUNoZWNrZWQoZS5wcm9wcywgcyk7XG4gIH0gZWxzZVxuICAgIHRocm93IG5ldyAkKGUuY29udGVudC50eXBlKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBpZShlLCBvLCB0KSB7XG4gIGxldCBuID0gZS5pZDtcbiAgbiA9PT0gdm9pZCAwICYmIChuID0gdmUub3B0aW9ucy5nZW5lcmF0ZUlEKCkpO1xuICBjb25zdCByID0gW107XG4gIGlmIChlLmNoaWxkcmVuKVxuICAgIGZvciAoY29uc3QgaSBvZiBlLmNoaWxkcmVuKVxuICAgICAgci5wdXNoKGllKGksIG8sIHQpKTtcbiAgaWYgKCFlLnR5cGUgfHwgLy8gY2FuIGhhcHBlbiBpZiBibG9jay50eXBlIGlzIG5vdCBkZWZpbmVkICh0aGlzIHNob3VsZCBjcmVhdGUgdGhlIGRlZmF1bHQgbm9kZSlcbiAgby5ub2Rlc1tlLnR5cGVdLmlzSW5Hcm91cChcImJsb2NrQ29udGVudFwiKSkge1xuICAgIGNvbnN0IGkgPSBubyhcbiAgICAgIGUsXG4gICAgICBvLFxuICAgICAgdFxuICAgICksIGEgPSByLmxlbmd0aCA+IDAgPyBvLm5vZGVzLmJsb2NrR3JvdXAuY3JlYXRlQ2hlY2tlZCh7fSwgcikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG8ubm9kZXMuYmxvY2tDb250YWluZXIuY3JlYXRlQ2hlY2tlZChcbiAgICAgIHtcbiAgICAgICAgaWQ6IG4sXG4gICAgICAgIC4uLmUucHJvcHNcbiAgICAgIH0sXG4gICAgICBhID8gW2ksIGFdIDogaVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG8ubm9kZXNbZS50eXBlXS5pc0luR3JvdXAoXCJibkJsb2NrXCIpKVxuICAgICAgcmV0dXJuIG8ubm9kZXNbZS50eXBlXS5jcmVhdGVDaGVja2VkKFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IG4sXG4gICAgICAgICAgLi4uZS5wcm9wc1xuICAgICAgICB9LFxuICAgICAgICByXG4gICAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBibG9jayB0eXBlICR7ZS50eXBlfSBkb2Vzbid0IG1hdGNoIGJsb2NrQ29udGVudCBvciBibkJsb2NrIGdyb3VwYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIEQoZSwgbykge1xuICBsZXQgdCwgbjtcbiAgaWYgKG8uZmlyc3RDaGlsZC5kZXNjZW5kYW50cygociwgcykgPT4gdCA/ICExIDogIXIudHlwZS5pc0luR3JvdXAoXCJibkJsb2NrXCIpIHx8IHIuYXR0cnMuaWQgIT09IGUgPyAhMCA6ICh0ID0gciwgbiA9IHMgKyAxLCAhMSkpLCAhKHQgPT09IHZvaWQgMCB8fCBuID09PSB2b2lkIDApKVxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiB0LFxuICAgICAgcG9zQmVmb3JlTm9kZTogblxuICAgIH07XG59XG5jb25zdCB4ID0gKGUsIG8sIHQpID0+ICh7XG4gIHN0YXRlOiBuLFxuICBkaXNwYXRjaDogclxufSkgPT4ge1xuICBjb25zdCBzID0gQ2UoXG4gICAgbi5kb2MucmVzb2x2ZShvKVxuICApO1xuICBpZiAocikge1xuICAgIGNvbnN0IGkgPSBuLnNjaGVtYS5ub2Rlc1tzLmJsb2NrTm90ZVR5cGVdLCBhID0gbi5zY2hlbWEubm9kZXNbdC50eXBlIHx8IHMuYmxvY2tOb3RlVHlwZV0sIGMgPSBhLmlzSW5Hcm91cChcImJuQmxvY2tcIikgPyBhIDogbi5zY2hlbWEubm9kZXMuYmxvY2tDb250YWluZXI7XG4gICAgaWYgKHMuaXNCbG9ja0NvbnRhaW5lciAmJiBhLmlzSW5Hcm91cChcImJsb2NrQ29udGVudFwiKSlcbiAgICAgIEV0KHQsIG4sIGUsIHMpLCBlcihcbiAgICAgICAgdCxcbiAgICAgICAgbixcbiAgICAgICAgZSxcbiAgICAgICAgaSxcbiAgICAgICAgYSxcbiAgICAgICAgc1xuICAgICAgKTtcbiAgICBlbHNlIGlmICghcy5pc0Jsb2NrQ29udGFpbmVyICYmIGEuaXNJbkdyb3VwKFwiYm5CbG9ja1wiKSlcbiAgICAgIEV0KHQsIG4sIGUsIHMpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbCA9IEUoXG4gICAgICAgIHMuYm5CbG9jay5ub2RlLFxuICAgICAgICBlLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIGUuYmxvY2tDYWNoZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuLnRyLnJlcGxhY2VXaXRoKFxuICAgICAgICBzLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICBzLmJuQmxvY2suYWZ0ZXJQb3MsXG4gICAgICAgIGllKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBsLmNoaWxkcmVuLFxuICAgICAgICAgICAgLy8gaWYgbm8gY2hpbGRyZW4gYXJlIHBhc3NlZCBpbiwgdXNlIGV4aXN0aW5nIGNoaWxkcmVuXG4gICAgICAgICAgICAuLi50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBuLnNjaGVtYSxcbiAgICAgICAgICBlLnNjaGVtYS5zdHlsZVNjaGVtYVxuICAgICAgICApXG4gICAgICApLCAhMDtcbiAgICB9XG4gICAgbi50ci5zZXROb2RlTWFya3VwKHMuYm5CbG9jay5iZWZvcmVQb3MsIGMsIHtcbiAgICAgIC4uLnMuYm5CbG9jay5ub2RlLmF0dHJzLFxuICAgICAgLi4udC5wcm9wc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAhMDtcbn07XG5mdW5jdGlvbiBlcihlLCBvLCB0LCBuLCByLCBzKSB7XG4gIGxldCBpID0gXCJrZWVwXCI7XG4gIGlmIChlLmNvbnRlbnQpXG4gICAgaWYgKHR5cGVvZiBlLmNvbnRlbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgIGkgPSBPKFxuICAgICAgICBbZS5jb250ZW50XSxcbiAgICAgICAgby5zY2hlbWEsXG4gICAgICAgIHQuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgICByLm5hbWVcbiAgICAgICk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlLmNvbnRlbnQpKVxuICAgICAgaSA9IE8oXG4gICAgICAgIGUuY29udGVudCxcbiAgICAgICAgby5zY2hlbWEsXG4gICAgICAgIHQuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgICByLm5hbWVcbiAgICAgICk7XG4gICAgZWxzZSBpZiAoZS5jb250ZW50LnR5cGUgPT09IFwidGFibGVDb250ZW50XCIpXG4gICAgICBpID0gUmUoXG4gICAgICAgIGUuY29udGVudCxcbiAgICAgICAgby5zY2hlbWEsXG4gICAgICAgIHQuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgICApO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyAkKGUuY29udGVudC50eXBlKTtcbiAgZWxzZVxuICAgIG4uc3BlYy5jb250ZW50ID09PSBcIlwiIHx8IHIuc3BlYy5jb250ZW50ICE9PSBuLnNwZWMuY29udGVudCAmJiAoaSA9IFtdKTtcbiAgaSA9PT0gXCJrZWVwXCIgPyBvLnRyLnNldE5vZGVNYXJrdXAoXG4gICAgcy5ibG9ja0NvbnRlbnQuYmVmb3JlUG9zLFxuICAgIGUudHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogby5zY2hlbWEubm9kZXNbZS50eXBlXSxcbiAgICB7XG4gICAgICAuLi5zLmJsb2NrQ29udGVudC5ub2RlLmF0dHJzLFxuICAgICAgLi4uZS5wcm9wc1xuICAgIH1cbiAgKSA6IG8udHIucmVwbGFjZVdpdGgoXG4gICAgcy5ibG9ja0NvbnRlbnQuYmVmb3JlUG9zLFxuICAgIHMuYmxvY2tDb250ZW50LmFmdGVyUG9zLFxuICAgIHIuY3JlYXRlQ2hlY2tlZChcbiAgICAgIHtcbiAgICAgICAgLi4ucy5ibG9ja0NvbnRlbnQubm9kZS5hdHRycyxcbiAgICAgICAgLi4uZS5wcm9wc1xuICAgICAgfSxcbiAgICAgIGlcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBFdChlLCBvLCB0LCBuKSB7XG4gIGlmIChlLmNoaWxkcmVuICE9PSB2b2lkIDAgJiYgZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgciA9IGUuY2hpbGRyZW4ubWFwKChzKSA9PiBpZShzLCBvLnNjaGVtYSwgdC5zY2hlbWEuc3R5bGVTY2hlbWEpKTtcbiAgICBpZiAobi5jaGlsZENvbnRhaW5lcilcbiAgICAgIG8udHIuc3RlcChcbiAgICAgICAgbmV3IEZvKFxuICAgICAgICAgIG4uY2hpbGRDb250YWluZXIuYmVmb3JlUG9zICsgMSxcbiAgICAgICAgICBuLmNoaWxkQ29udGFpbmVyLmFmdGVyUG9zIC0gMSxcbiAgICAgICAgICBuZXcgdGUoVi5mcm9tKHIpLCAwLCAwKVxuICAgICAgICApXG4gICAgICApO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKCFuLmlzQmxvY2tDb250YWluZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcG9zc2libGVcIik7XG4gICAgICBvLnRyLmluc2VydChcbiAgICAgICAgbi5ibG9ja0NvbnRlbnQuYWZ0ZXJQb3MsXG4gICAgICAgIG8uc2NoZW1hLm5vZGVzLmJsb2NrR3JvdXAuY3JlYXRlQ2hlY2tlZCh7fSwgcilcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cihlLCBvLCB0KSB7XG4gIGNvbnN0IG4gPSBlLl90aXB0YXBFZGl0b3IsIHIgPSB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8gbyA6IG8uaWQsIHMgPSBEKHIsIG4uc3RhdGUuZG9jKTtcbiAgaWYgKCFzKVxuICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgd2l0aCBJRCAke3J9IG5vdCBmb3VuZGApO1xuICBuLmNvbW1hbmRzLmNvbW1hbmQoKHsgc3RhdGU6IGEsIGRpc3BhdGNoOiBjIH0pID0+ICh4KFxuICAgIGUsXG4gICAgcy5wb3NCZWZvcmVOb2RlLFxuICAgIHRcbiAgKSh7IHN0YXRlOiBhLCBkaXNwYXRjaDogYyB9KSwgITApKTtcbiAgY29uc3QgaSA9IG4uc3RhdGUuZG9jLnJlc29sdmUocy5wb3NCZWZvcmVOb2RlICsgMSkubm9kZSgpO1xuICByZXR1cm4gRShcbiAgICBpLFxuICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgIGUuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgZS5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgZS5ibG9ja0NhY2hlXG4gICk7XG59XG5mdW5jdGlvbiBybyhlKSB7XG4gIGNvbnN0IG8gPSBBcnJheS5mcm9tKGUuY2xhc3NMaXN0KS5maWx0ZXIoXG4gICAgKHQpID0+ICF0LnN0YXJ0c1dpdGgoXCJibi1cIilcbiAgKSB8fCBbXTtcbiAgby5sZW5ndGggPiAwID8gZS5jbGFzc05hbWUgPSBvLmpvaW4oXCIgXCIpIDogZS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbn1cbmZ1bmN0aW9uIHNvKGUsIG8sIHQsIG4pIHtcbiAgbGV0IHI7XG4gIGlmIChvKVxuICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiKVxuICAgICAgciA9IE8oXG4gICAgICAgIFtvXSxcbiAgICAgICAgZS5wbVNjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgICAgICk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSlcbiAgICAgIHIgPSBPKFxuICAgICAgICBvLFxuICAgICAgICBlLnBtU2NoZW1hLFxuICAgICAgICBlLnNjaGVtYS5zdHlsZVNjaGVtYVxuICAgICAgKTtcbiAgICBlbHNlIGlmIChvLnR5cGUgPT09IFwidGFibGVDb250ZW50XCIpXG4gICAgICByID0gUmUoXG4gICAgICAgIG8sXG4gICAgICAgIGUucG1TY2hlbWEsXG4gICAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgICApO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyAkKG8udHlwZSk7XG4gIGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tDb250ZW50IGlzIHJlcXVpcmVkXCIpO1xuICBjb25zdCBzID0gdC5zZXJpYWxpemVGcmFnbWVudChWLmZyb20ociksIG4pO1xuICByZXR1cm4gcy5ub2RlVHlwZSA9PT0gMSAmJiBybyhzKSwgcztcbn1cbmZ1bmN0aW9uIG9yKGUsIG8sIHQsIG4sIHIsIHMsIGkpIHtcbiAgdmFyIGcsIGIsIGssIHcsIHksIFQsIEYsIGo7XG4gIGNvbnN0IGEgPSAoaSA9PSBudWxsID8gdm9pZCAwIDogaS5kb2N1bWVudCkgPz8gZG9jdW1lbnQsIGMgPSBvLnBtU2NoZW1hLm5vZGVzLmJsb2NrQ29udGFpbmVyO1xuICBsZXQgbCA9IHQucHJvcHM7XG4gIGlmICghdC5wcm9wcykge1xuICAgIGwgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtCLCB2XSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgIG8uc2NoZW1hLmJsb2NrU2NoZW1hW3QudHlwZV0ucHJvcFNjaGVtYVxuICAgICkpXG4gICAgICB2LmRlZmF1bHQgIT09IHZvaWQgMCAmJiAobFtCXSA9IHYuZGVmYXVsdCk7XG4gIH1cbiAgY29uc3QgZCA9IChiID0gKGcgPSBjLnNwZWMpID09IG51bGwgPyB2b2lkIDAgOiBnLnRvRE9NKSA9PSBudWxsID8gdm9pZCAwIDogYi5jYWxsKFxuICAgIGcsXG4gICAgYy5jcmVhdGUoe1xuICAgICAgaWQ6IHQuaWQsXG4gICAgICAuLi5sXG4gICAgfSlcbiAgKSwgcCA9IEFycmF5LmZyb20oZC5kb20uYXR0cmlidXRlcyksIGggPSBvLmJsb2NrSW1wbGVtZW50YXRpb25zW3QudHlwZV0uaW1wbGVtZW50YXRpb24udG9FeHRlcm5hbEhUTUwoeyAuLi50LCBwcm9wczogbCB9LCBvKSwgZiA9IGEuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBpZiAoaC5kb20uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYm4tYmxvY2stY29udGVudFwiKSkge1xuICAgIGNvbnN0IEIgPSBbLi4ucCwgLi4uQXJyYXkuZnJvbShoLmRvbS5hdHRyaWJ1dGVzKV0uZmlsdGVyKFxuICAgICAgKHYpID0+IHYubmFtZS5zdGFydHNXaXRoKFwiZGF0YVwiKSAmJiB2Lm5hbWUgIT09IFwiZGF0YS1jb250ZW50LXR5cGVcIiAmJiB2Lm5hbWUgIT09IFwiZGF0YS1maWxlLWJsb2NrXCIgJiYgdi5uYW1lICE9PSBcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIiAmJiB2Lm5hbWUgIT09IFwiZGF0YS1ub2RlLXR5cGVcIiAmJiB2Lm5hbWUgIT09IFwiZGF0YS1pZFwiICYmIHYubmFtZSAhPT0gXCJkYXRhLWluZGV4XCIgJiYgdi5uYW1lICE9PSBcImRhdGEtZWRpdGFibGVcIlxuICAgICk7XG4gICAgZm9yIChjb25zdCB2IG9mIEIpXG4gICAgICBoLmRvbS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSh2Lm5hbWUsIHYudmFsdWUpO1xuICAgIHJvKGguZG9tLmZpcnN0Q2hpbGQpLCBmLmFwcGVuZCguLi5BcnJheS5mcm9tKGguZG9tLmNoaWxkTm9kZXMpKTtcbiAgfSBlbHNlXG4gICAgZi5hcHBlbmQoaC5kb20pO1xuICBpZiAoaC5jb250ZW50RE9NICYmIHQuY29udGVudCkge1xuICAgIGNvbnN0IEIgPSBzbyhcbiAgICAgIG8sXG4gICAgICB0LmNvbnRlbnQsXG4gICAgICAvLyBUT0RPXG4gICAgICBuLFxuICAgICAgaVxuICAgICk7XG4gICAgaC5jb250ZW50RE9NLmFwcGVuZENoaWxkKEIpO1xuICB9XG4gIGxldCBtO1xuICBpZiAoci5oYXModC50eXBlKSA/IG0gPSBcIk9MXCIgOiBzLmhhcyh0LnR5cGUpICYmIChtID0gXCJVTFwiKSwgbSkge1xuICAgIGlmICgoKGsgPSBlLmxhc3RDaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IGsubm9kZU5hbWUpICE9PSBtKSB7XG4gICAgICBjb25zdCB2ID0gYS5jcmVhdGVFbGVtZW50KG0pO1xuICAgICAgbSA9PT0gXCJPTFwiICYmIChsICE9IG51bGwgJiYgbC5zdGFydCkgJiYgKGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwuc3RhcnQpICE9PSAxICYmIHYuc2V0QXR0cmlidXRlKFwic3RhcnRcIiwgbC5zdGFydCArIFwiXCIpLCBlLmFwcGVuZCh2KTtcbiAgICB9XG4gICAgY29uc3QgQiA9IGEuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgIEIuYXBwZW5kKGYpLCBlLmxhc3RDaGlsZC5hcHBlbmRDaGlsZChCKTtcbiAgfSBlbHNlXG4gICAgZS5hcHBlbmQoZik7XG4gIGlmICh0LmNoaWxkcmVuICYmIHQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IEIgPSBhLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoaW8oXG4gICAgICBCLFxuICAgICAgbyxcbiAgICAgIHQuY2hpbGRyZW4sXG4gICAgICBuLFxuICAgICAgcixcbiAgICAgIHMsXG4gICAgICBpXG4gICAgKSwgKCh3ID0gZS5sYXN0Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiB3Lm5vZGVOYW1lKSA9PT0gXCJVTFwiIHx8ICgoeSA9IGUubGFzdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogeS5ub2RlTmFtZSkgPT09IFwiT0xcIilcbiAgICAgIGZvciAoOyAoKFQgPSBCLmZpcnN0Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBULm5vZGVOYW1lKSA9PT0gXCJVTFwiIHx8ICgoRiA9IEIuZmlyc3RDaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IEYubm9kZU5hbWUpID09PSBcIk9MXCI7IClcbiAgICAgICAgZS5sYXN0Q2hpbGQubGFzdENoaWxkLmFwcGVuZENoaWxkKEIuZmlyc3RDaGlsZCk7XG4gICAgby5wbVNjaGVtYS5ub2Rlc1t0LnR5cGVdLmlzSW5Hcm91cChcImJsb2NrQ29udGVudFwiKSA/IGUuYXBwZW5kKEIpIDogKGogPSBoLmNvbnRlbnRET00pID09IG51bGwgfHwgai5hcHBlbmQoQik7XG4gIH1cbn1cbmNvbnN0IGlvID0gKGUsIG8sIHQsIG4sIHIsIHMsIGkpID0+IHtcbiAgZm9yIChjb25zdCBhIG9mIHQpXG4gICAgb3IoXG4gICAgICBlLFxuICAgICAgbyxcbiAgICAgIGEsXG4gICAgICBuLFxuICAgICAgcixcbiAgICAgIHMsXG4gICAgICBpXG4gICAgKTtcbn0sIG5yID0gKGUsIG8sIHQsIG4sIHIsIHMpID0+IHtcbiAgY29uc3QgYSA9ICgocyA9PSBudWxsID8gdm9pZCAwIDogcy5kb2N1bWVudCkgPz8gZG9jdW1lbnQpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgcmV0dXJuIGlvKFxuICAgIGEsXG4gICAgZSxcbiAgICBvLFxuICAgIHQsXG4gICAgbixcbiAgICByLFxuICAgIHNcbiAgKSwgYTtcbn0sIFZlID0gKGUsIG8pID0+IHtcbiAgY29uc3QgdCA9IEZ0LmZyb21TY2hlbWEoZSk7XG4gIHJldHVybiB7XG4gICAgZXhwb3J0QmxvY2tzOiAobiwgcikgPT4ge1xuICAgICAgY29uc3QgcyA9IG5yKFxuICAgICAgICBvLFxuICAgICAgICBuLFxuICAgICAgICB0LFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJudW1iZXJlZExpc3RJdGVtXCJdKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYnVsbGV0TGlzdEl0ZW1cIiwgXCJjaGVja0xpc3RJdGVtXCJdKSxcbiAgICAgICAgclxuICAgICAgKSwgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByZXR1cm4gaS5hcHBlbmQocyksIGkuaW5uZXJIVE1MO1xuICAgIH0sXG4gICAgZXhwb3J0SW5saW5lQ29udGVudDogKG4sIHIpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBzbyhcbiAgICAgICAgbyxcbiAgICAgICAgbixcbiAgICAgICAgdCxcbiAgICAgICAgclxuICAgICAgKSwgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByZXR1cm4gaS5hcHBlbmQocy5jbG9uZU5vZGUoITApKSwgaS5pbm5lckhUTUw7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIHJyKGUsIG8sIHQsIG4sIHIpIHtcbiAgbGV0IHM7XG4gIGlmIChvKVxuICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiKVxuICAgICAgcyA9IE8oXG4gICAgICAgIFtvXSxcbiAgICAgICAgZS5wbVNjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIG5cbiAgICAgICk7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSlcbiAgICAgIHMgPSBPKFxuICAgICAgICBvLFxuICAgICAgICBlLnBtU2NoZW1hLFxuICAgICAgICBlLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICBlbHNlIGlmIChvLnR5cGUgPT09IFwidGFibGVDb250ZW50XCIpXG4gICAgICBzID0gUmUoXG4gICAgICAgIG8sXG4gICAgICAgIGUucG1TY2hlbWEsXG4gICAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgICApO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyAkKG8udHlwZSk7XG4gIGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tDb250ZW50IGlzIHJlcXVpcmVkXCIpO1xuICByZXR1cm4gdC5zZXJpYWxpemVGcmFnbWVudChWLmZyb20ocyksIHIpO1xufVxuZnVuY3Rpb24gc3IoZSwgbywgdCwgbiwgcikge1xuICB2YXIgcCwgaCwgZiwgbSwgZztcbiAgY29uc3QgcyA9IGUucG1TY2hlbWEubm9kZXMuYmxvY2tDb250YWluZXI7XG4gIGxldCBpID0gby5wcm9wcztcbiAgaWYgKCFvLnByb3BzKSB7XG4gICAgaSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2IsIGtdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgZS5zY2hlbWEuYmxvY2tTY2hlbWFbby50eXBlXS5wcm9wU2NoZW1hXG4gICAgKSlcbiAgICAgIGsuZGVmYXVsdCAhPT0gdm9pZCAwICYmIChpW2JdID0gay5kZWZhdWx0KTtcbiAgfVxuICBjb25zdCBjID0gZS5ibG9ja0ltcGxlbWVudGF0aW9uc1tvLnR5cGVdLmltcGxlbWVudGF0aW9uLnRvSW50ZXJuYWxIVE1MKHsgLi4ubywgcHJvcHM6IGkgfSwgZSk7XG4gIGlmIChvLnR5cGUgPT09IFwibnVtYmVyZWRMaXN0SXRlbVwiICYmIGMuZG9tLnNldEF0dHJpYnV0ZShcImRhdGEtaW5kZXhcIiwgbi50b1N0cmluZygpKSwgYy5jb250ZW50RE9NICYmIG8uY29udGVudCkge1xuICAgIGNvbnN0IGIgPSBycihcbiAgICAgIGUsXG4gICAgICBvLmNvbnRlbnQsXG4gICAgICAvLyBUT0RPXG4gICAgICB0LFxuICAgICAgby50eXBlLFxuICAgICAgclxuICAgICk7XG4gICAgYy5jb250ZW50RE9NLmFwcGVuZENoaWxkKGIpO1xuICB9XG4gIGlmIChlLnBtU2NoZW1hLm5vZGVzW28udHlwZV0uaXNJbkdyb3VwKFwiYm5CbG9ja1wiKSkge1xuICAgIGlmIChvLmNoaWxkcmVuICYmIG8uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYiA9IGFvKFxuICAgICAgICBlLFxuICAgICAgICBvLmNoaWxkcmVuLFxuICAgICAgICB0LFxuICAgICAgICByXG4gICAgICApO1xuICAgICAgKHAgPSBjLmNvbnRlbnRET00pID09IG51bGwgfHwgcC5hcHBlbmQoYik7XG4gICAgfVxuICAgIHJldHVybiBjLmRvbTtcbiAgfVxuICBjb25zdCBkID0gKGYgPSAoaCA9IHMuc3BlYykgPT0gbnVsbCA/IHZvaWQgMCA6IGgudG9ET00pID09IG51bGwgPyB2b2lkIDAgOiBmLmNhbGwoXG4gICAgaCxcbiAgICBzLmNyZWF0ZSh7XG4gICAgICBpZDogby5pZCxcbiAgICAgIC4uLmlcbiAgICB9KVxuICApO1xuICByZXR1cm4gKG0gPSBkLmNvbnRlbnRET00pID09IG51bGwgfHwgbS5hcHBlbmRDaGlsZChjLmRvbSksIG8uY2hpbGRyZW4gJiYgby5jaGlsZHJlbi5sZW5ndGggPiAwICYmICgoZyA9IGQuY29udGVudERPTSkgPT0gbnVsbCB8fCBnLmFwcGVuZENoaWxkKFxuICAgIGNvKGUsIG8uY2hpbGRyZW4sIHQsIHIpXG4gICkpLCBkLmRvbTtcbn1cbmZ1bmN0aW9uIGFvKGUsIG8sIHQsIG4pIHtcbiAgY29uc3QgcyA9ICgobiA9PSBudWxsID8gdm9pZCAwIDogbi5kb2N1bWVudCkgPz8gZG9jdW1lbnQpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGNvbnN0IGEgb2Ygbykge1xuICAgIGEudHlwZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIgPyBpKysgOiBpID0gMDtcbiAgICBjb25zdCBjID0gc3IoXG4gICAgICBlLFxuICAgICAgYSxcbiAgICAgIHQsXG4gICAgICBpLFxuICAgICAgblxuICAgICk7XG4gICAgcy5hcHBlbmRDaGlsZChjKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmNvbnN0IGNvID0gKGUsIG8sIHQsIG4pID0+IHtcbiAgdmFyIGE7XG4gIGNvbnN0IHIgPSBlLnBtU2NoZW1hLm5vZGVzLmJsb2NrR3JvdXAsIHMgPSByLnNwZWMudG9ET00oci5jcmVhdGUoe30pKSwgaSA9IGFvKGUsIG8sIHQsIG4pO1xuICByZXR1cm4gKGEgPSBzLmNvbnRlbnRET00pID09IG51bGwgfHwgYS5hcHBlbmRDaGlsZChpKSwgcy5kb207XG59LCBpciA9IChlLCBvKSA9PiB7XG4gIGNvbnN0IHQgPSBGdC5mcm9tU2NoZW1hKGUpO1xuICByZXR1cm4ge1xuICAgIHNlcmlhbGl6ZUJsb2NrczogKG4sIHIpID0+IGNvKG8sIG4sIHQsIHIpLm91dGVySFRNTFxuICB9O1xufSwgVWUgPSAoZSwgbykgPT4ge1xuICBjb25zdCB0ID0gZS5xdWVyeVNlbGVjdG9yKFxuICAgIG9cbiAgKTtcbiAgaWYgKCF0KVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IGUucXVlcnlTZWxlY3RvcihcImZpZ2NhcHRpb25cIiksIHIgPSAobiA9PSBudWxsID8gdm9pZCAwIDogbi50ZXh0Q29udGVudCkgPz8gdm9pZCAwO1xuICByZXR1cm4geyB0YXJnZXRFbGVtZW50OiB0LCBjYXB0aW9uOiByIH07XG59LCBhciA9IChlLCBvLCB0LCBuKSA9PiB7XG4gIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByLmNsYXNzTmFtZSA9IFwiYm4tYWRkLWZpbGUtYnV0dG9uXCI7XG4gIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBzLmNsYXNzTmFtZSA9IFwiYm4tYWRkLWZpbGUtYnV0dG9uLWljb25cIiwgbiA/IHMuYXBwZW5kQ2hpbGQobikgOiBzLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPjxwYXRoIGQ9XCJNMyA4TDkuMDAzMTkgMkgxOS45OTc4QzIwLjU1MTMgMiAyMSAyLjQ1NTMxIDIxIDIuOTkxOFYyMS4wMDgyQzIxIDIxLjU1NiAyMC41NTUxIDIyIDIwLjAwNjYgMjJIMy45OTM0QzMuNDQ0NzYgMjIgMyAyMS41NTAxIDMgMjAuOTkzMlY4Wk0xMCA0VjlINVYyMEgxOVY0SDEwWlwiPjwvcGF0aD48L3N2Zz4nLCByLmFwcGVuZENoaWxkKHMpO1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gIGkuY2xhc3NOYW1lID0gXCJibi1hZGQtZmlsZS1idXR0b24tdGV4dFwiLCBpLmlubmVySFRNTCA9IHQgfHwgby5kaWN0aW9uYXJ5LmZpbGVfYmxvY2tzLmZpbGUuYWRkX2J1dHRvbl90ZXh0LCByLmFwcGVuZENoaWxkKGkpO1xuICBjb25zdCBhID0gKGwpID0+IHtcbiAgICBsLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIGMgPSAoKSA9PiB7XG4gICAgby5kaXNwYXRjaChcbiAgICAgIG8uX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKG8uZmlsZVBhbmVsLnBsdWdpbiwge1xuICAgICAgICBibG9jazogZVxuICAgICAgfSlcbiAgICApO1xuICB9O1xuICByZXR1cm4gci5hZGRFdmVudExpc3RlbmVyKFxuICAgIFwibW91c2Vkb3duXCIsXG4gICAgYSxcbiAgICAhMFxuICApLCByLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjLCAhMCksIHtcbiAgICBkb206IHIsXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICBhLFxuICAgICAgICAhMFxuICAgICAgKSwgci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIGMsXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn0sIGNyID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+PHBhdGggZD1cIk0zIDhMOS4wMDMxOSAySDE5Ljk5NzhDMjAuNTUxMyAyIDIxIDIuNDU1MzEgMjEgMi45OTE4VjIxLjAwODJDMjEgMjEuNTU2IDIwLjU1NTEgMjIgMjAuMDA2NiAyMkgzLjk5MzRDMy40NDQ3NiAyMiAzIDIxLjU1MDEgMyAyMC45OTMyVjhaTTEwIDRWOUg1VjIwSDE5VjRIMTBaXCI+PC9wYXRoPjwvc3ZnPicsIGxyID0gKGUpID0+IHtcbiAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG8uY2xhc3NOYW1lID0gXCJibi1maWxlLW5hbWUtd2l0aC1pY29uXCI7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB0LmNsYXNzTmFtZSA9IFwiYm4tZmlsZS1pY29uXCIsIHQuaW5uZXJIVE1MID0gY3IsIG8uYXBwZW5kQ2hpbGQodCk7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgcmV0dXJuIG4uY2xhc3NOYW1lID0gXCJibi1maWxlLW5hbWVcIiwgbi50ZXh0Q29udGVudCA9IGUucHJvcHMubmFtZSwgby5hcHBlbmRDaGlsZChuKSwge1xuICAgIGRvbTogb1xuICB9O1xufSwgbHQgPSAoZSwgbywgdCwgbiwgcikgPT4ge1xuICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgaWYgKHMuY2xhc3NOYW1lID0gXCJibi1maWxlLWJsb2NrLWNvbnRlbnQtd3JhcHBlclwiLCBlLnByb3BzLnVybCA9PT0gXCJcIikge1xuICAgIGNvbnN0IGEgPSBhcihcbiAgICAgIGUsXG4gICAgICBvLFxuICAgICAgbixcbiAgICAgIHJcbiAgICApO1xuICAgIHMuYXBwZW5kQ2hpbGQoYS5kb20pO1xuICAgIGNvbnN0IGMgPSBvLm9uVXBsb2FkU3RhcnQoKGwpID0+IHtcbiAgICAgIGlmIChsID09PSBlLmlkKSB7XG4gICAgICAgIHMucmVtb3ZlQ2hpbGQoYS5kb20pO1xuICAgICAgICBjb25zdCBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZC5jbGFzc05hbWUgPSBcImJuLWZpbGUtbG9hZGluZy1wcmV2aWV3XCIsIGQudGV4dENvbnRlbnQgPSBcIkxvYWRpbmcuLi5cIiwgcy5hcHBlbmRDaGlsZChkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZG9tOiBzLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICBjKCksIGEuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY29uc3QgaSA9IHsgZG9tOiBzIH07XG4gIGlmIChlLnByb3BzLnNob3dQcmV2aWV3ID09PSAhMSB8fCAhdCkge1xuICAgIGNvbnN0IGEgPSBscihlKTtcbiAgICBzLmFwcGVuZENoaWxkKGEuZG9tKSwgaS5kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgdmFyIGM7XG4gICAgICAoYyA9IGEuZGVzdHJveSkgPT0gbnVsbCB8fCBjLmNhbGwoYSk7XG4gICAgfTtcbiAgfSBlbHNlXG4gICAgcy5hcHBlbmRDaGlsZCh0LmRvbSk7XG4gIGlmIChlLnByb3BzLmNhcHRpb24pIHtcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgYS5jbGFzc05hbWUgPSBcImJuLWZpbGUtY2FwdGlvblwiLCBhLnRleHRDb250ZW50ID0gZS5wcm9wcy5jYXB0aW9uLCBzLmFwcGVuZENoaWxkKGEpO1xuICB9XG4gIHJldHVybiBpO1xufSwgZHQgPSAoZSwgbykgPT4ge1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZ3VyZVwiKSwgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWdjYXB0aW9uXCIpO1xuICByZXR1cm4gbi50ZXh0Q29udGVudCA9IG8sIHQuYXBwZW5kQ2hpbGQoZSksIHQuYXBwZW5kQ2hpbGQobiksIHsgZG9tOiB0IH07XG59LCAkZSA9IChlLCBvKSA9PiB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gIHJldHVybiBuLnRleHRDb250ZW50ID0gbywgdC5hcHBlbmRDaGlsZChlKSwgdC5hcHBlbmRDaGlsZChuKSwge1xuICAgIGRvbTogdFxuICB9O1xufSwgU3QgPSAoZSkgPT4gKHsgdXJsOiBlLnNyYyB8fCB2b2lkIDAgfSksIGRyID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+PHBhdGggZD1cIk0yIDE2LjAwMDFINS44ODg4OUwxMS4xODM0IDIwLjMzMTlDMTEuMjcyNyAyMC40MDUgMTEuMzg0NiAyMC40NDQ5IDExLjUgMjAuNDQ0OUMxMS43NzYxIDIwLjQ0NDkgMTIgMjAuMjIxMSAxMiAxOS45NDQ5VjQuMDU1MTlDMTIgMy45Mzk3NyAxMS45NjAxIDMuODI3OSAxMS44ODcgMy43Mzg1N0MxMS43MTIxIDMuNTI0ODUgMTEuMzk3MSAzLjQ5MzM1IDExLjE4MzQgMy42NjgyMUw1Ljg4ODg5IDguMDAwMDdIMkMxLjQ0NzcyIDguMDAwMDcgMSA4LjQ0Nzc4IDEgOS4wMDAwN1YxNS4wMDAxQzEgMTUuNTUyNCAxLjQ0NzcyIDE2LjAwMDEgMiAxNi4wMDAxWk0yMyAxMkMyMyAxNS4yOTIgMjEuNTUzOSAxOC4yNDYzIDE5LjI2MjIgMjAuMjYyMkwxNy44NDQ1IDE4Ljg0NDRDMTkuNzc1OCAxNy4xOTM3IDIxIDE0LjczOTggMjEgMTJDMjEgOS4yNjAxNiAxOS43NzU4IDYuODA2MjkgMTcuODQ0NSA1LjE1NTU3TDE5LjI2MjIgMy43Mzc3OUMyMS41NTM5IDUuNzUzNjggMjMgOC43MDc5NSAyMyAxMlpNMTggMTJDMTggMTAuMDg4MyAxNy4xMDYgOC4zODU0OCAxNS43MTMzIDcuMjg2NzNMMTQuMjg0MiA4LjcxNTg0QzE1LjMyMTMgOS40Mzg1NSAxNiAxMC42NCAxNiAxMkMxNiAxMy4zNiAxNS4zMjEzIDE0LjU2MTQgMTQuMjg0MiAxNS4yODQxTDE1LjcxMzMgMTYuNzEzMkMxNy4xMDYgMTUuNjE0NSAxOCAxMy45MTE2IDE4IDEyWlwiPjwvcGF0aD48L3N2Zz4nLCBwciA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiBTLmJhY2tncm91bmRDb2xvcixcbiAgLy8gRmlsZSBuYW1lLlxuICBuYW1lOiB7XG4gICAgZGVmYXVsdDogXCJcIlxuICB9LFxuICAvLyBGaWxlIHVybC5cbiAgdXJsOiB7XG4gICAgZGVmYXVsdDogXCJcIlxuICB9LFxuICAvLyBGaWxlIGNhcHRpb24uXG4gIGNhcHRpb246IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIHNob3dQcmV2aWV3OiB7XG4gICAgZGVmYXVsdDogITBcbiAgfVxufSwgdXIgPSB7XG4gIHR5cGU6IFwiYXVkaW9cIixcbiAgcHJvcFNjaGVtYTogcHIsXG4gIGNvbnRlbnQ6IFwibm9uZVwiLFxuICBpc0ZpbGVCbG9jazogITAsXG4gIGZpbGVCbG9ja0FjY2VwdDogW1wiYXVkaW8vKlwiXVxufSwgaHIgPSAoZSwgbykgPT4ge1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdC5pbm5lckhUTUwgPSBkcjtcbiAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcbiAgcmV0dXJuIG4uY2xhc3NOYW1lID0gXCJibi1hdWRpb1wiLCBvLnJlc29sdmVGaWxlVXJsID8gby5yZXNvbHZlRmlsZVVybChlLnByb3BzLnVybCkudGhlbigocikgPT4ge1xuICAgIG4uc3JjID0gcjtcbiAgfSkgOiBuLnNyYyA9IGUucHJvcHMudXJsLCBuLmNvbnRyb2xzID0gITAsIG4uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiLCBuLmRyYWdnYWJsZSA9ICExLCBsdChcbiAgICBlLFxuICAgIG8sXG4gICAgeyBkb206IG4gfSxcbiAgICBvLmRpY3Rpb25hcnkuZmlsZV9ibG9ja3MuYXVkaW8uYWRkX2J1dHRvbl90ZXh0LFxuICAgIHQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgKTtcbn0sIGZyID0gKGUpID0+IHtcbiAgaWYgKGUudGFnTmFtZSA9PT0gXCJBVURJT1wiKVxuICAgIHJldHVybiBTdChlKTtcbiAgaWYgKGUudGFnTmFtZSA9PT0gXCJGSUdVUkVcIikge1xuICAgIGNvbnN0IG8gPSBVZShlLCBcImF1ZGlvXCIpO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRhcmdldEVsZW1lbnQ6IHQsIGNhcHRpb246IG4gfSA9IG87XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLlN0KHQpLFxuICAgICAgY2FwdGlvbjogblxuICAgIH07XG4gIH1cbn0sIG1yID0gKGUpID0+IHtcbiAgaWYgKCFlLnByb3BzLnVybCkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICByZXR1cm4gdC50ZXh0Q29udGVudCA9IFwiQWRkIGF1ZGlvXCIsIHtcbiAgICAgIGRvbTogdFxuICAgIH07XG4gIH1cbiAgbGV0IG87XG4gIHJldHVybiBlLnByb3BzLnNob3dQcmV2aWV3ID8gKG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXVkaW9cIiksIG8uc3JjID0gZS5wcm9wcy51cmwpIDogKG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSwgby5ocmVmID0gZS5wcm9wcy51cmwsIG8udGV4dENvbnRlbnQgPSBlLnByb3BzLm5hbWUgfHwgZS5wcm9wcy51cmwpLCBlLnByb3BzLmNhcHRpb24gPyBlLnByb3BzLnNob3dQcmV2aWV3ID8gZHQobywgZS5wcm9wcy5jYXB0aW9uKSA6ICRlKG8sIGUucHJvcHMuY2FwdGlvbikgOiB7XG4gICAgZG9tOiBvXG4gIH07XG59LCBnciA9IFNlKHVyLCB7XG4gIHJlbmRlcjogaHIsXG4gIHBhcnNlOiBmcixcbiAgdG9FeHRlcm5hbEhUTUw6IG1yXG59KSwgQnQgPSBTeW1ib2wuZm9yKFwiYmxvY2tub3RlLnNoaWtpUGFyc2VyXCIpLCBXZSA9IFN5bWJvbC5mb3IoXG4gIFwiYmxvY2tub3RlLnNoaWtpSGlnaGxpZ2h0ZXJQcm9taXNlXCJcbiksIGJyID0ge1xuICBsYW5ndWFnZToge1xuICAgIGRlZmF1bHQ6IFwidGV4dFwiXG4gIH1cbn0sIGtyID0gVyh7XG4gIG5hbWU6IFwiY29kZUJsb2NrXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgbWFya3M6IFwiXCIsXG4gIGNvZGU6ICEwLFxuICBkZWZpbmluZzogITAsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlZmF1bHRMYW5ndWFnZTogXCJ0ZXh0XCIsXG4gICAgICBpbmRlbnRMaW5lV2l0aFRhYjogITAsXG4gICAgICBzdXBwb3J0ZWRMYW5ndWFnZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZToge1xuICAgICAgICBkZWZhdWx0OiBlLmVkaXRvci5zZXR0aW5ncy5jb2RlQmxvY2suZGVmYXVsdExhbmd1YWdlLFxuICAgICAgICBwYXJzZUhUTUw6IChvKSA9PiB7XG4gICAgICAgICAgbGV0IHQgPSBvLCBuID0gbnVsbDtcbiAgICAgICAgICAodCA9PSBudWxsID8gdm9pZCAwIDogdC50YWdOYW1lKSA9PT0gXCJESVZcIiAmJiAodCA9PSBudWxsID8gdm9pZCAwIDogdC5kYXRhc2V0LmNvbnRlbnRUeXBlKSA9PT0gXCJjb2RlQmxvY2tcIiAmJiAodCA9IHQuY2hpbGRyZW5bMF0pLCAodCA9PSBudWxsID8gdm9pZCAwIDogdC50YWdOYW1lKSA9PT0gXCJQUkVcIiAmJiAodCA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgIGNvbnN0IHIgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmdldEF0dHJpYnV0ZShcImRhdGEtbGFuZ3VhZ2VcIik7XG4gICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICBuID0gci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaSA9IFsuLi4odCA9PSBudWxsID8gdm9pZCAwIDogdC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpKSB8fCBbXV0uZmlsdGVyKChhKSA9PiBhLnN0YXJ0c1dpdGgoXCJsYW5ndWFnZS1cIikpLm1hcCgoYSkgPT4gYS5yZXBsYWNlKFwibGFuZ3VhZ2UtXCIsIFwiXCIpKTtcbiAgICAgICAgICAgIGkubGVuZ3RoID4gMCAmJiAobiA9IGlbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuID8gVHQoZS5lZGl0b3Iuc2V0dGluZ3MuY29kZUJsb2NrLCBuKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlckhUTUw6IChvKSA9PiBvLmxhbmd1YWdlID8ge1xuICAgICAgICAgIGNsYXNzOiBgbGFuZ3VhZ2UtJHtvLmxhbmd1YWdlfWAsXG4gICAgICAgICAgXCJkYXRhLWxhbmd1YWdlXCI6IG8ubGFuZ3VhZ2VcbiAgICAgICAgfSA6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkaXZbZGF0YS1jb250ZW50LXR5cGU9XCIgKyB0aGlzLm5hbWUgKyBcIl1cIixcbiAgICAgICAgY29udGVudEVsZW1lbnQ6IFwiY29kZVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwicHJlXCIsXG4gICAgICAgIGNvbnRlbnRFbGVtZW50OiBcImNvZGVcIixcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiBcImZ1bGxcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgdmFyIHIsIHM7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiksIHsgZG9tOiB0LCBjb250ZW50RE9NOiBuIH0gPSB6KFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgXCJjb2RlXCIsXG4gICAgICAoKHIgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYmxvY2tDb250ZW50KSB8fCB7fSxcbiAgICAgIHtcbiAgICAgICAgLi4uKChzID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBzLmlubGluZUNvbnRlbnQpIHx8IHt9LFxuICAgICAgICAuLi5lXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdC5yZW1vdmVDaGlsZChuKSwgdC5hcHBlbmRDaGlsZChvKSwgby5hcHBlbmRDaGlsZChuKSwge1xuICAgICAgZG9tOiB0LFxuICAgICAgY29udGVudERPTTogblxuICAgIH07XG4gIH0sXG4gIGFkZE5vZGVWaWV3KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuICh7IGVkaXRvcjogbywgbm9kZTogdCwgZ2V0UG9zOiBuLCBIVE1MQXR0cmlidXRlczogciB9KSA9PiB7XG4gICAgICB2YXIgcCwgaDtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpLCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKSwgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHsgZG9tOiBjLCBjb250ZW50RE9NOiBsIH0gPSB6KFxuICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgIFwiY29kZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgLi4uKChwID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBwLmJsb2NrQ29udGVudCkgfHwge30sXG4gICAgICAgICAgLi4uclxuICAgICAgICB9LFxuICAgICAgICAoKGggPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGguaW5saW5lQ29udGVudCkgfHwge31cbiAgICAgICksIGQgPSAoZikgPT4ge1xuICAgICAgICBjb25zdCBtID0gZi50YXJnZXQudmFsdWU7XG4gICAgICAgIG8uY29tbWFuZHMuY29tbWFuZCgoeyB0cjogZyB9KSA9PiAoZy5zZXROb2RlQXR0cmlidXRlKG4oKSwgXCJsYW5ndWFnZVwiLCBtKSwgITApKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoXG4gICAgICAgIGUuZWRpdG9yLnNldHRpbmdzLmNvZGVCbG9jay5zdXBwb3J0ZWRMYW5ndWFnZXNcbiAgICAgICkuZm9yRWFjaCgoW2YsIHsgbmFtZTogbSB9XSkgPT4ge1xuICAgICAgICBjb25zdCBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgZy52YWx1ZSA9IGYsIGcudGV4dCA9IG0sIGkuYXBwZW5kQ2hpbGQoZyk7XG4gICAgICB9KSwgYS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCIsIGkudmFsdWUgPSB0LmF0dHJzLmxhbmd1YWdlIHx8IGUuZWRpdG9yLnNldHRpbmdzLmNvZGVCbG9jay5kZWZhdWx0TGFuZ3VhZ2UsIGMucmVtb3ZlQ2hpbGQobCksIGMuYXBwZW5kQ2hpbGQoYSksIGMuYXBwZW5kQ2hpbGQocyksIHMuYXBwZW5kQ2hpbGQobCksIGEuYXBwZW5kQ2hpbGQoaSksIGkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBkKSwge1xuICAgICAgICBkb206IGMsXG4gICAgICAgIGNvbnRlbnRET006IGwsXG4gICAgICAgIHVwZGF0ZTogKGYpID0+IGYudHlwZSA9PT0gdGhpcy50eXBlLFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLCBvID0gZ2xvYmFsVGhpcztcbiAgICBsZXQgdCwgbiwgciA9ICExO1xuICAgIHJldHVybiBbdG4oe1xuICAgICAgcGFyc2VyOiAoYSkgPT4ge1xuICAgICAgICBpZiAoIWUuZWRpdG9yLnNldHRpbmdzLmNvZGVCbG9jay5jcmVhdGVIaWdobGlnaHRlcilcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiAhciAmJiAoY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIkZvciBzeW50YXggaGlnaGxpZ2h0aW5nIG9mIGNvZGUgYmxvY2tzLCB5b3UgbXVzdCBwcm92aWRlIGEgaGlnaGxpZ2h0ZXIgZnVuY3Rpb25cIlxuICAgICAgICAgICksIHIgPSAhMCksIFtdO1xuICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgcmV0dXJuIG9bV2VdID0gb1tXZV0gfHwgZS5lZGl0b3Iuc2V0dGluZ3MuY29kZUJsb2NrLmNyZWF0ZUhpZ2hsaWdodGVyKCksIG9bV2VdLnRoZW4oXG4gICAgICAgICAgICAobCkgPT4ge1xuICAgICAgICAgICAgICB0ID0gbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCBjID0gYS5sYW5ndWFnZTtcbiAgICAgICAgcmV0dXJuIGMgJiYgYyAhPT0gXCJ0ZXh0XCIgJiYgIXQuZ2V0TG9hZGVkTGFuZ3VhZ2VzKCkuaW5jbHVkZXMoYykgJiYgYyBpbiBlLmVkaXRvci5zZXR0aW5ncy5jb2RlQmxvY2suc3VwcG9ydGVkTGFuZ3VhZ2VzID8gdC5sb2FkTGFuZ3VhZ2UoYykgOiAobiB8fCAobiA9IG9bQnRdIHx8IG9uKHQpLCBvW0J0XSA9IG4pLCBuKGEpKTtcbiAgICAgIH0sXG4gICAgICBsYW5ndWFnZUV4dHJhY3RvcjogKGEpID0+IGEuYXR0cnMubGFuZ3VhZ2UsXG4gICAgICBub2RlVHlwZXM6IFt0aGlzLm5hbWVdXG4gICAgfSldO1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBvZSh7XG4gICAgICAgIGZpbmQ6IC9eYGBgKC4qPylcXHMkLyxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGU6IG8sIHJhbmdlOiB0LCBtYXRjaDogbiB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IG8uZG9jLnJlc29sdmUodC5mcm9tKSwgcyA9IG5bMV0udHJpbSgpLCBpID0ge1xuICAgICAgICAgICAgbGFuZ3VhZ2U6IFR0KFxuICAgICAgICAgICAgICBlLmVkaXRvci5zZXR0aW5ncy5jb2RlQmxvY2ssXG4gICAgICAgICAgICAgIHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghci5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aChcbiAgICAgICAgICAgIHIuaW5kZXgoLTEpLFxuICAgICAgICAgICAgci5pbmRleEFmdGVyKC0xKSxcbiAgICAgICAgICAgIHRoaXMudHlwZVxuICAgICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBvLnRyLmRlbGV0ZSh0LmZyb20sIHQudG8pLnNldEJsb2NrVHlwZSh0LmZyb20sIHQuZnJvbSwgdGhpcy50eXBlLCBpKS5zZXRTZWxlY3Rpb24oUi5jcmVhdGUoby50ci5kb2MsIHQuZnJvbSkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBEZWxldGU6ICh7IGVkaXRvcjogZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uOiBvIH0gPSBlLnN0YXRlLCB7ICRmcm9tOiB0IH0gPSBvO1xuICAgICAgICBpZiAoZS5pc0FjdGl2ZSh0aGlzLm5hbWUpICYmICF0LnBhcmVudC50ZXh0Q29udGVudCAmJiBXdChvKSkge1xuICAgICAgICAgIGNvbnN0IG4gPSB0LnBvcyAtIHQucGFyZW50T2Zmc2V0IC0gMjtcbiAgICAgICAgICByZXR1cm4gZS5jaGFpbigpLnNldE5vZGVTZWxlY3Rpb24obikuZGVsZXRlU2VsZWN0aW9uKCkucnVuKCksICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0sXG4gICAgICBUYWI6ICh7IGVkaXRvcjogZSB9KSA9PiB0aGlzLm9wdGlvbnMuaW5kZW50TGluZVdpdGhUYWIgJiYgZS5pc0FjdGl2ZSh0aGlzLm5hbWUpID8gKGUuY29tbWFuZHMuaW5zZXJ0Q29udGVudChcIiAgXCIpLCAhMCkgOiAhMSxcbiAgICAgIEVudGVyOiAoeyBlZGl0b3I6IGUgfSkgPT4ge1xuICAgICAgICBjb25zdCB7ICRmcm9tOiBvIH0gPSBlLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFlLmlzQWN0aXZlKHRoaXMubmFtZSkpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCB0ID0gby5wYXJlbnRPZmZzZXQgPT09IG8ucGFyZW50Lm5vZGVTaXplIC0gMiwgbiA9IG8ucGFyZW50LnRleHRDb250ZW50LmVuZHNXaXRoKGBcblxuYCk7XG4gICAgICAgIHJldHVybiAhdCB8fCAhbiA/IChlLmNvbW1hbmRzLmluc2VydENvbnRlbnQoYFxuYCksICEwKSA6IGUuY2hhaW4oKS5jb21tYW5kKCh7IHRyOiByIH0pID0+IChyLmRlbGV0ZShvLnBvcyAtIDIsIG8ucG9zKSwgITApKS5leGl0Q29kZSgpLnJ1bigpO1xuICAgICAgfSxcbiAgICAgIFwiU2hpZnQtRW50ZXJcIjogKHsgZWRpdG9yOiBlIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyAkZnJvbTogbyB9ID0gZS5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIHJldHVybiBlLmlzQWN0aXZlKHRoaXMubmFtZSkgPyAoZS5jaGFpbigpLmluc2VydENvbnRlbnRBdChcbiAgICAgICAgICBvLnBvcyAtIG8ucGFyZW50T2Zmc2V0ICsgby5wYXJlbnQubm9kZVNpemUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIlxuICAgICAgICAgIH1cbiAgICAgICAgKS5ydW4oKSwgITApIDogITE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSksIHdyID0gWihcbiAga3IsXG4gIGJyXG4pO1xuZnVuY3Rpb24gVHQoZSwgbykge1xuICB2YXIgdDtcbiAgcmV0dXJuICgodCA9IE9iamVjdC5lbnRyaWVzKGUuc3VwcG9ydGVkTGFuZ3VhZ2VzKS5maW5kKChbbiwgeyBhbGlhc2VzOiByIH1dKSA9PiAociA9PSBudWxsID8gdm9pZCAwIDogci5pbmNsdWRlcyhvKSkgfHwgbiA9PT0gbykpID09IG51bGwgPyB2b2lkIDAgOiB0WzBdKSB8fCBvO1xufVxuY29uc3QgeHQgPSAoZSkgPT4gKHsgdXJsOiBlLnNyYyB8fCB2b2lkIDAgfSksIHlyID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFMuYmFja2dyb3VuZENvbG9yLFxuICAvLyBGaWxlIG5hbWUuXG4gIG5hbWU6IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIC8vIEZpbGUgdXJsLlxuICB1cmw6IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIC8vIEZpbGUgY2FwdGlvbi5cbiAgY2FwdGlvbjoge1xuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfVxufSwgQ3IgPSB7XG4gIHR5cGU6IFwiZmlsZVwiLFxuICBwcm9wU2NoZW1hOiB5cixcbiAgY29udGVudDogXCJub25lXCIsXG4gIGlzRmlsZUJsb2NrOiAhMFxufSwgdnIgPSAoZSwgbykgPT4gbHQoZSwgbyksIEVyID0gKGUpID0+IHtcbiAgaWYgKGUudGFnTmFtZSA9PT0gXCJFTUJFRFwiKVxuICAgIHJldHVybiB4dChlKTtcbiAgaWYgKGUudGFnTmFtZSA9PT0gXCJGSUdVUkVcIikge1xuICAgIGNvbnN0IG8gPSBVZShlLCBcImVtYmVkXCIpO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRhcmdldEVsZW1lbnQ6IHQsIGNhcHRpb246IG4gfSA9IG87XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnh0KHQpLFxuICAgICAgY2FwdGlvbjogblxuICAgIH07XG4gIH1cbn0sIFNyID0gKGUpID0+IHtcbiAgaWYgKCFlLnByb3BzLnVybCkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICByZXR1cm4gdC50ZXh0Q29udGVudCA9IFwiQWRkIGZpbGVcIiwge1xuICAgICAgZG9tOiB0XG4gICAgfTtcbiAgfVxuICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gIHJldHVybiBvLmhyZWYgPSBlLnByb3BzLnVybCwgby50ZXh0Q29udGVudCA9IGUucHJvcHMubmFtZSB8fCBlLnByb3BzLnVybCwgZS5wcm9wcy5jYXB0aW9uID8gJGUobywgZS5wcm9wcy5jYXB0aW9uKSA6IHtcbiAgICBkb206IG9cbiAgfTtcbn0sIEJyID0gU2UoQ3IsIHtcbiAgcmVuZGVyOiB2cixcbiAgcGFyc2U6IEVyLFxuICB0b0V4dGVybmFsSFRNTDogU3Jcbn0pLCBsbyA9IChlLCBvLCB0LCBuLCByLCBzKSA9PiB7XG4gIGNvbnN0IHsgZG9tOiBpLCBkZXN0cm95OiBhIH0gPSBsdChcbiAgICBlLFxuICAgIG8sXG4gICAgdCxcbiAgICByLFxuICAgIHNcbiAgKSwgYyA9IGk7XG4gIGUucHJvcHMudXJsICYmIGUucHJvcHMuc2hvd1ByZXZpZXcgJiYgKGMuc3R5bGUud2lkdGggPSBgJHtlLnByb3BzLnByZXZpZXdXaWR0aH1weGApO1xuICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbC5jbGFzc05hbWUgPSBcImJuLXJlc2l6ZS1oYW5kbGVcIiwgbC5zdHlsZS5sZWZ0ID0gXCI0cHhcIjtcbiAgY29uc3QgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGQuY2xhc3NOYW1lID0gXCJibi1yZXNpemUtaGFuZGxlXCIsIGQuc3R5bGUucmlnaHQgPSBcIjRweFwiO1xuICBsZXQgcCwgaCA9IGUucHJvcHMucHJldmlld1dpZHRoO1xuICBjb25zdCBmID0gKHkpID0+IHtcbiAgICBpZiAoIXApIHtcbiAgICAgICFvLmlzRWRpdGFibGUgJiYgbi5jb250YWlucyhsKSAmJiBuLmNvbnRhaW5zKGQpICYmIChuLnJlbW92ZUNoaWxkKGwpLCBuLnJlbW92ZUNoaWxkKGQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IFQ7XG4gICAgZS5wcm9wcy50ZXh0QWxpZ25tZW50ID09PSBcImNlbnRlclwiID8gcC5oYW5kbGVVc2VkID09PSBcImxlZnRcIiA/IFQgPSBwLmluaXRpYWxXaWR0aCArIChwLmluaXRpYWxDbGllbnRYIC0geS5jbGllbnRYKSAqIDIgOiBUID0gcC5pbml0aWFsV2lkdGggKyAoeS5jbGllbnRYIC0gcC5pbml0aWFsQ2xpZW50WCkgKiAyIDogcC5oYW5kbGVVc2VkID09PSBcImxlZnRcIiA/IFQgPSBwLmluaXRpYWxXaWR0aCArIHAuaW5pdGlhbENsaWVudFggLSB5LmNsaWVudFggOiBUID0gcC5pbml0aWFsV2lkdGggKyB5LmNsaWVudFggLSBwLmluaXRpYWxDbGllbnRYLCBoID0gTWF0aC5tYXgoVCwgNjQpLCBjLnN0eWxlLndpZHRoID0gYCR7aH1weGA7XG4gIH0sIG0gPSAoeSkgPT4ge1xuICAgICgheS50YXJnZXQgfHwgIWMuY29udGFpbnMoeS50YXJnZXQpIHx8ICFvLmlzRWRpdGFibGUpICYmIG4uY29udGFpbnMobCkgJiYgbi5jb250YWlucyhkKSAmJiAobi5yZW1vdmVDaGlsZChsKSwgbi5yZW1vdmVDaGlsZChkKSksIHAgJiYgKHAgPSB2b2lkIDAsIG8udXBkYXRlQmxvY2soZSwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcHJldmlld1dpZHRoOiBoXG4gICAgICB9XG4gICAgfSkpO1xuICB9LCBnID0gKCkgPT4ge1xuICAgIG8uaXNFZGl0YWJsZSAmJiAobi5hcHBlbmRDaGlsZChsKSwgbi5hcHBlbmRDaGlsZChkKSk7XG4gIH0sIGIgPSAoeSkgPT4ge1xuICAgIHkucmVsYXRlZFRhcmdldCA9PT0gbCB8fCB5LnJlbGF0ZWRUYXJnZXQgPT09IGQgfHwgcCB8fCBvLmlzRWRpdGFibGUgJiYgbi5jb250YWlucyhsKSAmJiBuLmNvbnRhaW5zKGQpICYmIChuLnJlbW92ZUNoaWxkKGwpLCBuLnJlbW92ZUNoaWxkKGQpKTtcbiAgfSwgayA9ICh5KSA9PiB7XG4gICAgeS5wcmV2ZW50RGVmYXVsdCgpLCBwID0ge1xuICAgICAgaGFuZGxlVXNlZDogXCJsZWZ0XCIsXG4gICAgICBpbml0aWFsV2lkdGg6IGMuY2xpZW50V2lkdGgsXG4gICAgICBpbml0aWFsQ2xpZW50WDogeS5jbGllbnRYXG4gICAgfTtcbiAgfSwgdyA9ICh5KSA9PiB7XG4gICAgeS5wcmV2ZW50RGVmYXVsdCgpLCBwID0ge1xuICAgICAgaGFuZGxlVXNlZDogXCJyaWdodFwiLFxuICAgICAgaW5pdGlhbFdpZHRoOiBjLmNsaWVudFdpZHRoLFxuICAgICAgaW5pdGlhbENsaWVudFg6IHkuY2xpZW50WFxuICAgIH07XG4gIH07XG4gIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG0pLCBjLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGcpLCBjLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGIpLCBsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgXCJtb3VzZWRvd25cIixcbiAgICBrXG4gICksIGQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBcIm1vdXNlZG93blwiLFxuICAgIHdcbiAgKSwge1xuICAgIGRvbTogYyxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBhID09IG51bGwgfHwgYSgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG0pLCBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGcpLCBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGIpLCBsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICAgIGtcbiAgICAgICksIGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgICAgd1xuICAgICAgKTtcbiAgICB9XG4gIH07XG59LCBpYyA9IGFzeW5jIChlKSA9PiB7XG4gIGNvbnN0IG8gPSBuZXcgRm9ybURhdGEoKTtcbiAgcmV0dXJuIG8uYXBwZW5kKFwiZmlsZVwiLCBlKSwgKGF3YWl0IChhd2FpdCBmZXRjaChcImh0dHBzOi8vdG1wZmlsZXMub3JnL2FwaS92MS91cGxvYWRcIiwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogb1xuICB9KSkuanNvbigpKS5kYXRhLnVybC5yZXBsYWNlKFxuICAgIFwidG1wZmlsZXMub3JnL1wiLFxuICAgIFwidG1wZmlsZXMub3JnL2RsL1wiXG4gICk7XG59LCBNdCA9IChlKSA9PiB7XG4gIGNvbnN0IG8gPSBlLnNyYyB8fCB2b2lkIDAsIHQgPSBlLndpZHRoIHx8IHZvaWQgMDtcbiAgcmV0dXJuIHsgdXJsOiBvLCBwcmV2aWV3V2lkdGg6IHQgfTtcbn0sIFRyID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+PHBhdGggZD1cIk01IDExLjEwMDVMNyA5LjEwMDVMMTIuNSAxNC42MDA1TDE2IDExLjEwMDVMMTkgMTQuMTAwNVY1SDVWMTEuMTAwNVpNNCAzSDIwQzIwLjU1MjMgMyAyMSAzLjQ0NzcyIDIxIDRWMjBDMjEgMjAuNTUyMyAyMC41NTIzIDIxIDIwIDIxSDRDMy40NDc3MiAyMSAzIDIwLjU1MjMgMyAyMFY0QzMgMy40NDc3MiAzLjQ0NzcyIDMgNCAzWk0xNS41IDEwQzE0LjY3MTYgMTAgMTQgOS4zMjg0MyAxNCA4LjVDMTQgNy42NzE1NyAxNC42NzE2IDcgMTUuNSA3QzE2LjMyODQgNyAxNyA3LjY3MTU3IDE3IDguNUMxNyA5LjMyODQzIDE2LjMyODQgMTAgMTUuNSAxMFpcIj48L3BhdGg+PC9zdmc+JywgeHIgPSB7XG4gIHRleHRBbGlnbm1lbnQ6IFMudGV4dEFsaWdubWVudCxcbiAgYmFja2dyb3VuZENvbG9yOiBTLmJhY2tncm91bmRDb2xvcixcbiAgLy8gRmlsZSBuYW1lLlxuICBuYW1lOiB7XG4gICAgZGVmYXVsdDogXCJcIlxuICB9LFxuICAvLyBGaWxlIHVybC5cbiAgdXJsOiB7XG4gICAgZGVmYXVsdDogXCJcIlxuICB9LFxuICAvLyBGaWxlIGNhcHRpb24uXG4gIGNhcHRpb246IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIHNob3dQcmV2aWV3OiB7XG4gICAgZGVmYXVsdDogITBcbiAgfSxcbiAgLy8gRmlsZSBwcmV2aWV3IHdpZHRoIGluIHB4LlxuICBwcmV2aWV3V2lkdGg6IHtcbiAgICBkZWZhdWx0OiA1MTJcbiAgfVxufSwgTXIgPSB7XG4gIHR5cGU6IFwiaW1hZ2VcIixcbiAgcHJvcFNjaGVtYTogeHIsXG4gIGNvbnRlbnQ6IFwibm9uZVwiLFxuICBpc0ZpbGVCbG9jazogITAsXG4gIGZpbGVCbG9ja0FjY2VwdDogW1wiaW1hZ2UvKlwiXVxufSwgUHIgPSAoZSwgbykgPT4ge1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdC5pbm5lckhUTUwgPSBUcjtcbiAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG4uY2xhc3NOYW1lID0gXCJibi12aXN1YWwtbWVkaWEtd3JhcHBlclwiO1xuICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgcmV0dXJuIHIuY2xhc3NOYW1lID0gXCJibi12aXN1YWwtbWVkaWFcIiwgby5yZXNvbHZlRmlsZVVybCA/IG8ucmVzb2x2ZUZpbGVVcmwoZS5wcm9wcy51cmwpLnRoZW4oKHMpID0+IHtcbiAgICByLnNyYyA9IHM7XG4gIH0pIDogci5zcmMgPSBlLnByb3BzLnVybCwgci5hbHQgPSBlLnByb3BzLm5hbWUgfHwgZS5wcm9wcy5jYXB0aW9uIHx8IFwiQmxvY2tOb3RlIGltYWdlXCIsIHIuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiLCByLmRyYWdnYWJsZSA9ICExLCBuLmFwcGVuZENoaWxkKHIpLCBsbyhcbiAgICBlLFxuICAgIG8sXG4gICAgeyBkb206IG4gfSxcbiAgICBuLFxuICAgIG8uZGljdGlvbmFyeS5maWxlX2Jsb2Nrcy5pbWFnZS5hZGRfYnV0dG9uX3RleHQsXG4gICAgdC5maXJzdEVsZW1lbnRDaGlsZFxuICApO1xufSwgSXIgPSAoZSkgPT4ge1xuICBpZiAoZS50YWdOYW1lID09PSBcIklNR1wiKVxuICAgIHJldHVybiBNdChlKTtcbiAgaWYgKGUudGFnTmFtZSA9PT0gXCJGSUdVUkVcIikge1xuICAgIGNvbnN0IG8gPSBVZShlLCBcImltZ1wiKTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0YXJnZXRFbGVtZW50OiB0LCBjYXB0aW9uOiBuIH0gPSBvO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5NdCh0KSxcbiAgICAgIGNhcHRpb246IG5cbiAgICB9O1xuICB9XG59LCBMciA9IChlKSA9PiB7XG4gIGlmICghZS5wcm9wcy51cmwpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcmV0dXJuIHQudGV4dENvbnRlbnQgPSBcIkFkZCBpbWFnZVwiLCB7XG4gICAgICBkb206IHRcbiAgICB9O1xuICB9XG4gIGxldCBvO1xuICByZXR1cm4gZS5wcm9wcy5zaG93UHJldmlldyA/IChvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSwgby5zcmMgPSBlLnByb3BzLnVybCwgby5hbHQgPSBlLnByb3BzLm5hbWUgfHwgZS5wcm9wcy5jYXB0aW9uIHx8IFwiQmxvY2tOb3RlIGltYWdlXCIsIG8ud2lkdGggPSBlLnByb3BzLnByZXZpZXdXaWR0aCkgOiAobyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLCBvLmhyZWYgPSBlLnByb3BzLnVybCwgby50ZXh0Q29udGVudCA9IGUucHJvcHMubmFtZSB8fCBlLnByb3BzLnVybCksIGUucHJvcHMuY2FwdGlvbiA/IGUucHJvcHMuc2hvd1ByZXZpZXcgPyBkdChvLCBlLnByb3BzLmNhcHRpb24pIDogJGUobywgZS5wcm9wcy5jYXB0aW9uKSA6IHtcbiAgICBkb206IG9cbiAgfTtcbn0sIEFyID0gU2UoTXIsIHtcbiAgcmVuZGVyOiBQcixcbiAgcGFyc2U6IElyLFxuICB0b0V4dGVybmFsSFRNTDogTHJcbn0pLCBOciA9IHtcbiAgdHlwZTogXCJwYWdlQnJlYWtcIixcbiAgcHJvcFNjaGVtYToge30sXG4gIGNvbnRlbnQ6IFwibm9uZVwiLFxuICBpc0ZpbGVCbG9jazogITEsXG4gIGlzU2VsZWN0YWJsZTogITFcbn0sIEhyID0gKCkgPT4ge1xuICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcmV0dXJuIGUuY2xhc3NOYW1lID0gXCJibi1wYWdlLWJyZWFrXCIsIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1wYWdlLWJyZWFrXCIsIFwiXCIpLCB7XG4gICAgZG9tOiBlXG4gIH07XG59LCBEciA9IChlKSA9PiB7XG4gIGlmIChlLnRhZ05hbWUgPT09IFwiRElWXCIgJiYgZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXBhZ2UtYnJlYWtcIikpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicGFnZUJyZWFrXCJcbiAgICB9O1xufSwgT3IgPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhZ2UtYnJlYWtcIiwgXCJcIiksIHtcbiAgICBkb206IGVcbiAgfTtcbn0sIF9yID0gU2UoTnIsIHtcbiAgcmVuZGVyOiBIcixcbiAgcGFyc2U6IERyLFxuICB0b0V4dGVybmFsSFRNTDogT3Jcbn0pLCBSciA9IGtlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICAgIGRlZmF1bHQ6IHZvaWQgMCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZSkgPT4gZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJhY2tncm91bmQtY29sb3JcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChlKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCI6IGUuc3RyaW5nVmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInNwYW5cIixcbiAgICAgICAgZ2V0QXR0cnM6IChlKSA9PiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gITEgOiBlLmhhc0F0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKSA/IHtcbiAgICAgICAgICBzdHJpbmdWYWx1ZTogZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJhY2tncm91bmQtY29sb3JcIilcbiAgICAgICAgfSA6ICExXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBlIH0pIHtcbiAgICByZXR1cm4gW1wic3BhblwiLCBlLCAwXTtcbiAgfVxufSksIFZyID0gZWUoXG4gIFJyLFxuICBcInN0cmluZ1wiXG4pLCBVciA9IGtlLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGV4dENvbG9yXCIsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICAgIGRlZmF1bHQ6IHZvaWQgMCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZSkgPT4gZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRleHQtY29sb3JcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChlKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS10ZXh0LWNvbG9yXCI6IGUuc3RyaW5nVmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInNwYW5cIixcbiAgICAgICAgZ2V0QXR0cnM6IChlKSA9PiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gITEgOiBlLmhhc0F0dHJpYnV0ZShcImRhdGEtdGV4dC1jb2xvclwiKSA/IHsgc3RyaW5nVmFsdWU6IGUuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZXh0LWNvbG9yXCIpIH0gOiAhMVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgcmV0dXJuIFtcInNwYW5cIiwgZSwgMF07XG4gIH1cbn0pLCAkciA9IGVlKFVyLCBcInN0cmluZ1wiKSwgcG8gPSB7XG4gIC4uLlMsXG4gIGxldmVsOiB7IGRlZmF1bHQ6IDEsIHZhbHVlczogWzEsIDIsIDNdIH1cbn0sIEZyID0gVyh7XG4gIG5hbWU6IFwiaGVhZGluZ1wiLFxuICBjb250ZW50OiBcImlubGluZSpcIixcbiAgZ3JvdXA6IFwiYmxvY2tDb250ZW50XCIsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIEVlKHBvKTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uWzEsIDIsIDNdLm1hcCgoZSkgPT4gbmV3IG9lKHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjeyR7ZX19KVxcXFxzJGApLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZTogbywgY2hhaW46IHQsIHJhbmdlOiBuIH0pID0+IHtcbiAgICAgICAgICBjb25zdCByID0gQyhvKTtcbiAgICAgICAgICAhci5pc0Jsb2NrQ29udGFpbmVyIHx8IHIuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiIHx8IHQoKS5jb21tYW5kKFxuICAgICAgICAgICAgeChcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRvcixcbiAgICAgICAgICAgICAgci5ibkJsb2NrLmJlZm9yZVBvcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICBsZXZlbDogZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICkuZGVsZXRlUmFuZ2UoeyBmcm9tOiBuLmZyb20sIHRvOiBuLnRvIH0pLnJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICBdO1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtQWx0LTFcIjogKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gQyh0aGlzLmVkaXRvci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhZS5pc0Jsb2NrQ29udGFpbmVyIHx8IGUuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiID8gITAgOiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKFxuICAgICAgICAgIHgodGhpcy5vcHRpb25zLmVkaXRvciwgZS5ibkJsb2NrLmJlZm9yZVBvcywge1xuICAgICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICBsZXZlbDogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgXCJNb2QtQWx0LTJcIjogKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gQyh0aGlzLmVkaXRvci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhZS5pc0Jsb2NrQ29udGFpbmVyIHx8IGUuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiID8gITAgOiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKFxuICAgICAgICAgIHgodGhpcy5vcHRpb25zLmVkaXRvciwgZS5ibkJsb2NrLmJlZm9yZVBvcywge1xuICAgICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICBsZXZlbDogMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgXCJNb2QtQWx0LTNcIjogKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gQyh0aGlzLmVkaXRvci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhZS5pc0Jsb2NrQ29udGFpbmVyIHx8IGUuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiID8gITAgOiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKFxuICAgICAgICAgIHgodGhpcy5vcHRpb25zLmVkaXRvciwgZS5ibkJsb2NrLmJlZm9yZVBvcywge1xuICAgICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICBsZXZlbDogM1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkaXZbZGF0YS1jb250ZW50LXR5cGU9XCIgKyB0aGlzLm5hbWUgKyBcIl1cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImgxXCIsXG4gICAgICAgIGF0dHJzOiB7IGxldmVsOiAxIH0sXG4gICAgICAgIG5vZGU6IFwiaGVhZGluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiaDJcIixcbiAgICAgICAgYXR0cnM6IHsgbGV2ZWw6IDIgfSxcbiAgICAgICAgbm9kZTogXCJoZWFkaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJoM1wiLFxuICAgICAgICBhdHRyczogeyBsZXZlbDogMyB9LFxuICAgICAgICBub2RlOiBcImhlYWRpbmdcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBub2RlOiBlLCBIVE1MQXR0cmlidXRlczogbyB9KSB7XG4gICAgdmFyIHQsIG47XG4gICAgcmV0dXJuIHooXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICBgaCR7ZS5hdHRycy5sZXZlbH1gLFxuICAgICAge1xuICAgICAgICAuLi4oKHQgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuYmxvY2tDb250ZW50KSB8fCB7fSxcbiAgICAgICAgLi4ub1xuICAgICAgfSxcbiAgICAgICgobiA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogbi5pbmxpbmVDb250ZW50KSB8fCB7fVxuICAgICk7XG4gIH1cbn0pLCB6ciA9IFooXG4gIEZyLFxuICBwb1xuKSwgdW8gPSAoZSwgbywgdCkgPT4gKHtcbiAgc3RhdGU6IG4sXG4gIGRpc3BhdGNoOiByXG59KSA9PiB7XG4gIGNvbnN0IHMgPSBYKG4uZG9jLCBlKSwgaSA9IG5lKHMpO1xuICBpZiAoIWkuaXNCbG9ja0NvbnRhaW5lcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQmxvY2tDb250YWluZXIgZXhwZWN0ZWQgd2hlbiBjYWxsaW5nIHNwbGl0QmxvY2ssIHBvc2l0aW9uICR7ZX1gXG4gICAgKTtcbiAgY29uc3QgYSA9IFtcbiAgICB7XG4gICAgICB0eXBlOiBpLmJuQmxvY2subm9kZS50eXBlLFxuICAgICAgLy8gYWx3YXlzIGtlZXAgYmxvY2tjb250YWluZXIgdHlwZVxuICAgICAgYXR0cnM6IHQgPyB7IC4uLmkuYm5CbG9jay5ub2RlLmF0dHJzLCBpZDogdm9pZCAwIH0gOiB7fVxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogbyA/IGkuYmxvY2tDb250ZW50Lm5vZGUudHlwZSA6IG4uc2NoZW1hLm5vZGVzLnBhcmFncmFwaCxcbiAgICAgIGF0dHJzOiB0ID8geyAuLi5pLmJsb2NrQ29udGVudC5ub2RlLmF0dHJzIH0gOiB7fVxuICAgIH1cbiAgXTtcbiAgcmV0dXJuIHIgJiYgbi50ci5zcGxpdChlLCAyLCBhKSwgITA7XG59LCBwdCA9IChlKSA9PiB7XG4gIGNvbnN0IG8gPSBlLl90aXB0YXBFZGl0b3IsIHQgPSBDKG8uc3RhdGUpO1xuICBpZiAoIXQuaXNCbG9ja0NvbnRhaW5lcilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHsgYm5CbG9jazogbiwgYmxvY2tDb250ZW50OiByIH0gPSB0LCBzID0gby5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID09PSBvLnN0YXRlLnNlbGVjdGlvbi5oZWFkO1xuICByZXR1cm4gIShyLm5vZGUudHlwZS5uYW1lID09PSBcImJ1bGxldExpc3RJdGVtXCIgfHwgci5ub2RlLnR5cGUubmFtZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIgfHwgci5ub2RlLnR5cGUubmFtZSA9PT0gXCJjaGVja0xpc3RJdGVtXCIpIHx8ICFzID8gITEgOiBvLmNvbW1hbmRzLmZpcnN0KCh7IHN0YXRlOiBpLCBjaGFpbjogYSwgY29tbWFuZHM6IGMgfSkgPT4gW1xuICAgICgpID0+IChcbiAgICAgIC8vIENoYW5nZXMgbGlzdCBpdGVtIGJsb2NrIHRvIGEgcGFyYWdyYXBoIGJsb2NrIGlmIHRoZSBjb250ZW50IGlzIGVtcHR5LlxuICAgICAgYy5jb21tYW5kKCgpID0+IHIubm9kZS5jaGlsZENvdW50ID09PSAwID8gYy5jb21tYW5kKFxuICAgICAgICB4KGUsIG4uYmVmb3JlUG9zLCB7XG4gICAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgfSlcbiAgICAgICkgOiAhMSlcbiAgICApLFxuICAgICgpID0+IChcbiAgICAgIC8vIFNwbGl0cyB0aGUgY3VycmVudCBibG9jaywgbW92aW5nIGNvbnRlbnQgaW5zaWRlIHRoYXQncyBhZnRlciB0aGUgY3Vyc29yXG4gICAgICAvLyB0byBhIG5ldyBibG9jayBvZiB0aGUgc2FtZSB0eXBlIGJlbG93LlxuICAgICAgYy5jb21tYW5kKCgpID0+IHIubm9kZS5jaGlsZENvdW50ID4gMCA/IChhKCkuZGVsZXRlU2VsZWN0aW9uKCkuY29tbWFuZCh1byhpLnNlbGVjdGlvbi5mcm9tLCAhMCkpLnJ1bigpLCAhMCkgOiAhMSlcbiAgICApXG4gIF0pO1xufSwgV3IgPSB7XG4gIC4uLlNcbn0sIGpyID0gVyh7XG4gIG5hbWU6IFwiYnVsbGV0TGlzdEl0ZW1cIixcbiAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gIGdyb3VwOiBcImJsb2NrQ29udGVudFwiLFxuICAvLyBUaGlzIGlzIHRvIG1ha2Ugc3VyZSB0aGF0IGNoZWNrIGxpc3QgcGFyc2UgcnVsZXMgcnVuIGJlZm9yZSwgc2luY2UgdGhleVxuICAvLyBib3RoIHBhcnNlIGBsaWAgZWxlbWVudHMgYnV0IGNoZWNrIGxpc3RzIGFyZSBtb3JlIHNwZWNpZmljLlxuICBwcmlvcml0eTogOTAsXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIENyZWF0ZXMgYW4gdW5vcmRlcmVkIGxpc3Qgd2hlbiBzdGFydGluZyB3aXRoIFwiLVwiLCBcIitcIiwgb3IgXCIqXCIuXG4gICAgICBuZXcgb2Uoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKFwiXlstKypdXFxcXHMkXCIpLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZTogZSwgY2hhaW46IG8sIHJhbmdlOiB0IH0pID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gQyhlKTtcbiAgICAgICAgICAhbi5pc0Jsb2NrQ29udGFpbmVyIHx8IG4uYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiIHx8IG8oKS5jb21tYW5kKFxuICAgICAgICAgICAgeChcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRvcixcbiAgICAgICAgICAgICAgbi5ibkJsb2NrLmJlZm9yZVBvcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnVsbGV0TGlzdEl0ZW1cIixcbiAgICAgICAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICkuZGVsZXRlUmFuZ2UoeyBmcm9tOiB0LmZyb20sIHRvOiB0LnRvIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gcHQodGhpcy5vcHRpb25zLmVkaXRvciksXG4gICAgICBcIk1vZC1TaGlmdC04XCI6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZSA9IEModGhpcy5lZGl0b3Iuc3RhdGUpO1xuICAgICAgICByZXR1cm4gIWUuaXNCbG9ja0NvbnRhaW5lciB8fCBlLmJsb2NrQ29udGVudC5ub2RlLnR5cGUuc3BlYy5jb250ZW50ICE9PSBcImlubGluZSpcIiA/ICEwIDogdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZChcbiAgICAgICAgICB4KHRoaXMub3B0aW9ucy5lZGl0b3IsIGUuYm5CbG9jay5iZWZvcmVQb3MsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnVsbGV0TGlzdEl0ZW1cIixcbiAgICAgICAgICAgIHByb3BzOiB7fVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBDYXNlIGZvciByZWd1bGFyIEhUTUwgbGlzdCBzdHJ1Y3R1cmUuXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkaXZbZGF0YS1jb250ZW50LXR5cGU9XCIgKyB0aGlzLm5hbWUgKyBcIl1cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImxpXCIsXG4gICAgICAgIGdldEF0dHJzOiAoZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IG8gPSBlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIG8gPT09IG51bGwgPyAhMSA6IG8udGFnTmFtZSA9PT0gXCJVTFwiIHx8IG8udGFnTmFtZSA9PT0gXCJESVZcIiAmJiBvLnBhcmVudEVsZW1lbnQudGFnTmFtZSA9PT0gXCJVTFwiID8ge30gOiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZTogXCJidWxsZXRMaXN0SXRlbVwiXG4gICAgICB9LFxuICAgICAgLy8gQ2FzZSBmb3IgQmxvY2tOb3RlIGxpc3Qgc3RydWN0dXJlLlxuICAgICAge1xuICAgICAgICB0YWc6IFwicFwiLFxuICAgICAgICBnZXRBdHRyczogKGUpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBjb25zdCBvID0gZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIHJldHVybiBvID09PSBudWxsID8gITEgOiBvLmdldEF0dHJpYnV0ZShcImRhdGEtY29udGVudC10eXBlXCIpID09PSBcImJ1bGxldExpc3RJdGVtXCIgPyB7fSA6ICExO1xuICAgICAgICB9LFxuICAgICAgICBwcmlvcml0eTogMzAwLFxuICAgICAgICBub2RlOiBcImJ1bGxldExpc3RJdGVtXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXM6IGUgfSkge1xuICAgIHZhciBvLCB0O1xuICAgIHJldHVybiB6KFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgLy8gV2UgdXNlIGEgPHA+IHRhZywgYmVjYXVzZSBmb3IgPGxpPiB0YWdzIHdlJ2QgbmVlZCBhIDx1bD4gZWxlbWVudCB0byBwdXRcbiAgICAgIC8vIHRoZW0gaW4gdG8gYmUgc2VtYW50aWNhbGx5IGNvcnJlY3QsIHdoaWNoIHdlIGNhbid0IGhhdmUgZHVlIHRvIHRoZVxuICAgICAgLy8gc2NoZW1hLlxuICAgICAgXCJwXCIsXG4gICAgICB7XG4gICAgICAgIC4uLigobyA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogby5ibG9ja0NvbnRlbnQpIHx8IHt9LFxuICAgICAgICAuLi5lXG4gICAgICB9LFxuICAgICAgKCh0ID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiB0LmlubGluZUNvbnRlbnQpIHx8IHt9XG4gICAgKTtcbiAgfVxufSksIEdyID0gWihcbiAganIsXG4gIFdyXG4pLCBobyA9IHtcbiAgLi4uUyxcbiAgY2hlY2tlZDoge1xuICAgIGRlZmF1bHQ6ICExXG4gIH1cbn0sIHFyID0gVyh7XG4gIG5hbWU6IFwiY2hlY2tMaXN0SXRlbVwiLFxuICBjb250ZW50OiBcImlubGluZSpcIixcbiAgZ3JvdXA6IFwiYmxvY2tDb250ZW50XCIsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIEVlKGhvKTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQ3JlYXRlcyBhIGNoZWNrbGlzdCB3aGVuIHN0YXJ0aW5nIHdpdGggXCJbXVwiIG9yIFwiW1hdXCIuXG4gICAgICBuZXcgb2Uoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKFwiXFxcXFtcXFxccypcXFxcXVxcXFxzJFwiKSxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGU6IGUsIGNoYWluOiBvLCByYW5nZTogdCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IEMoZSk7XG4gICAgICAgICAgIW4uaXNCbG9ja0NvbnRhaW5lciB8fCBuLmJsb2NrQ29udGVudC5ub2RlLnR5cGUuc3BlYy5jb250ZW50ICE9PSBcImlubGluZSpcIiB8fCBvKCkuY29tbWFuZChcbiAgICAgICAgICAgIHgoXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0b3IsXG4gICAgICAgICAgICAgIG4uYm5CbG9jay5iZWZvcmVQb3MsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNoZWNrTGlzdEl0ZW1cIixcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgY2hlY2tlZDogITFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApLmRlbGV0ZVJhbmdlKHsgZnJvbTogdC5mcm9tLCB0bzogdC50byB9KTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBuZXcgb2Uoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKFwiXFxcXFtbWHhdXFxcXF1cXFxccyRcIiksXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlOiBlLCBjaGFpbjogbywgcmFuZ2U6IHQgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBDKGUpO1xuICAgICAgICAgICFuLmlzQmxvY2tDb250YWluZXIgfHwgbi5ibG9ja0NvbnRlbnQubm9kZS50eXBlLnNwZWMuY29udGVudCAhPT0gXCJpbmxpbmUqXCIgfHwgbygpLmNvbW1hbmQoXG4gICAgICAgICAgICB4KFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdG9yLFxuICAgICAgICAgICAgICBuLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjaGVja0xpc3RJdGVtXCIsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6ICEwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKS5kZWxldGVSYW5nZSh7IGZyb206IHQuZnJvbSwgdG86IHQudG8gfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiBwdCh0aGlzLm9wdGlvbnMuZWRpdG9yKSxcbiAgICAgIFwiTW9kLVNoaWZ0LTlcIjogKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gQyh0aGlzLmVkaXRvci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhZS5pc0Jsb2NrQ29udGFpbmVyIHx8IGUuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiID8gITAgOiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKFxuICAgICAgICAgIHgodGhpcy5vcHRpb25zLmVkaXRvciwgZS5ibkJsb2NrLmJlZm9yZVBvcywge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja0xpc3RJdGVtXCIsXG4gICAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiZGl2W2RhdGEtY29udGVudC10eXBlPVwiICsgdGhpcy5uYW1lICsgXCJdXCJcbiAgICAgIH0sXG4gICAgICAvLyBDaGVja2JveCBvbmx5LlxuICAgICAge1xuICAgICAgICB0YWc6IFwiaW5wdXRcIixcbiAgICAgICAgZ2V0QXR0cnM6IChlKSA9PiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gITEgOiBlLnR5cGUgPT09IFwiY2hlY2tib3hcIiA/IHsgY2hlY2tlZDogZS5jaGVja2VkIH0gOiAhMSxcbiAgICAgICAgbm9kZTogXCJjaGVja0xpc3RJdGVtXCJcbiAgICAgIH0sXG4gICAgICAvLyBDb250YWluZXIgZWxlbWVudCBmb3IgY2hlY2tib3ggKyBsYWJlbC5cbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImxpXCIsXG4gICAgICAgIGdldEF0dHJzOiAoZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IG8gPSBlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKG8gPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgaWYgKG8udGFnTmFtZSA9PT0gXCJVTFwiIHx8IG8udGFnTmFtZSA9PT0gXCJESVZcIiAmJiBvLnBhcmVudEVsZW1lbnQudGFnTmFtZSA9PT0gXCJVTFwiKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gZS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICBcImlucHV0W3R5cGU9Y2hlY2tib3hdXCJcbiAgICAgICAgICAgICkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0ID09PSBudWxsID8gITEgOiB7IGNoZWNrZWQ6IHQuY2hlY2tlZCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgIG5vZGU6IFwiY2hlY2tMaXN0SXRlbVwiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgLy8gU2luY2UgdGhlcmUgaXMgbm8gSFRNTCBjaGVja2xpc3QgZWxlbWVudCwgdGhlcmUgaXNuJ3QgcmVhbGx5IGFueVxuICAvLyBzdGFuZGFyZGl6YXRpb24gZm9yIHdoYXQgY2hlY2tsaXN0cyBzaG91bGQgbG9vayBsaWtlIGluIHRoZSBET00uIEdEb2NzJ1xuICAvLyBhbmQgTm90aW9uJ3MgYXJlbid0IGNyb3NzIGNvbXBhdGlibGUsIGZvciBleGFtcGxlLiBUaGlzIGltcGxlbWVudGF0aW9uXG4gIC8vIGhhcyBhIHNlbWFudGljYWxseSBjb3JyZWN0IERPTSBzdHJ1Y3R1cmUgKHRob3VnaCBtaXNzaW5nIGEgbGFiZWwgZm9yIHRoZVxuICAvLyBjaGVja2JveCkgd2hpY2ggaXMgYWxzbyBjb252ZXJ0ZWQgY29ycmVjdGx5IHRvIE1hcmtkb3duIGJ5IHJlbWFyay5cbiAgcmVuZGVySFRNTCh7IG5vZGU6IGUsIEhUTUxBdHRyaWJ1dGVzOiBvIH0pIHtcbiAgICB2YXIgcywgaTtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIHQudHlwZSA9IFwiY2hlY2tib3hcIiwgdC5jaGVja2VkID0gZS5hdHRycy5jaGVja2VkLCBlLmF0dHJzLmNoZWNrZWQgJiYgdC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIFwiXCIpO1xuICAgIGNvbnN0IHsgZG9tOiBuLCBjb250ZW50RE9NOiByIH0gPSB6KFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgXCJwXCIsXG4gICAgICB7XG4gICAgICAgIC4uLigocyA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogcy5ibG9ja0NvbnRlbnQpIHx8IHt9LFxuICAgICAgICAuLi5vXG4gICAgICB9LFxuICAgICAgKChpID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBpLmlubGluZUNvbnRlbnQpIHx8IHt9XG4gICAgKTtcbiAgICByZXR1cm4gbi5pbnNlcnRCZWZvcmUodCwgciksIHsgZG9tOiBuLCBjb250ZW50RE9NOiByIH07XG4gIH0sXG4gIC8vIE5lZWQgdG8gcmVuZGVyIG5vZGUgdmlldyBzaW5jZSB0aGUgY2hlY2tib3ggbmVlZHMgdG8gYmUgYWJsZSB0byB1cGRhdGUgdGhlXG4gIC8vIG5vZGUuIFRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIGEgbm9kZSB2aWV3IGFzIGl0IGV4cG9zZXMgYGdldFBvc2AuXG4gIGFkZE5vZGVWaWV3KCkge1xuICAgIHJldHVybiAoeyBub2RlOiBlLCBnZXRQb3M6IG8sIGVkaXRvcjogdCwgSFRNTEF0dHJpYnV0ZXM6IG4gfSkgPT4ge1xuICAgICAgdmFyIGQsIHA7XG4gICAgICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBzLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBpLnR5cGUgPSBcImNoZWNrYm94XCIsIGkuY2hlY2tlZCA9IGUuYXR0cnMuY2hlY2tlZCwgZS5hdHRycy5jaGVja2VkICYmIGkuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcIlwiKTtcbiAgICAgIGNvbnN0IGEgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdC5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgaS5jaGVja2VkID0gIWkuY2hlY2tlZDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvICE9IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgY29uc3QgaCA9IFgoXG4gICAgICAgICAgICB0LnN0YXRlLmRvYyxcbiAgICAgICAgICAgIG8oKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGgubm9kZS50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEV4cGVjdGVkIGJsb2NrQ29udGFpbmVyIG5vZGUsIGdvdCAke2gubm9kZS50eXBlLm5hbWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKFxuICAgICAgICAgICAgeChcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRvcixcbiAgICAgICAgICAgICAgaC5wb3NCZWZvcmVOb2RlLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjaGVja0xpc3RJdGVtXCIsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGkuY2hlY2tlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgYSk7XG4gICAgICBjb25zdCB7IGRvbTogYywgY29udGVudERPTTogbCB9ID0geihcbiAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICBcInBcIixcbiAgICAgICAge1xuICAgICAgICAgIC4uLigoZCA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogZC5ibG9ja0NvbnRlbnQpIHx8IHt9LFxuICAgICAgICAgIC4uLm5cbiAgICAgICAgfSxcbiAgICAgICAgKChwID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBwLmlubGluZUNvbnRlbnQpIHx8IHt9XG4gICAgICApO1xuICAgICAgaWYgKHR5cGVvZiBvICE9IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGNvbnN0IGYgPSBcImxhYmVsLVwiICsgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUobygpKS5ub2RlKCkuYXR0cnMuaWQ7XG4gICAgICAgIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGYpLCBsLmlkID0gZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjLnJlbW92ZUNoaWxkKGwpLCBjLmFwcGVuZENoaWxkKHIpLCByLmFwcGVuZENoaWxkKHMpLCByLmFwcGVuZENoaWxkKGwpLCBzLmFwcGVuZENoaWxkKGkpLCB7XG4gICAgICAgIGRvbTogYyxcbiAgICAgICAgY29udGVudERPTTogbCxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBhKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9XG59KSwgS3IgPSBaKFxuICBxcixcbiAgaG9cbiksIFhyID0gbmV3IE4oXCJudW1iZXJlZC1saXN0LWluZGV4aW5nXCIpLCBKciA9ICgpID0+IG5ldyBNKHtcbiAga2V5OiBYcixcbiAgYXBwZW5kVHJhbnNhY3Rpb246IChlLCBvLCB0KSA9PiB7XG4gICAgY29uc3QgbiA9IHQudHI7XG4gICAgbi5zZXRNZXRhKFwibnVtYmVyZWRMaXN0SW5kZXhpbmdcIiwgITApO1xuICAgIGxldCByID0gITE7XG4gICAgcmV0dXJuIHQuZG9jLmRlc2NlbmRhbnRzKChzLCBpKSA9PiB7XG4gICAgICB2YXIgYTtcbiAgICAgIGlmIChzLnR5cGUubmFtZSA9PT0gXCJibG9ja0NvbnRhaW5lclwiICYmIHMuZmlyc3RDaGlsZC50eXBlLm5hbWUgPT09IFwibnVtYmVyZWRMaXN0SXRlbVwiKSB7XG4gICAgICAgIGxldCBjID0gYCR7cy5maXJzdENoaWxkLmF0dHJzLnN0YXJ0IHx8IDF9YDtcbiAgICAgICAgY29uc3QgbCA9IG5lKHtcbiAgICAgICAgICBwb3NCZWZvcmVOb2RlOiBpLFxuICAgICAgICAgIG5vZGU6IHNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbC5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcG9zc2libGVcIik7XG4gICAgICAgIGNvbnN0IGQgPSBuLmRvYy5yZXNvbHZlKFxuICAgICAgICAgIGwuYm5CbG9jay5iZWZvcmVQb3NcbiAgICAgICAgKS5ub2RlQmVmb3JlO1xuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIGNvbnN0IG0gPSBuZSh7XG4gICAgICAgICAgICBwb3NCZWZvcmVOb2RlOiBsLmJuQmxvY2suYmVmb3JlUG9zIC0gZC5ub2RlU2l6ZSxcbiAgICAgICAgICAgIG5vZGU6IGRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobS5ibG9ja05vdGVUeXBlID09PSBcIm51bWJlcmVkTGlzdEl0ZW1cIikge1xuICAgICAgICAgICAgaWYgKCFtLmlzQmxvY2tDb250YWluZXIpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcG9zc2libGVcIik7XG4gICAgICAgICAgICBjb25zdCBiID0gbS5ibG9ja0NvbnRlbnQubm9kZS5hdHRycy5pbmRleDtcbiAgICAgICAgICAgIGMgPSAocGFyc2VJbnQoYikgKyAxKS50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwID0gbC5ibG9ja0NvbnRlbnQubm9kZSwgaCA9IHAuYXR0cnMuaW5kZXgsIGYgPSAoKGEgPSBkID09IG51bGwgPyB2b2lkIDAgOiBkLmZpcnN0Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBhLnR5cGUubmFtZSkgIT09IFwibnVtYmVyZWRMaXN0SXRlbVwiO1xuICAgICAgICBpZiAoaCAhPT0gYyB8fCBwLmF0dHJzLnN0YXJ0ICYmICFmKSB7XG4gICAgICAgICAgciA9ICEwO1xuICAgICAgICAgIGNvbnN0IHsgc3RhcnQ6IG0sIC4uLmcgfSA9IHAuYXR0cnM7XG4gICAgICAgICAgbi5zZXROb2RlTWFya3VwKGwuYmxvY2tDb250ZW50LmJlZm9yZVBvcywgdm9pZCAwLCB7XG4gICAgICAgICAgICAuLi5nLFxuICAgICAgICAgICAgaW5kZXg6IGMsXG4gICAgICAgICAgICAuLi50eXBlb2YgbSA9PSBcIm51bWJlclwiICYmIGYgJiYge1xuICAgICAgICAgICAgICBzdGFydDogbVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIHIgPyBuIDogbnVsbDtcbiAgfVxufSksIGZvID0ge1xuICAuLi5TLFxuICBzdGFydDogeyBkZWZhdWx0OiB2b2lkIDAsIHR5cGU6IFwibnVtYmVyXCIgfVxufSwgWXIgPSBXKHtcbiAgbmFtZTogXCJudW1iZXJlZExpc3RJdGVtXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgcHJpb3JpdHk6IDkwLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5FZShmbyksXG4gICAgICAvLyB0aGUgaW5kZXggYXR0cmlidXRlIGlzIG9ubHkgdXNlZCBpbnRlcm5hbGx5IChpdCdzIG5vdCBwYXJ0IG9mIHRoZSBibG9ja25vdGUgc2NoZW1hKVxuICAgICAgLy8gdGhhdCdzIHdoeSBpdCdzIGRlZmluZWQgZXhwbGljaXRseSBoZXJlLCBhbmQgbm90IHBhcnQgb2YgdGhlIHByb3Agc2NoZW1hXG4gICAgICBpbmRleDoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlKSA9PiBlLmdldEF0dHJpYnV0ZShcImRhdGEtaW5kZXhcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChlKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBlLmluZGV4XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQ3JlYXRlcyBhbiBvcmRlcmVkIGxpc3Qgd2hlbiBzdGFydGluZyB3aXRoIFwiMS5cIi5cbiAgICAgIG5ldyBvZSh7XG4gICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoXCJeKFxcXFxkKylcXFxcLlxcXFxzJFwiKSxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGU6IGUsIGNoYWluOiBvLCByYW5nZTogdCwgbWF0Y2g6IG4gfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBDKGUpO1xuICAgICAgICAgIGlmICghci5pc0Jsb2NrQ29udGFpbmVyIHx8IHIuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiIHx8IHIuYmxvY2tOb3RlVHlwZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgcyA9IHBhcnNlSW50KG5bMV0pO1xuICAgICAgICAgIG8oKS5jb21tYW5kKFxuICAgICAgICAgICAgeChcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRvcixcbiAgICAgICAgICAgICAgci5ibkJsb2NrLmJlZm9yZVBvcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyZWRMaXN0SXRlbVwiLFxuICAgICAgICAgICAgICAgIHByb3BzOiBzID09PSAxICYmIHt9IHx8IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKS5kZWxldGVSYW5nZSh7IGZyb206IHQuZnJvbSwgdG86IHQudG8gfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiBwdCh0aGlzLm9wdGlvbnMuZWRpdG9yKSxcbiAgICAgIFwiTW9kLVNoaWZ0LTdcIjogKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gQyh0aGlzLmVkaXRvci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhZS5pc0Jsb2NrQ29udGFpbmVyIHx8IGUuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiID8gITAgOiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKFxuICAgICAgICAgIHgodGhpcy5vcHRpb25zLmVkaXRvciwgZS5ibkJsb2NrLmJlZm9yZVBvcywge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJlZExpc3RJdGVtXCIsXG4gICAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW0pyKCldO1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImRpdltkYXRhLWNvbnRlbnQtdHlwZT1cIiArIHRoaXMubmFtZSArIFwiXVwiXG4gICAgICB9LFxuICAgICAgLy8gQ2FzZSBmb3IgcmVndWxhciBIVE1MIGxpc3Qgc3RydWN0dXJlLlxuICAgICAgLy8gKGUuZy46IHdoZW4gcGFzdGluZyBmcm9tIG90aGVyIGFwcHMpXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJsaVwiLFxuICAgICAgICBnZXRBdHRyczogKGUpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBjb25zdCBvID0gZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIGlmIChvID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGlmIChvLnRhZ05hbWUgPT09IFwiT0xcIiB8fCBvLnRhZ05hbWUgPT09IFwiRElWXCIgJiYgby5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09IFwiT0xcIikge1xuICAgICAgICAgICAgY29uc3QgdCA9IHBhcnNlSW50KG8uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgfHwgXCIxXCIpIHx8IDE7XG4gICAgICAgICAgICByZXR1cm4gZS5wcmV2aW91c1NpYmxpbmcgfHwgdCA9PT0gMSA/IHt9IDoge1xuICAgICAgICAgICAgICBzdGFydDogdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LFxuICAgICAgICBub2RlOiBcIm51bWJlcmVkTGlzdEl0ZW1cIlxuICAgICAgfSxcbiAgICAgIC8vIENhc2UgZm9yIEJsb2NrTm90ZSBsaXN0IHN0cnVjdHVyZS5cbiAgICAgIC8vIChlLmcuOiB3aGVuIHBhc3RpbmcgZnJvbSBibG9ja25vdGUpXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJwXCIsXG4gICAgICAgIGdldEF0dHJzOiAoZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IG8gPSBlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIG8gPT09IG51bGwgPyAhMSA6IG8uZ2V0QXR0cmlidXRlKFwiZGF0YS1jb250ZW50LXR5cGVcIikgPT09IFwibnVtYmVyZWRMaXN0SXRlbVwiID8ge30gOiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJpb3JpdHk6IDMwMCxcbiAgICAgICAgbm9kZTogXCJudW1iZXJlZExpc3RJdGVtXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXM6IGUgfSkge1xuICAgIHZhciBvLCB0O1xuICAgIHJldHVybiB6KFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgLy8gV2UgdXNlIGEgPHA+IHRhZywgYmVjYXVzZSBmb3IgPGxpPiB0YWdzIHdlJ2QgbmVlZCBhbiA8b2w+IGVsZW1lbnQgdG9cbiAgICAgIC8vIHB1dCB0aGVtIGluIHRvIGJlIHNlbWFudGljYWxseSBjb3JyZWN0LCB3aGljaCB3ZSBjYW4ndCBoYXZlIGR1ZSB0byB0aGVcbiAgICAgIC8vIHNjaGVtYS5cbiAgICAgIFwicFwiLFxuICAgICAge1xuICAgICAgICAuLi4oKG8gPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IG8uYmxvY2tDb250ZW50KSB8fCB7fSxcbiAgICAgICAgLi4uZVxuICAgICAgfSxcbiAgICAgICgodCA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogdC5pbmxpbmVDb250ZW50KSB8fCB7fVxuICAgICk7XG4gIH1cbn0pLCBaciA9IFooXG4gIFlyLFxuICBmb1xuKSwgUXIgPSB7XG4gIC4uLlNcbn0sIGVzID0gVyh7XG4gIG5hbWU6IFwicGFyYWdyYXBoXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLUFsdC0wXCI6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZSA9IEModGhpcy5lZGl0b3Iuc3RhdGUpO1xuICAgICAgICByZXR1cm4gIWUuaXNCbG9ja0NvbnRhaW5lciB8fCBlLmJsb2NrQ29udGVudC5ub2RlLnR5cGUuc3BlYy5jb250ZW50ICE9PSBcImlubGluZSpcIiA/ICEwIDogdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZChcbiAgICAgICAgICB4KHRoaXMub3B0aW9ucy5lZGl0b3IsIGUuYm5CbG9jay5iZWZvcmVQb3MsIHtcbiAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6IFwiZGl2W2RhdGEtY29udGVudC10eXBlPVwiICsgdGhpcy5uYW1lICsgXCJdXCIgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInBcIixcbiAgICAgICAgcHJpb3JpdHk6IDIwMCxcbiAgICAgICAgZ2V0QXR0cnM6IChlKSA9PiB7XG4gICAgICAgICAgdmFyIG87XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgISgobyA9IGUudGV4dENvbnRlbnQpICE9IG51bGwgJiYgby50cmltKCkpID8gITEgOiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZTogXCJwYXJhZ3JhcGhcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgdmFyIG8sIHQ7XG4gICAgcmV0dXJuIHooXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICBcInBcIixcbiAgICAgIHtcbiAgICAgICAgLi4uKChvID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBvLmJsb2NrQ29udGVudCkgfHwge30sXG4gICAgICAgIC4uLmVcbiAgICAgIH0sXG4gICAgICAoKHQgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaW5saW5lQ29udGVudCkgfHwge31cbiAgICApO1xuICB9XG59KSwgdHMgPSBaKFxuICBlcyxcbiAgUXJcbiksIG9zID0ge1xuICAuLi5TXG59LCBucyA9IFcoe1xuICBuYW1lOiBcInF1b3RlXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQ3JlYXRlcyBhIGJsb2NrIHF1b3RlIHdoZW4gc3RhcnRpbmcgd2l0aCBcIj5cIi5cbiAgICAgIG5ldyBvZSh7XG4gICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoXCJePlxcXFxzJFwiKSxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGU6IGUsIGNoYWluOiBvLCByYW5nZTogdCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IEMoZSk7XG4gICAgICAgICAgIW4uaXNCbG9ja0NvbnRhaW5lciB8fCBuLmJsb2NrQ29udGVudC5ub2RlLnR5cGUuc3BlYy5jb250ZW50ICE9PSBcImlubGluZSpcIiB8fCBvKCkuY29tbWFuZChcbiAgICAgICAgICAgIHgoXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0b3IsXG4gICAgICAgICAgICAgIG4uYm5CbG9jay5iZWZvcmVQb3MsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInF1b3RlXCIsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApLmRlbGV0ZVJhbmdlKHsgZnJvbTogdC5mcm9tLCB0bzogdC50byB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtQWx0LXFcIjogKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gQyh0aGlzLmVkaXRvci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhZS5pc0Jsb2NrQ29udGFpbmVyIHx8IGUuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiID8gITAgOiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKFxuICAgICAgICAgIHgodGhpcy5vcHRpb25zLmVkaXRvciwgZS5ibkJsb2NrLmJlZm9yZVBvcywge1xuICAgICAgICAgICAgdHlwZTogXCJxdW90ZVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdGFnOiBcImRpdltkYXRhLWNvbnRlbnQtdHlwZT1cIiArIHRoaXMubmFtZSArIFwiXVwiIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJibG9ja3F1b3RlXCIsXG4gICAgICAgIG5vZGU6IFwicXVvdGVcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgdmFyIG8sIHQ7XG4gICAgcmV0dXJuIHooXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICBcImJsb2NrcXVvdGVcIixcbiAgICAgIHtcbiAgICAgICAgLi4uKChvID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBvLmJsb2NrQ29udGVudCkgfHwge30sXG4gICAgICAgIC4uLmVcbiAgICAgIH0sXG4gICAgICAoKHQgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaW5saW5lQ29udGVudCkgfHwge31cbiAgICApO1xuICB9XG59KSwgcnMgPSBaKFxuICBucyxcbiAgb3NcbiksIHNzID0gMzUsIG1vID0gMTIwLCBhYyA9IDMxLCBpcyA9IEguY3JlYXRlKHtcbiAgbmFtZTogXCJCbG9ja05vdGVUYWJsZUV4dGVuc2lvblwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnM6ICgpID0+IFtcbiAgICBubih7XG4gICAgICBjZWxsTWluV2lkdGg6IHNzLFxuICAgICAgZGVmYXVsdENlbGxNaW5XaWR0aDogbW8sXG4gICAgICAvLyBXZSBzZXQgdGhpcyB0byBudWxsIGFzIHdlIGltcGxlbWVudCBvdXIgb3duIG5vZGUgdmlldyBpbiB0aGUgdGFibGVcbiAgICAgIC8vIGJsb2NrIGNvbnRlbnQuIFRoaXMgbm9kZSB2aWV3IGlzIHRoZSBzYW1lIGFzIHdoYXQncyB1c2VkIGJ5IGRlZmF1bHQsXG4gICAgICAvLyBidXQgaXMgd3JhcHBlZCBpbiBhIGBibG9ja0NvbnRlbnRgIEhUTUwgZWxlbWVudC5cbiAgICAgIFZpZXc6IG51bGxcbiAgICB9KSxcbiAgICBybigpXG4gIF0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBNYWtlcyBlbnRlciBjcmVhdGUgYSBuZXcgbGluZSB3aXRoaW4gdGhlIGNlbGwuXG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmIHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5wYXJlbnQudHlwZS5uYW1lID09PSBcInRhYmxlUGFyYWdyYXBoXCIgPyAodGhpcy5lZGl0b3IuY29tbWFuZHMuaW5zZXJ0Q29udGVudCh7IHR5cGU6IFwiaGFyZEJyZWFrXCIgfSksICEwKSA6ICExLFxuICAgICAgLy8gRW5zdXJlcyB0aGF0IGJhY2tzcGFjZSB3b24ndCBkZWxldGUgdGhlIHRhYmxlIGlmIHRoZSB0ZXh0IGN1cnNvciBpcyBhdFxuICAgICAgLy8gdGhlIHN0YXJ0IG9mIGEgY2VsbCBhbmQgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eS5cbiAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLCBvID0gZS5lbXB0eSwgdCA9IGUuJGhlYWQucGFyZW50T2Zmc2V0ID09PSAwLCBuID0gZS4kaGVhZC5ub2RlKCkudHlwZS5uYW1lID09PSBcInRhYmxlUGFyYWdyYXBoXCI7XG4gICAgICAgIHJldHVybiBvICYmIHQgJiYgbjtcbiAgICAgIH0sXG4gICAgICAvLyBFbmFibGVzIG5hdmlnYXRpbmcgY2VsbHMgdXNpbmcgdGhlIHRhYiBrZXkuXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoXG4gICAgICAgICh7IHN0YXRlOiBlLCBkaXNwYXRjaDogbywgdmlldzogdCB9KSA9PiBidCgxKShlLCBvLCB0KVxuICAgICAgKSxcbiAgICAgIFwiU2hpZnQtVGFiXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoXG4gICAgICAgICh7IHN0YXRlOiBlLCBkaXNwYXRjaDogbywgdmlldzogdCB9KSA9PiBidCgtMSkoZSwgbywgdClcbiAgICAgIClcbiAgICB9O1xuICB9LFxuICBleHRlbmROb2RlU2NoZW1hKGUpIHtcbiAgICBjb25zdCBvID0ge1xuICAgICAgbmFtZTogZS5uYW1lLFxuICAgICAgb3B0aW9uczogZS5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZS5zdG9yYWdlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGVSb2xlOiBxbyhcbiAgICAgICAgS28oZSwgXCJ0YWJsZVJvbGVcIiwgbylcbiAgICAgIClcbiAgICB9O1xuICB9XG59KSwgYXMgPSB7XG4gIHRleHRDb2xvcjogUy50ZXh0Q29sb3Jcbn0sIGNzID0gVyh7XG4gIG5hbWU6IFwidGFibGVcIixcbiAgY29udGVudDogXCJ0YWJsZVJvdytcIixcbiAgZ3JvdXA6IFwiYmxvY2tDb250ZW50XCIsXG4gIHRhYmxlUm9sZTogXCJ0YWJsZVwiLFxuICBpc29sYXRpbmc6ICEwLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJ0YWJsZVwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXM6IGUgfSkge1xuICAgIHZhciBvLCB0O1xuICAgIHJldHVybiB6KFxuICAgICAgdGhpcy5uYW1lLFxuICAgICAgXCJ0YWJsZVwiLFxuICAgICAge1xuICAgICAgICAuLi4oKG8gPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IG8uYmxvY2tDb250ZW50KSB8fCB7fSxcbiAgICAgICAgLi4uZVxuICAgICAgfSxcbiAgICAgICgodCA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogdC5pbmxpbmVDb250ZW50KSB8fCB7fVxuICAgICk7XG4gIH0sXG4gIC8vIFRoaXMgbm9kZSB2aWV3IGlzIG5lZWRlZCBmb3IgdGhlIGBjb2x1bW5SZXNpemluZ2AgcGx1Z2luLiBCeSBkZWZhdWx0LCB0aGVcbiAgLy8gcGx1Z2luIGFkZHMgaXRzIG93biBub2RlIHZpZXcsIHdoaWNoIG92ZXJyaWRlcyBob3cgdGhlIG5vZGUgaXMgcmVuZGVyZWQgdnNcbiAgLy8gYHJlbmRlckhUTUxgLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHdyYXBwaW5nIGBibG9ja0NvbnRlbnRgIEhUTUwgZWxlbWVudCBpc1xuICAvLyBubyBsb25nZXIgcmVuZGVyZWQuIFRoZSBgY29sdW1uUmVzaXppbmdgIHBsdWdpbiB1c2VzIHRoZSBgVGFibGVWaWV3YCBhcyBpdHNcbiAgLy8gZGVmYXVsdCBub2RlIHZpZXcuIGBCbG9ja05vdGVUYWJsZVZpZXdgIGV4dGVuZHMgaXQgYnkgd3JhcHBpbmcgaXQgaW4gYVxuICAvLyBgYmxvY2tDb250ZW50YCBlbGVtZW50LCBzbyB0aGUgRE9NIHN0cnVjdHVyZSBpcyBjb25zaXN0ZW50IHdpdGggb3RoZXIgYmxvY2tcbiAgLy8gdHlwZXMuXG4gIGFkZE5vZGVWaWV3KCkge1xuICAgIHJldHVybiAoeyBub2RlOiBlLCBIVE1MQXR0cmlidXRlczogbyB9KSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGNsYXNzIHQgZXh0ZW5kcyBzbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHMsIGksIGEpIHtcbiAgICAgICAgICBzdXBlcihzLCBpKSwgdGhpcy5ub2RlID0gcywgdGhpcy5jZWxsTWluV2lkdGggPSBpLCB0aGlzLmJsb2NrQ29udGVudEhUTUxBdHRyaWJ1dGVzID0gYTtcbiAgICAgICAgICBjb25zdCBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICBjLmNsYXNzTmFtZSA9IFkoXG4gICAgICAgICAgICBcImJuLWJsb2NrLWNvbnRlbnRcIixcbiAgICAgICAgICAgIGEuY2xhc3NcbiAgICAgICAgICApLCBjLnNldEF0dHJpYnV0ZShcImRhdGEtY29udGVudC10eXBlXCIsIFwidGFibGVcIik7XG4gICAgICAgICAgZm9yIChjb25zdCBbaCwgZl0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICBhXG4gICAgICAgICAgKSlcbiAgICAgICAgICAgIGggIT09IFwiY2xhc3NcIiAmJiBjLnNldEF0dHJpYnV0ZShoLCBmKTtcbiAgICAgICAgICBjb25zdCBsID0gdGhpcy5kb20sIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIGQuY2xhc3NOYW1lID0gXCJ0YWJsZVdyYXBwZXItaW5uZXJcIiwgZC5hcHBlbmRDaGlsZChsLmZpcnN0Q2hpbGQpLCBsLmFwcGVuZENoaWxkKGQpLCBjLmFwcGVuZENoaWxkKGwpO1xuICAgICAgICAgIGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHAuY2xhc3NOYW1lID0gXCJ0YWJsZS13aWRnZXRzLWNvbnRhaW5lclwiLCBwLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiLCBsLmFwcGVuZENoaWxkKHApLCB0aGlzLmRvbSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlTXV0YXRpb24ocykge1xuICAgICAgICAgIHJldHVybiAhcy50YXJnZXQuY2xvc2VzdChcIi50YWJsZVdyYXBwZXItaW5uZXJcIikgfHwgc3VwZXIuaWdub3JlTXV0YXRpb24ocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdChlLCBtbywge1xuICAgICAgICAuLi4oKG4gPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IG4uYmxvY2tDb250ZW50KSB8fCB7fSxcbiAgICAgICAgLi4ub1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufSksIGxzID0gVyh7XG4gIG5hbWU6IFwidGFibGVQYXJhZ3JhcGhcIixcbiAgZ3JvdXA6IFwidGFibGVDb250ZW50XCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiBcImZ1bGxcIixcbiAgICAgICAgLy8gc2V0IHRoaXMgcnVsZSBhcyBoaWdoIHByaW9yaXR5IHNvIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBwYXJhZ3JhcGggcnVsZSxcbiAgICAgICAgLy8gYnV0IG9ubHkgaWYgd2UncmUgaW4gdGhlIHRhYmxlQ29udGVudCBjb250ZXh0XG4gICAgICAgIHByaW9yaXR5OiAyMTAsXG4gICAgICAgIGNvbnRleHQ6IFwidGFibGVDb250ZW50XCIsXG4gICAgICAgIHRhZzogXCJwXCIsXG4gICAgICAgIGdldEF0dHJzOiAoZSkgPT4gKHt9KVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInBcIixcbiAgICAgICAgZ2V0QXR0cnM6IChlKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgIWUudGV4dENvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgY29uc3QgbyA9IGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICByZXR1cm4gbyA9PT0gbnVsbCA/ICExIDogby50YWdOYW1lID09PSBcIlREXCIgPyB7fSA6ICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBlIH0pIHtcbiAgICByZXR1cm4gW1wicFwiLCBlLCAwXTtcbiAgfVxufSksIGRzID0gWihcbiAgY3MsXG4gIGFzLFxuICBbXG4gICAgaXMsXG4gICAgbHMsXG4gICAgQ24uZXh0ZW5kKHtcbiAgICAgIC8qKlxuICAgICAgICogV2UgYWxsb3cgdGFibGUgaGVhZGVycyBhbmQgY2VsbHMgdG8gaGF2ZSBtdWx0aXBsZSB0YWJsZUNvbnRlbnQgbm9kZXMgYmVjYXVzZVxuICAgICAgICogd2hlbiBtZXJnaW5nIGNlbGxzLCBwcm9zZW1pcnJvci10YWJsZXMgd2lsbCBjb25jYXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBjZWxscyBuYWl2ZWx5LlxuICAgICAgICogVGhpcyB3b3VsZCBjYXVzZSB0aGF0IGNvbnRlbnQgdG8gb3ZlcmZsb3cgaW50byBvdGhlciBjZWxscyB3aGVuIHByb3NlbWlycm9yIHRyaWVzIHRvIGVuZm9yY2UgdGhlIGNlbGwgc3RydWN0dXJlLlxuICAgICAgICpcbiAgICAgICAqIFNvLCB3ZSBtYW51YWxseSBmaXggdGhpcyB1cCB3aGVuIHJlYWRpbmcgYmFjayBpbiB0aGUgYG5vZGVUb0Jsb2NrYCBhbmQgb25seSBldmVyIHBsYWNlIGEgc2luZ2xlIHRhYmxlQ29udGVudCBiYWNrIGludG8gdGhlIGNlbGwuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IFwidGFibGVDb250ZW50K1wiXG4gICAgfSksXG4gICAgeW4uZXh0ZW5kKHtcbiAgICAgIGNvbnRlbnQ6IFwidGFibGVDb250ZW50K1wiXG4gICAgfSksXG4gICAgdm5cbiAgXVxuKSwgUHQgPSAoZSkgPT4ge1xuICBjb25zdCBvID0gZS5zcmMgfHwgdm9pZCAwLCB0ID0gZS53aWR0aCB8fCB2b2lkIDA7XG4gIHJldHVybiB7IHVybDogbywgcHJldmlld1dpZHRoOiB0IH07XG59LCBwcyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPjxwYXRoIGQ9XCJNMiAzLjk5MzRDMiAzLjQ0NDc2IDIuNDU1MzEgMyAyLjk5MTggM0gyMS4wMDgyQzIxLjU1NiAzIDIyIDMuNDQ0OTUgMjIgMy45OTM0VjIwLjAwNjZDMjIgMjAuNTU1MiAyMS41NDQ3IDIxIDIxLjAwODIgMjFIMi45OTE4QzIuNDQ0MDUgMjEgMiAyMC41NTUxIDIgMjAuMDA2NlYzLjk5MzRaTTggNVYxOUgxNlY1SDhaTTQgNVY3SDZWNUg0Wk0xOCA1VjdIMjBWNUgxOFpNNCA5VjExSDZWOUg0Wk0xOCA5VjExSDIwVjlIMThaTTQgMTNWMTVINlYxM0g0Wk0xOCAxM1YxNUgyMFYxM0gxOFpNNCAxN1YxOUg2VjE3SDRaTTE4IDE3VjE5SDIwVjE3SDE4WlwiPjwvcGF0aD48L3N2Zz4nLCB1cyA9IHtcbiAgdGV4dEFsaWdubWVudDogUy50ZXh0QWxpZ25tZW50LFxuICBiYWNrZ3JvdW5kQ29sb3I6IFMuYmFja2dyb3VuZENvbG9yLFxuICAvLyBGaWxlIG5hbWUuXG4gIG5hbWU6IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIC8vIEZpbGUgdXJsLlxuICB1cmw6IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIC8vIEZpbGUgY2FwdGlvbi5cbiAgY2FwdGlvbjoge1xuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSxcbiAgc2hvd1ByZXZpZXc6IHtcbiAgICBkZWZhdWx0OiAhMFxuICB9LFxuICAvLyBGaWxlIHByZXZpZXcgd2lkdGggaW4gcHguXG4gIHByZXZpZXdXaWR0aDoge1xuICAgIGRlZmF1bHQ6IDUxMlxuICB9XG59LCBocyA9IHtcbiAgdHlwZTogXCJ2aWRlb1wiLFxuICBwcm9wU2NoZW1hOiB1cyxcbiAgY29udGVudDogXCJub25lXCIsXG4gIGlzRmlsZUJsb2NrOiAhMCxcbiAgZmlsZUJsb2NrQWNjZXB0OiBbXCJ2aWRlby8qXCJdXG59LCBmcyA9IChlLCBvKSA9PiB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB0LmlubmVySFRNTCA9IHBzO1xuICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbi5jbGFzc05hbWUgPSBcImJuLXZpc3VhbC1tZWRpYS13cmFwcGVyXCI7XG4gIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gIHJldHVybiByLmNsYXNzTmFtZSA9IFwiYm4tdmlzdWFsLW1lZGlhXCIsIG8ucmVzb2x2ZUZpbGVVcmwgPyBvLnJlc29sdmVGaWxlVXJsKGUucHJvcHMudXJsKS50aGVuKChzKSA9PiB7XG4gICAgci5zcmMgPSBzO1xuICB9KSA6IHIuc3JjID0gZS5wcm9wcy51cmwsIHIuY29udHJvbHMgPSAhMCwgci5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCIsIHIuZHJhZ2dhYmxlID0gITEsIHIud2lkdGggPSBlLnByb3BzLnByZXZpZXdXaWR0aCwgbi5hcHBlbmRDaGlsZChyKSwgbG8oXG4gICAgZSxcbiAgICBvLFxuICAgIHsgZG9tOiBuIH0sXG4gICAgbixcbiAgICBvLmRpY3Rpb25hcnkuZmlsZV9ibG9ja3MudmlkZW8uYWRkX2J1dHRvbl90ZXh0LFxuICAgIHQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgKTtcbn0sIG1zID0gKGUpID0+IHtcbiAgaWYgKGUudGFnTmFtZSA9PT0gXCJWSURFT1wiKVxuICAgIHJldHVybiBQdChlKTtcbiAgaWYgKGUudGFnTmFtZSA9PT0gXCJGSUdVUkVcIikge1xuICAgIGNvbnN0IG8gPSBVZShlLCBcInZpZGVvXCIpO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRhcmdldEVsZW1lbnQ6IHQsIGNhcHRpb246IG4gfSA9IG87XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLlB0KHQpLFxuICAgICAgY2FwdGlvbjogblxuICAgIH07XG4gIH1cbn0sIGdzID0gKGUpID0+IHtcbiAgaWYgKCFlLnByb3BzLnVybCkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICByZXR1cm4gdC50ZXh0Q29udGVudCA9IFwiQWRkIHZpZGVvXCIsIHtcbiAgICAgIGRvbTogdFxuICAgIH07XG4gIH1cbiAgbGV0IG87XG4gIHJldHVybiBlLnByb3BzLnNob3dQcmV2aWV3ID8gKG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiksIG8uc3JjID0gZS5wcm9wcy51cmwsIG8ud2lkdGggPSBlLnByb3BzLnByZXZpZXdXaWR0aCkgOiAobyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLCBvLmhyZWYgPSBlLnByb3BzLnVybCwgby50ZXh0Q29udGVudCA9IGUucHJvcHMubmFtZSB8fCBlLnByb3BzLnVybCksIGUucHJvcHMuY2FwdGlvbiA/IGUucHJvcHMuc2hvd1ByZXZpZXcgPyBkdChvLCBlLnByb3BzLmNhcHRpb24pIDogJGUobywgZS5wcm9wcy5jYXB0aW9uKSA6IHtcbiAgICBkb206IG9cbiAgfTtcbn0sIGJzID0gU2UoaHMsIHtcbiAgcmVuZGVyOiBmcyxcbiAgcGFyc2U6IG1zLFxuICB0b0V4dGVybmFsSFRNTDogZ3Ncbn0pLCBnbyA9IHtcbiAgcGFyYWdyYXBoOiB0cyxcbiAgaGVhZGluZzogenIsXG4gIHF1b3RlOiBycyxcbiAgY29kZUJsb2NrOiB3cixcbiAgYnVsbGV0TGlzdEl0ZW06IEdyLFxuICBudW1iZXJlZExpc3RJdGVtOiBacixcbiAgY2hlY2tMaXN0SXRlbTogS3IsXG4gIHRhYmxlOiBkcyxcbiAgZmlsZTogQnIsXG4gIGltYWdlOiBBcixcbiAgdmlkZW86IGJzLFxuICBhdWRpbzogZ3Jcbn0sIGtzID0gWHQoZ28pLCBibyA9IHtcbiAgYm9sZDogZWUobW4sIFwiYm9vbGVhblwiKSxcbiAgaXRhbGljOiBlZShibiwgXCJib29sZWFuXCIpLFxuICB1bmRlcmxpbmU6IGVlKHduLCBcImJvb2xlYW5cIiksXG4gIHN0cmlrZTogZWUoa24sIFwiYm9vbGVhblwiKSxcbiAgY29kZTogZWUoZ24sIFwiYm9vbGVhblwiKSxcbiAgdGV4dENvbG9yOiAkcixcbiAgYmFja2dyb3VuZENvbG9yOiBWclxufSwgY2MgPSBRdChibyksIGtvID0ge1xuICB0ZXh0OiB7IGNvbmZpZzogXCJ0ZXh0XCIsIGltcGxlbWVudGF0aW9uOiB7fSB9LFxuICBsaW5rOiB7IGNvbmZpZzogXCJsaW5rXCIsIGltcGxlbWVudGF0aW9uOiB7fSB9XG59LCB3cyA9IFl0KFxuICBrb1xuKTtcbmZ1bmN0aW9uIEwoZSwgbykge1xuICByZXR1cm4gZSBpbiBvLnNjaGVtYS5ibG9ja1NjaGVtYSAmJiBvLnNjaGVtYS5ibG9ja1NjaGVtYVtlXSA9PT0ga3NbZV07XG59XG5mdW5jdGlvbiB5cyhlLCBvKSB7XG4gIHJldHVybiBlIGluIG8uc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEgJiYgby5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYVtlXSA9PT0gd3NbZV07XG59XG5mdW5jdGlvbiBDcyhlLCBvLCB0KSB7XG4gIHJldHVybiBvLnR5cGUgPT09IGUgJiYgby50eXBlIGluIHQuc2NoZW1hLmJsb2NrU2NoZW1hICYmIEwoby50eXBlLCB0KTtcbn1cbmZ1bmN0aW9uIGxjKGUsIG8pIHtcbiAgcmV0dXJuIGUudHlwZSBpbiBvLnNjaGVtYS5ibG9ja1NjaGVtYSAmJiBvLnNjaGVtYS5ibG9ja1NjaGVtYVtlLnR5cGVdLmlzRmlsZUJsb2NrIHx8ICExO1xufVxuZnVuY3Rpb24gZGMoZSwgbykge1xuICByZXR1cm4gZS50eXBlIGluIG8uc2NoZW1hLmJsb2NrU2NoZW1hICYmIG8uc2NoZW1hLmJsb2NrU2NoZW1hW2UudHlwZV0uaXNGaWxlQmxvY2sgJiYgXCJzaG93UHJldmlld1wiIGluIG8uc2NoZW1hLmJsb2NrU2NoZW1hW2UudHlwZV0ucHJvcFNjaGVtYSB8fCAhMTtcbn1cbmZ1bmN0aW9uIHBjKGUsIG8pIHtcbiAgcmV0dXJuIG8uc2NoZW1hLmJsb2NrU2NoZW1hW2UudHlwZV0uaXNGaWxlQmxvY2sgJiYgIWUucHJvcHMudXJsO1xufVxuZnVuY3Rpb24gdnMoZSwgbywgdCkge1xuICByZXR1cm4gbyBpbiB0LnNjaGVtYS5ibG9ja1NjaGVtYSAmJiBlIGluIHQuc2NoZW1hLmJsb2NrU2NoZW1hW29dLnByb3BTY2hlbWEgJiYgdC5zY2hlbWEuYmxvY2tTY2hlbWFbb10ucHJvcFNjaGVtYVtlXSA9PT0gU1tlXTtcbn1cbmZ1bmN0aW9uIHVjKGUsIG8sIHQpIHtcbiAgcmV0dXJuIHZzKGUsIG8udHlwZSwgdCk7XG59XG5mdW5jdGlvbiBJdChlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgeWU7XG59XG5mdW5jdGlvbiBFcyhlKSB7XG4gIGxldCBvID0gZS5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jaywgdCA9IGUuc2NoZW1hLmJsb2NrU2NoZW1hW28udHlwZV0uY29udGVudDtcbiAgZm9yICg7IHQgPT09IFwibm9uZVwiOyApIHtcbiAgICBpZiAobyA9IGUuZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkubmV4dEJsb2NrLCBvID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgdCA9IGUuc2NoZW1hLmJsb2NrU2NoZW1hW28udHlwZV0uY29udGVudCwgZS5zZXRUZXh0Q3Vyc29yUG9zaXRpb24obywgXCJlbmRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIFAoZSwgbykge1xuICBjb25zdCB0ID0gZS5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jaztcbiAgaWYgKHQuY29udGVudCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNsYXNoIE1lbnUgb3BlbiBpbiBhIGJsb2NrIHRoYXQgZG9lc24ndCBjb250YWluIGNvbnRlbnQuXCIpO1xuICBsZXQgbjtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodC5jb250ZW50KSAmJiAodC5jb250ZW50Lmxlbmd0aCA9PT0gMSAmJiBKKHQuY29udGVudFswXSkgJiYgdC5jb250ZW50WzBdLnR5cGUgPT09IFwidGV4dFwiICYmIHQuY29udGVudFswXS50ZXh0ID09PSBcIi9cIiB8fCB0LmNvbnRlbnQubGVuZ3RoID09PSAwKSA/IChuID0gZS51cGRhdGVCbG9jayh0LCBvKSwgZS5zZXRUZXh0Q3Vyc29yUG9zaXRpb24obikpIDogKG4gPSBlLmluc2VydEJsb2Nrcyhbb10sIHQsIFwiYWZ0ZXJcIilbMF0sIGUuc2V0VGV4dEN1cnNvclBvc2l0aW9uKGUuZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkubmV4dEJsb2NrKSksIEVzKGUpLCBuO1xufVxuZnVuY3Rpb24gaGMoZSkge1xuICBjb25zdCBvID0gW107XG4gIHJldHVybiBMKFwiaGVhZGluZ1wiLCBlKSAmJiBvLnB1c2goXG4gICAge1xuICAgICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgUChlLCB7XG4gICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgcHJvcHM6IHsgbGV2ZWw6IDEgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBiYWRnZTogSyhcIk1vZC1BbHQtMVwiKSxcbiAgICAgIGtleTogXCJoZWFkaW5nXCIsXG4gICAgICAuLi5lLmRpY3Rpb25hcnkuc2xhc2hfbWVudS5oZWFkaW5nXG4gICAgfSxcbiAgICB7XG4gICAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgICBQKGUsIHtcbiAgICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgICBwcm9wczogeyBsZXZlbDogMiB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGJhZGdlOiBLKFwiTW9kLUFsdC0yXCIpLFxuICAgICAga2V5OiBcImhlYWRpbmdfMlwiLFxuICAgICAgLi4uZS5kaWN0aW9uYXJ5LnNsYXNoX21lbnUuaGVhZGluZ18yXG4gICAgfSxcbiAgICB7XG4gICAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgICBQKGUsIHtcbiAgICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgICBwcm9wczogeyBsZXZlbDogMyB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGJhZGdlOiBLKFwiTW9kLUFsdC0zXCIpLFxuICAgICAga2V5OiBcImhlYWRpbmdfM1wiLFxuICAgICAgLi4uZS5kaWN0aW9uYXJ5LnNsYXNoX21lbnUuaGVhZGluZ18zXG4gICAgfVxuICApLCBMKFwicXVvdGVcIiwgZSkgJiYgby5wdXNoKHtcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgUChlLCB7XG4gICAgICAgIHR5cGU6IFwicXVvdGVcIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBrZXk6IFwicXVvdGVcIixcbiAgICAuLi5lLmRpY3Rpb25hcnkuc2xhc2hfbWVudS5xdW90ZVxuICB9KSwgTChcIm51bWJlcmVkTGlzdEl0ZW1cIiwgZSkgJiYgby5wdXNoKHtcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgUChlLCB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyZWRMaXN0SXRlbVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJhZGdlOiBLKFwiTW9kLVNoaWZ0LTdcIiksXG4gICAga2V5OiBcIm51bWJlcmVkX2xpc3RcIixcbiAgICAuLi5lLmRpY3Rpb25hcnkuc2xhc2hfbWVudS5udW1iZXJlZF9saXN0XG4gIH0pLCBMKFwiYnVsbGV0TGlzdEl0ZW1cIiwgZSkgJiYgby5wdXNoKHtcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgUChlLCB7XG4gICAgICAgIHR5cGU6IFwiYnVsbGV0TGlzdEl0ZW1cIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBiYWRnZTogSyhcIk1vZC1TaGlmdC04XCIpLFxuICAgIGtleTogXCJidWxsZXRfbGlzdFwiLFxuICAgIC4uLmUuZGljdGlvbmFyeS5zbGFzaF9tZW51LmJ1bGxldF9saXN0XG4gIH0pLCBMKFwiY2hlY2tMaXN0SXRlbVwiLCBlKSAmJiBvLnB1c2goe1xuICAgIG9uSXRlbUNsaWNrOiAoKSA9PiB7XG4gICAgICBQKGUsIHtcbiAgICAgICAgdHlwZTogXCJjaGVja0xpc3RJdGVtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYmFkZ2U6IEsoXCJNb2QtU2hpZnQtOVwiKSxcbiAgICBrZXk6IFwiY2hlY2tfbGlzdFwiLFxuICAgIC4uLmUuZGljdGlvbmFyeS5zbGFzaF9tZW51LmNoZWNrX2xpc3RcbiAgfSksIEwoXCJwYXJhZ3JhcGhcIiwgZSkgJiYgby5wdXNoKHtcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgUChlLCB7XG4gICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYmFkZ2U6IEsoXCJNb2QtQWx0LTBcIiksXG4gICAga2V5OiBcInBhcmFncmFwaFwiLFxuICAgIC4uLmUuZGljdGlvbmFyeS5zbGFzaF9tZW51LnBhcmFncmFwaFxuICB9KSwgTChcImNvZGVCbG9ja1wiLCBlKSAmJiBvLnB1c2goe1xuICAgIG9uSXRlbUNsaWNrOiAoKSA9PiB7XG4gICAgICBQKGUsIHtcbiAgICAgICAgdHlwZTogXCJjb2RlQmxvY2tcIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBiYWRnZTogSyhcIk1vZC1BbHQtY1wiKSxcbiAgICBrZXk6IFwiY29kZV9ibG9ja1wiLFxuICAgIC4uLmUuZGljdGlvbmFyeS5zbGFzaF9tZW51LmNvZGVfYmxvY2tcbiAgfSksIEwoXCJ0YWJsZVwiLCBlKSAmJiBvLnB1c2goe1xuICAgIG9uSXRlbUNsaWNrOiAoKSA9PiB7XG4gICAgICBQKGUsIHtcbiAgICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJ0YWJsZUNvbnRlbnRcIixcbiAgICAgICAgICByb3dzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNlbGxzOiBbXCJcIiwgXCJcIiwgXCJcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNlbGxzOiBbXCJcIiwgXCJcIiwgXCJcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYmFkZ2U6IHZvaWQgMCxcbiAgICBrZXk6IFwidGFibGVcIixcbiAgICAuLi5lLmRpY3Rpb25hcnkuc2xhc2hfbWVudS50YWJsZVxuICB9KSwgTChcImltYWdlXCIsIGUpICYmIG8ucHVzaCh7XG4gICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBQKGUsIHtcbiAgICAgICAgdHlwZTogXCJpbWFnZVwiXG4gICAgICB9KTtcbiAgICAgIGUuZGlzcGF0Y2goXG4gICAgICAgIGUuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKGUuZmlsZVBhbmVsLnBsdWdpbiwge1xuICAgICAgICAgIGJsb2NrOiB0XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0sXG4gICAga2V5OiBcImltYWdlXCIsXG4gICAgLi4uZS5kaWN0aW9uYXJ5LnNsYXNoX21lbnUuaW1hZ2VcbiAgfSksIEwoXCJ2aWRlb1wiLCBlKSAmJiBvLnB1c2goe1xuICAgIG9uSXRlbUNsaWNrOiAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gUChlLCB7XG4gICAgICAgIHR5cGU6IFwidmlkZW9cIlxuICAgICAgfSk7XG4gICAgICBlLmRpc3BhdGNoKFxuICAgICAgICBlLl90aXB0YXBFZGl0b3Iuc3RhdGUudHIuc2V0TWV0YShlLmZpbGVQYW5lbC5wbHVnaW4sIHtcbiAgICAgICAgICBibG9jazogdFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICAgIGtleTogXCJ2aWRlb1wiLFxuICAgIC4uLmUuZGljdGlvbmFyeS5zbGFzaF9tZW51LnZpZGVvXG4gIH0pLCBMKFwiYXVkaW9cIiwgZSkgJiYgby5wdXNoKHtcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IFAoZSwge1xuICAgICAgICB0eXBlOiBcImF1ZGlvXCJcbiAgICAgIH0pO1xuICAgICAgZS5kaXNwYXRjaChcbiAgICAgICAgZS5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyLnNldE1ldGEoZS5maWxlUGFuZWwucGx1Z2luLCB7XG4gICAgICAgICAgYmxvY2s6IHRcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgICBrZXk6IFwiYXVkaW9cIixcbiAgICAuLi5lLmRpY3Rpb25hcnkuc2xhc2hfbWVudS5hdWRpb1xuICB9KSwgTChcImZpbGVcIiwgZSkgJiYgby5wdXNoKHtcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IFAoZSwge1xuICAgICAgICB0eXBlOiBcImZpbGVcIlxuICAgICAgfSk7XG4gICAgICBlLmRpc3BhdGNoKFxuICAgICAgICBlLl90aXB0YXBFZGl0b3Iuc3RhdGUudHIuc2V0TWV0YShlLmZpbGVQYW5lbC5wbHVnaW4sIHtcbiAgICAgICAgICBibG9jazogdFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICAgIGtleTogXCJmaWxlXCIsXG4gICAgLi4uZS5kaWN0aW9uYXJ5LnNsYXNoX21lbnUuZmlsZVxuICB9KSwgby5wdXNoKHtcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgZS5vcGVuU3VnZ2VzdGlvbk1lbnUoXCI6XCIsIHtcbiAgICAgICAgZGVsZXRlVHJpZ2dlckNoYXJhY3RlcjogITAsXG4gICAgICAgIGlnbm9yZVF1ZXJ5TGVuZ3RoOiAhMFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBrZXk6IFwiZW1vamlcIixcbiAgICAuLi5lLmRpY3Rpb25hcnkuc2xhc2hfbWVudS5lbW9qaVxuICB9KSwgbztcbn1cbmZ1bmN0aW9uIGZjKGUsIG8pIHtcbiAgcmV0dXJuIGUuZmlsdGVyKFxuICAgICh7IHRpdGxlOiB0LCBhbGlhc2VzOiBuIH0pID0+IHQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhvLnRvTG93ZXJDYXNlKCkpIHx8IG4gJiYgbi5maWx0ZXIoXG4gICAgICAocikgPT4gci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG8udG9Mb3dlckNhc2UoKSlcbiAgICApLmxlbmd0aCAhPT0gMFxuICApO1xufVxuZnVuY3Rpb24gamUoZSkge1xuICByZXR1cm4gZSAmJiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoZSkuZmlsdGVyKChbLCBvXSkgPT4gbyAhPT0gdm9pZCAwKVxuICApO1xufVxuY2xhc3MgQmUge1xuICBjb25zdHJ1Y3RvcihvKSB7XG4gICAgdSh0aGlzLCBcImJsb2NrU3BlY3NcIik7XG4gICAgdSh0aGlzLCBcImlubGluZUNvbnRlbnRTcGVjc1wiKTtcbiAgICB1KHRoaXMsIFwic3R5bGVTcGVjc1wiKTtcbiAgICB1KHRoaXMsIFwiYmxvY2tTY2hlbWFcIik7XG4gICAgdSh0aGlzLCBcImlubGluZUNvbnRlbnRTY2hlbWFcIik7XG4gICAgdSh0aGlzLCBcInN0eWxlU2NoZW1hXCIpO1xuICAgIC8vIEhlbHBlciBzbyB0aGF0IHlvdSBjYW4gdXNlIHR5cGVvZiBzY2hlbWEuQmxvY2tOb3RlRWRpdG9yXG4gICAgdSh0aGlzLCBcIkJsb2NrTm90ZUVkaXRvclwiLCBcIm9ubHkgZm9yIHR5cGVzXCIpO1xuICAgIHUodGhpcywgXCJCbG9ja1wiLCBcIm9ubHkgZm9yIHR5cGVzXCIpO1xuICAgIHUodGhpcywgXCJQYXJ0aWFsQmxvY2tcIiwgXCJvbmx5IGZvciB0eXBlc1wiKTtcbiAgICB0aGlzLmJsb2NrU3BlY3MgPSBqZShvID09IG51bGwgPyB2b2lkIDAgOiBvLmJsb2NrU3BlY3MpIHx8IGdvLCB0aGlzLmlubGluZUNvbnRlbnRTcGVjcyA9IGplKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uaW5saW5lQ29udGVudFNwZWNzKSB8fCBrbywgdGhpcy5zdHlsZVNwZWNzID0gamUobyA9PSBudWxsID8gdm9pZCAwIDogby5zdHlsZVNwZWNzKSB8fCBibywgdGhpcy5ibG9ja1NjaGVtYSA9IFh0KHRoaXMuYmxvY2tTcGVjcyksIHRoaXMuaW5saW5lQ29udGVudFNjaGVtYSA9IFl0KFxuICAgICAgdGhpcy5pbmxpbmVDb250ZW50U3BlY3NcbiAgICApLCB0aGlzLnN0eWxlU2NoZW1hID0gUXQodGhpcy5zdHlsZVNwZWNzKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKG8pIHtcbiAgICByZXR1cm4gbmV3IEJlKG8pO1xuICB9XG59XG5jb25zdCB3byA9IEJlLmNyZWF0ZSh7XG4gIGJsb2NrU3BlY3M6IHtcbiAgICBwYWdlQnJlYWs6IF9yXG4gIH1cbn0pLCBtYyA9IChlKSA9PiBCZS5jcmVhdGUoe1xuICBibG9ja1NwZWNzOiB7XG4gICAgLi4uZS5ibG9ja1NwZWNzLFxuICAgIC4uLndvLmJsb2NrU3BlY3NcbiAgfSxcbiAgaW5saW5lQ29udGVudFNwZWNzOiBlLmlubGluZUNvbnRlbnRTcGVjcyxcbiAgc3R5bGVTcGVjczogZS5zdHlsZVNwZWNzXG59KTtcbmZ1bmN0aW9uIFNzKGUpIHtcbiAgcmV0dXJuIFwicGFnZUJyZWFrXCIgaW4gZS5zY2hlbWEuYmxvY2tTY2hlbWEgJiYgZS5zY2hlbWEuYmxvY2tTY2hlbWEucGFnZUJyZWFrID09PSB3by5ibG9ja1NjaGVtYS5wYWdlQnJlYWs7XG59XG5mdW5jdGlvbiBnYyhlKSB7XG4gIGNvbnN0IG8gPSBbXTtcbiAgcmV0dXJuIFNzKGUpICYmIG8ucHVzaCh7XG4gICAgLi4uZS5kaWN0aW9uYXJ5LnNsYXNoX21lbnUucGFnZV9icmVhayxcbiAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgUChlLCB7XG4gICAgICAgIHR5cGU6IFwicGFnZUJyZWFrXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAga2V5OiBcInBhZ2VfYnJlYWtcIlxuICB9KSwgbztcbn1cbmZ1bmN0aW9uIEJzKGUsIG8sIHQsIG4gPSBcImJlZm9yZVwiKSB7XG4gIGNvbnN0IHIgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuaWQsIHMgPSBbXTtcbiAgZm9yIChjb25zdCBjIG9mIG8pXG4gICAgcy5wdXNoKFxuICAgICAgaWUoYywgZS5wbVNjaGVtYSwgZS5zY2hlbWEuc3R5bGVTY2hlbWEpXG4gICAgKTtcbiAgY29uc3QgaSA9IEQociwgZS5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyk7XG4gIGlmICghaSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggSUQgJHtyfSBub3QgZm91bmRgKTtcbiAgbiA9PT0gXCJiZWZvcmVcIiAmJiBlLmRpc3BhdGNoKFxuICAgIGUuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5pbnNlcnQoaS5wb3NCZWZvcmVOb2RlLCBzKVxuICApLCBuID09PSBcImFmdGVyXCIgJiYgZS5kaXNwYXRjaChcbiAgICBlLl90aXB0YXBFZGl0b3Iuc3RhdGUudHIuaW5zZXJ0KFxuICAgICAgaS5wb3NCZWZvcmVOb2RlICsgaS5ub2RlLm5vZGVTaXplLFxuICAgICAgc1xuICAgIClcbiAgKTtcbiAgY29uc3QgYSA9IFtdO1xuICBmb3IgKGNvbnN0IGMgb2YgcylcbiAgICBhLnB1c2goXG4gICAgICBFKFxuICAgICAgICBjLFxuICAgICAgICBlLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIGUuYmxvY2tDYWNoZVxuICAgICAgKVxuICAgICk7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gVHMoZSkge1xuICBjb25zdCBvID0gZS5fdGlwdGFwRWRpdG9yLnN0YXRlLCB0ID0gby5zZWxlY3Rpb24sIG4gPSBYKG8uZG9jLCB0LmFuY2hvcik7XG4gIGlmICh0IGluc3RhbmNlb2YgeWUpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgYW5jaG9yQmxvY2tJZDogbi5ub2RlLmF0dHJzLmlkLFxuICAgICAgYW5jaG9yQ2VsbE9mZnNldDogdC4kYW5jaG9yQ2VsbC5wb3MgLSBuLnBvc0JlZm9yZU5vZGUsXG4gICAgICBoZWFkQ2VsbE9mZnNldDogdC4kaGVhZENlbGwucG9zIC0gbi5wb3NCZWZvcmVOb2RlXG4gICAgfTtcbiAgaWYgKGUuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiB3ZSlcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJub2RlXCIsXG4gICAgICBhbmNob3JCbG9ja0lkOiBuLm5vZGUuYXR0cnMuaWRcbiAgICB9O1xuICB7XG4gICAgY29uc3QgciA9IFgoby5kb2MsIHQuaGVhZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgYW5jaG9yQmxvY2tJZDogbi5ub2RlLmF0dHJzLmlkLFxuICAgICAgaGVhZEJsb2NrSWQ6IHIubm9kZS5hdHRycy5pZCxcbiAgICAgIGFuY2hvck9mZnNldDogdC5hbmNob3IgLSBuLnBvc0JlZm9yZU5vZGUsXG4gICAgICBoZWFkT2Zmc2V0OiB0LmhlYWQgLSByLnBvc0JlZm9yZU5vZGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiB4cyhlLCBvKSB7XG4gIHZhciByLCBzO1xuICBjb25zdCB0ID0gKHIgPSBEKFxuICAgIG8uYW5jaG9yQmxvY2tJZCxcbiAgICBlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jXG4gICkpID09IG51bGwgPyB2b2lkIDAgOiByLnBvc0JlZm9yZU5vZGU7XG4gIGlmICh0ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENvdWxkIG5vdCBmaW5kIGJsb2NrIHdpdGggSUQgJHtvLmFuY2hvckJsb2NrSWR9IHRvIHVwZGF0ZSBzZWxlY3Rpb25gXG4gICAgKTtcbiAgbGV0IG47XG4gIGlmIChvLnR5cGUgPT09IFwiY2VsbFwiKVxuICAgIG4gPSB5ZS5jcmVhdGUoXG4gICAgICBlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLFxuICAgICAgdCArIG8uYW5jaG9yQ2VsbE9mZnNldCxcbiAgICAgIHQgKyBvLmhlYWRDZWxsT2Zmc2V0XG4gICAgKTtcbiAgZWxzZSBpZiAoby50eXBlID09PSBcIm5vZGVcIilcbiAgICBuID0gd2UuY3JlYXRlKFxuICAgICAgZS5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyxcbiAgICAgIHQgKyAxXG4gICAgKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgaSA9IChzID0gRChcbiAgICAgIG8uaGVhZEJsb2NrSWQsXG4gICAgICBlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jXG4gICAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMucG9zQmVmb3JlTm9kZTtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgYmxvY2sgd2l0aCBJRCAke28uaGVhZEJsb2NrSWR9IHRvIHVwZGF0ZSBzZWxlY3Rpb25gXG4gICAgICApO1xuICAgIG4gPSBSLmNyZWF0ZShcbiAgICAgIGUuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MsXG4gICAgICB0ICsgby5hbmNob3JPZmZzZXQsXG4gICAgICBpICsgby5oZWFkT2Zmc2V0XG4gICAgKTtcbiAgfVxuICBlLmRpc3BhdGNoKGUuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obikpO1xufVxuZnVuY3Rpb24gbnQoZSkge1xuICByZXR1cm4gZS5tYXAoKG8pID0+IG8udHlwZSA9PT0gXCJjb2x1bW5MaXN0XCIgPyBvLmNoaWxkcmVuLm1hcCgodCkgPT4gbnQodC5jaGlsZHJlbikpLmZsYXQoKSA6IHtcbiAgICAuLi5vLFxuICAgIGNoaWxkcmVuOiBudChvLmNoaWxkcmVuKVxuICB9KS5mbGF0KCk7XG59XG5mdW5jdGlvbiB5byhlLCBvLCB0KSB7XG4gIHZhciBzO1xuICBjb25zdCBuID0gKChzID0gZS5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuYmxvY2tzKSB8fCBbXG4gICAgZS5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9ja1xuICBdLCByID0gVHMoZSk7XG4gIGUucmVtb3ZlQmxvY2tzKG4pLCBlLmluc2VydEJsb2NrcyhudChuKSwgbywgdCksIHhzKGUsIHIpO1xufVxuZnVuY3Rpb24gQ28oZSkge1xuICByZXR1cm4gIWUgfHwgZS50eXBlICE9PSBcImNvbHVtbkxpc3RcIjtcbn1cbmZ1bmN0aW9uIHZvKGUsIG8sIHQpIHtcbiAgbGV0IG4sIHI7XG4gIGlmIChvID8gby5jaGlsZHJlbi5sZW5ndGggPiAwID8gKG4gPSBvLmNoaWxkcmVuW28uY2hpbGRyZW4ubGVuZ3RoIC0gMV0sIHIgPSBcImFmdGVyXCIpIDogKG4gPSBvLCByID0gXCJiZWZvcmVcIikgOiB0ICYmIChuID0gdCwgciA9IFwiYmVmb3JlXCIpLCAhbiB8fCAhcilcbiAgICByZXR1cm47XG4gIGNvbnN0IHMgPSBlLmdldFBhcmVudEJsb2NrKG4pO1xuICByZXR1cm4gQ28ocykgPyB7IHJlZmVyZW5jZUJsb2NrOiBuLCBwbGFjZW1lbnQ6IHIgfSA6IHZvKFxuICAgIGUsXG4gICAgciA9PT0gXCJhZnRlclwiID8gbiA6IGUuZ2V0UHJldkJsb2NrKG4pLFxuICAgIHNcbiAgKTtcbn1cbmZ1bmN0aW9uIEVvKGUsIG8sIHQpIHtcbiAgbGV0IG4sIHI7XG4gIGlmIChvID8gby5jaGlsZHJlbi5sZW5ndGggPiAwID8gKG4gPSBvLmNoaWxkcmVuWzBdLCByID0gXCJiZWZvcmVcIikgOiAobiA9IG8sIHIgPSBcImFmdGVyXCIpIDogdCAmJiAobiA9IHQsIHIgPSBcImFmdGVyXCIpLCAhbiB8fCAhcilcbiAgICByZXR1cm47XG4gIGNvbnN0IHMgPSBlLmdldFBhcmVudEJsb2NrKG4pO1xuICByZXR1cm4gQ28ocykgPyB7IHJlZmVyZW5jZUJsb2NrOiBuLCBwbGFjZW1lbnQ6IHIgfSA6IEVvKFxuICAgIGUsXG4gICAgciA9PT0gXCJiZWZvcmVcIiA/IG4gOiBlLmdldE5leHRCbG9jayhuKSxcbiAgICBzXG4gICk7XG59XG5mdW5jdGlvbiBNcyhlKSB7XG4gIGNvbnN0IG8gPSBlLmdldFNlbGVjdGlvbigpLCB0ID0gKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uYmxvY2tzWzBdKSB8fCBlLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrLCBuID0gdm8oXG4gICAgZSxcbiAgICBlLmdldFByZXZCbG9jayh0KSxcbiAgICBlLmdldFBhcmVudEJsb2NrKHQpXG4gICk7XG4gIG4gJiYgeW8oXG4gICAgZSxcbiAgICBuLnJlZmVyZW5jZUJsb2NrLFxuICAgIG4ucGxhY2VtZW50XG4gICk7XG59XG5mdW5jdGlvbiBQcyhlKSB7XG4gIGNvbnN0IG8gPSBlLmdldFNlbGVjdGlvbigpLCB0ID0gKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uYmxvY2tzWyhvID09IG51bGwgPyB2b2lkIDAgOiBvLmJsb2Nrcy5sZW5ndGgpIC0gMV0pIHx8IGUuZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2ssIG4gPSBFbyhcbiAgICBlLFxuICAgIGUuZ2V0TmV4dEJsb2NrKHQpLFxuICAgIGUuZ2V0UGFyZW50QmxvY2sodClcbiAgKTtcbiAgbiAmJiB5byhcbiAgICBlLFxuICAgIG4ucmVmZXJlbmNlQmxvY2ssXG4gICAgbi5wbGFjZW1lbnRcbiAgKTtcbn1cbmZ1bmN0aW9uIElzKGUsIG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHsgc3RhdGU6IHQsIGRpc3BhdGNoOiBuIH0pIHtcbiAgICBjb25zdCB7ICRmcm9tOiByLCAkdG86IHMgfSA9IHQuc2VsZWN0aW9uLCBpID0gci5ibG9ja1JhbmdlKFxuICAgICAgcyxcbiAgICAgIChkKSA9PiBkLmNoaWxkQ291bnQgPiAwICYmIChkLnR5cGUubmFtZSA9PT0gXCJibG9ja0dyb3VwXCIgfHwgZC50eXBlLm5hbWUgPT09IFwiY29sdW1uXCIpXG4gICAgICAvLyBjaGFuZ2UgbmVjZXNzYXJ5IHRvIG5vdCBsb29rIGF0IGZpcnN0IGl0ZW0gY2hpbGQgdHlwZVxuICAgICk7XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGEgPSBpLnN0YXJ0SW5kZXg7XG4gICAgaWYgKGEgPT09IDApXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbCA9IGkucGFyZW50LmNoaWxkKGEgLSAxKTtcbiAgICBpZiAobC50eXBlICE9PSBlKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChuKSB7XG4gICAgICBjb25zdCBkID0gbC5sYXN0Q2hpbGQgJiYgbC5sYXN0Q2hpbGQudHlwZSA9PT0gbywgcCA9IFYuZnJvbShkID8gZS5jcmVhdGUoKSA6IG51bGwpLCBoID0gbmV3IHRlKFxuICAgICAgICBWLmZyb20oXG4gICAgICAgICAgZS5jcmVhdGUobnVsbCwgVi5mcm9tKG8uY3JlYXRlKG51bGwsIHApKSlcbiAgICAgICAgICAvLyBjaGFuZ2UgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBcImdyb3VwVHlwZVwiIGluc3RlYWQgb2YgcGFyZW50LnR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgZCA/IDMgOiAxLFxuICAgICAgICAwXG4gICAgICApLCBmID0gaS5zdGFydCwgbSA9IGkuZW5kO1xuICAgICAgbihcbiAgICAgICAgdC50ci5zdGVwKFxuICAgICAgICAgIG5ldyBLZShcbiAgICAgICAgICAgIGYgLSAoZCA/IDMgOiAxKSxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApXG4gICAgICAgICkuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9O1xufVxuZnVuY3Rpb24gU28oZSkge1xuICByZXR1cm4gZS5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoXG4gICAgSXMoXG4gICAgICBlLl90aXB0YXBFZGl0b3Iuc2NoZW1hLm5vZGVzLmJsb2NrQ29udGFpbmVyLFxuICAgICAgZS5fdGlwdGFwRWRpdG9yLnNjaGVtYS5ub2Rlcy5ibG9ja0dyb3VwXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gTHMoZSkge1xuICBlLl90aXB0YXBFZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIik7XG59XG5mdW5jdGlvbiBBcyhlKSB7XG4gIGNvbnN0IHsgYm5CbG9jazogbyB9ID0gQyhcbiAgICBlLl90aXB0YXBFZGl0b3Iuc3RhdGVcbiAgKTtcbiAgcmV0dXJuIGUuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShvLmJlZm9yZVBvcykubm9kZUJlZm9yZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIE5zKGUpIHtcbiAgY29uc3QgeyBibkJsb2NrOiBvIH0gPSBDKFxuICAgIGUuX3RpcHRhcEVkaXRvci5zdGF0ZVxuICApO1xuICByZXR1cm4gZS5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKG8uYmVmb3JlUG9zKS5kZXB0aCA+IDE7XG59XG5mdW5jdGlvbiBCbyhlLCBvLCB0KSB7XG4gIGNvbnN0IG4gPSBlLl90aXB0YXBFZGl0b3I7XG4gIGxldCByID0gbi5zdGF0ZS50cjtcbiAgY29uc3QgcyA9IFtdO1xuICBmb3IgKGNvbnN0IHAgb2YgdClcbiAgICBzLnB1c2goXG4gICAgICBpZShwLCBlLnBtU2NoZW1hLCBlLnNjaGVtYS5zdHlsZVNjaGVtYSlcbiAgICApO1xuICBjb25zdCBpID0gbmV3IFNldChcbiAgICBvLm1hcChcbiAgICAgIChwKSA9PiB0eXBlb2YgcCA9PSBcInN0cmluZ1wiID8gcCA6IHAuaWRcbiAgICApXG4gICksIGEgPSBbXSwgYyA9IHR5cGVvZiBvWzBdID09IFwic3RyaW5nXCIgPyBvWzBdIDogb1swXS5pZDtcbiAgbGV0IGwgPSAwO1xuICBpZiAobi5zdGF0ZS5kb2MuZGVzY2VuZGFudHMoKHAsIGgpID0+IHtcbiAgICBpZiAoaS5zaXplID09PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICghcC50eXBlLmlzSW5Hcm91cChcImJuQmxvY2tcIikgfHwgIWkuaGFzKHAuYXR0cnMuaWQpKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmIChhLnB1c2goXG4gICAgICBFKFxuICAgICAgICBwLFxuICAgICAgICBlLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgZS5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIGUuYmxvY2tDYWNoZVxuICAgICAgKVxuICAgICksIGkuZGVsZXRlKHAuYXR0cnMuaWQpLCB0Lmxlbmd0aCA+IDAgJiYgcC5hdHRycy5pZCA9PT0gYykge1xuICAgICAgY29uc3QgYiA9IHIuZG9jLm5vZGVTaXplO1xuICAgICAgciA9IHIuaW5zZXJ0KGgsIHMpO1xuICAgICAgY29uc3QgayA9IHIuZG9jLm5vZGVTaXplO1xuICAgICAgbCArPSBiIC0gaztcbiAgICB9XG4gICAgY29uc3QgZiA9IHIuZG9jLm5vZGVTaXplLCBtID0gci5kb2MucmVzb2x2ZShoIC0gbCk7XG4gICAgbS5ub2RlKCkudHlwZS5uYW1lID09PSBcImJsb2NrR3JvdXBcIiAmJiBtLm5vZGUobS5kZXB0aCAtIDEpLnR5cGUubmFtZSAhPT0gXCJkb2NcIiAmJiBtLm5vZGUoKS5jaGlsZENvdW50ID09PSAxID8gciA9IHIuZGVsZXRlKG0uYmVmb3JlKCksIG0uYWZ0ZXIoKSkgOiByID0gci5kZWxldGUoaCAtIGwsIGggLSBsICsgcC5ub2RlU2l6ZSk7XG4gICAgY29uc3QgZyA9IHIuZG9jLm5vZGVTaXplO1xuICAgIHJldHVybiBsICs9IGYgLSBnLCAhMTtcbiAgfSksIGkuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBwID0gWy4uLmldLmpvaW4oYFxuYCk7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcIkJsb2NrcyB3aXRoIHRoZSBmb2xsb3dpbmcgSURzIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiB0aGUgZWRpdG9yOiBcIiArIHBcbiAgICApO1xuICB9XG4gIGUuZGlzcGF0Y2gocik7XG4gIGNvbnN0IGQgPSBbXTtcbiAgZm9yIChjb25zdCBwIG9mIHMpXG4gICAgZC5wdXNoKFxuICAgICAgRShcbiAgICAgICAgcCxcbiAgICAgICAgZS5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICAgIGUuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgICBlLmJsb2NrQ2FjaGVcbiAgICAgIClcbiAgICApO1xuICByZXR1cm4geyBpbnNlcnRlZEJsb2NrczogZCwgcmVtb3ZlZEJsb2NrczogYSB9O1xufVxuZnVuY3Rpb24gSHMoZSwgbywgdCkge1xuICByZXR1cm4gQm8oZSwgbywgdCk7XG59XG5mdW5jdGlvbiBEcyhlLCBvKSB7XG4gIHJldHVybiBCbyhlLCBvLCBbXSkucmVtb3ZlZEJsb2Nrcztcbn1cbmZ1bmN0aW9uIE9zKGUsIG8pIHtcbiAgY29uc3QgdCA9IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyBvIDogby5pZCwgbiA9IEQodCwgZS5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyk7XG4gIGlmIChuKVxuICAgIHJldHVybiBFKFxuICAgICAgbi5ub2RlLFxuICAgICAgZS5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICBlLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgZS5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICBlLmJsb2NrQ2FjaGVcbiAgICApO1xufVxuZnVuY3Rpb24gX3MoZSwgbykge1xuICBjb25zdCB0ID0gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IG8gOiBvLmlkLCBuID0gRCh0LCBlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jKTtcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgY29uc3QgcyA9IGUuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShcbiAgICBuLnBvc0JlZm9yZU5vZGVcbiAgKS5ub2RlQmVmb3JlO1xuICBpZiAocylcbiAgICByZXR1cm4gRShcbiAgICAgIHMsXG4gICAgICBlLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgIGUuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICBlLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgIGUuYmxvY2tDYWNoZVxuICAgICk7XG59XG5mdW5jdGlvbiBScyhlLCBvKSB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8gbyA6IG8uaWQsIG4gPSBEKHQsIGUuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MpO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuO1xuICBjb25zdCBzID0gZS5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKFxuICAgIG4ucG9zQmVmb3JlTm9kZSArIG4ubm9kZS5ub2RlU2l6ZVxuICApLm5vZGVBZnRlcjtcbiAgaWYgKHMpXG4gICAgcmV0dXJuIEUoXG4gICAgICBzLFxuICAgICAgZS5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICBlLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgZS5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICBlLmJsb2NrQ2FjaGVcbiAgICApO1xufVxuZnVuY3Rpb24gVnMoZSwgbykge1xuICBjb25zdCB0ID0gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IG8gOiBvLmlkLCBuID0gRCh0LCBlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jKTtcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgY29uc3QgciA9IGUuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShcbiAgICBuLnBvc0JlZm9yZU5vZGVcbiAgKSwgcyA9IHIubm9kZSgpLCBpID0gci5ub2RlKC0xKSwgYSA9IGkudHlwZS5uYW1lICE9PSBcImRvY1wiID8gcy50eXBlLm5hbWUgPT09IFwiYmxvY2tHcm91cFwiID8gaSA6IHMgOiB2b2lkIDA7XG4gIGlmIChhKVxuICAgIHJldHVybiBFKFxuICAgICAgYSxcbiAgICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgZS5ibG9ja0NhY2hlXG4gICAgKTtcbn1cbmZ1bmN0aW9uIFVzKGUsIG8sIHQsIG4gPSB7IHVwZGF0ZVNlbGVjdGlvbjogITAgfSkge1xuICBjb25zdCByID0gdC5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyO1xuICBsZXQgeyBmcm9tOiBzLCB0bzogaSB9ID0gdHlwZW9mIGUgPT0gXCJudW1iZXJcIiA/IHsgZnJvbTogZSwgdG86IGUgfSA6IHsgZnJvbTogZS5mcm9tLCB0bzogZS50byB9LCBhID0gITAsIGMgPSAhMCwgbCA9IFwiXCI7XG4gIGlmIChvLmZvckVhY2goKGQpID0+IHtcbiAgICBkLmNoZWNrKCksIGEgJiYgZC5pc1RleHQgJiYgZC5tYXJrcy5sZW5ndGggPT09IDAgPyBsICs9IGQudGV4dCA6IGEgPSAhMSwgYyA9IGMgPyBkLmlzQmxvY2sgOiAhMTtcbiAgfSksIHMgPT09IGkgJiYgYykge1xuICAgIGNvbnN0IHsgcGFyZW50OiBkIH0gPSByLmRvYy5yZXNvbHZlKHMpO1xuICAgIGQuaXNUZXh0YmxvY2sgJiYgIWQudHlwZS5zcGVjLmNvZGUgJiYgIWQuY2hpbGRDb3VudCAmJiAocyAtPSAxLCBpICs9IDEpO1xuICB9XG4gIHJldHVybiBhID8gci5pbnNlcnRUZXh0KGwsIHMsIGkpIDogci5yZXBsYWNlV2l0aChzLCBpLCBvKSwgbi51cGRhdGVTZWxlY3Rpb24gJiYgWG8ociwgci5zdGVwcy5sZW5ndGggLSAxLCAtMSksIHQuZGlzcGF0Y2gociksICEwO1xufVxuZnVuY3Rpb24gJHMoZSkge1xuICBjb25zdCBvID0gZS5fdGlwdGFwRWRpdG9yLnN0YXRlO1xuICBpZiAoby5zZWxlY3Rpb24uZW1wdHkgfHwgXCJub2RlXCIgaW4gby5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCB0ID0gby5kb2MucmVzb2x2ZShcbiAgICBYKG8uZG9jLCBvLnNlbGVjdGlvbi5mcm9tKS5wb3NCZWZvcmVOb2RlXG4gICksIG4gPSBvLmRvYy5yZXNvbHZlKFxuICAgIFgoby5kb2MsIG8uc2VsZWN0aW9uLnRvKS5wb3NCZWZvcmVOb2RlXG4gICksIHIgPSAobCwgZCkgPT4ge1xuICAgIGNvbnN0IHAgPSB0LnBvc0F0SW5kZXgobCwgZCksIGggPSBvLmRvYy5yZXNvbHZlKHApLm5vZGVBZnRlcjtcbiAgICBpZiAoIWgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFcnJvciBnZXR0aW5nIHNlbGVjdGlvbiAtIG5vZGUgbm90IGZvdW5kIGF0IHBvc2l0aW9uICR7cH1gXG4gICAgICApO1xuICAgIHJldHVybiBFKFxuICAgICAgaCxcbiAgICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgZS5ibG9ja0NhY2hlXG4gICAgKTtcbiAgfSwgcyA9IFtdLCBpID0gdC5zaGFyZWREZXB0aChuLnBvcyksIGEgPSB0LmluZGV4KGkpLCBjID0gbi5pbmRleChpKTtcbiAgaWYgKHQuZGVwdGggPiBpKSB7XG4gICAgcy5wdXNoKFxuICAgICAgRShcbiAgICAgICAgdC5ub2RlQWZ0ZXIsXG4gICAgICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgICBlLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgICBlLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgICAgZS5ibG9ja0NhY2hlXG4gICAgICApXG4gICAgKTtcbiAgICBmb3IgKGxldCBsID0gdC5kZXB0aDsgbCA+IGk7IGwtLSlcbiAgICAgIGlmICh0Lm5vZGUobCkudHlwZS5pc0luR3JvdXAoXCJjaGlsZENvbnRhaW5lclwiKSkge1xuICAgICAgICBjb25zdCBwID0gdC5pbmRleChsKSArIDEsIGggPSB0Lm5vZGUobCkuY2hpbGRDb3VudDtcbiAgICAgICAgZm9yIChsZXQgZiA9IHA7IGYgPCBoOyBmKyspXG4gICAgICAgICAgcy5wdXNoKHIoZiwgbCkpO1xuICAgICAgfVxuICB9IGVsc2VcbiAgICBzLnB1c2gocihhLCBpKSk7XG4gIGZvciAobGV0IGwgPSBhICsgMTsgbCA8PSBjOyBsKyspXG4gICAgcy5wdXNoKHIobCwgaSkpO1xuICBpZiAocy5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEVycm9yIGdldHRpbmcgc2VsZWN0aW9uIC0gc2VsZWN0aW9uIGRvZXNuJ3Qgc3BhbiBhbnkgYmxvY2tzICgke28uc2VsZWN0aW9ufSlgXG4gICAgKTtcbiAgcmV0dXJuIHtcbiAgICBibG9ja3M6IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIEZzKGUsIG8sIHQpIHtcbiAgY29uc3QgbiA9IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyBvIDogby5pZCwgciA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogdC5pZDtcbiAgaWYgKG4gPT09IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRpbmcgdG8gc2V0IHNlbGVjdGlvbiB3aXRoIHRoZSBzYW1lIGFuY2hvciBhbmQgaGVhZCBibG9ja3MgKGlkICR7bn0pYFxuICAgICk7XG4gIGNvbnN0IHMgPSBlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLCBpID0gRChuLCBzKTtcbiAgaWYgKCFpKVxuICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgd2l0aCBJRCAke259IG5vdCBmb3VuZGApO1xuICBjb25zdCBhID0gRChyLCBzKTtcbiAgaWYgKCFhKVxuICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgd2l0aCBJRCAke3J9IG5vdCBmb3VuZGApO1xuICBjb25zdCBjID0gbmUoaSksIGwgPSBuZShhKSwgZCA9IGUuc2NoZW1hLmJsb2NrU2NoZW1hW2MuYmxvY2tOb3RlVHlwZV0sIHAgPSBlLnNjaGVtYS5ibG9ja1NjaGVtYVtsLmJsb2NrTm90ZVR5cGVdO1xuICBpZiAoIWMuaXNCbG9ja0NvbnRhaW5lciB8fCBkLmNvbnRlbnQgPT09IFwibm9uZVwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0aW5nIHRvIHNldCBzZWxlY3Rpb24gYW5jaG9yIGluIGJsb2NrIHdpdGhvdXQgY29udGVudCAoaWQgJHtufSlgXG4gICAgKTtcbiAgaWYgKCFsLmlzQmxvY2tDb250YWluZXIgfHwgcC5jb250ZW50ID09PSBcIm5vbmVcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGluZyB0byBzZXQgc2VsZWN0aW9uIGFuY2hvciBpbiBibG9jayB3aXRob3V0IGNvbnRlbnQgKGlkICR7cn0pYFxuICAgICk7XG4gIGxldCBoLCBmO1xuICBpZiAoZC5jb250ZW50ID09PSBcInRhYmxlXCIpIHtcbiAgICBjb25zdCBtID0ga3QuZ2V0KGMuYmxvY2tDb250ZW50Lm5vZGUpO1xuICAgIGggPSBjLmJsb2NrQ29udGVudC5iZWZvcmVQb3MgKyBtLnBvc2l0aW9uQXQoMCwgMCwgYy5ibG9ja0NvbnRlbnQubm9kZSkgKyAxICsgMjtcbiAgfSBlbHNlXG4gICAgaCA9IGMuYmxvY2tDb250ZW50LmJlZm9yZVBvcyArIDE7XG4gIGlmIChwLmNvbnRlbnQgPT09IFwidGFibGVcIikge1xuICAgIGNvbnN0IG0gPSBrdC5nZXQobC5ibG9ja0NvbnRlbnQubm9kZSksIGcgPSBsLmJsb2NrQ29udGVudC5iZWZvcmVQb3MgKyBtLnBvc2l0aW9uQXQoXG4gICAgICBtLmhlaWdodCAtIDEsXG4gICAgICBtLndpZHRoIC0gMSxcbiAgICAgIGwuYmxvY2tDb250ZW50Lm5vZGVcbiAgICApICsgMSwgYiA9IHMucmVzb2x2ZShnKS5ub2RlQWZ0ZXIubm9kZVNpemU7XG4gICAgZiA9IGcgKyBiIC0gMjtcbiAgfSBlbHNlXG4gICAgZiA9IGwuYmxvY2tDb250ZW50LmFmdGVyUG9zIC0gMTtcbiAgZS5fdGlwdGFwRWRpdG9yLmRpc3BhdGNoKFxuICAgIGUuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oXG4gICAgICBSLmNyZWF0ZShlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLCBoLCBmKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHpzKGUpIHtcbiAgY29uc3QgeyBibkJsb2NrOiBvIH0gPSBDKGUuX3RpcHRhcEVkaXRvci5zdGF0ZSksIHQgPSBlLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUoby5iZWZvcmVQb3MpLCBuID0gdC5ub2RlQmVmb3JlLCByID0gZS5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKFxuICAgIG8uYWZ0ZXJQb3NcbiAgKS5ub2RlQWZ0ZXI7XG4gIGxldCBzO1xuICByZXR1cm4gdC5kZXB0aCA+IDEgJiYgKHMgPSB0Lm5vZGUoKSwgcy50eXBlLmlzSW5Hcm91cChcImJuQmxvY2tcIikgfHwgKHMgPSB0Lm5vZGUodC5kZXB0aCAtIDEpKSksIHtcbiAgICBibG9jazogRShcbiAgICAgIG8ubm9kZSxcbiAgICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgZS5ibG9ja0NhY2hlXG4gICAgKSxcbiAgICBwcmV2QmxvY2s6IG4gPT09IG51bGwgPyB2b2lkIDAgOiBFKFxuICAgICAgbixcbiAgICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgZS5ibG9ja0NhY2hlXG4gICAgKSxcbiAgICBuZXh0QmxvY2s6IHIgPT09IG51bGwgPyB2b2lkIDAgOiBFKFxuICAgICAgcixcbiAgICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgZS5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgZS5ibG9ja0NhY2hlXG4gICAgKSxcbiAgICBwYXJlbnRCbG9jazogcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogRShcbiAgICAgIHMsXG4gICAgICBlLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgIGUuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICBlLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgIGUuYmxvY2tDYWNoZVxuICAgIClcbiAgfTtcbn1cbmZ1bmN0aW9uIFRvKGUsIG8sIHQgPSBcInN0YXJ0XCIpIHtcbiAgY29uc3QgbiA9IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyBvIDogby5pZCwgciA9IEQobiwgZS5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyk7XG4gIGlmICghcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggSUQgJHtufSBub3QgZm91bmRgKTtcbiAgY29uc3QgcyA9IG5lKHIpLCBpID0gZS5zY2hlbWEuYmxvY2tTY2hlbWFbcy5ibG9ja05vdGVUeXBlXS5jb250ZW50O1xuICBpZiAocy5pc0Jsb2NrQ29udGFpbmVyKSB7XG4gICAgY29uc3QgYSA9IHMuYmxvY2tDb250ZW50O1xuICAgIGlmIChpID09PSBcIm5vbmVcIikge1xuICAgICAgZS5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnNldE5vZGVTZWxlY3Rpb24oYS5iZWZvcmVQb3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gXCJpbmxpbmVcIilcbiAgICAgIHQgPT09IFwic3RhcnRcIiA/IGUuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKFxuICAgICAgICBhLmJlZm9yZVBvcyArIDFcbiAgICAgICkgOiBlLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuc2V0VGV4dFNlbGVjdGlvbihcbiAgICAgICAgYS5hZnRlclBvcyAtIDFcbiAgICAgICk7XG4gICAgZWxzZSBpZiAoaSA9PT0gXCJ0YWJsZVwiKVxuICAgICAgdCA9PT0gXCJzdGFydFwiID8gZS5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24oXG4gICAgICAgIGEuYmVmb3JlUG9zICsgNFxuICAgICAgKSA6IGUuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKFxuICAgICAgICBhLmFmdGVyUG9zIC0gNFxuICAgICAgKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgJChpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhID0gdCA9PT0gXCJzdGFydFwiID8gcy5jaGlsZENvbnRhaW5lci5ub2RlLmZpcnN0Q2hpbGQgOiBzLmNoaWxkQ29udGFpbmVyLm5vZGUubGFzdENoaWxkO1xuICAgIFRvKGUsIGEuYXR0cnMuaWQsIHQpO1xuICB9XG59XG5sZXQgY2U7XG5hc3luYyBmdW5jdGlvbiB1dCgpIHtcbiAgaWYgKGNlKVxuICAgIHJldHVybiBjZTtcbiAgY29uc3QgZSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICBpbXBvcnQoXCJyZWh5cGUtcGFyc2VcIiksXG4gICAgaW1wb3J0KFwicmVoeXBlLXN0cmluZ2lmeVwiKSxcbiAgICBpbXBvcnQoXCJ1bmlmaWVkXCIpLFxuICAgIGltcG9ydChcImhhc3QtdXRpbC1mcm9tLWRvbVwiKSxcbiAgICBpbXBvcnQoXCJyZWh5cGUtcmVtYXJrXCIpLFxuICAgIGltcG9ydChcInJlbWFyay1nZm1cIiksXG4gICAgaW1wb3J0KFwicmVtYXJrLXN0cmluZ2lmeVwiKSxcbiAgICBpbXBvcnQoXCJyZW1hcmstcGFyc2VcIiksXG4gICAgaW1wb3J0KFwicmVtYXJrLXJlaHlwZVwiKSxcbiAgICBpbXBvcnQoXCJyZWh5cGUtZm9ybWF0XCIpXG4gIF0pO1xuICByZXR1cm4gY2UgPSB7XG4gICAgcmVoeXBlUGFyc2U6IGVbMF0sXG4gICAgcmVoeXBlU3RyaW5naWZ5OiBlWzFdLFxuICAgIHVuaWZpZWQ6IGVbMl0sXG4gICAgaGFzdFV0aWxGcm9tRG9tOiBlWzNdLFxuICAgIHJlaHlwZVJlbWFyazogZVs0XSxcbiAgICByZW1hcmtHZm06IGVbNV0sXG4gICAgcmVtYXJrU3RyaW5naWZ5OiBlWzZdLFxuICAgIHJlbWFya1BhcnNlOiBlWzddLFxuICAgIHJlbWFya1JlaHlwZTogZVs4XSxcbiAgICByZWh5cGVGb3JtYXQ6IGVbOV1cbiAgfSwgY2U7XG59XG5mdW5jdGlvbiBXcygpIHtcbiAgY29uc3QgZSA9IChvKSA9PiB7XG4gICAgbGV0IHQgPSBvLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHQ7IG4rKykge1xuICAgICAgY29uc3QgciA9IG8uY2hpbGRyZW5bbl07XG4gICAgICBpZiAoci50eXBlID09PSBcImVsZW1lbnRcIiAmJiAoZShyKSwgci50YWdOYW1lID09PSBcInVcIikpXG4gICAgICAgIGlmIChyLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvLmNoaWxkcmVuLnNwbGljZShuLCAxLCAuLi5yLmNoaWxkcmVuKTtcbiAgICAgICAgICBjb25zdCBzID0gci5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICAgIHQgKz0gcywgbiArPSBzO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBvLmNoaWxkcmVuLnNwbGljZShuLCAxKSwgdC0tLCBuLS07XG4gICAgfVxuICB9O1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGpzKCkge1xuICBjb25zdCBlID0gY2U7XG4gIGlmICghZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImFkZFNwYWNlc1RvQ2hlY2tib3hlcyByZXF1aXJlcyBFU00gZGVwZW5kZW5jaWVzIHRvIGJlIGluaXRpYWxpemVkXCJcbiAgICApO1xuICBjb25zdCBvID0gKHQpID0+IHtcbiAgICB2YXIgbjtcbiAgICBpZiAodC5jaGlsZHJlbiAmJiBcImxlbmd0aFwiIGluIHQuY2hpbGRyZW4gJiYgdC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICBmb3IgKGxldCByID0gdC5jaGlsZHJlbi5sZW5ndGggLSAxOyByID49IDA7IHItLSkge1xuICAgICAgICBjb25zdCBzID0gdC5jaGlsZHJlbltyXSwgaSA9IHIgKyAxIDwgdC5jaGlsZHJlbi5sZW5ndGggPyB0LmNoaWxkcmVuW3IgKyAxXSA6IHZvaWQgMDtcbiAgICAgICAgcy50eXBlID09PSBcImVsZW1lbnRcIiAmJiBzLnRhZ05hbWUgPT09IFwiaW5wdXRcIiAmJiAoKG4gPSBzLnByb3BlcnRpZXMpID09IG51bGwgPyB2b2lkIDAgOiBuLnR5cGUpID09PSBcImNoZWNrYm94XCIgJiYgKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudHlwZSkgPT09IFwiZWxlbWVudFwiICYmIGkudGFnTmFtZSA9PT0gXCJwXCIgPyAoaS50YWdOYW1lID0gXCJzcGFuXCIsIGkuY2hpbGRyZW4uc3BsaWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBlLmhhc3RVdGlsRnJvbURvbS5mcm9tRG9tKFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpXG4gICAgICAgICAgKVxuICAgICAgICApKSA6IG8ocyk7XG4gICAgICB9XG4gIH07XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gaHQoZSkge1xuICBjb25zdCBvID0gY2U7XG4gIGlmICghbylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImNsZWFuSFRNTFRvTWFya2Rvd24gcmVxdWlyZXMgRVNNIGRlcGVuZGVuY2llcyB0byBiZSBpbml0aWFsaXplZFwiXG4gICAgKTtcbiAgcmV0dXJuIG8udW5pZmllZC51bmlmaWVkKCkudXNlKG8ucmVoeXBlUGFyc2UuZGVmYXVsdCwgeyBmcmFnbWVudDogITAgfSkudXNlKFdzKS51c2UoanMpLnVzZShvLnJlaHlwZVJlbWFyay5kZWZhdWx0KS51c2Uoby5yZW1hcmtHZm0uZGVmYXVsdCkudXNlKG8ucmVtYXJrU3RyaW5naWZ5LmRlZmF1bHQsIHtcbiAgICBoYW5kbGVyczogeyB0ZXh0OiAobikgPT4gbi52YWx1ZSB9XG4gIH0pLnByb2Nlc3NTeW5jKGUpLnZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gR3MoZSwgbywgdCwgbikge1xuICBhd2FpdCB1dCgpO1xuICBjb25zdCBzID0gVmUobywgdCkuZXhwb3J0QmxvY2tzKGUsIG4pO1xuICByZXR1cm4gaHQocyk7XG59XG5mdW5jdGlvbiBxcyhlKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUucGFyZW50RWxlbWVudC5jaGlsZE5vZGVzLCBlKTtcbn1cbmZ1bmN0aW9uIEtzKGUpIHtcbiAgcmV0dXJuIGUubm9kZVR5cGUgPT09IDMgJiYgIS9cXFMvLnRlc3QoZS5ub2RlVmFsdWUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBYcyhlKSB7XG4gIGUucXVlcnlTZWxlY3RvckFsbChcImxpID4gdWwsIGxpID4gb2xcIikuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IHQgPSBxcyhvKSwgbiA9IG8ucGFyZW50RWxlbWVudCwgciA9IEFycmF5LmZyb20obi5jaGlsZE5vZGVzKS5zbGljZShcbiAgICAgIHQgKyAxXG4gICAgKTtcbiAgICBvLnJlbW92ZSgpLCByLmZvckVhY2goKHMpID0+IHtcbiAgICAgIHMucmVtb3ZlKCk7XG4gICAgfSksIG4uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgbyksIHIucmV2ZXJzZSgpLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGlmIChLcyhzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgIGkuYXBwZW5kKHMpLCBvLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGkpO1xuICAgIH0pLCBuLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwICYmIG4ucmVtb3ZlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gSnMoZSkge1xuICBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaSArIHVsLCBsaSArIG9sXCIpLmZvckVhY2goKG8pID0+IHtcbiAgICB2YXIgcywgaTtcbiAgICBjb25zdCB0ID0gby5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIG4pLCBuLmFwcGVuZCh0KTtcbiAgICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBmb3IgKHIuc2V0QXR0cmlidXRlKFwiZGF0YS1ub2RlLXR5cGVcIiwgXCJibG9ja0dyb3VwXCIpLCBuLmFwcGVuZChyKTsgKChzID0gbi5uZXh0RWxlbWVudFNpYmxpbmcpID09IG51bGwgPyB2b2lkIDAgOiBzLm5vZGVOYW1lKSA9PT0gXCJVTFwiIHx8ICgoaSA9IG4ubmV4dEVsZW1lbnRTaWJsaW5nKSA9PSBudWxsID8gdm9pZCAwIDogaS5ub2RlTmFtZSkgPT09IFwiT0xcIjsgKVxuICAgICAgci5hcHBlbmQobi5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICB9KTtcbn1cbmxldCBMdCA9IG51bGw7XG5mdW5jdGlvbiBZcygpIHtcbiAgcmV0dXJuIEx0IHx8IChMdCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRpdGxlXCIpKTtcbn1cbmZ1bmN0aW9uIHhvKGUpIHtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBvID0gWXMoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG8uaW5uZXJIVE1MID0gZSwgZSA9IG87XG4gIH1cbiAgcmV0dXJuIFhzKGUpLCBKcyhlKSwgZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIE1vKGUsIG8sIHQsIG4sIHIpIHtcbiAgY29uc3QgcyA9IHhvKGUpLCBhID0genQuZnJvbVNjaGVtYShyKS5wYXJzZShzLCB7XG4gICAgdG9wTm9kZTogci5ub2Rlcy5ibG9ja0dyb3VwLmNyZWF0ZSgpXG4gIH0pLCBjID0gW107XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgYS5jaGlsZENvdW50OyBsKyspXG4gICAgYy5wdXNoKFxuICAgICAgRShhLmNoaWxkKGwpLCBvLCB0LCBuKVxuICAgICk7XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gWnMoZSwgbykge1xuICBjb25zdCB0ID0gby52YWx1ZSA/IG8udmFsdWUgOiBcIlwiLCBuID0ge307XG4gIG8ubGFuZyAmJiAobltcImRhdGEtbGFuZ3VhZ2VcIl0gPSBvLmxhbmcpO1xuICBsZXQgciA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImNvZGVcIixcbiAgICBwcm9wZXJ0aWVzOiBuLFxuICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHQgfV1cbiAgfTtcbiAgcmV0dXJuIG8ubWV0YSAmJiAoci5kYXRhID0geyBtZXRhOiBvLm1ldGEgfSksIGUucGF0Y2gobywgciksIHIgPSBlLmFwcGx5RGF0YShvLCByKSwgciA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcInByZVwiLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGNoaWxkcmVuOiBbcl1cbiAgfSwgZS5wYXRjaChvLCByKSwgcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIFBvKGUpIHtcbiAgY29uc3QgbyA9IGF3YWl0IHV0KCk7XG4gIHJldHVybiBvLnVuaWZpZWQudW5pZmllZCgpLnVzZShvLnJlbWFya1BhcnNlLmRlZmF1bHQpLnVzZShvLnJlbWFya0dmbS5kZWZhdWx0KS51c2Uoby5yZW1hcmtSZWh5cGUuZGVmYXVsdCwge1xuICAgIGhhbmRsZXJzOiB7XG4gICAgICAuLi5vLnJlbWFya1JlaHlwZS5kZWZhdWx0SGFuZGxlcnMsXG4gICAgICBjb2RlOiBac1xuICAgIH1cbiAgfSkudXNlKG8ucmVoeXBlU3RyaW5naWZ5LmRlZmF1bHQpLnByb2Nlc3NTeW5jKGUpLnZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gUXMoZSwgbywgdCwgbiwgcikge1xuICBjb25zdCBzID0gYXdhaXQgUG8oZSk7XG4gIHJldHVybiBNbyhzLCBvLCB0LCBuLCByKTtcbn1cbmNvbnN0IGZ0ID0gW1xuICBcInZzY29kZS1lZGl0b3ItZGF0YVwiLFxuICBcImJsb2Nrbm90ZS9odG1sXCIsXG4gIFwidGV4dC9tYXJrZG93blwiLFxuICBcInRleHQvaHRtbFwiLFxuICBcInRleHQvcGxhaW5cIixcbiAgXCJGaWxlc1wiXG5dO1xuZnVuY3Rpb24gZWkoZSwgbykge1xuICBpZiAoIWUuc3RhcnRzV2l0aChcIi5cIikgfHwgIW8uc3RhcnRzV2l0aChcIi5cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmluZ3MgcHJvdmlkZWQgYXJlIG5vdCB2YWxpZCBmaWxlIGV4dGVuc2lvbnMuXCIpO1xuICByZXR1cm4gZSA9PT0gbztcbn1cbmZ1bmN0aW9uIHRpKGUsIG8pIHtcbiAgY29uc3QgdCA9IGUuc3BsaXQoXCIvXCIpLCBuID0gby5zcGxpdChcIi9cIik7XG4gIGlmICh0Lmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdHJpbmcgJHtlfSBpcyBub3QgYSB2YWxpZCBNSU1FIHR5cGUuYCk7XG4gIGlmIChuLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdHJpbmcgJHtvfSBpcyBub3QgYSB2YWxpZCBNSU1FIHR5cGUuYCk7XG4gIHJldHVybiB0WzFdID09PSBcIipcIiB8fCBuWzFdID09PSBcIipcIiA/IHRbMF0gPT09IG5bMF0gOiAodFswXSA9PT0gXCIqXCIgfHwgblswXSA9PT0gXCIqXCIgfHwgdFswXSA9PT0gblswXSkgJiYgdFsxXSA9PT0gblsxXTtcbn1cbmZ1bmN0aW9uIEF0KGUsIG8sIHQpIHtcbiAgbGV0IG47XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG8uY29udGVudCkgJiYgby5jb250ZW50Lmxlbmd0aCA9PT0gMCA/IG4gPSBlLnVwZGF0ZUJsb2NrKG8sIHQpLmlkIDogbiA9IGUuaW5zZXJ0QmxvY2tzKFxuICAgIFt0XSxcbiAgICBvLFxuICAgIFwiYWZ0ZXJcIlxuICApWzBdLmlkLCBuO1xufVxuYXN5bmMgZnVuY3Rpb24gSW8oZSwgbykge1xuICB2YXIgaTtcbiAgaWYgKCFvLnVwbG9hZEZpbGUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkF0dGVtcHRlZCBvdCBpbnNlcnQgZmlsZSwgYnV0IHVwbG9hZEZpbGUgaXMgbm90IHNldCBpbiB0aGUgQmxvY2tOb3RlIGVkaXRvciBvcHRpb25zXCJcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0ID0gXCJkYXRhVHJhbnNmZXJcIiBpbiBlID8gZS5kYXRhVHJhbnNmZXIgOiBlLmNsaXBib2FyZERhdGE7XG4gIGlmICh0ID09PSBudWxsKVxuICAgIHJldHVybjtcbiAgbGV0IG4gPSBudWxsO1xuICBmb3IgKGNvbnN0IGEgb2YgZnQpXG4gICAgaWYgKHQudHlwZXMuaW5jbHVkZXMoYSkpIHtcbiAgICAgIG4gPSBhO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICBpZiAobiAhPT0gXCJGaWxlc1wiKVxuICAgIHJldHVybjtcbiAgY29uc3QgciA9IHQuaXRlbXM7XG4gIGlmICghcilcbiAgICByZXR1cm47XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgcyA9IE9iamVjdC52YWx1ZXMoby5zY2hlbWEuYmxvY2tTY2hlbWEpLmZpbHRlcihcbiAgICAoYSkgPT4gYS5pc0ZpbGVCbG9ja1xuICApO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IHIubGVuZ3RoOyBhKyspIHtcbiAgICBsZXQgYyA9IFwiZmlsZVwiO1xuICAgIGZvciAoY29uc3QgZCBvZiBzKVxuICAgICAgZm9yIChjb25zdCBwIG9mIGQuZmlsZUJsb2NrQWNjZXB0IHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IGggPSBwLnN0YXJ0c1dpdGgoXCIuXCIpLCBmID0gclthXS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgaWYgKGYgJiYgKCFoICYmIGYudHlwZSAmJiB0aShyW2FdLnR5cGUsIHApIHx8IGggJiYgZWkoXG4gICAgICAgICAgXCIuXCIgKyBmLm5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpLFxuICAgICAgICAgIHBcbiAgICAgICAgKSkpIHtcbiAgICAgICAgICBjID0gZC50eXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgY29uc3QgbCA9IHJbYV0uZ2V0QXNGaWxlKCk7XG4gICAgaWYgKGwpIHtcbiAgICAgIGNvbnN0IGQgPSB7XG4gICAgICAgIHR5cGU6IGMsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbmFtZTogbC5uYW1lXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgcDtcbiAgICAgIGlmIChlLnR5cGUgPT09IFwicGFzdGVcIikge1xuICAgICAgICBjb25zdCBtID0gby5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jaztcbiAgICAgICAgcCA9IEF0KG8sIG0sIGQpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09IFwiZHJvcFwiKSB7XG4gICAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgIHRvcDogZS5jbGllbnRZXG4gICAgICAgIH0sIGcgPSAoaSA9IG8ucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogaS5wb3NBdENvb3JkcyhtKTtcbiAgICAgICAgaWYgKCFnKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYiA9IFgoXG4gICAgICAgICAgby5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyxcbiAgICAgICAgICBnLnBvc1xuICAgICAgICApO1xuICAgICAgICBwID0gQXQoXG4gICAgICAgICAgbyxcbiAgICAgICAgICBvLmdldEJsb2NrKGIubm9kZS5hdHRycy5pZCksXG4gICAgICAgICAgZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGggPSBhd2FpdCBvLnVwbG9hZEZpbGUobCwgcCksIGYgPSB0eXBlb2YgaCA9PSBcInN0cmluZ1wiID8ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHVybDogaFxuICAgICAgICB9XG4gICAgICB9IDogeyAuLi5oIH07XG4gICAgICBvLnVwZGF0ZUJsb2NrKHAsIGYpO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgb2kgPSAoZSkgPT4gSC5jcmVhdGUoe1xuICBuYW1lOiBcImRyb3BGaWxlXCIsXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IE0oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgZHJvcChvLCB0KSB7XG4gICAgICAgICAgICAgIGlmICghZS5pc0VkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgbGV0IG4gPSBudWxsO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgZnQpXG4gICAgICAgICAgICAgICAgaWYgKHQuZGF0YVRyYW5zZmVyLnR5cGVzLmluY2x1ZGVzKHIpKSB7XG4gICAgICAgICAgICAgICAgICBuID0gcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG4gPT09IG51bGwgPyAhMCA6IG4gPT09IFwiRmlsZXNcIiA/IChJbyh0LCBlKSwgITApIDogITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gbmkoZSwgbykge1xuICBjb25zdCB7IHNjaGVtYTogdCB9ID0gby5zdGF0ZTtcbiAgaWYgKCFlLmNsaXBib2FyZERhdGEpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBuID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuICExO1xuICBpZiAoIXQubm9kZXMuY29kZUJsb2NrKVxuICAgIHJldHVybiBvLnBhc3RlVGV4dChuKSwgITA7XG4gIGNvbnN0IHIgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInZzY29kZS1lZGl0b3ItZGF0YVwiKSwgcyA9IHIgPyBKU09OLnBhcnNlKHIpIDogdm9pZCAwLCBpID0gcyA9PSBudWxsID8gdm9pZCAwIDogcy5tb2RlO1xuICByZXR1cm4gaSA/IChvLnBhc3RlSFRNTChcbiAgICBgPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLSR7aX1cIj4ke24ucmVwbGFjZShcbiAgICAgIC9cXHJcXG4/L2csXG4gICAgICBgXG5gXG4gICAgKX08L2NvZGU+PC9wcmU+YFxuICApLCAhMCkgOiAhMTtcbn1cbmNvbnN0IHJpID0gLyhefFxcbikgezAsM30jezEsNn0gezEsOH1bXlxcbl17MSw2NH1cXHI/XFxuXFxyP1xcblxcc3swLDMyfVxcUy8sIHNpID0gbmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pKF98X198XFxcXCp8XFxcXCpcXFxcKnx+fnw9PXxcXFxcK1xcXFwrKSg/IVxcXFxzKS57MSw2NH0oPzwhXFxcXHMpKD89XFxcXDEpXCIpLCBpaSA9IC9cXFtbXlxcXV17MSwxMjh9XFxdXFwoaHR0cHM/OlxcL1xcL1xcU3sxLDk5OX1cXCkvLCBhaSA9IG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKWAoPyFcXFxccylbXmBdezEsNDh9KD88IVxcXFxzKWAoW15cXFxcd118JClcIiksIGNpID0gLyg/Ol58XFxuKVxcc3swLDV9LVxcc3sxfVteXFxuXStcXG5cXHN7MCwxNX0tXFxzLywgbGkgPSAvKD86XnxcXG4pXFxzezAsNX1cXGQrXFwuXFxzezF9W15cXG5dK1xcblxcc3swLDE1fVxcZCtcXC5cXHMvLCBkaSA9IC9cXG57Mn0gezAsM30tezIsNDh9XFxuezJ9LywgcGkgPSAvKD86XFxufF4pKGBgYHx+fn58XFwkXFwkKSg/IWB8filbXlxcc117MCw2NH0gezAsNjR9W15cXG5dezAsNjR9XFxuW1xcc1xcU117MCw5OTk5fT9cXHMqXFwxIHswLDY0fSg/Olxcbit8JCkvLCB1aSA9IC8oPzpcXG58XikoPyFcXHMpXFx3W15cXG5dezAsNjR9XFxyP1xcbigtfD0pXFwxezAsNjR9XFxuXFxuXFxzezAsNjR9KFxcd3wkKS8sIGhpID0gLyg/Ol58KFxccj9cXG5cXHI/XFxuKSkoIHswLDN9PlteXFxuXXsxLDMzM31cXG4pezEsOTk5fSgkfChcXHI/XFxuKSkvLCBmaSA9IC9eXFxzKlxcfCguK1xcfCkrXFxzKiQvbSwgbWkgPSAvXlxccypcXHwoXFxzKlstOl0rWy06XVxccypcXHwpK1xccyokL20sIGdpID0gL15cXHMqXFx8KC4rXFx8KStcXHMqJC9tLCBiaSA9IChlKSA9PiByaS50ZXN0KGUpIHx8IHNpLnRlc3QoZSkgfHwgaWkudGVzdChlKSB8fCBhaS50ZXN0KGUpIHx8IGNpLnRlc3QoZSkgfHwgbGkudGVzdChlKSB8fCBkaS50ZXN0KGUpIHx8IHBpLnRlc3QoZSkgfHwgdWkudGVzdChlKSB8fCBoaS50ZXN0KGUpIHx8IGZpLnRlc3QoZSkgfHwgbWkudGVzdChlKSB8fCBnaS50ZXN0KGUpO1xuZnVuY3Rpb24ga2koe1xuICBldmVudDogZSxcbiAgZWRpdG9yOiBvLFxuICBwcmlvcml0aXplTWFya2Rvd25PdmVySFRNTDogdCxcbiAgcGxhaW5UZXh0QXNNYXJrZG93bjogblxufSkge1xuICBsZXQgcjtcbiAgZm9yIChjb25zdCBpIG9mIGZ0KVxuICAgIGlmIChlLmNsaXBib2FyZERhdGEudHlwZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgIHIgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICBpZiAoIXIpXG4gICAgcmV0dXJuICEwO1xuICBpZiAociA9PT0gXCJ2c2NvZGUtZWRpdG9yLWRhdGFcIilcbiAgICByZXR1cm4gbmkoZSwgby5wcm9zZW1pcnJvclZpZXcpLCAhMDtcbiAgaWYgKHIgPT09IFwiRmlsZXNcIilcbiAgICByZXR1cm4gSW8oZSwgbyksICEwO1xuICBjb25zdCBzID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEocik7XG4gIGlmIChyID09PSBcImJsb2Nrbm90ZS9odG1sXCIpXG4gICAgcmV0dXJuIG8ucGFzdGVIVE1MKHMsICEwKSwgITA7XG4gIGlmIChyID09PSBcInRleHQvbWFya2Rvd25cIilcbiAgICByZXR1cm4gby5wYXN0ZU1hcmtkb3duKHMpLCAhMDtcbiAgaWYgKHQpIHtcbiAgICBjb25zdCBpID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgIGlmIChiaShpKSlcbiAgICAgIHJldHVybiBvLnBhc3RlTWFya2Rvd24oaSksICEwO1xuICB9XG4gIHJldHVybiByID09PSBcInRleHQvaHRtbFwiID8gKG8ucGFzdGVIVE1MKHMpLCAhMCkgOiBuID8gKG8ucGFzdGVNYXJrZG93bihzKSwgITApIDogKG8ucGFzdGVUZXh0KHMpLCAhMCk7XG59XG5jb25zdCB3aSA9IChlLCBvKSA9PiBILmNyZWF0ZSh7XG4gIG5hbWU6IFwicGFzdGVGcm9tQ2xpcGJvYXJkXCIsXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IE0oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgcGFzdGUodCwgbikge1xuICAgICAgICAgICAgICBpZiAobi5wcmV2ZW50RGVmYXVsdCgpLCAhIWUuaXNFZGl0YWJsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbyh7XG4gICAgICAgICAgICAgICAgICBldmVudDogbixcbiAgICAgICAgICAgICAgICAgIGVkaXRvcjogZSxcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRQYXN0ZUhhbmRsZXI6ICh7XG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXRpemVNYXJrZG93bk92ZXJIVE1MOiByID0gITAsXG4gICAgICAgICAgICAgICAgICAgIHBsYWluVGV4dEFzTWFya2Rvd246IHMgPSAhMFxuICAgICAgICAgICAgICAgICAgfSA9IHt9KSA9PiBraSh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuLFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IGUsXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXRpemVNYXJrZG93bk92ZXJIVE1MOiByLFxuICAgICAgICAgICAgICAgICAgICBwbGFpblRleHRBc01hcmtkb3duOiBzXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcbmZ1bmN0aW9uIExvKGUsIG8pIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gZS5kZXNjZW5kYW50cygobikgPT4ge1xuICAgIHZhciByLCBzO1xuICAgIHJldHVybiBuLnR5cGUubmFtZSA9PT0gXCJibG9ja0NvbnRhaW5lclwiICYmICgociA9IG4uZmlyc3RDaGlsZCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIudHlwZS5uYW1lKSA9PT0gXCJibG9ja0dyb3VwXCIgPyAhMCA6IG4udHlwZS5uYW1lID09PSBcImNvbHVtbkxpc3RcIiAmJiBuLmNoaWxkQ291bnQgPT09IDEgPyAoKHMgPSBuLmZpcnN0Q2hpbGQpID09IG51bGwgfHwgcy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0LnB1c2goXG4gICAgICAgIEUoXG4gICAgICAgICAgaSxcbiAgICAgICAgICBvLmJsb2NrU2NoZW1hLFxuICAgICAgICAgIG8uaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgICBvLnN0eWxlU2NoZW1hXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSksICExKSA6IG4udHlwZS5pc0luR3JvdXAoXCJibkJsb2NrXCIpID8gKHQucHVzaChcbiAgICAgIEUoXG4gICAgICAgIG4sXG4gICAgICAgIG8uYmxvY2tTY2hlbWEsXG4gICAgICAgIG8uaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgby5zdHlsZVNjaGVtYVxuICAgICAgKVxuICAgICksICExKSA6ICEwO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIHlpKGUsIG8sIHQpIHtcbiAgdmFyIGE7XG4gIGxldCBuID0gITE7XG4gIGNvbnN0IHIgPSBlLnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHllO1xuICBpZiAoIXIpIHtcbiAgICBjb25zdCBjID0gZS5zdGF0ZS5kb2Muc2xpY2UoXG4gICAgICBlLnN0YXRlLnNlbGVjdGlvbi5mcm9tLFxuICAgICAgZS5zdGF0ZS5zZWxlY3Rpb24udG8sXG4gICAgICAhMVxuICAgICkuY29udGVudCwgbCA9IFtdO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgYy5jaGlsZENvdW50OyBkKyspXG4gICAgICBsLnB1c2goYy5jaGlsZChkKSk7XG4gICAgbiA9IGwuZmluZChcbiAgICAgIChkKSA9PiBkLnR5cGUuaXNJbkdyb3VwKFwiYm5CbG9ja1wiKSB8fCBkLnR5cGUubmFtZSA9PT0gXCJibG9ja0dyb3VwXCIgfHwgZC50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCJcbiAgICApID09PSB2b2lkIDAsIG4gJiYgKG8gPSBjKTtcbiAgfVxuICBsZXQgcztcbiAgY29uc3QgaSA9IFZlKFxuICAgIGUuc3RhdGUuc2NoZW1hLFxuICAgIHRcbiAgKTtcbiAgaWYgKHIpIHtcbiAgICAoKGEgPSBvLmZpcnN0Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBhLnR5cGUubmFtZSkgPT09IFwidGFibGVcIiAmJiAobyA9IG8uZmlyc3RDaGlsZC5jb250ZW50KTtcbiAgICBjb25zdCBjID0gSnQoXG4gICAgICBvLFxuICAgICAgdC5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIHQuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgKTtcbiAgICBzID0gYDx0YWJsZT4ke2kuZXhwb3J0SW5saW5lQ29udGVudChcbiAgICAgIGMsXG4gICAgICB7fVxuICAgICl9PC90YWJsZT5gO1xuICB9IGVsc2UgaWYgKG4pIHtcbiAgICBjb25zdCBjID0gX2UoXG4gICAgICBvLFxuICAgICAgdC5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIHQuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgKTtcbiAgICBzID0gaS5leHBvcnRJbmxpbmVDb250ZW50KGMsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjID0gTG8obywgdC5zY2hlbWEpO1xuICAgIHMgPSBpLmV4cG9ydEJsb2NrcyhjLCB7fSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBBbyhlLCBvKSB7XG4gIFwibm9kZVwiIGluIGUuc3RhdGUuc2VsZWN0aW9uICYmIGUuc3RhdGUuc2VsZWN0aW9uLm5vZGUudHlwZS5zcGVjLmdyb3VwID09PSBcImJsb2NrQ29udGVudFwiICYmIG8uZGlzcGF0Y2goXG4gICAgby5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyLnNldFNlbGVjdGlvbihcbiAgICAgIG5ldyB3ZShlLnN0YXRlLmRvYy5yZXNvbHZlKGUuc3RhdGUuc2VsZWN0aW9uLmZyb20gLSAxKSlcbiAgICApXG4gICk7XG4gIGNvbnN0IHQgPSBlLnNlcmlhbGl6ZUZvckNsaXBib2FyZChcbiAgICBlLnN0YXRlLnNlbGVjdGlvbi5jb250ZW50KClcbiAgKS5kb20uaW5uZXJIVE1MLCBuID0gZS5zdGF0ZS5zZWxlY3Rpb24uY29udGVudCgpLmNvbnRlbnQsIHIgPSB5aShcbiAgICBlLFxuICAgIG4sXG4gICAgb1xuICApLCBzID0gaHQocik7XG4gIHJldHVybiB7IGNsaXBib2FyZEhUTUw6IHQsIGV4dGVybmFsSFRNTDogciwgbWFya2Rvd246IHMgfTtcbn1cbmNvbnN0IE50ID0gKCkgPT4ge1xuICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBpZiAoIWUgfHwgZS5pc0NvbGxhcHNlZClcbiAgICByZXR1cm4gITA7XG4gIGxldCBvID0gZS5mb2N1c05vZGU7XG4gIGZvciAoOyBvOyApIHtcbiAgICBpZiAobyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG8uZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpID09PSBcImZhbHNlXCIpXG4gICAgICByZXR1cm4gITA7XG4gICAgbyA9IG8ucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gITE7XG59LCBIdCA9IChlLCBvLCB0KSA9PiB7XG4gIHQucHJldmVudERlZmF1bHQoKSwgdC5jbGlwYm9hcmREYXRhLmNsZWFyRGF0YSgpO1xuICBjb25zdCB7IGNsaXBib2FyZEhUTUw6IG4sIGV4dGVybmFsSFRNTDogciwgbWFya2Rvd246IHMgfSA9IEFvKFxuICAgIG8sXG4gICAgZVxuICApO1xuICB0LmNsaXBib2FyZERhdGEuc2V0RGF0YShcImJsb2Nrbm90ZS9odG1sXCIsIG4pLCB0LmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCByKSwgdC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHMpO1xufSwgQ2kgPSAoZSkgPT4gSC5jcmVhdGUoe1xuICBuYW1lOiBcImNvcHlUb0NsaXBib2FyZFwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBNKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgIGNvcHkobywgdCkge1xuICAgICAgICAgICAgICByZXR1cm4gTnQoKSB8fCBIdChlLCBvLCB0KSwgITA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3V0KG8sIHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE50KCkgfHwgKEh0KGUsIG8sIHQpLCBvLmVkaXRhYmxlICYmIG8uZGlzcGF0Y2goby5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKSkpLCAhMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGZvciB0aGUgdXNlLWNhc2UgaW4gd2hpY2ggb25seSBhIGJsb2NrIHdpdGhvdXQgY29udGVudFxuICAgICAgICAgICAgLy8gaXMgc2VsZWN0ZWQsIGUuZy4gYW4gaW1hZ2UgYmxvY2ssIGFuZCBkcmFnZ2VkIChub3QgdXNpbmcgdGhlXG4gICAgICAgICAgICAvLyBkcmFnIGhhbmRsZSkuXG4gICAgICAgICAgICBkcmFnc3RhcnQobywgdCkge1xuICAgICAgICAgICAgICBpZiAoIShcIm5vZGVcIiBpbiBvLnN0YXRlLnNlbGVjdGlvbikgfHwgby5zdGF0ZS5zZWxlY3Rpb24ubm9kZS50eXBlLnNwZWMuZ3JvdXAgIT09IFwiYmxvY2tDb250ZW50XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBlLmRpc3BhdGNoKFxuICAgICAgICAgICAgICAgIGUuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgICAgICAgICBuZXcgd2UoXG4gICAgICAgICAgICAgICAgICAgIG8uc3RhdGUuZG9jLnJlc29sdmUoby5zdGF0ZS5zZWxlY3Rpb24uZnJvbSAtIDEpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLCB0LnByZXZlbnREZWZhdWx0KCksIHQuZGF0YVRyYW5zZmVyLmNsZWFyRGF0YSgpO1xuICAgICAgICAgICAgICBjb25zdCB7IGNsaXBib2FyZEhUTUw6IG4sIGV4dGVybmFsSFRNTDogciwgbWFya2Rvd246IHMgfSA9IEFvKG8sIGUpO1xuICAgICAgICAgICAgICByZXR1cm4gdC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcImJsb2Nrbm90ZS9odG1sXCIsIG4pLCB0LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9odG1sXCIsIHIpLCB0LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBzKSwgITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pLCB2aSA9IEguY3JlYXRlKHtcbiAgbmFtZTogXCJibG9ja0JhY2tncm91bmRDb2xvclwiLFxuICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGVzOiBbXCJibG9ja0NvbnRhaW5lclwiLCBcInRhYmxlQ2VsbFwiLCBcInRhYmxlSGVhZGVyXCJdLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBTLmJhY2tncm91bmRDb2xvci5kZWZhdWx0LFxuICAgICAgICAgICAgcGFyc2VIVE1MOiAoZSkgPT4gZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLWJhY2tncm91bmQtY29sb3JcIikgPyBlLmdldEF0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKSA6IFMuYmFja2dyb3VuZENvbG9yLmRlZmF1bHQsXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAoZSkgPT4gZS5iYWNrZ3JvdW5kQ29sb3IgPT09IFMuYmFja2dyb3VuZENvbG9yLmRlZmF1bHQgPyB7fSA6IHtcbiAgICAgICAgICAgICAgXCJkYXRhLWJhY2tncm91bmQtY29sb3JcIjogZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9XG59KSwgRWkgPSAoZSkgPT4ge1xuICB2YXIgbjtcbiAgY29uc3QgbyA9IFtdO1xuICBvLnB1c2goXG4gICAgeG4uY29uZmlndXJlKHtcbiAgICAgIGZyYWdtZW50OiBlLmZyYWdtZW50XG4gICAgfSlcbiAgKTtcbiAgY29uc3QgdCA9IChuID0gZS5wcm92aWRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IG4uYXdhcmVuZXNzO1xuICBpZiAodCkge1xuICAgIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGUuc2hvd0N1cnNvckxhYmVscyAhPT0gXCJhbHdheXNcIiAmJiB0Lm9uKFxuICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICh7XG4gICAgICAgIHVwZGF0ZWQ6IGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGEpIHtcbiAgICAgICAgICBjb25zdCBsID0gci5nZXQoYyk7XG4gICAgICAgICAgbCAmJiAobC5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtYWN0aXZlXCIsIFwiXCIpLCBsLmhpZGVUaW1lb3V0ICYmIGNsZWFyVGltZW91dChsLmhpZGVUaW1lb3V0KSwgci5zZXQoYywge1xuICAgICAgICAgICAgZWxlbWVudDogbC5lbGVtZW50LFxuICAgICAgICAgICAgaGlkZVRpbWVvdXQ6IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBsLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1hY3RpdmVcIik7XG4gICAgICAgICAgICB9LCAyZTMpXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBzID0gKGEpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIGMuY2xhc3NMaXN0LmFkZChcImJuLWNvbGxhYm9yYXRpb24tY3Vyc29yX19iYXNlXCIpO1xuICAgICAgY29uc3QgbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRFZGl0YWJsZVwiLCBcImZhbHNlXCIpLCBsLmNsYXNzTGlzdC5hZGQoXCJibi1jb2xsYWJvcmF0aW9uLWN1cnNvcl9fY2FyZXRcIiksIGwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7YS5jb2xvcn1gKTtcbiAgICAgIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHJldHVybiBkLmNsYXNzTGlzdC5hZGQoXCJibi1jb2xsYWJvcmF0aW9uLWN1cnNvcl9fbGFiZWxcIiksIGQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7YS5jb2xvcn1gKSwgZC5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYS5uYW1lKSwgbnVsbCksIGwuaW5zZXJ0QmVmb3JlKGQsIG51bGwpLCBjLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKBoFwiKSwgbnVsbCksIGMuaW5zZXJ0QmVmb3JlKGwsIG51bGwpLCBjLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKBoFwiKSwgbnVsbCksIGM7XG4gICAgfSwgaSA9IChhLCBjKSA9PiB7XG4gICAgICB2YXIgZDtcbiAgICAgIGxldCBsID0gci5nZXQoYyk7XG4gICAgICBpZiAoIWwpIHtcbiAgICAgICAgY29uc3QgcCA9ICgoZCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucmVuZGVyQ3Vyc29yKSA9PSBudWxsID8gdm9pZCAwIDogZC5jYWxsKGUsIGEpKSB8fCBzKGEpO1xuICAgICAgICAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5zaG93Q3Vyc29yTGFiZWxzKSAhPT0gXCJhbHdheXNcIiAmJiAocC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaCA9IHIuZ2V0KGMpO1xuICAgICAgICAgIGguZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFjdGl2ZVwiLCBcIlwiKSwgaC5oaWRlVGltZW91dCAmJiAoY2xlYXJUaW1lb3V0KGguaGlkZVRpbWVvdXQpLCByLnNldChjLCB7XG4gICAgICAgICAgICBlbGVtZW50OiBoLmVsZW1lbnQsXG4gICAgICAgICAgICBoaWRlVGltZW91dDogdm9pZCAwXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KSwgcC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaCA9IHIuZ2V0KGMpO1xuICAgICAgICAgIHIuc2V0KGMsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGguZWxlbWVudCxcbiAgICAgICAgICAgIGhpZGVUaW1lb3V0OiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaC5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSwgMmUzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSksIGwgPSB7XG4gICAgICAgICAgZWxlbWVudDogcCxcbiAgICAgICAgICBoaWRlVGltZW91dDogdm9pZCAwXG4gICAgICAgIH0sIHIuc2V0KGMsIGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGwuZWxlbWVudDtcbiAgICB9O1xuICAgIG8ucHVzaChcbiAgICAgIE1uLmNvbmZpZ3VyZSh7XG4gICAgICAgIHVzZXI6IGUudXNlcixcbiAgICAgICAgcmVuZGVyOiBpLFxuICAgICAgICAvLyB0aXB0YXAgdHlwZSBub3QgY29tcGF0aWJsZSB3aXRoIGxhdGVzdCB5LXByb3NlbWlycm9yXG4gICAgICAgIHByb3ZpZGVyOiBlLnByb3ZpZGVyXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG87XG59LCBObyA9IGtlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiY29tbWVudFwiLFxuICBleGNsdWRlczogXCJcIixcbiAgaW5jbHVzaXZlOiAhMSxcbiAga2VlcE9uU3BsaXQ6ICEwLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBvcnBoYW5zIGFyZSBtYXJrcyB0aGF0IGN1cnJlbnRseSBkb24ndCBoYXZlIGFuIGFjdGl2ZSB0aHJlYWQuIEl0IGNvdWxkIGJlXG4gICAgICAvLyB0aGF0IHVzZXJzIGhhdmUgcmVzb2x2ZWQgdGhlIHRocmVhZC4gUmVzb2x2ZWQgdGhyZWFkcyBieSBkZWZhdWx0IGFyZSBub3Qgc2hvd24gaW4gdGhlIGRvY3VtZW50LFxuICAgICAgLy8gYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgbWFyayAocG9zaXRpb25pbmcpIGRhdGEgc28gd2UgY2FuIHN0aWxsIFwicmV2aXZlXCIgaXQgd2hlbiB0aGUgdGhyZWFkIGlzIHVucmVzb2x2ZWRcbiAgICAgIC8vIG9yIHdlIGVudGVyIGEgXCJjb21tZW50c1wiIHZpZXcgdGhhdCBpbmNsdWRlcyByZXNvbHZlZCB0aHJlYWRzLlxuICAgICAgb3JwaGFuOiB7XG4gICAgICAgIHBhcnNlSFRNTDogKGUpID0+ICEhZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9ycGhhblwiKSxcbiAgICAgICAgcmVuZGVySFRNTDogKGUpID0+IGUub3JwaGFuID8ge1xuICAgICAgICAgIFwiZGF0YS1vcnBoYW5cIjogXCJ0cnVlXCJcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgfSxcbiAgICAgIHRocmVhZElkOiB7XG4gICAgICAgIHBhcnNlSFRNTDogKGUpID0+IGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1ibi10aHJlYWQtaWRcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChlKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1ibi10aHJlYWQtaWRcIjogZS50aHJlYWRJZFxuICAgICAgICB9KSxcbiAgICAgICAgZGVmYXVsdDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwic3BhblwiLFxuICAgICAganQoZSwge1xuICAgICAgICBjbGFzczogXCJibi10aHJlYWQtbWFya1wiXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcInNwYW4uYm4tdGhyZWFkLW1hcmtcIiB9XTtcbiAgfSxcbiAgZXh0ZW5kTWFya1NjaGVtYShlKSB7XG4gICAgcmV0dXJuIGUubmFtZSA9PT0gXCJjb21tZW50XCIgPyB7XG4gICAgICBibG9ja25vdGVJZ25vcmU6ICEwXG4gICAgfSA6IHt9O1xuICB9XG59KTtcbmNsYXNzIHEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIHUodGhpcywgXCJjYWxsYmFja3NcIiwge30pO1xuICB9XG4gIG9uKG8sIHQpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFja3Nbb10gfHwgKHRoaXMuY2FsbGJhY2tzW29dID0gW10pLCB0aGlzLmNhbGxiYWNrc1tvXS5wdXNoKHQpLCAoKSA9PiB0aGlzLm9mZihvLCB0KTtcbiAgfVxuICBlbWl0KG8sIC4uLnQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5jYWxsYmFja3Nbb107XG4gICAgbiAmJiBuLmZvckVhY2goKHIpID0+IHIuYXBwbHkodGhpcywgdCkpO1xuICB9XG4gIG9mZihvLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuY2FsbGJhY2tzW29dO1xuICAgIG4gJiYgKHQgPyB0aGlzLmNhbGxiYWNrc1tvXSA9IG4uZmlsdGVyKChyKSA9PiByICE9PSB0KSA6IGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tvXSk7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gIH1cbn1cbmNsYXNzIFNpIGV4dGVuZHMgcSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHUodGhpcywgXCJ1c2VyQ2FjaGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgLy8gYXZvaWQgZHVwbGljYXRlIGxvYWRzXG4gICAgdSh0aGlzLCBcImxvYWRpbmdVc2Vyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB0aGlzLnJlc29sdmVVc2VycyA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgaW5mb3JtYXRpb24gYWJvdXQgdXNlcnMgYmFzZWQgb24gYW4gYXJyYXkgb2YgdXNlciBpZHMuXG4gICAqL1xuICBhc3luYyBsb2FkVXNlcnModCkge1xuICAgIGNvbnN0IG4gPSB0LmZpbHRlcihcbiAgICAgIChyKSA9PiAhdGhpcy51c2VyQ2FjaGUuaGFzKHIpICYmICF0aGlzLmxvYWRpbmdVc2Vycy5oYXMocilcbiAgICApO1xuICAgIGlmIChuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCByIG9mIG4pXG4gICAgICAgIHRoaXMubG9hZGluZ1VzZXJzLmFkZChyKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnJlc29sdmVVc2VycyhuKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHIpXG4gICAgICAgICAgdGhpcy51c2VyQ2FjaGUuc2V0KHMuaWQsIHMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcy51c2VyQ2FjaGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZm9yIChjb25zdCByIG9mIG4pXG4gICAgICAgICAgdGhpcy5sb2FkaW5nVXNlcnMuZGVsZXRlKHIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXQgYSB1c2VyIGJhc2VkIG9uIHRoZWlyIGlkLCBpZiBjYWNoZWQuXG4gICAqXG4gICAqIFRoZSB1c2VyIHdpbGwgaGF2ZSB0byBiZSBsb2FkZWQgdmlhIGBsb2FkVXNlcnNgIGZpcnN0XG4gICAqL1xuICBnZXRVc2VyKHQpIHtcbiAgICByZXR1cm4gdGhpcy51c2VyQ2FjaGUuZ2V0KHQpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgdXNlciBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNiIC0gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiB0aGUgdXNlciBzdG9yZSBjaGFuZ2VzLlxuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlIGZyb20gdGhlIHVzZXIgc3RvcmUuXG4gICAqL1xuICBzdWJzY3JpYmUodCkge1xuICAgIHJldHVybiB0aGlzLm9uKFwidXBkYXRlXCIsIHQpO1xuICB9XG59XG5jb25zdCB4ZSA9IG5ldyBOKFwiYmxvY2tub3RlLWNvbW1lbnRzXCIpLCBCaSA9IFwiU0VUX1NFTEVDVEVEX1RIUkVBRF9JRFwiO1xuZnVuY3Rpb24gVGkoZSwgbykge1xuICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIGUuZGVzY2VuZGFudHMoKG4sIHIpID0+IHtcbiAgICBuLm1hcmtzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGlmIChzLnR5cGUubmFtZSA9PT0gbykge1xuICAgICAgICBjb25zdCBpID0gcy5hdHRycy50aHJlYWRJZDtcbiAgICAgICAgaWYgKCFpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYSA9IHIsIGMgPSBhICsgbi5ub2RlU2l6ZSwgbCA9IHQuZ2V0KGkpID8/IHtcbiAgICAgICAgICBmcm9tOiAxIC8gMCxcbiAgICAgICAgICB0bzogMFxuICAgICAgICB9O1xuICAgICAgICB0LnNldChpLCB7XG4gICAgICAgICAgZnJvbTogTWF0aC5taW4oYSwgbC5mcm9tKSxcbiAgICAgICAgICB0bzogTWF0aC5tYXgoYywgbC50bylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCB0O1xufVxuY2xhc3MgeGkgZXh0ZW5kcyBxIHtcbiAgY29uc3RydWN0b3IodCwgbiwgcikge1xuICAgIHN1cGVyKCk7XG4gICAgdSh0aGlzLCBcInBsdWdpblwiKTtcbiAgICB1KHRoaXMsIFwidXNlclN0b3JlXCIpO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYSBjb21tZW50IGlzIGN1cnJlbnRseSBiZWluZyBjb21wb3NlZFxuICAgICAqL1xuICAgIHUodGhpcywgXCJwZW5kaW5nQ29tbWVudFwiLCAhMSk7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0aHJlYWQgaWRcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwic2VsZWN0ZWRUaHJlYWRJZFwiKTtcbiAgICAvKipcbiAgICAgKiBTdG9yZSB0aGUgcG9zaXRpb25zIG9mIGFsbCB0aHJlYWRzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKiB0aGlzIGNhbiBiZSB1c2VkIGxhdGVyIHRvIGltcGxlbWVudCBhIGZsb2F0aW5nIHNpZGViYXJcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwidGhyZWFkUG9zaXRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIC8qKlxuICAgICAqIHdoZW4gYSB0aHJlYWQgaXMgcmVzb2x2ZWQgb3IgZGVsZXRlZCwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIG1hcmtzIHRvIHJlZmxlY3QgdGhlIG5ldyBzdGF0ZVxuICAgICAqL1xuICAgIHUodGhpcywgXCJ1cGRhdGVNYXJrc0Zyb21UaHJlYWRzXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvcjtcbiAgICAgIG4uc3RhdGUuZG9jLmRlc2NlbmRhbnRzKChyLCBzKSA9PiB7XG4gICAgICAgIHIubWFya3MuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICAgIGlmIChpLnR5cGUubmFtZSA9PT0gdGhpcy5tYXJrVHlwZSkge1xuICAgICAgICAgICAgY29uc3QgYSA9IGkudHlwZSwgYyA9IGkuYXR0cnMudGhyZWFkSWQsIGwgPSB0LmdldChjKSwgZCA9ICEhKCFsIHx8IGwucmVzb2x2ZWQgfHwgbC5kZWxldGVkQXQpO1xuICAgICAgICAgICAgaWYgKGQgIT09IGkuYXR0cnMub3JwaGFuKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdHI6IHAgfSA9IG4uc3RhdGUsIGggPSBNYXRoLm1heChzLCAwKSwgZiA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIHMgKyByLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgIG4uc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcC5yZW1vdmVNYXJrKGgsIGYsIGkpLCBwLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgaCxcbiAgICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICAgIGEuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgIC4uLmkuYXR0cnMsXG4gICAgICAgICAgICAgICAgICBvcnBoYW46IGRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApLCBuLmRpc3BhdGNoKHApLCBkICYmIHRoaXMuc2VsZWN0ZWRUaHJlYWRJZCA9PT0gYyAmJiAodGhpcy5zZWxlY3RlZFRocmVhZElkID0gdm9pZCAwLCB0aGlzLmVtaXRTdGF0ZVVwZGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZWRpdG9yID0gdCwgdGhpcy50aHJlYWRTdG9yZSA9IG4sIHRoaXMubWFya1R5cGUgPSByLCAhdC5yZXNvbHZlVXNlcnMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlVXNlcnMgaXMgcmVxdWlyZWQgZm9yIGNvbW1lbnRzXCIpO1xuICAgIHRoaXMudXNlclN0b3JlID0gbmV3IFNpKHQucmVzb2x2ZVVzZXJzKSwgdGhpcy50aHJlYWRTdG9yZS5zdWJzY3JpYmUodGhpcy51cGRhdGVNYXJrc0Zyb21UaHJlYWRzKSwgdC5vbkNyZWF0ZSgoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtzRnJvbVRocmVhZHModGhpcy50aHJlYWRTdG9yZS5nZXRUaHJlYWRzKCkpLCB0Lm9uU2VsZWN0aW9uQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29tbWVudCAmJiAodGhpcy5wZW5kaW5nQ29tbWVudCA9ICExLCB0aGlzLmVtaXRTdGF0ZVVwZGF0ZSgpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHMgPSB0aGlzO1xuICAgIHRoaXMucGx1Z2luID0gbmV3IE0oe1xuICAgICAga2V5OiB4ZSxcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBVLmVtcHR5XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwbHkoaSwgYSkge1xuICAgICAgICAgIGNvbnN0IGMgPSBpLmdldE1ldGEoeGUpO1xuICAgICAgICAgIGlmICghaS5kb2NDaGFuZ2VkICYmICFjKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgY29uc3QgbCA9IGkuZG9jQ2hhbmdlZCA/IFRpKGkuZG9jLCBzLm1hcmtUeXBlKSA6IHMudGhyZWFkUG9zaXRpb25zO1xuICAgICAgICAgIChsLnNpemUgPiAwIHx8IHMudGhyZWFkUG9zaXRpb25zLnNpemUgPiAwKSAmJiAocy50aHJlYWRQb3NpdGlvbnMgPSBsLCBzLmVtaXRTdGF0ZVVwZGF0ZSgpKTtcbiAgICAgICAgICBjb25zdCBkID0gW107XG4gICAgICAgICAgaWYgKHMuc2VsZWN0ZWRUaHJlYWRJZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IGwuZ2V0KFxuICAgICAgICAgICAgICBzLnNlbGVjdGVkVGhyZWFkSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwICYmIGQucHVzaChcbiAgICAgICAgICAgICAgRy5pbmxpbmUoXG4gICAgICAgICAgICAgICAgcC5mcm9tLFxuICAgICAgICAgICAgICAgIHAudG8sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiYm4tdGhyZWFkLW1hcmstc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBVLmNyZWF0ZShpLmRvYywgZClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGVjb3JhdGlvbnMoaSkge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiAoKGEgPSB4ZS5nZXRTdGF0ZShpKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZGVjb3JhdGlvbnMpID8/IFUuZW1wdHk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgY2xpY2sgb24gYSB0aHJlYWQgbWFyayBhbmQgbWFyayBpdCBhcyBzZWxlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlQ2xpY2s6IChpLCBhLCBjKSA9PiB7XG4gICAgICAgICAgaWYgKGMuYnV0dG9uICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGwgPSBpLnN0YXRlLmRvYy5ub2RlQXQoYSk7XG4gICAgICAgICAgaWYgKCFsKSB7XG4gICAgICAgICAgICBzLnNlbGVjdFRocmVhZCh2b2lkIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkID0gbC5tYXJrcy5maW5kKFxuICAgICAgICAgICAgKGgpID0+IGgudHlwZS5uYW1lID09PSByICYmIGguYXR0cnMub3JwaGFuICE9PSAhMFxuICAgICAgICAgICksIHAgPSBkID09IG51bGwgPyB2b2lkIDAgOiBkLmF0dHJzLnRocmVhZElkO1xuICAgICAgICAgIHMuc2VsZWN0VGhyZWFkKHAsICExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVtaXRTdGF0ZVVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwge1xuICAgICAgc2VsZWN0ZWRUaHJlYWRJZDogdGhpcy5zZWxlY3RlZFRocmVhZElkLFxuICAgICAgcGVuZGluZ0NvbW1lbnQ6IHRoaXMucGVuZGluZ0NvbW1lbnQsXG4gICAgICB0aHJlYWRQb3NpdGlvbnM6IHRoaXMudGhyZWFkUG9zaXRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBzdGF0ZSB1cGRhdGVzXG4gICAqL1xuICBvblVwZGF0ZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMub24oXCJ1cGRhdGVcIiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc2VsZWN0ZWQgdGhyZWFkXG4gICAqL1xuICBzZWxlY3RUaHJlYWQodCwgbiA9ICEwKSB7XG4gICAgdmFyIHIsIHM7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRUaHJlYWRJZCAhPT0gdCAmJiAodGhpcy5zZWxlY3RlZFRocmVhZElkID0gdCwgdGhpcy5lbWl0U3RhdGVVcGRhdGUoKSwgdGhpcy5lZGl0b3IuZGlzcGF0Y2goXG4gICAgICB0aGlzLmVkaXRvci5wcm9zZW1pcnJvclZpZXcuc3RhdGUudHIuc2V0TWV0YSh4ZSwge1xuICAgICAgICBuYW1lOiBCaVxuICAgICAgfSlcbiAgICApLCB0ICYmIG4pKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy50aHJlYWRQb3NpdGlvbnMuZ2V0KHQpO1xuICAgICAgaWYgKCFpKVxuICAgICAgICByZXR1cm47XG4gICAgICAocyA9IChyID0gdGhpcy5lZGl0b3IucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogci5kb21BdFBvcyhpLmZyb20pLm5vZGUpID09IG51bGwgfHwgcy5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgICBibG9jazogXCJjZW50ZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIHBlbmRpbmcgY29tbWVudCAoZS5nLjogd2hlbiBjbGlja2luZyB0aGUgXCJBZGQgY29tbWVudFwiIGJ1dHRvbilcbiAgICovXG4gIHN0YXJ0UGVuZGluZ0NvbW1lbnQoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ29tbWVudCA9ICEwLCB0aGlzLmVtaXRTdGF0ZVVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIGEgcGVuZGluZyBjb21tZW50IChlLmcuOiB1c2VyIGNsb3NlcyB0aGUgY29tbWVudCBjb21wb3NlcilcbiAgICovXG4gIHN0b3BQZW5kaW5nQ29tbWVudCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDb21tZW50ID0gITEsIHRoaXMuZW1pdFN0YXRlVXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRocmVhZCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRocmVhZCh0KSB7XG4gICAgY29uc3QgbiA9IGF3YWl0IHRoaXMudGhyZWFkU3RvcmUuY3JlYXRlVGhyZWFkKHQpO1xuICAgIGlmICh0aGlzLnRocmVhZFN0b3JlLmFkZFRocmVhZFRvRG9jdW1lbnQpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmVkaXRvci5wcm9zZW1pcnJvclZpZXcsIHMgPSByLnN0YXRlLnNlbGVjdGlvbiwgaSA9IE5lLmdldFN0YXRlKHIuc3RhdGUpLCBhID0ge1xuICAgICAgICBwcm9zZW1pcnJvcjoge1xuICAgICAgICAgIGhlYWQ6IHMuaGVhZCxcbiAgICAgICAgICBhbmNob3I6IHMuYW5jaG9yXG4gICAgICAgIH0sXG4gICAgICAgIHlqczogaSA/IEluKGkuYmluZGluZywgci5zdGF0ZSkgOiB2b2lkIDBcbiAgICAgICAgLy8gaWYgd2UncmUgbm90IHVzaW5nIHlqc1xuICAgICAgfTtcbiAgICAgIGF3YWl0IHRoaXMudGhyZWFkU3RvcmUuYWRkVGhyZWFkVG9Eb2N1bWVudCh7XG4gICAgICAgIHRocmVhZElkOiBuLmlkLFxuICAgICAgICBzZWxlY3Rpb246IGFcbiAgICAgIH0pO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRNYXJrKHRoaXMubWFya1R5cGUsIHtcbiAgICAgICAgb3JwaGFuOiAhMSxcbiAgICAgICAgdGhyZWFkSWQ6IG4uaWRcbiAgICAgIH0pO1xuICB9XG59XG5jbGFzcyBNaSB7XG4gIGNvbnN0cnVjdG9yKG8sIHQsIG4sIHIpIHtcbiAgICB1KHRoaXMsIFwic3RhdGVcIik7XG4gICAgdSh0aGlzLCBcImVtaXRVcGRhdGVcIik7XG4gICAgdSh0aGlzLCBcIm1vdXNlRG93bkhhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICAobyA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgby5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCkpO1xuICAgIH0pO1xuICAgIC8vIEZvciBkcmFnZ2luZyB0aGUgd2hvbGUgZWRpdG9yLlxuICAgIHUodGhpcywgXCJkcmFnc3RhcnRIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgKG8gPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIG8uc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwic2Nyb2xsSGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIGlmICgobyA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgby5zaG93KSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnBtVmlldy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYFtkYXRhLW5vZGUtdHlwZT1cImJsb2NrQ29udGFpbmVyXCJdW2RhdGEtaWQ9XCIke3RoaXMuc3RhdGUuYmxvY2suaWR9XCJdYFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLnJlZmVyZW5jZVBvcyA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRoaXMuZW1pdFVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHUodGhpcywgXCJjbG9zZU1lbnVcIiwgKCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICAobyA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgby5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCkpO1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yID0gbywgdGhpcy5wbHVnaW5LZXkgPSB0LCB0aGlzLnBtVmlldyA9IG4sIHRoaXMuZW1pdFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGluZyB0byB1cGRhdGUgdW5pbml0aWFsaXplZCBmaWxlIHBhbmVsXCIpO1xuICAgICAgcih0aGlzLnN0YXRlKTtcbiAgICB9LCBuLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMubW91c2VEb3duSGFuZGxlciksIG4uZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKSwgbi5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyLCAhMCk7XG4gIH1cbiAgdXBkYXRlKG8sIHQpIHtcbiAgICB2YXIgciwgcztcbiAgICBjb25zdCBuID0gdGhpcy5wbHVnaW5LZXkuZ2V0U3RhdGUoby5zdGF0ZSk7XG4gICAgaWYgKCEoKHIgPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIHIuc2hvdykgJiYgbi5ibG9jayAmJiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5wbVZpZXcucm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBgW2RhdGEtbm9kZS10eXBlPVwiYmxvY2tDb250YWluZXJcIl1bZGF0YS1pZD1cIiR7bi5ibG9jay5pZH1cIl1gXG4gICAgICApO1xuICAgICAgaWYgKCFpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBzaG93OiAhMCxcbiAgICAgICAgcmVmZXJlbmNlUG9zOiBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBibG9jazogbi5ibG9ja1xuICAgICAgfSwgdGhpcy5lbWl0VXBkYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICghby5zdGF0ZS5zZWxlY3Rpb24uZXEodC5zZWxlY3Rpb24pIHx8ICFvLnN0YXRlLmRvYy5lcSh0LmRvYykgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpICYmIChzID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBzLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm1vdXNlRG93bkhhbmRsZXIpLCB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpLCB0aGlzLnBtVmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyLCAhMCk7XG4gIH1cbn1cbmNvbnN0IEdlID0gbmV3IE4oXCJGaWxlUGFuZWxQbHVnaW5cIik7XG5jbGFzcyBQaSBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB1KHRoaXMsIFwidmlld1wiKTtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIHUodGhpcywgXCJjbG9zZU1lbnVcIiwgKCkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICByZXR1cm4gKHQgPSB0aGlzLnZpZXcpID09IG51bGwgPyB2b2lkIDAgOiB0LmNsb3NlTWVudSgpO1xuICAgIH0pO1xuICAgIHRoaXMucGx1Z2luID0gbmV3IE0oe1xuICAgICAga2V5OiBHZSxcbiAgICAgIHZpZXc6IChuKSA9PiAodGhpcy52aWV3ID0gbmV3IE1pKFxuICAgICAgICB0LFxuICAgICAgICBHZSxcbiAgICAgICAgbixcbiAgICAgICAgKHIpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgcik7XG4gICAgICAgIH1cbiAgICAgICksIHRoaXMudmlldyksXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVLZXlEb3duOiAobiwgcikgPT4ge1xuICAgICAgICAgIHZhciBzO1xuICAgICAgICAgIHJldHVybiByLmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLnNob3duID8gKChzID0gdGhpcy52aWV3KSA9PSBudWxsIHx8IHMuY2xvc2VNZW51KCksICEwKSA6ICExO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgaW5pdDogKCkgPT4gKHtcbiAgICAgICAgICBibG9jazogdm9pZCAwXG4gICAgICAgIH0pLFxuICAgICAgICBhcHBseTogKG4pID0+IHtcbiAgICAgICAgICB2YXIgcztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2s6IChzID0gbi5nZXRNZXRhKEdlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuYmxvY2tcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHNob3duKCkge1xuICAgIHZhciB0LCBuO1xuICAgIHJldHVybiAoKG4gPSAodCA9IHRoaXMudmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBuLnNob3cpIHx8ICExO1xuICB9XG4gIG9uVXBkYXRlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5vbihcInVwZGF0ZVwiLCB0KTtcbiAgfVxufVxuY2xhc3MgSWkge1xuICBjb25zdHJ1Y3RvcihvLCB0LCBuKSB7XG4gICAgdSh0aGlzLCBcInN0YXRlXCIpO1xuICAgIHUodGhpcywgXCJlbWl0VXBkYXRlXCIpO1xuICAgIHUodGhpcywgXCJwcmV2ZW50SGlkZVwiLCAhMSk7XG4gICAgdSh0aGlzLCBcInByZXZlbnRTaG93XCIsICExKTtcbiAgICB1KHRoaXMsIFwic2hvdWxkU2hvd1wiLCAoeyBzdGF0ZTogbywgZnJvbTogdCwgdG86IG4gfSkgPT4ge1xuICAgICAgY29uc3QgeyBkb2M6IHIsIHNlbGVjdGlvbjogcyB9ID0gbywgeyBlbXB0eTogaSB9ID0gcywgYSA9ICFyLnRleHRCZXR3ZWVuKHQsIG4pLmxlbmd0aCAmJiBXdChvLnNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gcy4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgWGUocykgJiYgcy5ub2RlLnR5cGUuc3BlYy5jb2RlID8gITEgOiAhKGkgfHwgYSk7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcImJsdXJIYW5kbGVyXCIsIChvKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IHRoaXMucG1WaWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgLy8gQW4gZWxlbWVudCBpcyBjbGlja2VkLlxuICAgICAgbyAmJiBvLnJlbGF0ZWRUYXJnZXQgJiYgLy8gRWxlbWVudCBpcyBpbnNpZGUgdGhlIGVkaXRvci5cbiAgICAgICh0ID09PSBvLnJlbGF0ZWRUYXJnZXQgfHwgdC5jb250YWlucyhvLnJlbGF0ZWRUYXJnZXQpIHx8IG8ucmVsYXRlZFRhcmdldC5tYXRjaGVzKFxuICAgICAgICBcIi5ibi11aS1jb250YWluZXIsIC5ibi11aS1jb250YWluZXIgKlwiXG4gICAgICApKSB8fCAobiA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgbi5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCkpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJ2aWV3TW91c2Vkb3duSGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByZXZlbnRTaG93ID0gITA7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcIm1vdXNldXBIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJldmVudFNob3cgJiYgKHRoaXMucHJldmVudFNob3cgPSAhMSwgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZSh0aGlzLnBtVmlldykpKTtcbiAgICB9KTtcbiAgICAvLyBGb3IgZHJhZ2dpbmcgdGhlIHdob2xlIGVkaXRvci5cbiAgICB1KHRoaXMsIFwiZHJhZ0hhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICAobyA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgby5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCkpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJzY3JvbGxIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgKG8gPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIG8uc2hvdyAmJiAodGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3MgPSB0aGlzLmdldFNlbGVjdGlvbkJvdW5kaW5nQm94KCksIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwiY2xvc2VNZW51XCIsICgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgKG8gPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIG8uc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IG8sIHRoaXMucG1WaWV3ID0gdCwgdGhpcy5lbWl0VXBkYXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIHVwZGF0ZSB1bmluaXRpYWxpemVkIGZvcm1hdHRpbmcgdG9vbGJhclwiXG4gICAgICAgICk7XG4gICAgICBuKHRoaXMuc3RhdGUpO1xuICAgIH0sIHQuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy52aWV3TW91c2Vkb3duSGFuZGxlciksIHQucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm1vdXNldXBIYW5kbGVyKSwgdC5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCB0aGlzLmRyYWdIYW5kbGVyKSwgdC5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ0hhbmRsZXIpLCB0LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXJIYW5kbGVyKSwgdC5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyLCAhMCk7XG4gIH1cbiAgdXBkYXRlKG8sIHQpIHtcbiAgICB2YXIgaDtcbiAgICBjb25zdCB7IHN0YXRlOiBuLCBjb21wb3Npbmc6IHIgfSA9IG8sIHsgc2VsZWN0aW9uOiBzIH0gPSBuLCBpID0gdCAmJiB0LnNlbGVjdGlvbi5mcm9tID09PSBuLnNlbGVjdGlvbi5mcm9tICYmIHQuc2VsZWN0aW9uLnRvID09PSBuLnNlbGVjdGlvbi50bztcbiAgICBpZiAociB8fCBpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgcmFuZ2VzOiBhIH0gPSBzLCBjID0gTWF0aC5taW4oLi4uYS5tYXAoKGYpID0+IGYuJGZyb20ucG9zKSksIGwgPSBNYXRoLm1heCguLi5hLm1hcCgoZikgPT4gZi4kdG8ucG9zKSksIGQgPSB0aGlzLnNob3VsZFNob3coe1xuICAgICAgdmlldzogbyxcbiAgICAgIHN0YXRlOiBuLFxuICAgICAgZnJvbTogYyxcbiAgICAgIHRvOiBsXG4gICAgfSksIHAgPSB0eXBlb2YgUmFuZ2UucHJvdG90eXBlLmdldENsaWVudFJlY3RzID4gXCJ1XCI7XG4gICAgaWYgKCF0aGlzLnByZXZlbnRTaG93ICYmIChkIHx8IHRoaXMucHJldmVudEhpZGUpICYmICFwKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBzaG93OiAhMCxcbiAgICAgICAgcmVmZXJlbmNlUG9zOiB0aGlzLmdldFNlbGVjdGlvbkJvdW5kaW5nQm94KClcbiAgICAgIH0sIHRoaXMuZW1pdFVwZGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKGggPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIGguc2hvdyAmJiAhdGhpcy5wcmV2ZW50SGlkZSAmJiAoIWQgfHwgdGhpcy5wcmV2ZW50U2hvdyB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkpIHtcbiAgICAgIHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLnZpZXdNb3VzZWRvd25IYW5kbGVyKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm1vdXNldXBIYW5kbGVyKSwgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5kcmFnSGFuZGxlciksIHRoaXMucG1WaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5kcmFnSGFuZGxlciksIHRoaXMucG1WaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXJIYW5kbGVyKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciwgITApO1xuICB9XG4gIGdldFNlbGVjdGlvbkJvdW5kaW5nQm94KCkge1xuICAgIGNvbnN0IHsgc3RhdGU6IG8gfSA9IHRoaXMucG1WaWV3LCB7IHNlbGVjdGlvbjogdCB9ID0gbywgeyByYW5nZXM6IG4gfSA9IHQsIHIgPSBNYXRoLm1pbiguLi5uLm1hcCgoaSkgPT4gaS4kZnJvbS5wb3MpKSwgcyA9IE1hdGgubWF4KC4uLm4ubWFwKChpKSA9PiBpLiR0by5wb3MpKTtcbiAgICBpZiAoWGUodCkpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnBtVmlldy5ub2RlRE9NKHIpO1xuICAgICAgaWYgKGkpXG4gICAgICAgIHJldHVybiBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gQWUodGhpcy5wbVZpZXcsIHIsIHMpO1xuICB9XG59XG5jb25zdCBMaSA9IG5ldyBOKFxuICBcIkZvcm1hdHRpbmdUb29sYmFyUGx1Z2luXCJcbik7XG5jbGFzcyBBaSBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB1KHRoaXMsIFwidmlld1wiKTtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIHUodGhpcywgXCJjbG9zZU1lbnVcIiwgKCkgPT4gdGhpcy52aWV3LmNsb3NlTWVudSgpKTtcbiAgICB0aGlzLnBsdWdpbiA9IG5ldyBNKHtcbiAgICAgIGtleTogTGksXG4gICAgICB2aWV3OiAobikgPT4gKHRoaXMudmlldyA9IG5ldyBJaSh0LCBuLCAocikgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgcik7XG4gICAgICB9KSwgdGhpcy52aWV3KSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhhbmRsZUtleURvd246IChuLCByKSA9PiByLmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLnNob3duID8gKHRoaXMudmlldy5jbG9zZU1lbnUoKSwgITApIDogITFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgc2hvd24oKSB7XG4gICAgdmFyIHQsIG47XG4gICAgcmV0dXJuICgobiA9ICh0ID0gdGhpcy52aWV3KSA9PSBudWxsID8gdm9pZCAwIDogdC5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2hvdykgfHwgITE7XG4gIH1cbiAgb25VcGRhdGUodCkge1xuICAgIHJldHVybiB0aGlzLm9uKFwidXBkYXRlXCIsIHQpO1xuICB9XG59XG5jb25zdCBOaSA9IHNlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaGFyZEJyZWFrXCIsXG4gIGlubGluZTogITAsXG4gIGdyb3VwOiBcImlubGluZVwiLFxuICBzZWxlY3RhYmxlOiAhMSxcbiAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6ICEwLFxuICBwcmlvcml0eTogMTAsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImJyXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgcmV0dXJuIFtcImJyXCIsIGp0KHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgZSldO1xuICB9LFxuICByZW5kZXJUZXh0KCkge1xuICAgIHJldHVybiBgXG5gO1xuICB9XG59KSwgRHQgPSAoZSwgbykgPT4ge1xuICBjb25zdCB0ID0gZS5yZXNvbHZlKG8pO1xuICBpZiAodC5kZXB0aCA8PSAxKVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IHQucG9zQXRJbmRleChcbiAgICB0LmluZGV4KHQuZGVwdGggLSAxKSxcbiAgICB0LmRlcHRoIC0gMVxuICApO1xuICByZXR1cm4gQ2UoXG4gICAgZS5yZXNvbHZlKG4pXG4gICk7XG59LCBMZSA9IChlLCBvKSA9PiB7XG4gIGNvbnN0IHQgPSBlLnJlc29sdmUobyksIG4gPSB0LmluZGV4KCk7XG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgciA9IHQucG9zQXRJbmRleChuIC0gMSk7XG4gIHJldHVybiBDZShcbiAgICBlLnJlc29sdmUocilcbiAgKTtcbn0sIEhvID0gKGUsIG8pID0+IHtcbiAgZm9yICg7IG8uY2hpbGRDb250YWluZXI7ICkge1xuICAgIGNvbnN0IHQgPSBvLmNoaWxkQ29udGFpbmVyLm5vZGUsIG4gPSBlLnJlc29sdmUoby5jaGlsZENvbnRhaW5lci5iZWZvcmVQb3MgKyAxKS5wb3NBdEluZGV4KHQuY2hpbGRDb3VudCAtIDEpO1xuICAgIG8gPSBDZShlLnJlc29sdmUobikpO1xuICB9XG4gIHJldHVybiBvO1xufSwgSGkgPSAoZSwgbykgPT4gZS5pc0Jsb2NrQ29udGFpbmVyICYmIGUuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgPT09IFwiaW5saW5lKlwiICYmIGUuYmxvY2tDb250ZW50Lm5vZGUuY2hpbGRDb3VudCA+IDAgJiYgby5pc0Jsb2NrQ29udGFpbmVyICYmIG8uYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgPT09IFwiaW5saW5lKlwiLCBEaSA9IChlLCBvLCB0LCBuKSA9PiB7XG4gIGlmICghbi5pc0Jsb2NrQ29udGFpbmVyKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gbWVyZ2UgYmxvY2sgYXQgcG9zaXRpb24gJHtuLmJuQmxvY2suYmVmb3JlUG9zfSBpbnRvIHByZXZpb3VzIGJsb2NrIGF0IHBvc2l0aW9uICR7dC5ibkJsb2NrLmJlZm9yZVBvc30sIGJ1dCBuZXh0IGJsb2NrIGlzIG5vdCBhIGJsb2NrIGNvbnRhaW5lcmBcbiAgICApO1xuICBpZiAobi5jaGlsZENvbnRhaW5lcikge1xuICAgIGNvbnN0IHIgPSBlLmRvYy5yZXNvbHZlKFxuICAgICAgbi5jaGlsZENvbnRhaW5lci5iZWZvcmVQb3MgKyAxXG4gICAgKSwgcyA9IGUuZG9jLnJlc29sdmUoXG4gICAgICBuLmNoaWxkQ29udGFpbmVyLmFmdGVyUG9zIC0gMVxuICAgICksIGkgPSByLmJsb2NrUmFuZ2Uocyk7XG4gICAgaWYgKG8pIHtcbiAgICAgIGNvbnN0IGEgPSBlLmRvYy5yZXNvbHZlKG4uYm5CbG9jay5iZWZvcmVQb3MpO1xuICAgICAgZS50ci5saWZ0KGksIGEuZGVwdGgpO1xuICAgIH1cbiAgfVxuICBpZiAobykge1xuICAgIGlmICghdC5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIG1lcmdlIGJsb2NrIGF0IHBvc2l0aW9uICR7bi5ibkJsb2NrLmJlZm9yZVBvc30gaW50byBwcmV2aW91cyBibG9jayBhdCBwb3NpdGlvbiAke3QuYm5CbG9jay5iZWZvcmVQb3N9LCBidXQgcHJldmlvdXMgYmxvY2sgaXMgbm90IGEgYmxvY2sgY29udGFpbmVyYFxuICAgICAgKTtcbiAgICBvKFxuICAgICAgZS50ci5kZWxldGUoXG4gICAgICAgIHQuYmxvY2tDb250ZW50LmFmdGVyUG9zIC0gMSxcbiAgICAgICAgbi5ibG9ja0NvbnRlbnQuYmVmb3JlUG9zICsgMVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuICEwO1xufSwgT3QgPSAoZSkgPT4gKHtcbiAgc3RhdGU6IG8sXG4gIGRpc3BhdGNoOiB0XG59KSA9PiB7XG4gIGNvbnN0IG4gPSBvLmRvYy5yZXNvbHZlKGUpLCByID0gQ2UobiksIHMgPSBMZShcbiAgICBvLmRvYyxcbiAgICByLmJuQmxvY2suYmVmb3JlUG9zXG4gICk7XG4gIGlmICghcylcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGkgPSBIbyhcbiAgICBvLmRvYyxcbiAgICBzXG4gICk7XG4gIHJldHVybiBIaShpLCByKSA/IERpKG8sIHQsIGksIHIpIDogITE7XG59LCBPaSA9IEguY3JlYXRlKHtcbiAgcHJpb3JpdHk6IDUwLFxuICAvLyBUT0RPOiBUaGUgc2hvcnRjdXRzIG5lZWQgYSByZWZhY3Rvci4gRG8gd2Ugd2FudCB0byB1c2UgYSBjb21tYW5kIHByaW9yaXR5XG4gIC8vICBkZXNpZ24gYXMgdGhlcmUgaXMgbm93LCBvciBjbHVtcCB0aGUgbG9naWMgaW50byBhIHNpbmdsZSBmdW5jdGlvbj9cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3QgZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNoYWluOiBuLCBjb21tYW5kczogciB9KSA9PiBbXG4gICAgICAvLyBEZWxldGVzIHRoZSBzZWxlY3Rpb24gaWYgaXQncyBub3QgZW1wdHkuXG4gICAgICAoKSA9PiByLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgLy8gVW5kb2VzIGFuIGlucHV0IHJ1bGUgaWYgb25lIHdhcyB0cmlnZ2VyZWQgaW4gdGhlIGxhc3QgZWRpdG9yIHN0YXRlIGNoYW5nZS5cbiAgICAgICgpID0+IHIudW5kb0lucHV0UnVsZSgpLFxuICAgICAgLy8gUmV2ZXJ0cyBibG9jayBjb250ZW50IHR5cGUgdG8gYSBwYXJhZ3JhcGggaWYgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGJsb2NrLlxuICAgICAgKCkgPT4gci5jb21tYW5kKCh7IHN0YXRlOiBzIH0pID0+IHtcbiAgICAgICAgY29uc3QgaSA9IEMocyk7XG4gICAgICAgIGlmICghaS5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgYSA9IHMuc2VsZWN0aW9uLmZyb20gPT09IGkuYmxvY2tDb250ZW50LmJlZm9yZVBvcyArIDEsIGMgPSBpLmJsb2NrQ29udGVudC5ub2RlLnR5cGUubmFtZSA9PT0gXCJwYXJhZ3JhcGhcIjtcbiAgICAgICAgcmV0dXJuIGEgJiYgIWMgPyByLmNvbW1hbmQoXG4gICAgICAgICAgeChcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0b3IsXG4gICAgICAgICAgICBpLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICkgOiAhMTtcbiAgICAgIH0pLFxuICAgICAgLy8gUmVtb3ZlcyBhIGxldmVsIG9mIG5lc3RpbmcgaWYgdGhlIGJsb2NrIGlzIGluZGVudGVkIGlmIHRoZSBzZWxlY3Rpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBibG9jay5cbiAgICAgICgpID0+IHIuY29tbWFuZCgoeyBzdGF0ZTogcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBDKHMpO1xuICAgICAgICBpZiAoIWkuaXNCbG9ja0NvbnRhaW5lcilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tDb250ZW50OiBhIH0gPSBpO1xuICAgICAgICByZXR1cm4gcy5zZWxlY3Rpb24uZnJvbSA9PT0gYS5iZWZvcmVQb3MgKyAxID8gci5saWZ0TGlzdEl0ZW0oXCJibG9ja0NvbnRhaW5lclwiKSA6ICExO1xuICAgICAgfSksXG4gICAgICAvLyBNZXJnZXMgYmxvY2sgd2l0aCB0aGUgcHJldmlvdXMgb25lIGlmIGl0IGlzbid0IGluZGVudGVkLCBhbmQgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAvLyBibG9jay4gVGhlIHRhcmdldCBibG9jayBmb3IgbWVyZ2luZyBtdXN0IGNvbnRhaW4gaW5saW5lIGNvbnRlbnQuXG4gICAgICAoKSA9PiByLmNvbW1hbmQoKHsgc3RhdGU6IHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBpID0gQyhzKTtcbiAgICAgICAgaWYgKCFpLmlzQmxvY2tDb250YWluZXIpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCB7IGJuQmxvY2s6IGEsIGJsb2NrQ29udGVudDogYyB9ID0gaSwgbCA9IHMuc2VsZWN0aW9uLmZyb20gPT09IGMuYmVmb3JlUG9zICsgMSwgZCA9IHMuc2VsZWN0aW9uLmVtcHR5LCBwID0gYS5iZWZvcmVQb3M7XG4gICAgICAgIHJldHVybiBsICYmIGQgPyBuKCkuY29tbWFuZChPdChwKSkuc2Nyb2xsSW50b1ZpZXcoKS5ydW4oKSA6ICExO1xuICAgICAgfSksXG4gICAgICAoKSA9PiByLmNvbW1hbmQoKHsgc3RhdGU6IHMsIGRpc3BhdGNoOiBpIH0pID0+IHtcbiAgICAgICAgY29uc3QgYSA9IEMocyk7XG4gICAgICAgIGlmICghYS5pc0Jsb2NrQ29udGFpbmVyIHx8ICEocy5zZWxlY3Rpb24uZnJvbSA9PT0gYS5ibG9ja0NvbnRlbnQuYmVmb3JlUG9zICsgMSkgfHwgTGUoXG4gICAgICAgICAgcy5kb2MsXG4gICAgICAgICAgYS5ibkJsb2NrLmJlZm9yZVBvc1xuICAgICAgICApKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgZCA9IER0KFxuICAgICAgICAgIHMuZG9jLFxuICAgICAgICAgIGEuYm5CbG9jay5iZWZvcmVQb3NcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKChkID09IG51bGwgPyB2b2lkIDAgOiBkLmJsb2NrTm90ZVR5cGUpICE9PSBcImNvbHVtblwiKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgcCA9IGQsIGggPSBEdChcbiAgICAgICAgICBzLmRvYyxcbiAgICAgICAgICBwLmJuQmxvY2suYmVmb3JlUG9zXG4gICAgICAgICk7XG4gICAgICAgIGlmICgoaCA9PSBudWxsID8gdm9pZCAwIDogaC5ibG9ja05vdGVUeXBlKSAhPT0gXCJjb2x1bW5MaXN0XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFyZW50IG9mIGNvbHVtbiBpcyBub3QgYSBjb2x1bW4gbGlzdFwiKTtcbiAgICAgICAgY29uc3QgZiA9IHAuY2hpbGRDb250YWluZXIubm9kZS5jaGlsZENvdW50ID09PSAxLCBtID0gZiAmJiBoLmNoaWxkQ29udGFpbmVyLm5vZGUuY2hpbGRDb3VudCA9PT0gMiwgZyA9IGguY2hpbGRDb250YWluZXIubm9kZS5maXJzdENoaWxkID09PSBwLmJuQmxvY2subm9kZTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBjb25zdCBiID0gcy5kb2Muc2xpY2UoXG4gICAgICAgICAgICBhLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICAgICAgYS5ibkJsb2NrLmFmdGVyUG9zLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChtKVxuICAgICAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAgICAgcy50ci5zdGVwKFxuICAgICAgICAgICAgICAgIG5ldyBLZShcbiAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgZW50aXJlIGNvbHVtbiBsaXN0XG4gICAgICAgICAgICAgICAgICBoLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICAgICAgICAgICAgaC5ibkJsb2NrLmFmdGVyUG9zLFxuICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0IGNvbnRlbnQgb2YgcmVtYWluaW5nIGNvbHVtbjpcbiAgICAgICAgICAgICAgICAgIHAuYm5CbG9jay5hZnRlclBvcyArIDEsXG4gICAgICAgICAgICAgICAgICBoLmJuQmxvY2suYWZ0ZXJQb3MgLSAyLFxuICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgIGIuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBleGlzdGluZyBjb250ZW50IHRvIGJsb2NrVG9Nb3ZlXG4gICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29uc3QgayA9IHMudHIuZG9jLnJlc29sdmUocC5ibkJsb2NrLmJlZm9yZVBvcyk7XG4gICAgICAgICAgICAgIHMudHIuc2V0U2VsZWN0aW9uKFIuYmV0d2VlbihrLCBrKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzLnRyLnN0ZXAoXG4gICAgICAgICAgICAgICAgbmV3IEtlKFxuICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBlbnRpcmUgY29sdW1uIGxpc3RcbiAgICAgICAgICAgICAgICAgIGguYm5CbG9jay5iZWZvcmVQb3MsXG4gICAgICAgICAgICAgICAgICBoLmJuQmxvY2suYWZ0ZXJQb3MsXG4gICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgY29udGVudCBvZiBleGlzdGluZyBjb2x1bW46XG4gICAgICAgICAgICAgICAgICBoLmJuQmxvY2suYmVmb3JlUG9zICsgMixcbiAgICAgICAgICAgICAgICAgIHAuYm5CbG9jay5iZWZvcmVQb3MgLSAxLFxuICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIGV4aXN0aW5nIGNvbnRlbnQgdG8gYmxvY2tUb01vdmVcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCBrID0gcy50ci5kb2MucmVzb2x2ZShcbiAgICAgICAgICAgICAgICBzLnRyLm1hcHBpbmcubWFwKHAuYm5CbG9jay5iZWZvcmVQb3MgLSAxKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzLnRyLnNldFNlbGVjdGlvbihSLmJldHdlZW4oaywgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGYpXG4gICAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgICBzLnRyLmRlbGV0ZShcbiAgICAgICAgICAgICAgICBwLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICAgICAgICAgIHAuYm5CbG9jay5hZnRlclBvc1xuICAgICAgICAgICAgICApLCBzLnRyLmluc2VydChcbiAgICAgICAgICAgICAgICBoLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICAgICAgICAgIGIuY29udGVudFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb25zdCBrID0gcy50ci5kb2MucmVzb2x2ZShcbiAgICAgICAgICAgICAgICBoLmJuQmxvY2suYmVmb3JlUG9zXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHMudHIuc2V0U2VsZWN0aW9uKFIuYmV0d2VlbihrLCBrKSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgcy50ci5kZWxldGUoXG4gICAgICAgICAgICAgICAgcC5ibkJsb2NrLmJlZm9yZVBvcyAtIDEsXG4gICAgICAgICAgICAgICAgcC5ibkJsb2NrLmJlZm9yZVBvcyArIDFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMudHIuZGVsZXRlKFxuICAgICAgICAgICAgICBhLmJuQmxvY2suYmVmb3JlUG9zLFxuICAgICAgICAgICAgICBhLmJuQmxvY2suYWZ0ZXJQb3NcbiAgICAgICAgICAgICksIGcgPyBzLnRyLmluc2VydChcbiAgICAgICAgICAgICAgaC5ibkJsb2NrLmJlZm9yZVBvcyAtIDEsXG4gICAgICAgICAgICAgIGIuY29udGVudFxuICAgICAgICAgICAgKSA6IHMudHIuaW5zZXJ0KFxuICAgICAgICAgICAgICBwLmJuQmxvY2suYmVmb3JlUG9zIC0gMSxcbiAgICAgICAgICAgICAgYi5jb250ZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgayA9IHMudHIuZG9jLnJlc29sdmUocC5ibkJsb2NrLmJlZm9yZVBvcyAtIDEpO1xuICAgICAgICAgICAgcy50ci5zZXRTZWxlY3Rpb24oUi5iZXR3ZWVuKGssIGspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSksXG4gICAgICAvLyBEZWxldGVzIHRoZSBjdXJyZW50IGJsb2NrIGlmIGl0J3MgYW4gZW1wdHkgYmxvY2sgd2l0aCBpbmxpbmUgY29udGVudCxcbiAgICAgIC8vIGFuZCBtb3ZlcyB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBibG9jay5cbiAgICAgICgpID0+IHIuY29tbWFuZCgoeyBzdGF0ZTogcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBDKHMpO1xuICAgICAgICBpZiAoIWkuaXNCbG9ja0NvbnRhaW5lcilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGlmIChpLmJsb2NrQ29udGVudC5ub2RlLmNoaWxkQ291bnQgPT09IDAgJiYgaS5ibG9ja0NvbnRlbnQubm9kZS50eXBlLnNwZWMuY29udGVudCA9PT0gXCJpbmxpbmUqXCIpIHtcbiAgICAgICAgICBjb25zdCBjID0gTGUoXG4gICAgICAgICAgICBzLmRvYyxcbiAgICAgICAgICAgIGkuYm5CbG9jay5iZWZvcmVQb3NcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghYyB8fCAhYy5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGxldCBsID0gbigpO1xuICAgICAgICAgIGlmIChjLmJsb2NrQ29udGVudC5ub2RlLnR5cGUuc3BlYy5jb250ZW50ID09PSBcInRhYmxlUm93K1wiKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gaS5ibkJsb2NrLmJlZm9yZVBvcyAtIDEgLSAxIC0gMSAtIDEgLSAxO1xuICAgICAgICAgICAgbCA9IGwuc2V0VGV4dFNlbGVjdGlvbihcbiAgICAgICAgICAgICAgbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBjLmJsb2NrQ29udGVudC5hZnRlclBvcyAtIGMuYmxvY2tDb250ZW50Lm5vZGUubm9kZVNpemU7XG4gICAgICAgICAgICBsID0gbC5zZXROb2RlU2VsZWN0aW9uKFxuICAgICAgICAgICAgICBkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkID0gYy5ibG9ja0NvbnRlbnQuYWZ0ZXJQb3MgLSBjLmJsb2NrQ29udGVudC5ub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgbCA9IGwuc2V0VGV4dFNlbGVjdGlvbihkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGwuZGVsZXRlUmFuZ2Uoe1xuICAgICAgICAgICAgZnJvbTogaS5ibkJsb2NrLmJlZm9yZVBvcyxcbiAgICAgICAgICAgIHRvOiBpLmJuQmxvY2suYWZ0ZXJQb3NcbiAgICAgICAgICB9KS5zY3JvbGxJbnRvVmlldygpLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0pLFxuICAgICAgLy8gRGVsZXRlcyBwcmV2aW91cyBibG9jayBpZiBpdCBjb250YWlucyBubyBjb250ZW50IGFuZCBpc24ndCBhIHRhYmxlLFxuICAgICAgLy8gd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgdGhlIGJsb2NrLiBNb3ZlcyB0aGVcbiAgICAgIC8vIGN1cnJlbnQgYmxvY2sgaW50byB0aGUgZGVsZXRlZCBibG9jaydzIHBsYWNlLlxuICAgICAgKCkgPT4gci5jb21tYW5kKCh7IHN0YXRlOiBzIH0pID0+IHtcbiAgICAgICAgY29uc3QgaSA9IEMocyk7XG4gICAgICAgIGlmICghaS5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvZG9cIik7XG4gICAgICAgIGNvbnN0IGEgPSBzLnNlbGVjdGlvbi5mcm9tID09PSBpLmJsb2NrQ29udGVudC5iZWZvcmVQb3MgKyAxLCBjID0gcy5zZWxlY3Rpb24uZW1wdHksIGwgPSBMZShcbiAgICAgICAgICBzLmRvYyxcbiAgICAgICAgICBpLmJuQmxvY2suYmVmb3JlUG9zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsICYmIGEgJiYgYykge1xuICAgICAgICAgIGNvbnN0IGQgPSBIbyhcbiAgICAgICAgICAgIHMuZG9jLFxuICAgICAgICAgICAgbFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFkLmlzQmxvY2tDb250YWluZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b2RvXCIpO1xuICAgICAgICAgIGlmIChkLmJsb2NrQ29udGVudC5ub2RlLnR5cGUuc3BlYy5jb250ZW50ID09PSBcIlwiIHx8IGQuYmxvY2tDb250ZW50Lm5vZGUudHlwZS5zcGVjLmNvbnRlbnQgPT09IFwiaW5saW5lKlwiICYmIGQuYmxvY2tDb250ZW50Lm5vZGUuY2hpbGRDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBuKCkuY3V0KFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogaS5ibkJsb2NrLmJlZm9yZVBvcyxcbiAgICAgICAgICAgICAgICB0bzogaS5ibkJsb2NrLmFmdGVyUG9zXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGQuYm5CbG9jay5hZnRlclBvc1xuICAgICAgICAgICAgKS5kZWxldGVSYW5nZSh7XG4gICAgICAgICAgICAgIGZyb206IGQuYm5CbG9jay5iZWZvcmVQb3MsXG4gICAgICAgICAgICAgIHRvOiBkLmJuQmxvY2suYWZ0ZXJQb3NcbiAgICAgICAgICAgIH0pLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0pXG4gICAgXSksIG8gPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kczogbiB9KSA9PiBbXG4gICAgICAvLyBEZWxldGVzIHRoZSBzZWxlY3Rpb24gaWYgaXQncyBub3QgZW1wdHkuXG4gICAgICAoKSA9PiBuLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgLy8gTWVyZ2VzIGJsb2NrIHdpdGggdGhlIG5leHQgb25lIChhdCB0aGUgc2FtZSBuZXN0aW5nIGxldmVsIG9yIGxvd2VyKSxcbiAgICAgIC8vIGlmIG9uZSBleGlzdHMsIHRoZSBibG9jayBoYXMgbm8gY2hpbGRyZW4sIGFuZCB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZVxuICAgICAgLy8gZW5kIG9mIHRoZSBibG9jay5cbiAgICAgICgpID0+IG4uY29tbWFuZCgoeyBzdGF0ZTogciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBDKHIpO1xuICAgICAgICBpZiAoIXMuaXNCbG9ja0NvbnRhaW5lcilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBibkJsb2NrOiBpLFxuICAgICAgICAgIGJsb2NrQ29udGVudDogYSxcbiAgICAgICAgICBjaGlsZENvbnRhaW5lcjogY1xuICAgICAgICB9ID0gcywgeyBkZXB0aDogbCB9ID0gci5kb2MucmVzb2x2ZShpLmJlZm9yZVBvcyksIGQgPSBpLmFmdGVyUG9zID09PSByLmRvYy5ub2RlU2l6ZSAtIDMsIHAgPSByLnNlbGVjdGlvbi5mcm9tID09PSBhLmFmdGVyUG9zIC0gMSwgaCA9IHIuc2VsZWN0aW9uLmVtcHR5O1xuICAgICAgICBpZiAoIWQgJiYgcCAmJiBoICYmICEoYyAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgIGxldCBtID0gbCwgZyA9IGkuYWZ0ZXJQb3MgKyAxLCBiID0gci5kb2MucmVzb2x2ZShnKS5kZXB0aDtcbiAgICAgICAgICBmb3IgKDsgYiA8IG07IClcbiAgICAgICAgICAgIG0gPSBiLCBnICs9IDIsIGIgPSByLmRvYy5yZXNvbHZlKGcpLmRlcHRoO1xuICAgICAgICAgIHJldHVybiBuLmNvbW1hbmQoT3QoZyAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9KVxuICAgIF0pLCB0ID0gKG4gPSAhMSkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHM6IHIgfSkgPT4gW1xuICAgICAgLy8gUmVtb3ZlcyBhIGxldmVsIG9mIG5lc3RpbmcgaWYgdGhlIGJsb2NrIGlzIGVtcHR5ICYgaW5kZW50ZWQsIHdoaWxlIHRoZSBzZWxlY3Rpb24gaXMgYWxzbyBlbXB0eSAmIGF0IHRoZSBzdGFydFxuICAgICAgLy8gb2YgdGhlIGJsb2NrLlxuICAgICAgKCkgPT4gci5jb21tYW5kKCh7IHN0YXRlOiBzIH0pID0+IHtcbiAgICAgICAgY29uc3QgaSA9IEMocyk7XG4gICAgICAgIGlmICghaS5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgeyBibkJsb2NrOiBhLCBibG9ja0NvbnRlbnQ6IGMgfSA9IGksIHsgZGVwdGg6IGwgfSA9IHMuZG9jLnJlc29sdmUoYS5iZWZvcmVQb3MpLCBkID0gcy5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnRPZmZzZXQgPT09IDAsIHAgPSBzLnNlbGVjdGlvbi5hbmNob3IgPT09IHMuc2VsZWN0aW9uLmhlYWQsIGggPSBjLm5vZGUuY2hpbGRDb3VudCA9PT0gMCwgZiA9IGwgPiAxO1xuICAgICAgICByZXR1cm4gZCAmJiBwICYmIGggJiYgZiA/IHIubGlmdExpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIikgOiAhMTtcbiAgICAgIH0pLFxuICAgICAgLy8gQ3JlYXRlcyBhIGhhcmQgYnJlYWsgaWYgYmxvY2sgaXMgY29uZmlndXJlZCB0byBkbyBzby5cbiAgICAgICgpID0+IHIuY29tbWFuZCgoeyBzdGF0ZTogcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBDKHMpLCBhID0gdGhpcy5vcHRpb25zLmVkaXRvci5zY2hlbWEuYmxvY2tTY2hlbWFbaS5ibG9ja05vdGVUeXBlXS5oYXJkQnJlYWtTaG9ydGN1dCA/PyBcInNoaWZ0K2VudGVyXCI7XG4gICAgICAgIHJldHVybiBhID09PSBcIm5vbmVcIiA/ICExIDogKFxuICAgICAgICAgIC8vIElmIHNob3J0Y3V0IGlzIG5vdCBjb25maWd1cmVkLCBvciBpcyBjb25maWd1cmVkIGFzIFwic2hpZnQrZW50ZXJcIixcbiAgICAgICAgICAvLyBjcmVhdGUgYSBoYXJkIGJyZWFrIGZvciBzaGlmdCtlbnRlciwgYnV0IG5vdCBmb3IgZW50ZXIuXG4gICAgICAgICAgYSA9PT0gXCJzaGlmdCtlbnRlclwiICYmIG4gfHwgLy8gSWYgc2hvcnRjdXQgaXMgY29uZmlndXJlZCBhcyBcImVudGVyXCIsIGNyZWF0ZSBhIGhhcmQgYnJlYWsgZm9yXG4gICAgICAgICAgLy8gYm90aCBlbnRlciBhbmQgc2hpZnQrZW50ZXIuXG4gICAgICAgICAgYSA9PT0gXCJlbnRlclwiID8gci5pbnNlcnRDb250ZW50KHtcbiAgICAgICAgICAgIHR5cGU6IFwiaGFyZEJyZWFrXCJcbiAgICAgICAgICB9KSA6ICExXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgIC8vIENyZWF0ZXMgYSBuZXcgYmxvY2sgYW5kIG1vdmVzIHRoZSBzZWxlY3Rpb24gdG8gaXQgaWYgdGhlIGN1cnJlbnQgb25lIGlzIGVtcHR5LCB3aGlsZSB0aGUgc2VsZWN0aW9uIGlzIGFsc29cbiAgICAgIC8vIGVtcHR5ICYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBibG9jay5cbiAgICAgICgpID0+IHIuY29tbWFuZCgoeyBzdGF0ZTogcywgZGlzcGF0Y2g6IGkgfSkgPT4ge1xuICAgICAgICBjb25zdCBhID0gQyhzKTtcbiAgICAgICAgaWYgKCFhLmlzQmxvY2tDb250YWluZXIpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCB7IGJuQmxvY2s6IGMsIGJsb2NrQ29udGVudDogbCB9ID0gYSwgZCA9IHMuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0ID09PSAwLCBwID0gcy5zZWxlY3Rpb24uYW5jaG9yID09PSBzLnNlbGVjdGlvbi5oZWFkLCBoID0gbC5ub2RlLmNoaWxkQ291bnQgPT09IDA7XG4gICAgICAgIGlmIChkICYmIHAgJiYgaCkge1xuICAgICAgICAgIGNvbnN0IGYgPSBjLmFmdGVyUG9zLCBtID0gZiArIDI7XG4gICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBzLnNjaGVtYS5ub2Rlcy5ibG9ja0NvbnRhaW5lci5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgICAgICBzLnRyLmluc2VydChmLCBnKS5zY3JvbGxJbnRvVmlldygpLCBzLnRyLnNldFNlbGVjdGlvbihcbiAgICAgICAgICAgICAgbmV3IFIocy5kb2MucmVzb2x2ZShtKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9KSxcbiAgICAgIC8vIFNwbGl0cyB0aGUgY3VycmVudCBibG9jaywgbW92aW5nIGNvbnRlbnQgaW5zaWRlIHRoYXQncyBhZnRlciB0aGUgY3Vyc29yIHRvIGEgbmV3IHRleHQgYmxvY2sgYmVsb3cuIEFsc29cbiAgICAgIC8vIGRlbGV0ZXMgdGhlIHNlbGVjdGlvbiBiZWZvcmVoYW5kLCBpZiBpdCdzIG5vdCBlbXB0eS5cbiAgICAgICgpID0+IHIuY29tbWFuZCgoeyBzdGF0ZTogcywgY2hhaW46IGkgfSkgPT4ge1xuICAgICAgICBjb25zdCBhID0gQyhzKTtcbiAgICAgICAgaWYgKCFhLmlzQmxvY2tDb250YWluZXIpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCB7IGJsb2NrQ29udGVudDogYyB9ID0gYSwgbCA9IHMuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0ID09PSAwO1xuICAgICAgICByZXR1cm4gYy5ub2RlLmNoaWxkQ291bnQgPT09IDAgPyAhMSA6IChpKCkuZGVsZXRlU2VsZWN0aW9uKCkuY29tbWFuZChcbiAgICAgICAgICB1byhcbiAgICAgICAgICAgIHMuc2VsZWN0aW9uLmZyb20sXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgbFxuICAgICAgICAgIClcbiAgICAgICAgKS5ydW4oKSwgITApO1xuICAgICAgfSlcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgQmFja3NwYWNlOiBlLFxuICAgICAgRGVsZXRlOiBvLFxuICAgICAgRW50ZXI6ICgpID0+IHQoKSxcbiAgICAgIFwiU2hpZnQtRW50ZXJcIjogKCkgPT4gdCghMCksXG4gICAgICAvLyBBbHdheXMgcmV0dXJuaW5nIHRydWUgZm9yIHRhYiBrZXkgcHJlc3NlcyBlbnN1cmVzIHRoZXkncmUgbm90IGNhcHR1cmVkIGJ5IHRoZSBicm93c2VyLiBPdGhlcndpc2UsIHRoZXkgYmx1ciB0aGVcbiAgICAgIC8vIGVkaXRvciBzaW5jZSB0aGUgYnJvd3NlciB3aWxsIHRyeSB0byB1c2UgdGFiIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICAgICAgVGFiOiAoKSA9PiB7XG4gICAgICAgIHZhciBuLCByLCBzO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhYkJlaGF2aW9yICE9PSBcInByZWZlci1pbmRlbnRcIiAmJiAoKG4gPSB0aGlzLm9wdGlvbnMuZWRpdG9yLmZvcm1hdHRpbmdUb29sYmFyKSAhPSBudWxsICYmIG4uc2hvd24gfHwgKHIgPSB0aGlzLm9wdGlvbnMuZWRpdG9yLmxpbmtUb29sYmFyKSAhPSBudWxsICYmIHIuc2hvd24gfHwgKHMgPSB0aGlzLm9wdGlvbnMuZWRpdG9yLmZpbGVQYW5lbCkgIT0gbnVsbCAmJiBzLnNob3duKSA/ICExIDogU28odGhpcy5vcHRpb25zLmVkaXRvcik7XG4gICAgICB9LFxuICAgICAgXCJTaGlmdC1UYWJcIjogKCkgPT4ge1xuICAgICAgICB2YXIgbiwgciwgcztcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YWJCZWhhdmlvciAhPT0gXCJwcmVmZXItaW5kZW50XCIgJiYgKChuID0gdGhpcy5vcHRpb25zLmVkaXRvci5mb3JtYXR0aW5nVG9vbGJhcikgIT0gbnVsbCAmJiBuLnNob3duIHx8IChyID0gdGhpcy5vcHRpb25zLmVkaXRvci5saW5rVG9vbGJhcikgIT0gbnVsbCAmJiByLnNob3duIHx8IChzID0gdGhpcy5vcHRpb25zLmVkaXRvci5maWxlUGFuZWwpICE9IG51bGwgJiYgcy5zaG93bikgPyAhMSA6ICh0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0oXCJibG9ja0NvbnRhaW5lclwiKSwgITApO1xuICAgICAgfSxcbiAgICAgIFwiU2hpZnQtTW9kLUFycm93VXBcIjogKCkgPT4gKHRoaXMub3B0aW9ucy5lZGl0b3IubW92ZUJsb2Nrc1VwKCksICEwKSxcbiAgICAgIFwiU2hpZnQtTW9kLUFycm93RG93blwiOiAoKSA9PiAodGhpcy5vcHRpb25zLmVkaXRvci5tb3ZlQmxvY2tzRG93bigpLCAhMClcbiAgICB9O1xuICB9XG59KTtcbmNsYXNzIF9pIHtcbiAgY29uc3RydWN0b3IobywgdCwgbikge1xuICAgIHUodGhpcywgXCJzdGF0ZVwiKTtcbiAgICB1KHRoaXMsIFwiZW1pdFVwZGF0ZVwiKTtcbiAgICB1KHRoaXMsIFwibWVudVVwZGF0ZVRpbWVyXCIpO1xuICAgIHUodGhpcywgXCJzdGFydE1lbnVVcGRhdGVUaW1lclwiKTtcbiAgICB1KHRoaXMsIFwic3RvcE1lbnVVcGRhdGVUaW1lclwiKTtcbiAgICB1KHRoaXMsIFwibW91c2VIb3ZlcmVkTGlua01hcmtcIik7XG4gICAgdSh0aGlzLCBcIm1vdXNlSG92ZXJlZExpbmtNYXJrUmFuZ2VcIik7XG4gICAgdSh0aGlzLCBcImtleWJvYXJkSG92ZXJlZExpbmtNYXJrXCIpO1xuICAgIHUodGhpcywgXCJrZXlib2FyZEhvdmVyZWRMaW5rTWFya1JhbmdlXCIpO1xuICAgIHUodGhpcywgXCJsaW5rTWFya1wiKTtcbiAgICB1KHRoaXMsIFwibGlua01hcmtSYW5nZVwiKTtcbiAgICB1KHRoaXMsIFwibW91c2VPdmVySGFuZGxlclwiLCAobykgPT4ge1xuICAgICAgaWYgKHRoaXMubW91c2VIb3ZlcmVkTGlua01hcmsgPSB2b2lkIDAsIHRoaXMubW91c2VIb3ZlcmVkTGlua01hcmtSYW5nZSA9IHZvaWQgMCwgdGhpcy5zdG9wTWVudVVwZGF0ZVRpbWVyKCksIG8udGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiYgby50YXJnZXQubm9kZU5hbWUgPT09IFwiQVwiKSB7XG4gICAgICAgIGNvbnN0IHQgPSBvLnRhcmdldCwgbiA9IHRoaXMucG1WaWV3LnBvc0F0RE9NKHQsIDApICsgMSwgciA9IHRoaXMucG1WaWV3LnN0YXRlLmRvYy5yZXNvbHZlKG4pLCBzID0gci5tYXJrcygpO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgcylcbiAgICAgICAgICBpZiAoaS50eXBlLm5hbWUgPT09IHRoaXMucG1WaWV3LnN0YXRlLnNjaGVtYS5tYXJrKFwibGlua1wiKS50eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VIb3ZlcmVkTGlua01hcmsgPSBpLCB0aGlzLm1vdXNlSG92ZXJlZExpbmtNYXJrUmFuZ2UgPSBtdChyLCBpLnR5cGUsIGkuYXR0cnMpIHx8IHZvaWQgMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0TWVudVVwZGF0ZVRpbWVyKCksICExO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJjbGlja0hhbmRsZXJcIiwgKG8pID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgY29uc3QgdCA9IHRoaXMucG1WaWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgLy8gVG9vbGJhciBpcyBvcGVuLlxuICAgICAgdGhpcy5saW5rTWFyayAmJiAvLyBBbiBlbGVtZW50IGlzIGNsaWNrZWQuXG4gICAgICBvICYmIG8udGFyZ2V0ICYmIC8vIFRoZSBjbGlja2VkIGVsZW1lbnQgaXMgbm90IHRoZSBlZGl0b3IuXG4gICAgICAhKHQgPT09IG8udGFyZ2V0IHx8IHQuY29udGFpbnMoby50YXJnZXQpKSAmJiAobiA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgbi5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCkpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJzY3JvbGxIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgdGhpcy5saW5rTWFyayAhPT0gdm9pZCAwICYmIChvID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBvLnNob3cgJiYgKHRoaXMuc3RhdGUucmVmZXJlbmNlUG9zID0gQWUoXG4gICAgICAgIHRoaXMucG1WaWV3LFxuICAgICAgICB0aGlzLmxpbmtNYXJrUmFuZ2UuZnJvbSxcbiAgICAgICAgdGhpcy5saW5rTWFya1JhbmdlLnRvXG4gICAgICApLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcImNsb3NlTWVudVwiLCAoKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIChvID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBvLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSBvLCB0aGlzLnBtVmlldyA9IHQsIHRoaXMuZW1pdFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGluZyB0byB1cGRhdGUgdW5pbml0aWFsaXplZCBsaW5rIHRvb2xiYXJcIik7XG4gICAgICBuKHRoaXMuc3RhdGUpO1xuICAgIH0sIHRoaXMuc3RhcnRNZW51VXBkYXRlVGltZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLm1lbnVVcGRhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBtVmlldywgdm9pZCAwLCAhMCk7XG4gICAgICB9LCAyNTApO1xuICAgIH0sIHRoaXMuc3RvcE1lbnVVcGRhdGVUaW1lciA9ICgpID0+ICh0aGlzLm1lbnVVcGRhdGVUaW1lciAmJiAoY2xlYXJUaW1lb3V0KHRoaXMubWVudVVwZGF0ZVRpbWVyKSwgdGhpcy5tZW51VXBkYXRlVGltZXIgPSB2b2lkIDApLCAhMSksIHRoaXMucG1WaWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMubW91c2VPdmVySGFuZGxlciksIHRoaXMucG1WaWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIHRoaXMuY2xpY2tIYW5kbGVyLFxuICAgICAgITBcbiAgICApLCB0aGlzLnBtVmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyLCAhMCk7XG4gIH1cbiAgZWRpdExpbmsobywgdCkge1xuICAgIHZhciByO1xuICAgIGNvbnN0IG4gPSB0aGlzLnBtVmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KFxuICAgICAgdCxcbiAgICAgIHRoaXMubGlua01hcmtSYW5nZS5mcm9tLFxuICAgICAgdGhpcy5saW5rTWFya1JhbmdlLnRvXG4gICAgKTtcbiAgICBuLmFkZE1hcmsoXG4gICAgICB0aGlzLmxpbmtNYXJrUmFuZ2UuZnJvbSxcbiAgICAgIHRoaXMubGlua01hcmtSYW5nZS5mcm9tICsgdC5sZW5ndGgsXG4gICAgICB0aGlzLnBtVmlldy5zdGF0ZS5zY2hlbWEubWFyayhcImxpbmtcIiwgeyBocmVmOiBvIH0pXG4gICAgKSwgdGhpcy5lZGl0b3IuZGlzcGF0Y2gobiksIHRoaXMucG1WaWV3LmZvY3VzKCksIChyID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiByLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gIH1cbiAgZGVsZXRlTGluaygpIHtcbiAgICB2YXIgbztcbiAgICB0aGlzLmVkaXRvci5kaXNwYXRjaChcbiAgICAgIHRoaXMucG1WaWV3LnN0YXRlLnRyLnJlbW92ZU1hcmsoXG4gICAgICAgIHRoaXMubGlua01hcmtSYW5nZS5mcm9tLFxuICAgICAgICB0aGlzLmxpbmtNYXJrUmFuZ2UudG8sXG4gICAgICAgIHRoaXMubGlua01hcmsudHlwZVxuICAgICAgKS5zZXRNZXRhKFwicHJldmVudEF1dG9saW5rXCIsICEwKVxuICAgICksIHRoaXMucG1WaWV3LmZvY3VzKCksIChvID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBvLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gIH1cbiAgdXBkYXRlKG8sIHQsIG4gPSAhMSkge1xuICAgIHZhciBhO1xuICAgIGNvbnN0IHsgc3RhdGU6IHIgfSA9IG87XG4gICAgaWYgKHQgJiYgdC5zZWxlY3Rpb24uZnJvbSA9PT0gci5zZWxlY3Rpb24uZnJvbSAmJiB0LnNlbGVjdGlvbi50byA9PT0gci5zZWxlY3Rpb24udG8gfHwgIXRoaXMucG1WaWV3Lmhhc0ZvY3VzKCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMubGlua01hcms7XG4gICAgaWYgKHRoaXMubGlua01hcmsgPSB2b2lkIDAsIHRoaXMubGlua01hcmtSYW5nZSA9IHZvaWQgMCwgdGhpcy5rZXlib2FyZEhvdmVyZWRMaW5rTWFyayA9IHZvaWQgMCwgdGhpcy5rZXlib2FyZEhvdmVyZWRMaW5rTWFya1JhbmdlID0gdm9pZCAwLCB0aGlzLnBtVmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLnBtVmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICAgIGZvciAoY29uc3QgbCBvZiBjKVxuICAgICAgICBpZiAobC50eXBlLm5hbWUgPT09IHRoaXMucG1WaWV3LnN0YXRlLnNjaGVtYS5tYXJrKFwibGlua1wiKS50eXBlLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLmtleWJvYXJkSG92ZXJlZExpbmtNYXJrID0gbCwgdGhpcy5rZXlib2FyZEhvdmVyZWRMaW5rTWFya1JhbmdlID0gbXQoXG4gICAgICAgICAgICB0aGlzLnBtVmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20sXG4gICAgICAgICAgICBsLnR5cGUsXG4gICAgICAgICAgICBsLmF0dHJzXG4gICAgICAgICAgKSB8fCB2b2lkIDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubW91c2VIb3ZlcmVkTGlua01hcmsgJiYgbiAmJiAodGhpcy5saW5rTWFyayA9IHRoaXMubW91c2VIb3ZlcmVkTGlua01hcmssIHRoaXMubGlua01hcmtSYW5nZSA9IHRoaXMubW91c2VIb3ZlcmVkTGlua01hcmtSYW5nZSksIHRoaXMua2V5Ym9hcmRIb3ZlcmVkTGlua01hcmsgJiYgKHRoaXMubGlua01hcmsgPSB0aGlzLmtleWJvYXJkSG92ZXJlZExpbmtNYXJrLCB0aGlzLmxpbmtNYXJrUmFuZ2UgPSB0aGlzLmtleWJvYXJkSG92ZXJlZExpbmtNYXJrUmFuZ2UpLCB0aGlzLmxpbmtNYXJrICYmIHRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIHNob3c6ICEwLFxuICAgICAgICByZWZlcmVuY2VQb3M6IEFlKFxuICAgICAgICAgIHRoaXMucG1WaWV3LFxuICAgICAgICAgIHRoaXMubGlua01hcmtSYW5nZS5mcm9tLFxuICAgICAgICAgIHRoaXMubGlua01hcmtSYW5nZS50b1xuICAgICAgICApLFxuICAgICAgICB1cmw6IHRoaXMubGlua01hcmsuYXR0cnMuaHJlZixcbiAgICAgICAgdGV4dDogdGhpcy5wbVZpZXcuc3RhdGUuZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICAgIHRoaXMubGlua01hcmtSYW5nZS5mcm9tLFxuICAgICAgICAgIHRoaXMubGlua01hcmtSYW5nZS50b1xuICAgICAgICApXG4gICAgICB9LCB0aGlzLmVtaXRVcGRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChhID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBhLnNob3cgJiYgaSAmJiAoIXRoaXMubGlua01hcmsgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpKSB7XG4gICAgICB0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciwgITApLCB0aGlzLnBtVmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcImNsaWNrXCIsXG4gICAgICB0aGlzLmNsaWNrSGFuZGxlcixcbiAgICAgICEwXG4gICAgKTtcbiAgfVxufVxuY29uc3QgUmkgPSBuZXcgTihcIkxpbmtUb29sYmFyUGx1Z2luXCIpO1xuY2xhc3MgVmkgZXh0ZW5kcyBxIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKCk7XG4gICAgdSh0aGlzLCBcInZpZXdcIik7XG4gICAgdSh0aGlzLCBcInBsdWdpblwiKTtcbiAgICAvKipcbiAgICAgKiBFZGl0IHRoZSBjdXJyZW50bHkgaG92ZXJlZCBsaW5rLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJlZGl0TGlua1wiLCAodCwgbikgPT4ge1xuICAgICAgdGhpcy52aWV3LmVkaXRMaW5rKHQsIG4pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgY3VycmVudGx5IGhvdmVyZWQgbGluay5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiZGVsZXRlTGlua1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnZpZXcuZGVsZXRlTGluaygpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFdoZW4gaG92ZXJpbmcgb24vb2ZmIGxpbmtzIHVzaW5nIHRoZSBtb3VzZSBjdXJzb3IsIHRoZSBsaW5rIHRvb2xiYXIgd2lsbFxuICAgICAqIG9wZW4gJiBjbG9zZSB3aXRoIGEgZGVsYXkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN0YXJ0cyB0aGUgZGVsYXkgdGltZXIsIGFuZCBzaG91bGQgYmUgdXNlZCBmb3Igd2hlbiB0aGUgbW91c2VcbiAgICAgKiBjdXJzb3IgZW50ZXJzIHRoZSBsaW5rIHRvb2xiYXIuXG4gICAgICovXG4gICAgdSh0aGlzLCBcInN0YXJ0SGlkZVRpbWVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlldy5zdGFydE1lbnVVcGRhdGVUaW1lcigpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFdoZW4gaG92ZXJpbmcgb24vb2ZmIGxpbmtzIHVzaW5nIHRoZSBtb3VzZSBjdXJzb3IsIHRoZSBsaW5rIHRvb2xiYXIgd2lsbFxuICAgICAqIG9wZW4gJiBjbG9zZSB3aXRoIGEgZGVsYXkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN0b3BzIHRoZSBkZWxheSB0aW1lciwgYW5kIHNob3VsZCBiZSB1c2VkIGZvciB3aGVuIHRoZSBtb3VzZVxuICAgICAqIGN1cnNvciBleGl0cyB0aGUgbGluayB0b29sYmFyLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJzdG9wSGlkZVRpbWVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlldy5zdG9wTWVudVVwZGF0ZVRpbWVyKCk7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcImNsb3NlTWVudVwiLCAoKSA9PiB0aGlzLnZpZXcuY2xvc2VNZW51KCkpO1xuICAgIHRoaXMucGx1Z2luID0gbmV3IE0oe1xuICAgICAga2V5OiBSaSxcbiAgICAgIHZpZXc6IChuKSA9PiAodGhpcy52aWV3ID0gbmV3IF9pKHQsIG4sIChyKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCByKTtcbiAgICAgIH0pLCB0aGlzLnZpZXcpLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaGFuZGxlS2V5RG93bjogKG4sIHIpID0+IHIua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuc2hvd24gPyAodGhpcy52aWV3LmNsb3NlTWVudSgpLCAhMCkgOiAhMVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uVXBkYXRlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5vbihcInVwZGF0ZVwiLCB0KTtcbiAgfVxuICBnZXQgc2hvd24oKSB7XG4gICAgdmFyIHQsIG47XG4gICAgcmV0dXJuICgobiA9ICh0ID0gdGhpcy52aWV3KSA9PSBudWxsID8gdm9pZCAwIDogdC5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2hvdykgfHwgITE7XG4gIH1cbn1cbmNvbnN0IFVpID0gW1xuICBcImh0dHBcIixcbiAgXCJodHRwc1wiLFxuICBcImZ0cFwiLFxuICBcImZ0cHNcIixcbiAgXCJtYWlsdG9cIixcbiAgXCJ0ZWxcIixcbiAgXCJjYWxsdG9cIixcbiAgXCJzbXNcIixcbiAgXCJjaWRcIixcbiAgXCJ4bXBwXCJcbl0sICRpID0gXCJodHRwc1wiLCBGaSA9IG5ldyBOKFwibm9kZS1zZWxlY3Rpb24ta2V5Ym9hcmRcIik7XG5jbGFzcyB6aSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHUodGhpcywgXCJwbHVnaW5cIik7XG4gICAgdGhpcy5wbHVnaW4gPSBuZXcgTSh7XG4gICAgICBrZXk6IEZpLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaGFuZGxlS2V5RG93bjogKG8sIHQpID0+IHtcbiAgICAgICAgICBpZiAoXCJub2RlXCIgaW4gby5zdGF0ZS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0LmN0cmxLZXkgfHwgdC5tZXRhS2V5KVxuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICBpZiAodC5rZXkubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLCAhMDtcbiAgICAgICAgICAgIGlmICh0LmtleSA9PT0gXCJFbnRlclwiICYmICF0LnNoaWZ0S2V5ICYmICF0LmFsdEtleSAmJiAhdC5jdHJsS2V5ICYmICF0Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IG8uc3RhdGUudHI7XG4gICAgICAgICAgICAgIHJldHVybiBvLmRpc3BhdGNoKFxuICAgICAgICAgICAgICAgIG4uaW5zZXJ0KFxuICAgICAgICAgICAgICAgICAgby5zdGF0ZS50ci5zZWxlY3Rpb24uJHRvLmFmdGVyKCksXG4gICAgICAgICAgICAgICAgICBvLnN0YXRlLnNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGguY3JlYXRlQ2hlY2tlZCgpXG4gICAgICAgICAgICAgICAgKS5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgICAgICAgICBuZXcgUihcbiAgICAgICAgICAgICAgICAgICAgbi5kb2MucmVzb2x2ZShvLnN0YXRlLnRyLnNlbGVjdGlvbi4kdG8uYWZ0ZXIoKSArIDEpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLCAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFdpID0gbmV3IE4oXCJibG9ja25vdGUtcGxhY2Vob2xkZXJcIik7XG5jbGFzcyBqaSB7XG4gIGNvbnN0cnVjdG9yKG8sIHQpIHtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIHRoaXMucGx1Z2luID0gbmV3IE0oe1xuICAgICAga2V5OiBXaSxcbiAgICAgIHZpZXc6IChuKSA9PiB7XG4gICAgICAgIHZhciBsLCBkO1xuICAgICAgICBjb25zdCByID0gYHBsYWNlaG9sZGVyLXNlbGVjdG9yLSR7R3QoKX1gO1xuICAgICAgICBuLmRvbS5jbGFzc0xpc3QuYWRkKHIpO1xuICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLCBpID0gby5fdGlwdGFwRWRpdG9yLm9wdGlvbnMuaW5qZWN0Tm9uY2U7XG4gICAgICAgIGkgJiYgcy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBpKSwgKChsID0gby5wcm9zZW1pcnJvclZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBsLnJvb3QpIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IG8ucHJvc2VtaXJyb3JWaWV3LnJvb3QuYXBwZW5kKHMpIDogKGQgPSBvLnByb3NlbWlycm9yVmlldykgPT0gbnVsbCB8fCBkLnJvb3QuaGVhZC5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgY29uc3QgYSA9IHMuc2hlZXQsIGMgPSAocCA9IFwiXCIpID0+IGAuJHtyfSAuYm4tYmxvY2stY29udGVudCR7cH0gLmJuLWlubGluZS1jb250ZW50Omhhcyg+IC5Qcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrOm9ubHktY2hpbGQpOmJlZm9yZWA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGVmYXVsdDogcCxcbiAgICAgICAgICAgIGVtcHR5RG9jdW1lbnQ6IGgsXG4gICAgICAgICAgICAuLi5mXG4gICAgICAgICAgfSA9IHQ7XG4gICAgICAgICAgZm9yIChjb25zdCBbYiwga10gb2YgT2JqZWN0LmVudHJpZXMoZikpIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBgW2RhdGEtY29udGVudC10eXBlPVwiJHtifVwiXWA7XG4gICAgICAgICAgICBhLmluc2VydFJ1bGUoXG4gICAgICAgICAgICAgIGAke2Modyl9IHsgY29udGVudDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBrXG4gICAgICAgICAgICAgICl9OyB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbSA9IFwiW2RhdGEtaXMtb25seS1lbXB0eS1ibG9ja11cIiwgZyA9IFwiW2RhdGEtaXMtZW1wdHktYW5kLWZvY3VzZWRdXCI7XG4gICAgICAgICAgYS5pbnNlcnRSdWxlKFxuICAgICAgICAgICAgYCR7YyhtKX0geyBjb250ZW50OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBoXG4gICAgICAgICAgICApfTsgfWBcbiAgICAgICAgICApLCBhLmluc2VydFJ1bGUoXG4gICAgICAgICAgICBgJHtjKGcpfSB7IGNvbnRlbnQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHBcbiAgICAgICAgICAgICl9OyB9YFxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBpbnNlcnQgcGxhY2Vob2xkZXIgQ1NTIHJ1bGUgLSB0aGlzIGlzIGxpa2VseSBkdWUgdG8gdGhlIGJyb3dzZXIgbm90IHN1cHBvcnRpbmcgY2VydGFpbiBDU1MgcHNldWRvLWVsZW1lbnQgc2VsZWN0b3JzICg6aGFzLCA6b25seS1jaGlsZDosIG9yIDpiZWZvcmUpXCIsXG4gICAgICAgICAgICBwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBwLCBoO1xuICAgICAgICAgICAgKChwID0gby5wcm9zZW1pcnJvclZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBwLnJvb3QpIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IG8ucHJvc2VtaXJyb3JWaWV3LnJvb3QucmVtb3ZlQ2hpbGQocykgOiAoaCA9IG8ucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsIHx8IGgucm9vdC5oZWFkLnJlbW92ZUNoaWxkKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWNvcmF0aW9uczogKG4pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRvYzogciwgc2VsZWN0aW9uOiBzIH0gPSBuO1xuICAgICAgICAgIGlmICghby5pc0VkaXRhYmxlIHx8ICFzLmVtcHR5IHx8IHMuJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGkgPSBbXTtcbiAgICAgICAgICBuLmRvYy5jb250ZW50LnNpemUgPT09IDYgJiYgaS5wdXNoKFxuICAgICAgICAgICAgRy5ub2RlKDIsIDQsIHtcbiAgICAgICAgICAgICAgXCJkYXRhLWlzLW9ubHktZW1wdHktYmxvY2tcIjogXCJ0cnVlXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBhID0gcy4kYW5jaG9yLCBjID0gYS5wYXJlbnQ7XG4gICAgICAgICAgaWYgKGMuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gYS5iZWZvcmUoKTtcbiAgICAgICAgICAgIGkucHVzaChcbiAgICAgICAgICAgICAgRy5ub2RlKGwsIGwgKyBjLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgXCJkYXRhLWlzLWVtcHR5LWFuZC1mb2N1c2VkXCI6IFwidHJ1ZVwiXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gVS5jcmVhdGUociwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgX3QgPSBuZXcgTihcInByZXZpb3VzLWJsb2Nrc1wiKSwgR2kgPSB7XG4gIC8vIE51bWJlcmVkIExpc3QgSXRlbXNcbiAgaW5kZXg6IFwiaW5kZXhcIixcbiAgLy8gSGVhZGluZ3NcbiAgbGV2ZWw6IFwibGV2ZWxcIixcbiAgLy8gQWxsIEJsb2Nrc1xuICB0eXBlOiBcInR5cGVcIixcbiAgZGVwdGg6IFwiZGVwdGhcIixcbiAgXCJkZXB0aC1jaGFuZ2VcIjogXCJkZXB0aC1jaGFuZ2VcIlxufTtcbmNsYXNzIHFpIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdSh0aGlzLCBcInBsdWdpblwiKTtcbiAgICBsZXQgbztcbiAgICB0aGlzLnBsdWdpbiA9IG5ldyBNKHtcbiAgICAgIGtleTogX3QsXG4gICAgICB2aWV3KHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1cGRhdGU6IGFzeW5jIChuLCByKSA9PiB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgICgocyA9IHRoaXMua2V5KSA9PSBudWxsID8gdm9pZCAwIDogcy5nZXRTdGF0ZShuLnN0YXRlKS51cGRhdGVkQmxvY2tzLnNpemUpID4gMCAmJiAobyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBuLmRpc3BhdGNoKFxuICAgICAgICAgICAgICAgIG4uc3RhdGUudHIuc2V0TWV0YShfdCwgeyBjbGVhclVwZGF0ZTogITAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIDApKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIG8gJiYgY2xlYXJUaW1lb3V0KG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzdGF0ZToge1xuICAgICAgICBpbml0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBCbG9jayBhdHRyaWJ1dGVzLCBieSBibG9jayBJRCwgZnJvbSBqdXN0IGJlZm9yZSB0aGUgcHJldmlvdXMgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICBwcmV2VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzOiB7fSxcbiAgICAgICAgICAgIC8vIEJsb2NrIGF0dHJpYnV0ZXMsIGJ5IGJsb2NrIElELCBmcm9tIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgY3VycmVudFRyYW5zYWN0aW9uT2xkQmxvY2tBdHRyczoge30sXG4gICAgICAgICAgICAvLyBTZXQgb2YgSURzIG9mIGJsb2NrcyB3aG9zZSBhdHRyaWJ1dGVzIGNoYW5nZWQgZnJvbSB0aGUgY3VycmVudCB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgIHVwZGF0ZWRCbG9ja3M6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhcHBseSh0LCBuLCByLCBzKSB7XG4gICAgICAgICAgaWYgKG4uY3VycmVudFRyYW5zYWN0aW9uT2xkQmxvY2tBdHRycyA9IHt9LCBuLnVwZGF0ZWRCbG9ja3MuY2xlYXIoKSwgIXQuZG9jQ2hhbmdlZCB8fCByLmRvYy5lcShzLmRvYykpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICBjb25zdCBpID0ge30sIGEgPSBndChyLmRvYywgKGQpID0+IGQuYXR0cnMuaWQpLCBjID0gbmV3IE1hcChcbiAgICAgICAgICAgIGEubWFwKChkKSA9PiBbZC5ub2RlLmF0dHJzLmlkLCBkXSlcbiAgICAgICAgICApLCBsID0gZ3Qocy5kb2MsIChkKSA9PiBkLmF0dHJzLmlkKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGQgb2YgbCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IGMuZ2V0KGQubm9kZS5hdHRycy5pZCksIGggPSBwID09IG51bGwgPyB2b2lkIDAgOiBwLm5vZGUuZmlyc3RDaGlsZCwgZiA9IGQubm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKHAgJiYgaCAmJiBmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGYuYXR0cnMuaW5kZXgsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGYuYXR0cnMubGV2ZWwsXG4gICAgICAgICAgICAgICAgdHlwZTogZi50eXBlLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVwdGg6IHMuZG9jLnJlc29sdmUoZC5wb3MpLmRlcHRoXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxldCBnID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBoLmF0dHJzLmluZGV4LFxuICAgICAgICAgICAgICAgIGxldmVsOiBoLmF0dHJzLmxldmVsLFxuICAgICAgICAgICAgICAgIHR5cGU6IGgudHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgIGRlcHRoOiByLmRvYy5yZXNvbHZlKHAucG9zKS5kZXB0aFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpW2Qubm9kZS5hdHRycy5pZF0gPSBnLCB0LmdldE1ldGEoXCJudW1iZXJlZExpc3RJbmRleGluZ1wiKSAmJiAoZC5ub2RlLmF0dHJzLmlkIGluIG4ucHJldlRyYW5zYWN0aW9uT2xkQmxvY2tBdHRycyAmJiAoZyA9IG4ucHJldlRyYW5zYWN0aW9uT2xkQmxvY2tBdHRyc1tkLm5vZGUuYXR0cnMuaWRdKSwgbS50eXBlID09PSBcIm51bWJlcmVkTGlzdEl0ZW1cIiAmJiAoZy5pbmRleCA9IG0uaW5kZXgpKSwgbi5jdXJyZW50VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzW2Qubm9kZS5hdHRycy5pZF0gPSBnLCBKU09OLnN0cmluZ2lmeShnKSAhPT0gSlNPTi5zdHJpbmdpZnkobSkgJiYgKGdbXCJkZXB0aC1jaGFuZ2VcIl0gPSBnLmRlcHRoIC0gbS5kZXB0aCwgbi51cGRhdGVkQmxvY2tzLmFkZChkLm5vZGUuYXR0cnMuaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG4ucHJldlRyYW5zYWN0aW9uT2xkQmxvY2tBdHRycyA9IGksIG47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWNvcmF0aW9ucyh0KSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0U3RhdGUodCk7XG4gICAgICAgICAgaWYgKG4udXBkYXRlZEJsb2Nrcy5zaXplID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICByZXR1cm4gdC5kb2MuZGVzY2VuZGFudHMoKHMsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghcy5hdHRycy5pZCB8fCAhbi51cGRhdGVkQmxvY2tzLmhhcyhzLmF0dHJzLmlkKSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYSA9IG4uY3VycmVudFRyYW5zYWN0aW9uT2xkQmxvY2tBdHRyc1tzLmF0dHJzLmlkXSwgYyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZCwgcF0gb2YgT2JqZWN0LmVudHJpZXMoYSkpXG4gICAgICAgICAgICAgIGNbXCJkYXRhLXByZXYtXCIgKyBHaVtkXV0gPSBwIHx8IFwibm9uZVwiO1xuICAgICAgICAgICAgY29uc3QgbCA9IEcubm9kZShpLCBpICsgcy5ub2RlU2l6ZSwge1xuICAgICAgICAgICAgICAuLi5jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHIucHVzaChsKTtcbiAgICAgICAgICB9KSwgVS5jcmVhdGUodC5kb2MsIHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFJ0ID0gbmV3IE4oXCJibG9ja25vdGUtc2hvdy1zZWxlY3Rpb25cIik7XG5jbGFzcyBLaSB7XG4gIGNvbnN0cnVjdG9yKG8pIHtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIHUodGhpcywgXCJlbmFibGVkXCIsICExKTtcbiAgICB0aGlzLmVkaXRvciA9IG8sIHRoaXMucGx1Z2luID0gbmV3IE0oe1xuICAgICAga2V5OiBSdCxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRlY29yYXRpb25zOiAodCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZG9jOiBuLCBzZWxlY3Rpb246IHIgfSA9IHQ7XG4gICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICAgICAgICByZXR1cm4gVS5lbXB0eTtcbiAgICAgICAgICBjb25zdCBzID0gRy5pbmxpbmUoci5mcm9tLCByLnRvLCB7XG4gICAgICAgICAgICBcImRhdGEtc2hvdy1zZWxlY3Rpb25cIjogXCJ0cnVlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gVS5jcmVhdGUobiwgW3NdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldEVuYWJsZWQobykge1xuICAgIHZhciB0LCBuO1xuICAgIHRoaXMuZW5hYmxlZCAhPT0gbyAmJiAodGhpcy5lbmFibGVkID0gbywgKG4gPSB0aGlzLmVkaXRvci5wcm9zZW1pcnJvclZpZXcpID09IG51bGwgfHwgbi5kaXNwYXRjaChcbiAgICAgICh0ID0gdGhpcy5lZGl0b3IucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogdC5zdGF0ZS50ci5zZXRNZXRhKFJ0LCB7fSlcbiAgICApKTtcbiAgfVxuICBnZXRFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIERvKGUsIG8pIHtcbiAgdmFyIHQsIG47XG4gIGZvciAoOyBlICYmIGUucGFyZW50RWxlbWVudCAmJiBlLnBhcmVudEVsZW1lbnQgIT09IG8uZG9tICYmICgodCA9IGUuZ2V0QXR0cmlidXRlKSA9PSBudWxsID8gdm9pZCAwIDogdC5jYWxsKGUsIFwiZGF0YS1ub2RlLXR5cGVcIikpICE9PSBcImJsb2NrQ29udGFpbmVyXCI7IClcbiAgICBlID0gZS5wYXJlbnRFbGVtZW50O1xuICBpZiAoKChuID0gZS5nZXRBdHRyaWJ1dGUpID09IG51bGwgPyB2b2lkIDAgOiBuLmNhbGwoZSwgXCJkYXRhLW5vZGUtdHlwZVwiKSkgPT09IFwiYmxvY2tDb250YWluZXJcIilcbiAgICByZXR1cm4geyBub2RlOiBlLCBpZDogZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpIH07XG59XG5jbGFzcyBsZSBleHRlbmRzIHplIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHQsIG4pO1xuICAgIHUodGhpcywgXCJub2Rlc1wiKTtcbiAgICBjb25zdCByID0gdC5ub2RlKCk7XG4gICAgdGhpcy5ub2RlcyA9IFtdLCB0LmRvYy5ub2Rlc0JldHdlZW4odC5wb3MsIG4ucG9zLCAocywgaSwgYSkgPT4ge1xuICAgICAgaWYgKGEgIT09IG51bGwgJiYgYS5lcShyKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucHVzaChzKSwgITE7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZSh0LCBuLCByID0gbikge1xuICAgIHJldHVybiBuZXcgbGUodC5yZXNvbHZlKG4pLCB0LnJlc29sdmUocikpO1xuICB9XG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIG5ldyB0ZShWLmZyb20odGhpcy5ub2RlcyksIDAsIDApO1xuICB9XG4gIGVxKHQpIHtcbiAgICBpZiAoISh0IGluc3RhbmNlb2YgbGUpIHx8IHRoaXMubm9kZXMubGVuZ3RoICE9PSB0Lm5vZGVzLmxlbmd0aCB8fCB0aGlzLmZyb20gIT09IHQuZnJvbSB8fCB0aGlzLnRvICE9PSB0LnRvKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IG4rKylcbiAgICAgIGlmICghdGhpcy5ub2Rlc1tuXS5lcSh0Lm5vZGVzW25dKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBtYXAodCwgbikge1xuICAgIGNvbnN0IHIgPSBuLm1hcFJlc3VsdCh0aGlzLmZyb20pLCBzID0gbi5tYXBSZXN1bHQodGhpcy50byk7XG4gICAgcmV0dXJuIHMuZGVsZXRlZCA/IHplLm5lYXIodC5yZXNvbHZlKHIucG9zKSkgOiByLmRlbGV0ZWQgPyB6ZS5uZWFyKHQucmVzb2x2ZShzLnBvcykpIDogbmV3IGxlKFxuICAgICAgdC5yZXNvbHZlKHIucG9zKSxcbiAgICAgIHQucmVzb2x2ZShzLnBvcylcbiAgICApO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm5vZGVcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gIH1cbn1cbmxldCBfO1xuZnVuY3Rpb24gWGkoZSwgbykge1xuICBsZXQgdCwgbjtcbiAgY29uc3QgciA9IG8ucmVzb2x2ZShlLmZyb20pLm5vZGUoKS50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCIsIHMgPSBvLnJlc29sdmUoZS50bykubm9kZSgpLnR5cGUuc3BlYy5ncm91cCA9PT0gXCJibG9ja0NvbnRlbnRcIiwgaSA9IE1hdGgubWluKGUuJGFuY2hvci5kZXB0aCwgZS4kaGVhZC5kZXB0aCk7XG4gIGlmIChyICYmIHMpIHtcbiAgICBjb25zdCBhID0gZS4kZnJvbS5zdGFydChpIC0gMSksIGMgPSBlLiR0by5lbmQoaSAtIDEpO1xuICAgIHQgPSBvLnJlc29sdmUoYSAtIDEpLnBvcywgbiA9IG8ucmVzb2x2ZShjICsgMSkucG9zO1xuICB9IGVsc2VcbiAgICB0ID0gZS5mcm9tLCBuID0gZS50bztcbiAgcmV0dXJuIHsgZnJvbTogdCwgdG86IG4gfTtcbn1cbmZ1bmN0aW9uIFZ0KGUsIG8sIHQgPSBvKSB7XG4gIG8gPT09IHQgJiYgKHQgKz0gZS5zdGF0ZS5kb2MucmVzb2x2ZShvICsgMSkubm9kZSgpLm5vZGVTaXplKTtcbiAgY29uc3QgbiA9IGUuZG9tQXRQb3Mobykubm9kZS5jbG9uZU5vZGUoITApLCByID0gZS5kb21BdFBvcyhvKS5ub2RlLCBzID0gKHAsIGgpID0+IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocC5jaGlsZHJlbiwgaCksIGkgPSBzKFxuICAgIHIsXG4gICAgLy8gRXhwZWN0cyBmcm9tIHBvc2l0aW9uIHRvIGJlIGp1c3QgYmVmb3JlIHRoZSBmaXJzdCBzZWxlY3RlZCBibG9jay5cbiAgICBlLmRvbUF0UG9zKG8gKyAxKS5ub2RlLnBhcmVudEVsZW1lbnRcbiAgKSwgYSA9IHMoXG4gICAgcixcbiAgICAvLyBFeHBlY3RzIHRvIHBvc2l0aW9uIHRvIGJlIGp1c3QgYWZ0ZXIgdGhlIGxhc3Qgc2VsZWN0ZWQgYmxvY2suXG4gICAgZS5kb21BdFBvcyh0IC0gMSkubm9kZS5wYXJlbnRFbGVtZW50XG4gICk7XG4gIGZvciAobGV0IHAgPSByLmNoaWxkRWxlbWVudENvdW50IC0gMTsgcCA+PSAwOyBwLS0pXG4gICAgKHAgPiBhIHx8IHAgPCBpKSAmJiBuLnJlbW92ZUNoaWxkKG4uY2hpbGRyZW5bcF0pO1xuICBPbyhlLnJvb3QpLCBfID0gbjtcbiAgY29uc3QgYyA9IF8uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpZnJhbWVcIik7XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgYy5sZW5ndGg7IHArKykge1xuICAgIGNvbnN0IGggPSBjW3BdLCBmID0gaC5wYXJlbnRFbGVtZW50O1xuICAgIGYgJiYgZi5yZW1vdmVDaGlsZChoKTtcbiAgfVxuICBjb25zdCBkID0gZS5kb20uY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5maWx0ZXIoXG4gICAgKHApID0+IHAgIT09IFwiUHJvc2VNaXJyb3JcIiAmJiBwICE9PSBcImJuLXJvb3RcIiAmJiBwICE9PSBcImJuLWVkaXRvclwiXG4gICkuam9pbihcIiBcIik7XG4gIF8uY2xhc3NOYW1lID0gXy5jbGFzc05hbWUgKyBcIiBibi1kcmFnLXByZXZpZXcgXCIgKyBkLCBlLnJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gZS5yb290LmFwcGVuZENoaWxkKF8pIDogZS5yb290LmJvZHkuYXBwZW5kQ2hpbGQoXyk7XG59XG5mdW5jdGlvbiBPbyhlKSB7XG4gIF8gIT09IHZvaWQgMCAmJiAoZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBlLnJlbW92ZUNoaWxkKF8pIDogZS5ib2R5LnJlbW92ZUNoaWxkKF8pLCBfID0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIEppKGUsIG8sIHQpIHtcbiAgaWYgKCFlLmRhdGFUcmFuc2ZlcilcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSB0LnByb3NlbWlycm9yVmlldztcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgY29uc3QgciA9IEQoby5pZCwgbi5zdGF0ZS5kb2MpO1xuICBpZiAoIXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIElEICR7by5pZH0gbm90IGZvdW5kYCk7XG4gIGNvbnN0IHMgPSByLnBvc0JlZm9yZU5vZGU7XG4gIGlmIChzICE9IG51bGwpIHtcbiAgICBjb25zdCBpID0gbi5zdGF0ZS5zZWxlY3Rpb24sIGEgPSBuLnN0YXRlLmRvYywgeyBmcm9tOiBjLCB0bzogbCB9ID0gWGkoaSwgYSksIGQgPSBjIDw9IHMgJiYgcyA8IGwsIHAgPSBpLiRhbmNob3Iubm9kZSgpICE9PSBpLiRoZWFkLm5vZGUoKSB8fCBpIGluc3RhbmNlb2YgbGU7XG4gICAgZCAmJiBwID8gKG4uZGlzcGF0Y2goXG4gICAgICBuLnN0YXRlLnRyLnNldFNlbGVjdGlvbihsZS5jcmVhdGUoYSwgYywgbCkpXG4gICAgKSwgVnQobiwgYywgbCkpIDogKG4uZGlzcGF0Y2goXG4gICAgICBuLnN0YXRlLnRyLnNldFNlbGVjdGlvbih3ZS5jcmVhdGUobi5zdGF0ZS5kb2MsIHMpKVxuICAgICksIFZ0KG4sIHMpKTtcbiAgICBjb25zdCBoID0gbi5zdGF0ZS5zZWxlY3Rpb24uY29udGVudCgpLCBmID0gdC5wbVNjaGVtYSwgbSA9IG4uc2VyaWFsaXplRm9yQ2xpcGJvYXJkKGgpLmRvbS5pbm5lckhUTUwsIGcgPSBWZShmLCB0KSwgYiA9IExvKGguY29udGVudCwgdC5zY2hlbWEpLCBrID0gZy5leHBvcnRCbG9ja3MoYiwge30pLCB3ID0gaHQoayk7XG4gICAgZS5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCksIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJibG9ja25vdGUvaHRtbFwiLCBtKSwgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvaHRtbFwiLCBrKSwgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdyksIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIiwgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKF8sIDAsIDApO1xuICB9XG59XG5jb25zdCBoZSA9IDAuMTtcbmZ1bmN0aW9uIHJ0KGUsIG8sIHQsIG4gPSAhMCkge1xuICBjb25zdCByID0gZS5yb290LmVsZW1lbnRzRnJvbVBvaW50KFxuICAgIC8vIGJpdCBoYWNreSAtIG9mZnNldCB4IHBvc2l0aW9uIHRvIHJpZ2h0IHRvIGFjY291bnQgZm9yIHRoZSB3aWR0aCBvZiBzaWRlbWVudSBpdHNlbGZcbiAgICBvLmxlZnQgKyAodCA9PT0gXCJlZGl0b3JcIiA/IDUwIDogMCksXG4gICAgby50b3BcbiAgKTtcbiAgZm9yIChjb25zdCBzIG9mIHIpXG4gICAgaWYgKGUuZG9tLmNvbnRhaW5zKHMpKVxuICAgICAgcmV0dXJuIG4gJiYgcy5jbG9zZXN0KFwiW2RhdGEtbm9kZS10eXBlPWNvbHVtbkxpc3RdXCIpID8gcnQoXG4gICAgICAgIGUsXG4gICAgICAgIHtcbiAgICAgICAgICBsZWZ0OiBvLmxlZnQgKyA1MCxcbiAgICAgICAgICAvLyBiaXQgaGFja3ksIGJ1dCBpZiB3ZSdyZSBpbnNpZGUgYSBjb2x1bW4sIG9mZnNldCB4IHBvc2l0aW9uIHRvIHJpZ2h0IHRvIGFjY291bnQgZm9yIHRoZSB3aWR0aCBvZiBzaWRlbWVudSBpdHNlbGZcbiAgICAgICAgICB0b3A6IG8udG9wXG4gICAgICAgIH0sXG4gICAgICAgIHQsXG4gICAgICAgICExXG4gICAgICApIDogRG8ocywgZSk7XG59XG5mdW5jdGlvbiBZaShlLCBvLCB0KSB7XG4gIGlmICghby5kb20uZmlyc3RDaGlsZClcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSBvLmRvbS5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCByID0ge1xuICAgIGxlZnQ6IGUueCxcbiAgICB0b3A6IGUueVxuICB9LCBzID0gci5sZWZ0IDwgbi5sZWZ0LCBpID0gci5sZWZ0ID4gbi5yaWdodDtcbiAgdCA9PT0gXCJ2aWV3cG9ydFwiICYmIChzICYmIChyLmxlZnQgPSBuLmxlZnQgKyAxMCksIGkgJiYgKHIubGVmdCA9IG4ucmlnaHQgLSAxMCkpO1xuICBsZXQgYSA9IHJ0KG8sIHIsIHQpO1xuICBpZiAoIWkgJiYgYSkge1xuICAgIGNvbnN0IGMgPSBhLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgci5sZWZ0ID0gYy5yaWdodCAtIDEwLCBhID0gcnQobywgciwgXCJ2aWV3cG9ydFwiLCAhMSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5jbGFzcyBaaSB7XG4gIGNvbnN0cnVjdG9yKG8sIHQsIG4sIHIpIHtcbiAgICB1KHRoaXMsIFwic3RhdGVcIik7XG4gICAgdSh0aGlzLCBcImVtaXRVcGRhdGVcIik7XG4gICAgdSh0aGlzLCBcIm1vdXNlUG9zXCIpO1xuICAgIHUodGhpcywgXCJob3ZlcmVkQmxvY2tcIik7XG4gICAgdSh0aGlzLCBcIm1lbnVGcm96ZW5cIiwgITEpO1xuICAgIHUodGhpcywgXCJpc0RyYWdPcmlnaW5cIiwgITEpO1xuICAgIHUodGhpcywgXCJ1cGRhdGVTdGF0ZVwiLCAobykgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IG8sIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnN0YXRlKTtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwidXBkYXRlU3RhdGVGcm9tTW91c2VQb3NcIiwgKCkgPT4ge1xuICAgICAgdmFyIG4sIHIsIHMsIGk7XG4gICAgICBpZiAodGhpcy5tZW51RnJvemVuIHx8ICF0aGlzLm1vdXNlUG9zKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gWWkoXG4gICAgICAgIHRoaXMubW91c2VQb3MsXG4gICAgICAgIHRoaXMucG1WaWV3LFxuICAgICAgICB0aGlzLnNpZGVNZW51RGV0ZWN0aW9uXG4gICAgICApO1xuICAgICAgaWYgKCFvIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgIChuID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBuLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChyID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiByLnNob3cgJiYgKChzID0gdGhpcy5ob3ZlcmVkQmxvY2spICE9IG51bGwgJiYgcy5oYXNBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpKSAmJiAoKGkgPSB0aGlzLmhvdmVyZWRCbG9jaykgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKSkgPT09IG8uaWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuaG92ZXJlZEJsb2NrID0gby5ub2RlO1xuICAgICAgY29uc3QgdCA9IG8ubm9kZS5maXJzdENoaWxkO1xuICAgICAgaWYgKHQgJiYgdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICBjb25zdCBhID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYyA9IG8ubm9kZS5jbG9zZXN0KFwiW2RhdGEtbm9kZS10eXBlPWNvbHVtbl1cIik7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHNob3c6ICEwLFxuICAgICAgICAgIHJlZmVyZW5jZVBvczogbmV3IERPTVJlY3QoXG4gICAgICAgICAgICBjID8gKFxuICAgICAgICAgICAgICAvLyBXZSB0YWtlIHRoZSBmaXJzdCBjaGlsZCBhcyBjb2x1bW4gZWxlbWVudHMgaGF2ZSBzb21lIGRlZmF1bHRcbiAgICAgICAgICAgICAgLy8gcGFkZGluZy4gVGhpcyBpcyBhIGxpdHRsZSB3ZWlyZCBzaW5jZSB0aGlzIGNoaWxkIGVsZW1lbnQgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSB0aGUgZmlyc3QgYmxvY2ssIGJ1dCBzaW5jZSBpdCdzIGFsd2F5cyBub24tbmVzdGVkIGFuZCB3ZVxuICAgICAgICAgICAgICAvLyBvbmx5IHRha2UgdGhlIHggY29vcmRpbmF0ZSwgaXQncyBvay5cbiAgICAgICAgICAgICAgYy5maXJzdEVsZW1lbnRDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54XG4gICAgICAgICAgICApIDogdGhpcy5wbVZpZXcuZG9tLmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCxcbiAgICAgICAgICAgIGEueSxcbiAgICAgICAgICAgIGEud2lkdGgsXG4gICAgICAgICAgICBhLmhlaWdodFxuICAgICAgICAgICksXG4gICAgICAgICAgYmxvY2s6IHRoaXMuZWRpdG9yLmdldEJsb2NrKFxuICAgICAgICAgICAgdGhpcy5ob3ZlcmVkQmxvY2suZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKVxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcIm9uRHJvcFwiLCAobykgPT4ge1xuICAgICAgdmFyIHIsIHM7XG4gICAgICBpZiAodGhpcy5wbVZpZXcuZHJhZ2dpbmcgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuYmx1cigpO1xuICAgICAgY29uc3QgdCA9IG8udGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJiAoKHIgPSBvLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gby50YXJnZXQgOiBvLnRhcmdldC5wYXJlbnRFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogci5jbG9zZXN0KFwiLmJuLWVkaXRvclwiKSkgfHwgbnVsbDtcbiAgICAgIGlmICh0ICYmICghdGhpcy5pc0RyYWdPcmlnaW4gJiYgdGhpcy5wbVZpZXcuZG9tID09PSB0ID8gdGhpcy5wbVZpZXcuZGlzcGF0Y2goXG4gICAgICAgIHRoaXMucG1WaWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihcbiAgICAgICAgICBSLmNyZWF0ZShcbiAgICAgICAgICAgIHRoaXMucG1WaWV3LnN0YXRlLnRyLmRvYyxcbiAgICAgICAgICAgIHRoaXMucG1WaWV3LnN0YXRlLnRyLnNlbGVjdGlvbi50b1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSA6IHRoaXMuaXNEcmFnT3JpZ2luICYmIHRoaXMucG1WaWV3LmRvbSAhPT0gdCAmJiBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiB0aGlzLnBtVmlldy5kaXNwYXRjaCh0aGlzLnBtVmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKSksXG4gICAgICAgIDBcbiAgICAgICkpLCB0aGlzLnNpZGVNZW51RGV0ZWN0aW9uID09PSBcImVkaXRvclwiIHx8IG8uc3ludGhldGljIHx8ICEoKHMgPSBvLmRhdGFUcmFuc2ZlcikgIT0gbnVsbCAmJiBzLnR5cGVzLmluY2x1ZGVzKFwiYmxvY2tub3RlL2h0bWxcIikpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuID0gdGhpcy5wbVZpZXcucG9zQXRDb29yZHMoe1xuICAgICAgICBsZWZ0OiBvLmNsaWVudFgsXG4gICAgICAgIHRvcDogby5jbGllbnRZXG4gICAgICB9KTtcbiAgICAgIGlmICghbiB8fCBuLmluc2lkZSA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuY3JlYXRlU3ludGhldGljRXZlbnQobyk7XG4gICAgICAgIHRoaXMucG1WaWV3LmRvbS5kaXNwYXRjaEV2ZW50KGkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHUodGhpcywgXCJvbkRyYWdFbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5wbVZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIElmIGEgYmxvY2sgaXMgYmVpbmcgZHJhZ2dlZCwgUHJvc2VNaXJyb3IgdXN1YWxseSBnZXRzIHRoZSBjb250ZXh0IG9mIHdoYXQnc1xuICAgICAqIGJlaW5nIGRyYWdnZWQgZnJvbSBgdmlldy5kcmFnZ2luZ2AsIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHdoZW4gYVxuICAgICAqIGBkcmFnc3RhcnRgIGV2ZW50IGZpcmVzIGluIHRoZSBlZGl0b3IuIEhvd2V2ZXIsIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGRyYWdcbiAgICAgKiBhbmQgZHJvcCBibG9ja3MgYmV0d2VlbiBtdWx0aXBsZSBlZGl0b3JzLCBvbmx5IHRoZSBvbmUgaW4gd2hpY2ggdGhlIGRyYWdcbiAgICAgKiBiZWdhbiBoYXMgdGhhdCBjb250ZXh0LCBzbyB3ZSBuZWVkIHRvIHNldCBpdCBvbiB0aGUgb3RoZXJzIG1hbnVhbGx5LiBUaGlzXG4gICAgICogZW5zdXJlcyB0aGF0IFBNIGFsd2F5cyBkcm9wcyB0aGUgYmxvY2tzIGluIGJldHdlZW4gb3RoZXIgYmxvY2tzLCBhbmQgbm90XG4gICAgICogaW5zaWRlIHRoZW0uXG4gICAgICpcbiAgICAgKiBBZnRlciB0aGUgYGRyYWdzdGFydGAgZXZlbnQgZmlyZXMgb24gdGhlIGRyYWcgaGFuZGxlLCBpdCBzZXRzXG4gICAgICogYGJsb2Nrbm90ZS9odG1sYCBkYXRhIG9uIHRoZSBjbGlwYm9hcmQuIFRoaXMgaGFuZGxlciBmaXJlcyByaWdodCBhZnRlcixcbiAgICAgKiBwYXJzaW5nIHRoZSBgYmxvY2tub3RlL2h0bWxgIGRhdGEgaW50byBub2RlcyBhbmQgc2V0dGluZyB0aGVtIG9uXG4gICAgICogYHZpZXcuZHJhZ2dpbmdgLlxuICAgICAqXG4gICAgICogTm90ZTogU2V0dGluZyBgdmlldy5kcmFnZ2luZ2Agb24gYGRyYWdvdmVyYCB3b3VsZCBiZSBiZXR0ZXIgYXMgdGhlIHVzZXJcbiAgICAgKiBjb3VsZCB0aGVuIGRyYWcgYmV0d2VlbiBlZGl0b3JzIGluIGRpZmZlcmVudCB3aW5kb3dzLCBidXQgeW91IGNhbiBvbmx5XG4gICAgICogYWNjZXNzIGBkYXRhVHJhbnNmZXJgIGNvbnRlbnRzIG9uIGBkcmFnc3RhcnRgIGFuZCBgZHJvcGAgZXZlbnRzLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJvbkRyYWdTdGFydFwiLCAobykgPT4ge1xuICAgICAgdmFyIGk7XG4gICAgICBjb25zdCB0ID0gKGkgPSBvLmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZ2V0RGF0YShcImJsb2Nrbm90ZS9odG1sXCIpO1xuICAgICAgaWYgKCF0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5wbVZpZXcuZHJhZ2dpbmcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ldyBkcmFnIHdhcyBzdGFydGVkIHdoaWxlIGFuIGV4aXN0aW5nIGRyYWcgaXMgb25nb2luZ1wiKTtcbiAgICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgbi5pbm5lckhUTUwgPSB0O1xuICAgICAgY29uc3QgcyA9IHp0LmZyb21TY2hlbWEodGhpcy5wbVZpZXcuc3RhdGUuc2NoZW1hKS5wYXJzZShuLCB7XG4gICAgICAgIHRvcE5vZGU6IHRoaXMucG1WaWV3LnN0YXRlLnNjaGVtYS5ub2Rlcy5ibG9ja0dyb3VwLmNyZWF0ZSgpXG4gICAgICB9KTtcbiAgICAgIHRoaXMucG1WaWV3LmRyYWdnaW5nID0ge1xuICAgICAgICBzbGljZTogbmV3IHRlKHMuY29udGVudCwgMCwgMCksXG4gICAgICAgIG1vdmU6ICEwXG4gICAgICB9O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBldmVudCBpcyBvdXRzaWRlIHRoZSBlZGl0b3IgY29udGVudHMsXG4gICAgICogd2UgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50LCBzbyB0aGF0IHdlIGNhbiBzdGlsbCBkcm9wIHRoZSBjb250ZW50XG4gICAgICogd2hlbiBkcmFnZ2luZyAvIGRyb3BwaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwib25EcmFnT3ZlclwiLCAobykgPT4ge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAodGhpcy5zaWRlTWVudURldGVjdGlvbiA9PT0gXCJlZGl0b3JcIiB8fCBvLnN5bnRoZXRpYyB8fCAhKChuID0gby5kYXRhVHJhbnNmZXIpICE9IG51bGwgJiYgbi50eXBlcy5pbmNsdWRlcyhcImJsb2Nrbm90ZS9odG1sXCIpKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdCA9IHRoaXMucG1WaWV3LnBvc0F0Q29vcmRzKHtcbiAgICAgICAgbGVmdDogby5jbGllbnRYLFxuICAgICAgICB0b3A6IG8uY2xpZW50WVxuICAgICAgfSk7XG4gICAgICBpZiAoIXQgfHwgdC5pbnNpZGUgPT09IC0xICYmIHRoaXMucG1WaWV3LmRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZVN5bnRoZXRpY0V2ZW50KG8pO1xuICAgICAgICB0aGlzLnBtVmlldy5kb20uZGlzcGF0Y2hFdmVudChyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1KHRoaXMsIFwib25LZXlEb3duXCIsIChvKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgICh0ID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiB0LnNob3cgJiYgdGhpcy5lZGl0b3IuaXNGb2N1c2VkKCkgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUodGhpcy5zdGF0ZSkpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJvbk1vdXNlTW92ZVwiLCAobykgPT4ge1xuICAgICAgdmFyIHM7XG4gICAgICBpZiAodGhpcy5tZW51RnJvemVuKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLm1vdXNlUG9zID0geyB4OiBvLmNsaWVudFgsIHk6IG8uY2xpZW50WSB9O1xuICAgICAgY29uc3QgdCA9IHRoaXMucG1WaWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IHRoaXMubW91c2VQb3MueCA+IHQubGVmdCAmJiB0aGlzLm1vdXNlUG9zLnggPCB0LnJpZ2h0ICYmIHRoaXMubW91c2VQb3MueSA+IHQudG9wICYmIHRoaXMubW91c2VQb3MueSA8IHQuYm90dG9tLCByID0gdGhpcy5wbVZpZXcuZG9tLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIEN1cnNvciBpcyB3aXRoaW4gdGhlIGVkaXRvciBhcmVhXG4gICAgICAgIG4gJiYgLy8gQW4gZWxlbWVudCBpcyBob3ZlcmVkXG4gICAgICAgIG8gJiYgby50YXJnZXQgJiYgLy8gRWxlbWVudCBpcyBvdXRzaWRlIHRoZSBlZGl0b3JcbiAgICAgICAgIShyID09PSBvLnRhcmdldCB8fCByLmNvbnRhaW5zKG8udGFyZ2V0KSlcbiAgICAgICkge1xuICAgICAgICAocyA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgcy5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKHRoaXMuc3RhdGUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTdGF0ZUZyb21Nb3VzZVBvcygpO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJvblNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIChvID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBvLnNob3cgJiYgKHRoaXMuc3RhdGUucmVmZXJlbmNlUG9zID0gdGhpcy5ob3ZlcmVkQmxvY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnN0YXRlKSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSBvLCB0aGlzLnNpZGVNZW51RGV0ZWN0aW9uID0gdCwgdGhpcy5wbVZpZXcgPSBuLCB0aGlzLmVtaXRVcGRhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gdXBkYXRlIHVuaW5pdGlhbGl6ZWQgc2lkZSBtZW51XCIpO1xuICAgICAgcih0aGlzLnN0YXRlKTtcbiAgICB9LCB0aGlzLnBtVmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImRyYWdzdGFydFwiLFxuICAgICAgdGhpcy5vbkRyYWdTdGFydFxuICAgICksIHRoaXMucG1WaWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiZHJhZ292ZXJcIixcbiAgICAgIHRoaXMub25EcmFnT3ZlclxuICAgICksIHRoaXMucG1WaWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiZHJvcFwiLFxuICAgICAgdGhpcy5vbkRyb3AsXG4gICAgICAhMFxuICAgICksIHRoaXMucG1WaWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiZHJhZ2VuZFwiLFxuICAgICAgdGhpcy5vbkRyYWdFbmQsXG4gICAgICAhMFxuICAgICksIHV0KCksIHRoaXMucG1WaWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwibW91c2Vtb3ZlXCIsXG4gICAgICB0aGlzLm9uTW91c2VNb3ZlLFxuICAgICAgITBcbiAgICApLCB0aGlzLnBtVmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMub25LZXlEb3duLFxuICAgICAgITBcbiAgICApLCBuLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsLCAhMCk7XG4gIH1cbiAgY3JlYXRlU3ludGhldGljRXZlbnQobykge1xuICAgIGNvbnN0IHQgPSBuZXcgRXZlbnQoby50eXBlLCBvKSwgbiA9IHRoaXMucG1WaWV3LmRvbS5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB0LmNsaWVudFggPSBvLmNsaWVudFgsIHQuY2xpZW50WSA9IG8uY2xpZW50WSwgby5jbGllbnRYIDwgbi5sZWZ0ICYmIG8uY2xpZW50WCA+IG4ubGVmdCAtIG4ud2lkdGggKiBoZSA/IHQuY2xpZW50WCA9IG4ubGVmdCArIG4ud2lkdGggKiBoZSAvIDIgOiBvLmNsaWVudFggPiBuLnJpZ2h0ICYmIG8uY2xpZW50WCA8IG4ucmlnaHQgKyBuLndpZHRoICogaGUgPyB0LmNsaWVudFggPSBuLnJpZ2h0IC0gbi53aWR0aCAqIGhlIC8gMiA6IChvLmNsaWVudFggPCBuLmxlZnQgfHwgby5jbGllbnRYID4gbi5yaWdodCkgJiYgKHQuY2xpZW50WCA9IG4ubGVmdCArIGhlICogbi53aWR0aCAqIDIpLCB0LmNsaWVudFkgPSBNYXRoLm1pbihcbiAgICAgIE1hdGgubWF4KG8uY2xpZW50WSwgbi50b3ApLFxuICAgICAgbi50b3AgKyBuLmhlaWdodFxuICAgICksIHQuZGF0YVRyYW5zZmVyID0gby5kYXRhVHJhbnNmZXIsIHQucHJldmVudERlZmF1bHQgPSAoKSA9PiBvLnByZXZlbnREZWZhdWx0KCksIHQuc3ludGhldGljID0gITAsIHQ7XG4gIH1cbiAgLy8gTmVlZGVkIGluIGNhc2VzIHdoZXJlIHRoZSBlZGl0b3Igc3RhdGUgdXBkYXRlcyB3aXRob3V0IHRoZSBtb3VzZSBjdXJzb3JcbiAgLy8gbW92aW5nLCBhcyBzb21lIHN0YXRlIHVwZGF0ZXMgY2FuIHJlcXVpcmUgYSBzaWRlIG1lbnUgdXBkYXRlLiBGb3IgZXhhbXBsZSxcbiAgLy8gYWRkaW5nIGEgYnV0dG9uIHRvIHRoZSBzaWRlIG1lbnUgd2hpY2ggcmVtb3ZlcyB0aGUgYmxvY2sgY2FuIGNhdXNlIHRoZVxuICAvLyBibG9jayBiZWxvdyB0byBqdW1wIHVwIGludG8gdGhlIHBsYWNlIG9mIHRoZSByZW1vdmVkIGJsb2NrIHdoZW4gY2xpY2tlZCxcbiAgLy8gYWxsb3dpbmcgdGhlIHVzZXIgdG8gY2xpY2sgdGhlIGJ1dHRvbiBhZ2FpbiB3aXRob3V0IG1vdmluZyB0aGUgY3Vyc29yLiBUaGlzXG4gIC8vIHdvdWxkIG90aGVyd2lzZSBub3QgdXBkYXRlIHRoZSBzaWRlIG1lbnUsIGFuZCBzbyBjbGlja2luZyB0aGUgYnV0dG9uIGFnYWluXG4gIC8vIHdvdWxkIGF0dGVtcHQgdG8gcmVtb3ZlIHRoZSBzYW1lIGJsb2NrIGFnYWluLCBjYXVzaW5nIGFuIGVycm9yLlxuICB1cGRhdGUobywgdCkge1xuICAgIHZhciByO1xuICAgICF0LmRvYy5lcSh0aGlzLnBtVmlldy5zdGF0ZS5kb2MpICYmICgociA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgci5zaG93KSAmJiB0aGlzLnVwZGF0ZVN0YXRlRnJvbU1vdXNlUG9zKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgbztcbiAgICAobyA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgby5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKHRoaXMuc3RhdGUpKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgIHRoaXMub25Nb3VzZU1vdmUsXG4gICAgICAhMFxuICAgICksIHRoaXMucG1WaWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiZHJhZ3N0YXJ0XCIsXG4gICAgICB0aGlzLm9uRHJhZ1N0YXJ0XG4gICAgKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJkcmFnb3ZlclwiLFxuICAgICAgdGhpcy5vbkRyYWdPdmVyXG4gICAgKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJkcm9wXCIsXG4gICAgICB0aGlzLm9uRHJvcCxcbiAgICAgICEwXG4gICAgKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJkcmFnZW5kXCIsXG4gICAgICB0aGlzLm9uRHJhZ0VuZCxcbiAgICAgICEwXG4gICAgKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLm9uS2V5RG93bixcbiAgICAgICEwXG4gICAgKSwgdGhpcy5wbVZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwsICEwKTtcbiAgfVxufVxuY29uc3QgUWkgPSBuZXcgTihcIlNpZGVNZW51UGx1Z2luXCIpO1xuY2xhc3MgZWEgZXh0ZW5kcyBxIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKCk7XG4gICAgdSh0aGlzLCBcInZpZXdcIik7XG4gICAgdSh0aGlzLCBcInBsdWdpblwiKTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGRyYWcgJiBkcm9wIGV2ZW50cyBmb3IgYmxvY2tzLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJibG9ja0RyYWdTdGFydFwiLCAodCwgbikgPT4ge1xuICAgICAgdGhpcy52aWV3ICYmICh0aGlzLnZpZXcuaXNEcmFnT3JpZ2luID0gITApLCBKaSh0LCBuLCB0aGlzLmVkaXRvcik7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBkcmFnICYgZHJvcCBldmVudHMgZm9yIGJsb2Nrcy5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiYmxvY2tEcmFnRW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yLnByb3NlbWlycm9yVmlldyAmJiBPbyh0aGlzLmVkaXRvci5wcm9zZW1pcnJvclZpZXcucm9vdCksIHRoaXMudmlldyAmJiAodGhpcy52aWV3LmlzRHJhZ09yaWdpbiA9ICExKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGcmVlemVzIHRoZSBzaWRlIG1lbnUuIFdoZW4gZnJvemVuLCB0aGUgc2lkZSBtZW51IHdpbGwgc3RheVxuICAgICAqIGF0dGFjaGVkIHRvIHRoZSBzYW1lIGJsb2NrIHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggYmxvY2sgaXMgaG92ZXJlZCBieSB0aGVcbiAgICAgKiBtb3VzZSBjdXJzb3IuXG4gICAgICovXG4gICAgdSh0aGlzLCBcImZyZWV6ZU1lbnVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy52aWV3Lm1lbnVGcm96ZW4gPSAhMCwgdGhpcy52aWV3LnN0YXRlLnNob3cgPSAhMCwgdGhpcy52aWV3LmVtaXRVcGRhdGUodGhpcy52aWV3LnN0YXRlKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVbmZyZWV6ZXMgdGhlIHNpZGUgbWVudS4gV2hlbiBmcm96ZW4sIHRoZSBzaWRlIG1lbnUgd2lsbCBzdGF5XG4gICAgICogYXR0YWNoZWQgdG8gdGhlIHNhbWUgYmxvY2sgcmVnYXJkbGVzcyBvZiB3aGljaCBibG9jayBpcyBob3ZlcmVkIGJ5IHRoZVxuICAgICAqIG1vdXNlIGN1cnNvci5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwidW5mcmVlemVNZW51XCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlldy5tZW51RnJvemVuID0gITEsIHRoaXMudmlldy5zdGF0ZS5zaG93ID0gITEsIHRoaXMudmlldy5lbWl0VXBkYXRlKHRoaXMudmlldy5zdGF0ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSB0LCB0aGlzLnBsdWdpbiA9IG5ldyBNKHtcbiAgICAgIGtleTogUWksXG4gICAgICB2aWV3OiAocikgPT4gKHRoaXMudmlldyA9IG5ldyBaaShcbiAgICAgICAgdCxcbiAgICAgICAgbixcbiAgICAgICAgcixcbiAgICAgICAgKHMpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgcyk7XG4gICAgICAgIH1cbiAgICAgICksIHRoaXMudmlldylcbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMub24oXCJ1cGRhdGVcIiwgdCk7XG4gIH1cbn1cbmNvbnN0IE1lID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHRhKGUpIHtcbiAgaWYgKE1lLmhhcyhlKSlcbiAgICByZXR1cm4gTWUuZ2V0KGUpO1xuICBjb25zdCBvID0gbmV3IHpvKCk7XG4gIHJldHVybiBlLl90aXB0YXBFZGl0b3Iub24oXCJ0cmFuc2FjdGlvblwiLCAoeyB0cmFuc2FjdGlvbjogdCB9KSA9PiB7XG4gICAgby5hcHBlbmRNYXBwaW5nKHQubWFwcGluZyk7XG4gIH0pLCBlLl90aXB0YXBFZGl0b3Iub24oXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICBNZS5kZWxldGUoZSk7XG4gIH0pLCBNZS5zZXQoZSwgbyksIG87XG59XG5mdW5jdGlvbiBvYShlLCBvLCB0ID0gXCJsZWZ0XCIpIHtcbiAgY29uc3QgbiA9IE5lLmdldFN0YXRlKGUucHJvc2VtaXJyb3JTdGF0ZSk7XG4gIGlmICghbikge1xuICAgIGNvbnN0IHMgPSB0YShlKSwgaSA9IHMubWFwcy5sZW5ndGg7XG4gICAgcmV0dXJuICgpID0+IHMuc2xpY2UoaSkubWFwKG8sIHQgPT09IFwibGVmdFwiID8gLTEgOiAxKTtcbiAgfVxuICBjb25zdCByID0gTG4oXG4gICAgLy8gVHJhY2sgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBwb3NpdGlvbiBpZiB3ZSBhcmUgb24gdGhlIHJpZ2h0IHNpZGVcbiAgICBvICsgKHQgPT09IFwicmlnaHRcIiA/IDEgOiAwKSxcbiAgICBuLmJpbmRpbmcudHlwZSxcbiAgICBuLmJpbmRpbmcubWFwcGluZ1xuICApO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHMgPSBOZS5nZXRTdGF0ZShcbiAgICAgIGUucHJvc2VtaXJyb3JTdGF0ZVxuICAgICksIGkgPSBBbihcbiAgICAgIHMuZG9jLFxuICAgICAgcy5iaW5kaW5nLnR5cGUsXG4gICAgICByLFxuICAgICAgcy5iaW5kaW5nLm1hcHBpbmdcbiAgICApO1xuICAgIGlmIChpID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpb24gbm90IGZvdW5kLCBjYW5ub3QgdHJhY2sgcG9zaXRpb25zXCIpO1xuICAgIHJldHVybiBpICsgKHQgPT09IFwicmlnaHRcIiA/IC0xIDogMCk7XG4gIH07XG59XG5jb25zdCBuYSA9IEpvKChlKSA9PiBlLnR5cGUubmFtZSA9PT0gXCJibG9ja0NvbnRhaW5lclwiKTtcbmNsYXNzIHJhIHtcbiAgY29uc3RydWN0b3IobywgdCkge1xuICAgIHUodGhpcywgXCJzdGF0ZVwiKTtcbiAgICB1KHRoaXMsIFwiZW1pdFVwZGF0ZVwiKTtcbiAgICB1KHRoaXMsIFwicm9vdEVsXCIpO1xuICAgIHUodGhpcywgXCJwbHVnaW5TdGF0ZVwiKTtcbiAgICB1KHRoaXMsIFwiaGFuZGxlU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHZhciBvLCB0O1xuICAgICAgaWYgKChvID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBvLnNob3cpIHtcbiAgICAgICAgY29uc3QgbiA9ICh0ID0gdGhpcy5yb290RWwpID09IG51bGwgPyB2b2lkIDAgOiB0LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3RoaXMucGx1Z2luU3RhdGUuZGVjb3JhdGlvbklkfVwiXWBcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3MgPSBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLmVtaXRVcGRhdGUodGhpcy5wbHVnaW5TdGF0ZS50cmlnZ2VyQ2hhcmFjdGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1KHRoaXMsIFwiY2xvc2VNZW51XCIsICgpID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoKFxuICAgICAgICB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyLnNldE1ldGEoZGUsIG51bGwpXG4gICAgICApO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJjbGVhclF1ZXJ5XCIsICgpID0+IHtcbiAgICAgIHRoaXMucGx1Z2luU3RhdGUgIT09IHZvaWQgMCAmJiB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLmNoYWluKCkuZm9jdXMoKS5kZWxldGVSYW5nZSh7XG4gICAgICAgIGZyb206IHRoaXMucGx1Z2luU3RhdGUucXVlcnlTdGFydFBvcygpIC0gKHRoaXMucGx1Z2luU3RhdGUuZGVsZXRlVHJpZ2dlckNoYXJhY3RlciA/IHRoaXMucGx1Z2luU3RhdGUudHJpZ2dlckNoYXJhY3Rlci5sZW5ndGggOiAwKSxcbiAgICAgICAgdG86IHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb21cbiAgICAgIH0pLnJ1bigpO1xuICAgIH0pO1xuICAgIHZhciBuLCByO1xuICAgIHRoaXMuZWRpdG9yID0gbywgdGhpcy5wbHVnaW5TdGF0ZSA9IHZvaWQgMCwgdGhpcy5lbWl0VXBkYXRlID0gKHMpID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHVwZGF0ZSB1bmluaXRpYWxpemVkIHN1Z2dlc3Rpb25zIG1lbnVcIik7XG4gICAgICB0KHMsIHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgaWdub3JlUXVlcnlMZW5ndGg6IChpID0gdGhpcy5wbHVnaW5TdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaWdub3JlUXVlcnlMZW5ndGhcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMucm9vdEVsID0gKG4gPSB0aGlzLmVkaXRvci5wcm9zZW1pcnJvclZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBuLnJvb3QsIChyID0gdGhpcy5yb290RWwpID09IG51bGwgfHwgci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlU2Nyb2xsLCAhMCk7XG4gIH1cbiAgdXBkYXRlKG8sIHQpIHtcbiAgICB2YXIgbDtcbiAgICBjb25zdCBuID0gZGUuZ2V0U3RhdGUodCksIHIgPSBkZS5nZXRTdGF0ZShcbiAgICAgIG8uc3RhdGVcbiAgICApLCBzID0gbiA9PT0gdm9pZCAwICYmIHIgIT09IHZvaWQgMCwgaSA9IG4gIT09IHZvaWQgMCAmJiByID09PSB2b2lkIDA7XG4gICAgaWYgKCFzICYmICEobiAhPT0gdm9pZCAwICYmIHIgIT09IHZvaWQgMCkgJiYgIWkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucGx1Z2luU3RhdGUgPSBpID8gbiA6IHIsIGkgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExKSwgdGhpcy5lbWl0VXBkYXRlKHRoaXMucGx1Z2luU3RhdGUudHJpZ2dlckNoYXJhY3Rlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGMgPSAobCA9IHRoaXMucm9vdEVsKSA9PSBudWxsID8gdm9pZCAwIDogbC5xdWVyeVNlbGVjdG9yKFxuICAgICAgYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3RoaXMucGx1Z2luU3RhdGUuZGVjb3JhdGlvbklkfVwiXWBcbiAgICApO1xuICAgIHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgJiYgYyAmJiAodGhpcy5zdGF0ZSA9IHtcbiAgICAgIHNob3c6ICEwLFxuICAgICAgcmVmZXJlbmNlUG9zOiBjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgcXVlcnk6IHRoaXMucGx1Z2luU3RhdGUucXVlcnlcbiAgICB9LCB0aGlzLmVtaXRVcGRhdGUodGhpcy5wbHVnaW5TdGF0ZS50cmlnZ2VyQ2hhcmFjdGVyKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgbztcbiAgICAobyA9IHRoaXMucm9vdEVsKSA9PSBudWxsIHx8IG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVNjcm9sbCwgITApO1xuICB9XG59XG5jb25zdCBkZSA9IG5ldyBOKFwiU3VnZ2VzdGlvbk1lbnVQbHVnaW5cIik7XG5jbGFzcyBzYSBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB1KHRoaXMsIFwidmlld1wiKTtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIHUodGhpcywgXCJ0cmlnZ2VyQ2hhcmFjdGVyc1wiLCBbXSk7XG4gICAgdSh0aGlzLCBcImFkZFRyaWdnZXJDaGFyYWN0ZXJcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlckNoYXJhY3RlcnMucHVzaCh0KTtcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBiZSBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIGxpc3RlbmVycyBhcmUgcmVtb3ZlZD9cbiAgICB1KHRoaXMsIFwicmVtb3ZlVHJpZ2dlckNoYXJhY3RlclwiLCAodCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyQ2hhcmFjdGVycyA9IHRoaXMudHJpZ2dlckNoYXJhY3RlcnMuZmlsdGVyKFxuICAgICAgICAobikgPT4gbiAhPT0gdFxuICAgICAgKTtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwiY2xvc2VNZW51XCIsICgpID0+IHRoaXMudmlldy5jbG9zZU1lbnUoKSk7XG4gICAgdSh0aGlzLCBcImNsZWFyUXVlcnlcIiwgKCkgPT4gdGhpcy52aWV3LmNsZWFyUXVlcnkoKSk7XG4gICAgY29uc3QgbiA9IHRoaXMudHJpZ2dlckNoYXJhY3RlcnM7XG4gICAgdGhpcy5wbHVnaW4gPSBuZXcgTSh7XG4gICAgICBrZXk6IGRlLFxuICAgICAgdmlldzogKCkgPT4gKHRoaXMudmlldyA9IG5ldyByYShcbiAgICAgICAgdCxcbiAgICAgICAgKHIsIHMpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoYHVwZGF0ZSAke3J9YCwgcyk7XG4gICAgICAgIH1cbiAgICAgICksIHRoaXMudmlldyksXG4gICAgICBzdGF0ZToge1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBwbHVnaW4ncyBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQXBwbHkgY2hhbmdlcyB0byB0aGUgcGx1Z2luIHN0YXRlIGZyb20gYW4gZWRpdG9yIHRyYW5zYWN0aW9uLlxuICAgICAgICBhcHBseShyLCBzLCBpLCBhKSB7XG4gICAgICAgICAgaWYgKHIuZ2V0TWV0YShcIm9yZGVyZWRMaXN0SW5kZXhpbmdcIikgIT09IHZvaWQgMCB8fCByLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUpXG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICBjb25zdCBjID0gci5nZXRNZXRhKGRlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJvYmplY3RcIiAmJiBjICE9PSBudWxsICYmIHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IG9hKFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICBhLnNlbGVjdGlvbi5mcm9tIC0gLy8gTmVlZCB0byBhY2NvdW50IGZvciB0aGUgdHJpZ2dlciBjaGFyIHRoYXQgd2FzIGluc2VydGVkLCBzbyB3ZSBvZmZzZXQgdGhlIHBvc2l0aW9uIGJ5IHRoZSBsZW5ndGggb2YgdGhlIHRyaWdnZXIgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICBjLnRyaWdnZXJDaGFyYWN0ZXIubGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHJpZ2dlckNoYXJhY3RlcjogYy50cmlnZ2VyQ2hhcmFjdGVyLFxuICAgICAgICAgICAgICBkZWxldGVUcmlnZ2VyQ2hhcmFjdGVyOiBjLmRlbGV0ZVRyaWdnZXJDaGFyYWN0ZXIgIT09ICExLFxuICAgICAgICAgICAgICAvLyBXaGVuIHJlYWRpbmcgdGhlIHF1ZXJ5U3RhcnRQb3MsIHdlIG9mZnNldCB0aGUgcmVzdWx0IGJ5IHRoZSBsZW5ndGggb2YgdGhlIHRyaWdnZXIgY2hhcmFjdGVyLCB0byBtYWtlIGl0IGVhc3kgb24gdGhlIGNhbGxlclxuICAgICAgICAgICAgICBxdWVyeVN0YXJ0UG9zOiAoKSA9PiBkKCkgKyBjLnRyaWdnZXJDaGFyYWN0ZXIubGVuZ3RoLFxuICAgICAgICAgICAgICBxdWVyeTogXCJcIixcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbklkOiBgaWRfJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1KX1gLFxuICAgICAgICAgICAgICBpZ25vcmVRdWVyeUxlbmd0aDogYyA9PSBudWxsID8gdm9pZCAwIDogYy5pZ25vcmVRdWVyeUxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodGluZyB0ZXh0IHNob3VsZCBoaWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgYS5zZWxlY3Rpb24uZnJvbSAhPT0gYS5zZWxlY3Rpb24udG8gfHwgLy8gVHJhbnNhY3Rpb25zIHdpdGggcGx1Z2luIG1ldGFkYXRhIHNob3VsZCBoaWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgYyA9PT0gbnVsbCB8fCAvLyBDZXJ0YWluIG1vdXNlIGV2ZW50cyBzaG91bGQgaGlkZSB0aGUgbWVudS5cbiAgICAgICAgICAgIC8vIFRPRE86IENoYW5nZSB0byBnbG9iYWwgbW91c2Vkb3duIGxpc3RlbmVyLlxuICAgICAgICAgICAgci5nZXRNZXRhKFwiZm9jdXNcIikgfHwgci5nZXRNZXRhKFwiYmx1clwiKSB8fCByLmdldE1ldGEoXCJwb2ludGVyXCIpIHx8IC8vIE1vdmluZyB0aGUgY2FyZXQgYmVmb3JlIHRoZSBjaGFyYWN0ZXIgd2hpY2ggdHJpZ2dlcmVkIHRoZSBtZW51IHNob3VsZCBoaWRlIGl0LlxuICAgICAgICAgICAgcy50cmlnZ2VyQ2hhcmFjdGVyICE9PSB2b2lkIDAgJiYgYS5zZWxlY3Rpb24uZnJvbSA8IHMucXVlcnlTdGFydFBvcygpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGwgPSB7IC4uLnMgfTtcbiAgICAgICAgICByZXR1cm4gbC5xdWVyeSA9IGEuZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICAgICAgcy5xdWVyeVN0YXJ0UG9zKCksXG4gICAgICAgICAgICBhLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKSwgbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhhbmRsZVRleHRJbnB1dChyLCBzLCBpLCBhKSB7XG4gICAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0U3RhdGUoci5zdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIG4uaW5jbHVkZXMoYSkgJiYgYyA9PT0gdm9pZCAwID8gKHIuZGlzcGF0Y2goXG4gICAgICAgICAgICByLnN0YXRlLnRyLmluc2VydFRleHQoYSkuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKGRlLCB7XG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFyYWN0ZXI6IGFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSwgITApIDogITE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldHVwIGRlY29yYXRvciBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzdWdnZXN0aW9uLlxuICAgICAgICBkZWNvcmF0aW9ucyhyKSB7XG4gICAgICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0U3RhdGUocik7XG4gICAgICAgICAgaWYgKHMgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIGlmICghcy5kZWxldGVUcmlnZ2VyQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gbmEoci5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgIHJldHVybiBVLmNyZWF0ZShyLmRvYywgW1xuICAgICAgICAgICAgICAgIEcubm9kZShcbiAgICAgICAgICAgICAgICAgIGkucG9zLFxuICAgICAgICAgICAgICAgICAgaS5wb3MgKyBpLm5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiYm4tc3VnZ2VzdGlvbi1kZWNvcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLWRlY29yYXRpb24taWRcIjogcy5kZWNvcmF0aW9uSWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gVS5jcmVhdGUoci5kb2MsIFtcbiAgICAgICAgICAgIEcuaW5saW5lKFxuICAgICAgICAgICAgICBzLnF1ZXJ5U3RhcnRQb3MoKSAtIHMudHJpZ2dlckNoYXJhY3Rlci5sZW5ndGgsXG4gICAgICAgICAgICAgIHMucXVlcnlTdGFydFBvcygpLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBcImJuLXN1Z2dlc3Rpb24tZGVjb3JhdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkYXRhLWRlY29yYXRpb24taWRcIjogcy5kZWNvcmF0aW9uSWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25VcGRhdGUodCwgbikge1xuICAgIHJldHVybiB0aGlzLnRyaWdnZXJDaGFyYWN0ZXJzLmluY2x1ZGVzKHQpIHx8IHRoaXMuYWRkVHJpZ2dlckNoYXJhY3Rlcih0KSwgdGhpcy5vbihgdXBkYXRlICR7dH1gLCBuKTtcbiAgfVxuICBnZXQgc2hvd24oKSB7XG4gICAgdmFyIHQsIG47XG4gICAgcmV0dXJuICgobiA9ICh0ID0gdGhpcy52aWV3KSA9PSBudWxsID8gdm9pZCAwIDogdC5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2hvdykgfHwgITE7XG4gIH1cbn1cbmZ1bmN0aW9uIGJjKGUsIG8pIHtcbiAgZS5zdWdnZXN0aW9uTWVudXMuYWRkVHJpZ2dlckNoYXJhY3RlcihvKTtcbn1cbmxldCBBO1xuZnVuY3Rpb24gVXQoZSkge1xuICBBIHx8IChBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgQS5pbm5lckhUTUwgPSBcIl9cIiwgQS5zdHlsZS5vcGFjaXR5ID0gXCIwXCIsIEEuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIiwgQS5zdHlsZS53aWR0aCA9IFwiMXB4XCIsIGUgaW5zdGFuY2VvZiBEb2N1bWVudCA/IGUuYm9keS5hcHBlbmRDaGlsZChBKSA6IGUuYXBwZW5kQ2hpbGQoQSkpO1xufVxuZnVuY3Rpb24gaWEoZSkge1xuICBBICYmIChlIGluc3RhbmNlb2YgRG9jdW1lbnQgPyBlLmJvZHkucmVtb3ZlQ2hpbGQoQSkgOiBlLnJlbW92ZUNoaWxkKEEpLCBBID0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIFBlKGUpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZS5wYXJlbnRFbGVtZW50LmNoaWxkTm9kZXMsIGUpO1xufVxuZnVuY3Rpb24gYWEoZSkge1xuICBsZXQgbyA9IGU7XG4gIGZvciAoOyBvICYmIG8ubm9kZU5hbWUgIT09IFwiVERcIiAmJiBvLm5vZGVOYW1lICE9PSBcIlRIXCIgJiYgIW8uY2xhc3NMaXN0LmNvbnRhaW5zKFwidGFibGVXcmFwcGVyXCIpOyApIHtcbiAgICBpZiAoby5jbGFzc0xpc3QuY29udGFpbnMoXCJQcm9zZU1pcnJvclwiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gby5wYXJlbnROb2RlO1xuICAgIGlmICghdCB8fCAhKHQgaW5zdGFuY2VvZiBFbGVtZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBvID0gdDtcbiAgfVxuICByZXR1cm4gby5ub2RlTmFtZSA9PT0gXCJURFwiIHx8IG8ubm9kZU5hbWUgPT09IFwiVEhcIiA/IHtcbiAgICB0eXBlOiBcImNlbGxcIixcbiAgICBkb21Ob2RlOiBvLFxuICAgIHRib2R5Tm9kZTogby5jbG9zZXN0KFwidGJvZHlcIilcbiAgfSA6IHtcbiAgICB0eXBlOiBcIndyYXBwZXJcIixcbiAgICBkb21Ob2RlOiBvLFxuICAgIHRib2R5Tm9kZTogby5xdWVyeVNlbGVjdG9yKFwidGJvZHlcIilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhKGUsIG8pIHtcbiAgY29uc3QgdCA9IG8ucXVlcnlTZWxlY3RvckFsbChlKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgIHRbbl0uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG59XG5jbGFzcyBsYSB7XG4gIGNvbnN0cnVjdG9yKG8sIHQsIG4pIHtcbiAgICB1KHRoaXMsIFwic3RhdGVcIik7XG4gICAgdSh0aGlzLCBcImVtaXRVcGRhdGVcIik7XG4gICAgdSh0aGlzLCBcInRhYmxlSWRcIik7XG4gICAgdSh0aGlzLCBcInRhYmxlUG9zXCIpO1xuICAgIHUodGhpcywgXCJ0YWJsZUVsZW1lbnRcIik7XG4gICAgdSh0aGlzLCBcIm1lbnVGcm96ZW5cIiwgITEpO1xuICAgIHUodGhpcywgXCJtb3VzZVN0YXRlXCIsIFwidXBcIik7XG4gICAgdSh0aGlzLCBcInByZXZXYXNFZGl0YWJsZVwiLCBudWxsKTtcbiAgICB1KHRoaXMsIFwidmlld01vdXNlZG93bkhhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5tb3VzZVN0YXRlID0gXCJkb3duXCI7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcIm1vdXNlVXBIYW5kbGVyXCIsIChvKSA9PiB7XG4gICAgICB0aGlzLm1vdXNlU3RhdGUgPSBcInVwXCIsIHRoaXMubW91c2VNb3ZlSGFuZGxlcihvKTtcbiAgICB9KTtcbiAgICB1KHRoaXMsIFwibW91c2VNb3ZlSGFuZGxlclwiLCAobykgPT4ge1xuICAgICAgdmFyIGwsIGQsIHAsIGgsIGYsIG0sIGc7XG4gICAgICBpZiAodGhpcy5tZW51RnJvemVuIHx8IHRoaXMubW91c2VTdGF0ZSA9PT0gXCJzZWxlY3RpbmdcIiB8fCAhKG8udGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkgfHwgIXRoaXMucG1WaWV3LmRvbS5jb250YWlucyhvLnRhcmdldCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHQgPSBhYShvLnRhcmdldCk7XG4gICAgICBpZiAoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQudHlwZSkgPT09IFwiY2VsbFwiICYmIHRoaXMubW91c2VTdGF0ZSA9PT0gXCJkb3duXCIgJiYgISgobCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgbC5kcmFnZ2luZ1N0YXRlKSkge1xuICAgICAgICB0aGlzLm1vdXNlU3RhdGUgPSBcInNlbGVjdGluZ1wiLCAoZCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgZC5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5zdGF0ZS5zaG93QWRkT3JSZW1vdmVSb3dzQnV0dG9uID0gITEsIHRoaXMuc3RhdGUuc2hvd0FkZE9yUmVtb3ZlQ29sdW1uc0J1dHRvbiA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdCB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICAocCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgcC5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5zdGF0ZS5zaG93QWRkT3JSZW1vdmVSb3dzQnV0dG9uID0gITEsIHRoaXMuc3RhdGUuc2hvd0FkZE9yUmVtb3ZlQ29sdW1uc0J1dHRvbiA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdC50Ym9keU5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSB0LnRib2R5Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgciA9IERvKHQuZG9tTm9kZSwgdGhpcy5wbVZpZXcpO1xuICAgICAgaWYgKCFyKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnRhYmxlRWxlbWVudCA9IHIubm9kZTtcbiAgICAgIGxldCBzO1xuICAgICAgY29uc3QgaSA9IEQoXG4gICAgICAgIHIuaWQsXG4gICAgICAgIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jXG4gICAgICApO1xuICAgICAgaWYgKCFpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggSUQgJHtyLmlkfSBub3QgZm91bmRgKTtcbiAgICAgIGNvbnN0IGEgPSBFKFxuICAgICAgICBpLm5vZGUsXG4gICAgICAgIHRoaXMuZWRpdG9yLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICAgIHRoaXMuZWRpdG9yLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgICAgdGhpcy5lZGl0b3IuYmxvY2tDYWNoZVxuICAgICAgKTtcbiAgICAgIGlmIChDcyhcInRhYmxlXCIsIGEsIHRoaXMuZWRpdG9yKSAmJiAodGhpcy50YWJsZVBvcyA9IGkucG9zQmVmb3JlTm9kZSArIDEsIHMgPSBhKSwgIXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMudGFibGVJZCA9IHIuaWQ7XG4gICAgICBjb25zdCBjID0gKGggPSB0LmRvbU5vZGUuY2xvc2VzdChcIi50YWJsZVdyYXBwZXJcIikpID09IG51bGwgPyB2b2lkIDAgOiBoLnF1ZXJ5U2VsZWN0b3IoXCIudGFibGUtd2lkZ2V0cy1jb250YWluZXJcIik7XG4gICAgICBpZiAoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQudHlwZSkgPT09IFwid3JhcHBlclwiKSB7XG4gICAgICAgIGNvbnN0IGIgPSBvLmNsaWVudFkgPj0gbi5ib3R0b20gLSAxICYmIC8vIC0xIHRvIGFjY291bnQgZm9yIGZyYWN0aW9ucyBvZiBwaXhlbHMgaW4gXCJib3R0b21cIlxuICAgICAgICBvLmNsaWVudFkgPCBuLmJvdHRvbSArIDIwLCBrID0gby5jbGllbnRYID49IG4ucmlnaHQgLSAxICYmIG8uY2xpZW50WCA8IG4ucmlnaHQgKyAyMCwgdyA9IG8uY2xpZW50WCA+IG4ucmlnaHQgfHwgby5jbGllbnRZID4gbi5ib3R0b207XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgICBzaG93OiAhMCxcbiAgICAgICAgICBzaG93QWRkT3JSZW1vdmVSb3dzQnV0dG9uOiBiLFxuICAgICAgICAgIHNob3dBZGRPclJlbW92ZUNvbHVtbnNCdXR0b246IGssXG4gICAgICAgICAgcmVmZXJlbmNlUG9zVGFibGU6IG4sXG4gICAgICAgICAgYmxvY2s6IHMsXG4gICAgICAgICAgd2lkZ2V0Q29udGFpbmVyOiBjLFxuICAgICAgICAgIGNvbEluZGV4OiB3IHx8IChmID0gdGhpcy5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuY29sSW5kZXgsXG4gICAgICAgICAgcm93SW5kZXg6IHcgfHwgKG0gPSB0aGlzLnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogbS5yb3dJbmRleCxcbiAgICAgICAgICByZWZlcmVuY2VQb3NDZWxsOiB3IHx8IChnID0gdGhpcy5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGcucmVmZXJlbmNlUG9zQ2VsbFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYiA9IFBlKHQuZG9tTm9kZSksIGsgPSBQZSh0LmRvbU5vZGUucGFyZW50RWxlbWVudCksIHcgPSB0LmRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB2b2lkIDAgJiYgdGhpcy5zdGF0ZS5zaG93ICYmIHRoaXMudGFibGVJZCA9PT0gci5pZCAmJiB0aGlzLnN0YXRlLnJvd0luZGV4ID09PSBrICYmIHRoaXMuc3RhdGUuY29sSW5kZXggPT09IGIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgIHNob3c6ICEwLFxuICAgICAgICAgIHNob3dBZGRPclJlbW92ZUNvbHVtbnNCdXR0b246IGIgPT09IHMuY29udGVudC5yb3dzWzBdLmNlbGxzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgc2hvd0FkZE9yUmVtb3ZlUm93c0J1dHRvbjogayA9PT0gcy5jb250ZW50LnJvd3MubGVuZ3RoIC0gMSxcbiAgICAgICAgICByZWZlcmVuY2VQb3NUYWJsZTogbixcbiAgICAgICAgICBibG9jazogcyxcbiAgICAgICAgICBkcmFnZ2luZ1N0YXRlOiB2b2lkIDAsXG4gICAgICAgICAgcmVmZXJlbmNlUG9zQ2VsbDogdyxcbiAgICAgICAgICBjb2xJbmRleDogYixcbiAgICAgICAgICByb3dJbmRleDogayxcbiAgICAgICAgICB3aWRnZXRDb250YWluZXI6IGNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXRVcGRhdGUoKSwgITE7XG4gICAgfSk7XG4gICAgdSh0aGlzLCBcImRyYWdPdmVySGFuZGxlclwiLCAobykgPT4ge1xuICAgICAgdmFyIGg7XG4gICAgICBpZiAoKChoID0gdGhpcy5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGguZHJhZ2dpbmdTdGF0ZSkgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgby5wcmV2ZW50RGVmYXVsdCgpLCBvLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJtb3ZlXCIsIGNhKFxuICAgICAgICBcIi5wcm9zZW1pcnJvci1kcm9wY3Vyc29yLWJsb2NrLCAucHJvc2VtaXJyb3ItZHJvcGN1cnNvci1pbmxpbmVcIixcbiAgICAgICAgdGhpcy5wbVZpZXcucm9vdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQgPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KG8uY2xpZW50WCwgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3NUYWJsZS5sZWZ0ICsgMSksXG4gICAgICAgICAgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3NUYWJsZS5yaWdodCAtIDFcbiAgICAgICAgKSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihcbiAgICAgICAgICBNYXRoLm1heChvLmNsaWVudFksIHRoaXMuc3RhdGUucmVmZXJlbmNlUG9zVGFibGUudG9wICsgMSksXG4gICAgICAgICAgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3NUYWJsZS5ib3R0b20gLSAxXG4gICAgICAgIClcbiAgICAgIH0sIG4gPSB0aGlzLnBtVmlldy5yb290LmVsZW1lbnRzRnJvbVBvaW50KHQubGVmdCwgdC50b3ApLmZpbHRlcihcbiAgICAgICAgKGYpID0+IGYudGFnTmFtZSA9PT0gXCJURFwiIHx8IGYudGFnTmFtZSA9PT0gXCJUSFwiXG4gICAgICApO1xuICAgICAgaWYgKG4ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gblswXTtcbiAgICAgIGxldCBzID0gITE7XG4gICAgICBjb25zdCBpID0gUGUoci5wYXJlbnRFbGVtZW50KSwgYSA9IFBlKHIpLCBjID0gdGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLmRyYWdnZWRDZWxsT3JpZW50YXRpb24gPT09IFwicm93XCIgPyB0aGlzLnN0YXRlLnJvd0luZGV4IDogdGhpcy5zdGF0ZS5jb2xJbmRleCwgZCA9ICh0aGlzLnN0YXRlLmRyYWdnaW5nU3RhdGUuZHJhZ2dlZENlbGxPcmllbnRhdGlvbiA9PT0gXCJyb3dcIiA/IGkgOiBhKSAhPT0gYztcbiAgICAgICh0aGlzLnN0YXRlLnJvd0luZGV4ICE9PSBpIHx8IHRoaXMuc3RhdGUuY29sSW5kZXggIT09IGEpICYmICh0aGlzLnN0YXRlLnJvd0luZGV4ID0gaSwgdGhpcy5zdGF0ZS5jb2xJbmRleCA9IGEsIHRoaXMuc3RhdGUucmVmZXJlbmNlUG9zQ2VsbCA9IHIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHMgPSAhMCk7XG4gICAgICBjb25zdCBwID0gdGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLmRyYWdnZWRDZWxsT3JpZW50YXRpb24gPT09IFwicm93XCIgPyB0LnRvcCA6IHQubGVmdDtcbiAgICAgIHRoaXMuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5tb3VzZVBvcyAhPT0gcCAmJiAodGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLm1vdXNlUG9zID0gcCwgcyA9ICEwKSwgcyAmJiB0aGlzLmVtaXRVcGRhdGUoKSwgZCAmJiB0aGlzLmVkaXRvci5kaXNwYXRjaChcbiAgICAgICAgdGhpcy5wbVZpZXcuc3RhdGUudHIuc2V0TWV0YShmZSwgITApXG4gICAgICApO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJkcm9wSGFuZGxlclwiLCAobykgPT4ge1xuICAgICAgaWYgKHRoaXMubW91c2VTdGF0ZSA9IFwidXBcIiwgdGhpcy5zdGF0ZSA9PT0gdm9pZCAwIHx8IHRoaXMuc3RhdGUuZHJhZ2dpbmdTdGF0ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5yb3dJbmRleCA9PT0gdm9pZCAwIHx8IHRoaXMuc3RhdGUuY29sSW5kZXggPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQXR0ZW1wdGVkIHRvIGRyb3AgdGFibGUgcm93IG9yIGNvbHVtbiwgYnV0IG5vIHRhYmxlIGJsb2NrIHdhcyBob3ZlcmVkIHByaW9yLlwiXG4gICAgICAgICk7XG4gICAgICBvLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB7IGRyYWdnaW5nU3RhdGU6IHQsIGNvbEluZGV4OiBuLCByb3dJbmRleDogciB9ID0gdGhpcy5zdGF0ZSwgcyA9IHRoaXMuc3RhdGUuYmxvY2suY29udGVudC5jb2x1bW5XaWR0aHM7XG4gICAgICBpZiAodC5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uID09PSBcInJvd1wiKSB7XG4gICAgICAgIGlmICghdG8oXG4gICAgICAgICAgdGhpcy5zdGF0ZS5ibG9jayxcbiAgICAgICAgICB0Lm9yaWdpbmFsSW5kZXgsXG4gICAgICAgICAgclxuICAgICAgICApKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgaSA9IFhuKFxuICAgICAgICAgIHRoaXMuc3RhdGUuYmxvY2ssXG4gICAgICAgICAgdC5vcmlnaW5hbEluZGV4LFxuICAgICAgICAgIHJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lZGl0b3IudXBkYXRlQmxvY2sodGhpcy5zdGF0ZS5ibG9jaywge1xuICAgICAgICAgIHR5cGU6IFwidGFibGVcIixcbiAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlLmJsb2NrLmNvbnRlbnQsXG4gICAgICAgICAgICByb3dzOiBpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb28oXG4gICAgICAgICAgdGhpcy5zdGF0ZS5ibG9jayxcbiAgICAgICAgICB0Lm9yaWdpbmFsSW5kZXgsXG4gICAgICAgICAgblxuICAgICAgICApKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgaSA9IEtuKFxuICAgICAgICAgIHRoaXMuc3RhdGUuYmxvY2ssXG4gICAgICAgICAgdC5vcmlnaW5hbEluZGV4LFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgW2FdID0gcy5zcGxpY2UodC5vcmlnaW5hbEluZGV4LCAxKTtcbiAgICAgICAgcy5zcGxpY2UobiwgMCwgYSksIHRoaXMuZWRpdG9yLnVwZGF0ZUJsb2NrKHRoaXMuc3RhdGUuYmxvY2ssIHtcbiAgICAgICAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZS5ibG9jay5jb250ZW50LFxuICAgICAgICAgICAgY29sdW1uV2lkdGhzOiBzLFxuICAgICAgICAgICAgcm93czogaVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3Iuc2V0VGV4dEN1cnNvclBvc2l0aW9uKHRoaXMuc3RhdGUuYmxvY2suaWQpLCAhMDtcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IG8sIHRoaXMucG1WaWV3ID0gdCwgdGhpcy5lbWl0VXBkYXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHVwZGF0ZSB1bmluaXRpYWxpemVkIGltYWdlIHRvb2xiYXJcIik7XG4gICAgICBuKHRoaXMuc3RhdGUpO1xuICAgIH0sIHQuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKSwgdC5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLnZpZXdNb3VzZWRvd25IYW5kbGVyKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMubW91c2VVcEhhbmRsZXIpLCB0LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiZHJhZ292ZXJcIixcbiAgICAgIHRoaXMuZHJhZ092ZXJIYW5kbGVyXG4gICAgKSwgdC5yb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImRyb3BcIixcbiAgICAgIHRoaXMuZHJvcEhhbmRsZXJcbiAgICApO1xuICB9XG4gIC8vIFVwZGF0ZXMgZHJhZyBoYW5kbGVzIHdoZW4gdGhlIHRhYmxlIGlzIG1vZGlmaWVkIG9yIHJlbW92ZWQuXG4gIHVwZGF0ZSgpIHtcbiAgICB2YXIgcjtcbiAgICBpZiAoIXRoaXMuc3RhdGUgfHwgIXRoaXMuc3RhdGUuc2hvdylcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5zdGF0ZS5ibG9jayA9IHRoaXMuZWRpdG9yLmdldEJsb2NrKHRoaXMuc3RhdGUuYmxvY2suaWQpLCAhdGhpcy5zdGF0ZS5ibG9jayB8fCAvLyB3aGVuIGNvbGxhYm9yYXRpbmcsIHRoZSB0YWJsZSBlbGVtZW50IG1pZ2h0IGJlIHJlcGxhY2VkIGFuZCBvdXQgb2YgZGF0ZVxuICAgIC8vIGJlY2F1c2UgeWpzIHJlcGxhY2VzIHRoZSBlbGVtZW50IHdoZW4gZm9yIGV4YW1wbGUgeW91IGNoYW5nZSB0aGUgY29sb3IgdmlhIHRoZSBzaWRlIG1lbnVcbiAgICAhKChyID0gdGhpcy50YWJsZUVsZW1lbnQpICE9IG51bGwgJiYgci5pc0Nvbm5lY3RlZCkpIHtcbiAgICAgIHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLnN0YXRlLnNob3dBZGRPclJlbW92ZVJvd3NCdXR0b24gPSAhMSwgdGhpcy5zdGF0ZS5zaG93QWRkT3JSZW1vdmVDb2x1bW5zQnV0dG9uID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGhlaWdodDogbywgd2lkdGg6IHQgfSA9IGN0KFxuICAgICAgdGhpcy5zdGF0ZS5ibG9ja1xuICAgICk7XG4gICAgdGhpcy5zdGF0ZS5yb3dJbmRleCAhPT0gdm9pZCAwICYmIHRoaXMuc3RhdGUuY29sSW5kZXggIT09IHZvaWQgMCAmJiAodGhpcy5zdGF0ZS5yb3dJbmRleCA+PSBvICYmICh0aGlzLnN0YXRlLnJvd0luZGV4ID0gbyAtIDEpLCB0aGlzLnN0YXRlLmNvbEluZGV4ID49IHQgJiYgKHRoaXMuc3RhdGUuY29sSW5kZXggPSB0IC0gMSkpO1xuICAgIGNvbnN0IG4gPSB0aGlzLnRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKFwidGJvZHlcIik7XG4gICAgaWYgKCFuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRhYmxlIGJsb2NrIGRvZXMgbm90IGNvbnRhaW4gYSAndGJvZHknIEhUTUwgZWxlbWVudC4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlwiXG4gICAgICApO1xuICAgIGlmICh0aGlzLnN0YXRlLnJvd0luZGV4ICE9PSB2b2lkIDAgJiYgdGhpcy5zdGF0ZS5jb2xJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBpID0gbi5jaGlsZHJlblt0aGlzLnN0YXRlLnJvd0luZGV4XS5jaGlsZHJlblt0aGlzLnN0YXRlLmNvbEluZGV4XTtcbiAgICAgIGkgPyB0aGlzLnN0YXRlLnJlZmVyZW5jZVBvc0NlbGwgPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogKHRoaXMuc3RhdGUucm93SW5kZXggPSB2b2lkIDAsIHRoaXMuc3RhdGUuY29sSW5kZXggPSB2b2lkIDApO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnJlZmVyZW5jZVBvc1RhYmxlID0gbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5lbWl0VXBkYXRlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5tb3VzZVVwSGFuZGxlciksIHRoaXMucG1WaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMudmlld01vdXNlZG93bkhhbmRsZXIpLCB0aGlzLnBtVmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcImRyYWdvdmVyXCIsXG4gICAgICB0aGlzLmRyYWdPdmVySGFuZGxlclxuICAgICksIHRoaXMucG1WaWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiZHJvcFwiLFxuICAgICAgdGhpcy5kcm9wSGFuZGxlclxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGZlID0gbmV3IE4oXCJUYWJsZUhhbmRsZXNQbHVnaW5cIik7XG5jbGFzcyBkYSBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB1KHRoaXMsIFwidmlld1wiKTtcbiAgICB1KHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgYGRyYWdTdGFydGAgZXZlbnQgZm9yIHdoaWNoZXZlciBlbGVtZW50XG4gICAgICogaXMgdXNlZCBhcyB0aGUgY29sdW1uIGRyYWcgaGFuZGxlLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJjb2xEcmFnU3RhcnRcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT09IHZvaWQgMCB8fCB0aGlzLnZpZXcuc3RhdGUuY29sSW5kZXggPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQXR0ZW1wdGVkIHRvIGRyYWcgdGFibGUgY29sdW1uLCBidXQgbm8gdGFibGUgYmxvY2sgd2FzIGhvdmVyZWQgcHJpb3IuXCJcbiAgICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZSA9IHtcbiAgICAgICAgZHJhZ2dlZENlbGxPcmllbnRhdGlvbjogXCJjb2xcIixcbiAgICAgICAgb3JpZ2luYWxJbmRleDogdGhpcy52aWV3LnN0YXRlLmNvbEluZGV4LFxuICAgICAgICBtb3VzZVBvczogdC5jbGllbnRYXG4gICAgICB9LCB0aGlzLnZpZXcuZW1pdFVwZGF0ZSgpLCB0aGlzLmVkaXRvci5kaXNwYXRjaChcbiAgICAgICAgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKGZlLCB7XG4gICAgICAgICAgZHJhZ2dlZENlbGxPcmllbnRhdGlvbjogdGhpcy52aWV3LnN0YXRlLmRyYWdnaW5nU3RhdGUuZHJhZ2dlZENlbGxPcmllbnRhdGlvbixcbiAgICAgICAgICBvcmlnaW5hbEluZGV4OiB0aGlzLnZpZXcuc3RhdGUuY29sSW5kZXgsXG4gICAgICAgICAgbmV3SW5kZXg6IHRoaXMudmlldy5zdGF0ZS5jb2xJbmRleCxcbiAgICAgICAgICB0YWJsZVBvczogdGhpcy52aWV3LnRhYmxlUG9zXG4gICAgICAgIH0pXG4gICAgICApLCAhdGhpcy5lZGl0b3IucHJvc2VtaXJyb3JWaWV3KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFZGl0b3IgdmlldyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgVXQodGhpcy5lZGl0b3IucHJvc2VtaXJyb3JWaWV3LnJvb3QpLCB0LmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoQSwgMCwgMCksIHQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIjtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGBkcmFnU3RhcnRgIGV2ZW50IGZvciB3aGljaGV2ZXIgZWxlbWVudFxuICAgICAqIGlzIHVzZWQgYXMgdGhlIHJvdyBkcmFnIGhhbmRsZS5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwicm93RHJhZ1N0YXJ0XCIsICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy52aWV3LnN0YXRlID09PSB2b2lkIDAgfHwgdGhpcy52aWV3LnN0YXRlLnJvd0luZGV4ID09PSB2b2lkIDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkF0dGVtcHRlZCB0byBkcmFnIHRhYmxlIHJvdywgYnV0IG5vIHRhYmxlIGJsb2NrIHdhcyBob3ZlcmVkIHByaW9yLlwiXG4gICAgICAgICk7XG4gICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRyYWdnaW5nU3RhdGUgPSB7XG4gICAgICAgIGRyYWdnZWRDZWxsT3JpZW50YXRpb246IFwicm93XCIsXG4gICAgICAgIG9yaWdpbmFsSW5kZXg6IHRoaXMudmlldy5zdGF0ZS5yb3dJbmRleCxcbiAgICAgICAgbW91c2VQb3M6IHQuY2xpZW50WVxuICAgICAgfSwgdGhpcy52aWV3LmVtaXRVcGRhdGUoKSwgdGhpcy5lZGl0b3IuZGlzcGF0Y2goXG4gICAgICAgIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iuc3RhdGUudHIuc2V0TWV0YShmZSwge1xuICAgICAgICAgIGRyYWdnZWRDZWxsT3JpZW50YXRpb246IHRoaXMudmlldy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLmRyYWdnZWRDZWxsT3JpZW50YXRpb24sXG4gICAgICAgICAgb3JpZ2luYWxJbmRleDogdGhpcy52aWV3LnN0YXRlLnJvd0luZGV4LFxuICAgICAgICAgIG5ld0luZGV4OiB0aGlzLnZpZXcuc3RhdGUucm93SW5kZXgsXG4gICAgICAgICAgdGFibGVQb3M6IHRoaXMudmlldy50YWJsZVBvc1xuICAgICAgICB9KVxuICAgICAgKSwgIXRoaXMuZWRpdG9yLnByb3NlbWlycm9yVmlldylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRpdG9yIHZpZXcgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICAgIFV0KHRoaXMuZWRpdG9yLnByb3NlbWlycm9yVmlldy5yb290KSwgdC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKEEsIDAsIDApLCB0LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgYGRyYWdFbmRgIGV2ZW50IGZvciBib3RoIHRoZSBlbGVtZW50XG4gICAgICogdXNlZCBhcyB0aGUgcm93IGRyYWcgaGFuZGxlLCBhbmQgdGhlIG9uZSB1c2VkIGFzIHRoZSBjb2x1bW4gZHJhZyBoYW5kbGUuXG4gICAgICovXG4gICAgdSh0aGlzLCBcImRyYWdFbmRcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJBdHRlbXB0ZWQgdG8gZHJhZyB0YWJsZSByb3csIGJ1dCBubyB0YWJsZSBibG9jayB3YXMgaG92ZXJlZCBwcmlvci5cIlxuICAgICAgICApO1xuICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kcmFnZ2luZ1N0YXRlID0gdm9pZCAwLCB0aGlzLnZpZXcuZW1pdFVwZGF0ZSgpLCB0aGlzLmVkaXRvci5kaXNwYXRjaChcbiAgICAgICAgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKGZlLCBudWxsKVxuICAgICAgKSwgIXRoaXMuZWRpdG9yLnByb3NlbWlycm9yVmlldylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRpdG9yIHZpZXcgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICAgIGlhKHRoaXMuZWRpdG9yLnByb3NlbWlycm9yVmlldy5yb290KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGcmVlemVzIHRoZSBkcmFnIGhhbmRsZXMuIFdoZW4gZnJvemVuLCB0aGV5IHdpbGwgc3RheSBhdHRhY2hlZCB0byB0aGUgc2FtZVxuICAgICAqIGNlbGwgcmVnYXJkbGVzcyBvZiB3aGljaCBjZWxsIGlzIGhvdmVyZWQgYnkgdGhlIG1vdXNlIGN1cnNvci5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiZnJlZXplSGFuZGxlc1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnZpZXcubWVudUZyb3plbiA9ICEwO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVuZnJlZXplcyB0aGUgZHJhZyBoYW5kbGVzLiBXaGVuIGZyb3plbiwgdGhleSB3aWxsIHN0YXkgYXR0YWNoZWQgdG8gdGhlXG4gICAgICogc2FtZSBjZWxsIHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggY2VsbCBpcyBob3ZlcmVkIGJ5IHRoZSBtb3VzZSBjdXJzb3IuXG4gICAgICovXG4gICAgdSh0aGlzLCBcInVuZnJlZXplSGFuZGxlc1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnZpZXcubWVudUZyb3plbiA9ICExO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJnZXRDZWxsc0F0Um93SGFuZGxlXCIsICh0LCBuKSA9PiBRZSh0LCBuKSk7XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgY2VsbHMgaW4gYSBjb2x1bW4gb2YgdGhlIHRhYmxlIGJsb2NrLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJnZXRDZWxsc0F0Q29sdW1uSGFuZGxlXCIsICh0LCBuKSA9PiBldCh0LCBuKSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiBjZWxsIG9yIGEgcmFuZ2Ugb2YgY2VsbHMuXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzdGF0ZSBhZnRlciB0aGUgc2VsZWN0aW9uIGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwic2V0Q2VsbFNlbGVjdGlvblwiLCAodCwgbiA9IHQpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLnZpZXc7XG4gICAgICBpZiAoIXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhYmxlIGhhbmRsZXMgdmlldyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICBjb25zdCBzID0gdGhpcy5lZGl0b3IucHJvc2VtaXJyb3JTdGF0ZSwgaSA9IHMuZG9jLnJlc29sdmUoci50YWJsZVBvcyArIDEpLCBhID0gcy5kb2MucmVzb2x2ZShcbiAgICAgICAgaS5wb3NBdEluZGV4KHQucm93KSArIDFcbiAgICAgICksIGMgPSBzLmRvYy5yZXNvbHZlKFxuICAgICAgICAvLyBObyBuZWVkIGZvciArMSwgc2luY2UgQ2VsbFNlbGVjdGlvbiBleHBlY3RzIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIGNlbGxcbiAgICAgICAgYS5wb3NBdEluZGV4KHQuY29sKVxuICAgICAgKSwgbCA9IHMuZG9jLnJlc29sdmUoXG4gICAgICAgIGkucG9zQXRJbmRleChuLnJvdykgKyAxXG4gICAgICApLCBkID0gcy5kb2MucmVzb2x2ZShcbiAgICAgICAgLy8gTm8gbmVlZCBmb3IgKzEsIHNpbmNlIENlbGxTZWxlY3Rpb24gZXhwZWN0cyB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBjZWxsXG4gICAgICAgIGwucG9zQXRJbmRleChuLmNvbClcbiAgICAgICksIHAgPSBzLnRyO1xuICAgICAgcmV0dXJuIHAuc2V0U2VsZWN0aW9uKFxuICAgICAgICBuZXcgeWUoYywgZClcbiAgICAgICksIHMuYXBwbHkocCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJvdyBvciBjb2x1bW4gdG8gdGhlIHRhYmxlIHVzaW5nIHByb3NlbWlycm9yLXRhYmxlIGNvbW1hbmRzXG4gICAgICovXG4gICAgdSh0aGlzLCBcImFkZFJvd09yQ29sdW1uXCIsICh0LCBuKSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy5zZXRDZWxsU2VsZWN0aW9uKFxuICAgICAgICBuLm9yaWVudGF0aW9uID09PSBcInJvd1wiID8geyByb3c6IHQsIGNvbDogMCB9IDogeyByb3c6IDAsIGNvbDogdCB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIG4ub3JpZW50YXRpb24gPT09IFwicm93XCIgPyBuLnNpZGUgPT09IFwiYWJvdmVcIiA/IGFuKHIsIHRoaXMuZWRpdG9yLmRpc3BhdGNoKSA6IGNuKHIsIHRoaXMuZWRpdG9yLmRpc3BhdGNoKSA6IG4uc2lkZSA9PT0gXCJsZWZ0XCIgPyBsbihyLCB0aGlzLmVkaXRvci5kaXNwYXRjaCkgOiBkbihyLCB0aGlzLmVkaXRvci5kaXNwYXRjaCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHJvdyBvciBjb2x1bW4gZnJvbSB0aGUgdGFibGUgdXNpbmcgcHJvc2VtaXJyb3ItdGFibGUgY29tbWFuZHNcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwicmVtb3ZlUm93T3JDb2x1bW5cIiwgKHQsIG4pID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLnNldENlbGxTZWxlY3Rpb24oXG4gICAgICAgIG4gPT09IFwicm93XCIgPyB7IHJvdzogdCwgY29sOiAwIH0gOiB7IHJvdzogMCwgY29sOiB0IH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gbiA9PT0gXCJyb3dcIiA/IHBuKHIsIHRoaXMuZWRpdG9yLmRpc3BhdGNoKSA6IHVuKHIsIHRoaXMuZWRpdG9yLmRpc3BhdGNoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGNlbGxzIGluIHRoZSB0YWJsZSBibG9jay5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwibWVyZ2VDZWxsc1wiLCAodCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHQgPyB0aGlzLnNldENlbGxTZWxlY3Rpb24oXG4gICAgICAgIHQucmVsYXRpdmVTdGFydENlbGwsXG4gICAgICAgIHQucmVsYXRpdmVFbmRDZWxsXG4gICAgICApIDogdGhpcy5lZGl0b3IucHJvc2VtaXJyb3JTdGF0ZTtcbiAgICAgIHJldHVybiBobihuLCB0aGlzLmVkaXRvci5kaXNwYXRjaCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBjZWxsIGluIHRoZSB0YWJsZSBibG9jay5cbiAgICAgKiBJZiBubyBjZWxsIGlzIHByb3ZpZGVkLCB0aGUgY3VycmVudCBjZWxsIHNlbGVjdGVkIHdpbGwgYmUgc3BsaXQuXG4gICAgICovXG4gICAgdSh0aGlzLCBcInNwbGl0Q2VsbFwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHQgPyB0aGlzLnNldENlbGxTZWxlY3Rpb24odCkgOiB0aGlzLmVkaXRvci5wcm9zZW1pcnJvclN0YXRlO1xuICAgICAgcmV0dXJuIGZuKG4sIHRoaXMuZWRpdG9yLmRpc3BhdGNoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFydCBhbmQgZW5kIGNlbGxzIG9mIHRoZSBjdXJyZW50IGNlbGwgc2VsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFydCBhbmQgZW5kIGNlbGxzIG9mIHRoZSBjdXJyZW50IGNlbGwgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJnZXRDZWxsU2VsZWN0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmVkaXRvci5wcm9zZW1pcnJvclN0YXRlLCBuID0gdC5zZWxlY3Rpb247XG4gICAgICBsZXQgciA9IG4uJGZyb20sIHMgPSBuLiR0bztcbiAgICAgIGlmIChJdChuKSkge1xuICAgICAgICBjb25zdCB7IHJhbmdlczogbSB9ID0gbjtcbiAgICAgICAgbS5mb3JFYWNoKChnKSA9PiB7XG4gICAgICAgICAgciA9IGcuJGZyb20ubWluKHIgPz8gZy4kZnJvbSksIHMgPSBnLiR0by5tYXgocyA/PyBnLiR0byk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyID0gdC5kb2MucmVzb2x2ZShcbiAgICAgICAgbi4kZnJvbS5wb3MgLSBuLiRmcm9tLnBhcmVudE9mZnNldCAtIDFcbiAgICAgICksIHMgPSB0LmRvYy5yZXNvbHZlKFxuICAgICAgICBuLiR0by5wb3MgLSBuLiR0by5wYXJlbnRPZmZzZXQgLSAxXG4gICAgICApLCByLnBvcyA9PT0gMCB8fCBzLnBvcyA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IHQuZG9jLnJlc29sdmUoXG4gICAgICAgIHIucG9zIC0gci5wYXJlbnRPZmZzZXQgLSAxXG4gICAgICApLCBhID0gdC5kb2MucmVzb2x2ZShzLnBvcyAtIHMucGFyZW50T2Zmc2V0IC0gMSksIGMgPSB0LmRvYy5yZXNvbHZlKGkucG9zIC0gaS5wYXJlbnRPZmZzZXQgLSAxKSwgbCA9IHIuaW5kZXgoaS5kZXB0aCksIGQgPSBpLmluZGV4KGMuZGVwdGgpLCBwID0gcy5pbmRleChhLmRlcHRoKSwgaCA9IGEuaW5kZXgoYy5kZXB0aCksIGYgPSBbXTtcbiAgICAgIGZvciAobGV0IG0gPSBkOyBtIDw9IGg7IG0rKylcbiAgICAgICAgZm9yIChsZXQgZyA9IGw7IGcgPD0gcDsgZysrKVxuICAgICAgICAgIGYucHVzaCh7IHJvdzogbSwgY29sOiBnIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHJvdzogZCxcbiAgICAgICAgICBjb2w6IGxcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICByb3c6IGgsXG4gICAgICAgICAgY29sOiBwXG4gICAgICAgIH0sXG4gICAgICAgIGNlbGxzOiBmXG4gICAgICB9O1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbWVyZ2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgY2VsbCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIHRoZXJlIGlzIG5vIGNlbGwgc2VsZWN0aW9uLCBvciB0aGUgc2VsZWN0aW9uIGlzIG5vdCB3aXRoaW4gYSB0YWJsZS5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiZ2V0TWVyZ2VEaXJlY3Rpb25cIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBJdChcbiAgICAgICAgdGhpcy5lZGl0b3IucHJvc2VtaXJyb3JTdGF0ZS5zZWxlY3Rpb25cbiAgICAgICkgPyB0aGlzLmVkaXRvci5wcm9zZW1pcnJvclN0YXRlLnNlbGVjdGlvbiA6IHZvaWQgMDtcbiAgICAgIGlmICghbiB8fCAhdCB8fCAvLyBPbmx5IG9mZmVyIHRoZSBtZXJnZSBidXR0b24gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBjZWxsIHNlbGVjdGVkLlxuICAgICAgbi5yYW5nZXMubGVuZ3RoIDw9IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmdldENlbGxTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChyKVxuICAgICAgICByZXR1cm4gWm4oci5mcm9tLCByLnRvLCB0KSA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiO1xuICAgIH0pO1xuICAgIHUodGhpcywgXCJjcm9wRW1wdHlSb3dzT3JDb2x1bW5zXCIsICh0LCBuKSA9PiBKbih0LCBuKSk7XG4gICAgdSh0aGlzLCBcImFkZFJvd3NPckNvbHVtbnNcIiwgKHQsIG4sIHIpID0+IFluKHQsIG4sIHIpKTtcbiAgICB0aGlzLmVkaXRvciA9IHQsIHRoaXMucGx1Z2luID0gbmV3IE0oe1xuICAgICAga2V5OiBmZSxcbiAgICAgIHZpZXc6IChuKSA9PiAodGhpcy52aWV3ID0gbmV3IGxhKHQsIG4sIChyKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCByKTtcbiAgICAgIH0pLCB0aGlzLnZpZXcpLFxuICAgICAgLy8gV2UgdXNlIGRlY29yYXRpb25zIHRvIHJlbmRlciB0aGUgZHJvcCBjdXJzb3Igd2hlbiBkcmFnZ2luZyBhIHRhYmxlIHJvd1xuICAgICAgLy8gb3IgY29sdW1uLiBUaGUgZGVjb3JhdGlvbnMgYXJlIHVwZGF0ZWQgaW4gdGhlIGBkcmFnT3ZlckhhbmRsZXJgIG1ldGhvZC5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRlY29yYXRpb25zOiAobikgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnZpZXcgPT09IHZvaWQgMCB8fCB0aGlzLnZpZXcuc3RhdGUgPT09IHZvaWQgMCB8fCB0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZSA9PT0gdm9pZCAwIHx8IHRoaXMudmlldy50YWJsZVBvcyA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uID09PSBcInJvd1wiID8gdGhpcy52aWV3LnN0YXRlLnJvd0luZGV4IDogdGhpcy52aWV3LnN0YXRlLmNvbEluZGV4O1xuICAgICAgICAgIGlmIChyID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgcyA9IFtdLCB7IGJsb2NrOiBpLCBkcmFnZ2luZ1N0YXRlOiBhIH0gPSB0aGlzLnZpZXcuc3RhdGUsIHsgb3JpZ2luYWxJbmRleDogYywgZHJhZ2dlZENlbGxPcmllbnRhdGlvbjogbCB9ID0gYTtcbiAgICAgICAgICBpZiAociA9PT0gYyB8fCAhaSB8fCBsID09PSBcInJvd1wiICYmICF0byhpLCBjLCByKSB8fCBsID09PSBcImNvbFwiICYmICFvbyhpLCBjLCByKSlcbiAgICAgICAgICAgIHJldHVybiBVLmNyZWF0ZShuLmRvYywgcyk7XG4gICAgICAgICAgY29uc3QgZCA9IG4uZG9jLnJlc29sdmUodGhpcy52aWV3LnRhYmxlUG9zICsgMSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLmRyYWdnZWRDZWxsT3JpZW50YXRpb24gPT09IFwicm93XCIgPyBRZShcbiAgICAgICAgICAgIHRoaXMudmlldy5zdGF0ZS5ibG9jayxcbiAgICAgICAgICAgIHJcbiAgICAgICAgICApLmZvckVhY2goKHsgcm93OiBoLCBjb2w6IGYgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbSA9IG4uZG9jLnJlc29sdmUoXG4gICAgICAgICAgICAgIGQucG9zQXRJbmRleChoKSArIDFcbiAgICAgICAgICAgICksIGcgPSBuLmRvYy5yZXNvbHZlKFxuICAgICAgICAgICAgICBtLnBvc0F0SW5kZXgoZikgKyAxXG4gICAgICAgICAgICApLCBiID0gZy5ub2RlKCksIGsgPSBnLnBvcyArIChyID4gYyA/IGIubm9kZVNpemUgLSAyIDogMCk7XG4gICAgICAgICAgICBzLnB1c2goXG4gICAgICAgICAgICAgIC8vIFRoZSB3aWRnZXQgaXMgYSBzbWFsbCBiYXIgd2hpY2ggc3BhbnMgdGhlIHdpZHRoIG9mIHRoZSBjZWxsLlxuICAgICAgICAgICAgICBHLndpZGdldChrLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcuY2xhc3NOYW1lID0gXCJibi10YWJsZS1kcm9wLWN1cnNvclwiLCB3LnN0eWxlLmxlZnQgPSBcIjBcIiwgdy5zdHlsZS5yaWdodCA9IFwiMFwiLCByID4gYyA/IHcuc3R5bGUuYm90dG9tID0gXCItMnB4XCIgOiB3LnN0eWxlLnRvcCA9IFwiLTNweFwiLCB3LnN0eWxlLmhlaWdodCA9IFwiNHB4XCIsIHc7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pIDogZXQoXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3RhdGUuYmxvY2ssXG4gICAgICAgICAgICByXG4gICAgICAgICAgKS5mb3JFYWNoKCh7IHJvdzogaCwgY29sOiBmIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuLmRvYy5yZXNvbHZlKFxuICAgICAgICAgICAgICBkLnBvc0F0SW5kZXgoaCkgKyAxXG4gICAgICAgICAgICApLCBnID0gbi5kb2MucmVzb2x2ZShcbiAgICAgICAgICAgICAgbS5wb3NBdEluZGV4KGYpICsgMVxuICAgICAgICAgICAgKSwgYiA9IGcubm9kZSgpLCBrID0gZy5wb3MgKyAociA+IGMgPyBiLm5vZGVTaXplIC0gMiA6IDApO1xuICAgICAgICAgICAgcy5wdXNoKFxuICAgICAgICAgICAgICAvLyBUaGUgd2lkZ2V0IGlzIGEgc21hbGwgYmFyIHdoaWNoIHNwYW5zIHRoZSBoZWlnaHQgb2YgdGhlIGNlbGwuXG4gICAgICAgICAgICAgIEcud2lkZ2V0KGssICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdy5jbGFzc05hbWUgPSBcImJuLXRhYmxlLWRyb3AtY3Vyc29yXCIsIHcuc3R5bGUudG9wID0gXCIwXCIsIHcuc3R5bGUuYm90dG9tID0gXCIwXCIsIHIgPiBjID8gdy5zdHlsZS5yaWdodCA9IFwiLTJweFwiIDogdy5zdHlsZS5sZWZ0ID0gXCItM3B4XCIsIHcuc3R5bGUud2lkdGggPSBcIjRweFwiLCB3O1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSwgVS5jcmVhdGUobi5kb2MsIHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25VcGRhdGUodCkge1xuICAgIHJldHVybiB0aGlzLm9uKFwidXBkYXRlXCIsIHQpO1xuICB9XG59XG5jb25zdCBwYSA9IEguY3JlYXRlKHtcbiAgbmFtZTogXCJ0ZXh0QWxpZ25tZW50XCIsXG4gIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgLy8gQXR0cmlidXRlIGlzIGFwcGxpZWQgdG8gYmxvY2sgY29udGVudCBpbnN0ZWFkIG9mIGNvbnRhaW5lciBzbyB0aGF0IGNoaWxkIGJsb2NrcyBkb24ndCBpbmhlcml0IHRoZSB0ZXh0XG4gICAgICAgIC8vIGFsaWdubWVudCBzdHlsaW5nLlxuICAgICAgICB0eXBlczogW1xuICAgICAgICAgIFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgXCJoZWFkaW5nXCIsXG4gICAgICAgICAgXCJidWxsZXRMaXN0SXRlbVwiLFxuICAgICAgICAgIFwibnVtYmVyZWRMaXN0SXRlbVwiLFxuICAgICAgICAgIFwiY2hlY2tMaXN0SXRlbVwiLFxuICAgICAgICAgIFwidGFibGVDZWxsXCIsXG4gICAgICAgICAgXCJ0YWJsZUhlYWRlclwiXG4gICAgICAgIF0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB0ZXh0QWxpZ25tZW50OiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBcImxlZnRcIixcbiAgICAgICAgICAgIHBhcnNlSFRNTDogKGUpID0+IGUuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZXh0LWFsaWdubWVudFwiKSxcbiAgICAgICAgICAgIHJlbmRlckhUTUw6IChlKSA9PiBlLnRleHRBbGlnbm1lbnQgPT09IFwibGVmdFwiID8ge30gOiB7XG4gICAgICAgICAgICAgIFwiZGF0YS10ZXh0LWFsaWdubWVudFwiOiBlLnRleHRBbGlnbm1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9XG59KSwgdWEgPSBILmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmxvY2tUZXh0Q29sb3JcIixcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlczogW1wiYmxvY2tDb250YWluZXJcIiwgXCJ0YWJsZUNlbGxcIiwgXCJ0YWJsZUhlYWRlclwiXSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIHRleHRDb2xvcjoge1xuICAgICAgICAgICAgZGVmYXVsdDogUy50ZXh0Q29sb3IuZGVmYXVsdCxcbiAgICAgICAgICAgIHBhcnNlSFRNTDogKGUpID0+IGUuaGFzQXR0cmlidXRlKFwiZGF0YS10ZXh0LWNvbG9yXCIpID8gZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRleHQtY29sb3JcIikgOiBTLnRleHRDb2xvci5kZWZhdWx0LFxuICAgICAgICAgICAgcmVuZGVySFRNTDogKGUpID0+IGUudGV4dENvbG9yID09PSBTLnRleHRDb2xvci5kZWZhdWx0ID8ge30gOiB7XG4gICAgICAgICAgICAgIFwiZGF0YS10ZXh0LWNvbG9yXCI6IGUudGV4dENvbG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfVxufSksIGhhID0gSC5jcmVhdGUoe1xuICBuYW1lOiBcInRyYWlsaW5nTm9kZVwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBOKHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBNKHtcbiAgICAgICAga2V5OiBlLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKG8sIHQsIG4pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRvYzogciwgdHI6IHMsIHNjaGVtYTogaSB9ID0gbiwgYSA9IGUuZ2V0U3RhdGUobiksIGMgPSByLmNvbnRlbnQuc2l6ZSAtIDIsIGwgPSBpLm5vZGVzLmJsb2NrQ29udGFpbmVyLCBkID0gaS5ub2Rlcy5wYXJhZ3JhcGg7XG4gICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICByZXR1cm4gcy5pbnNlcnQoXG4gICAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAgIGwuY3JlYXRlKHZvaWQgMCwgZC5jcmVhdGUoKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgaW5pdDogKG8sIHQpID0+IHtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFwcGx5OiAobywgdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgbGV0IG4gPSBvLmRvYy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIW4gfHwgbi50eXBlLm5hbWUgIT09IFwiYmxvY2tHcm91cFwiKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9ja0dyb3VwXCIpO1xuICAgICAgICAgICAgaWYgKG4gPSBuLmxhc3RDaGlsZCwgIW4gfHwgbi50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgY29uc3QgciA9IG4uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghcilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYmxvY2tDb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG4ubm9kZVNpemUgPiA0IHx8IHIudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KSwgZmEgPSB7XG4gIGJsb2NrQ29sb3I6IFwiZGF0YS1ibG9jay1jb2xvclwiLFxuICBibG9ja1N0eWxlOiBcImRhdGEtYmxvY2stc3R5bGVcIixcbiAgaWQ6IFwiZGF0YS1pZFwiLFxuICBkZXB0aDogXCJkYXRhLWRlcHRoXCIsXG4gIGRlcHRoQ2hhbmdlOiBcImRhdGEtZGVwdGgtY2hhbmdlXCJcbn0sIG1hID0gc2UuY3JlYXRlKHtcbiAgbmFtZTogXCJibG9ja0NvbnRhaW5lclwiLFxuICBncm91cDogXCJibG9ja0dyb3VwQ2hpbGQgYm5CbG9ja1wiLFxuICAvLyBBIGJsb2NrIGFsd2F5cyBjb250YWlucyBjb250ZW50LCBhbmQgb3B0aW9uYWxseSBhIGJsb2NrR3JvdXAgd2hpY2ggY29udGFpbnMgbmVzdGVkIGJsb2Nrc1xuICBjb250ZW50OiBcImJsb2NrQ29udGVudCBibG9ja0dyb3VwP1wiLFxuICAvLyBFbnN1cmVzIGNvbnRlbnQtc3BlY2lmaWMga2V5Ym9hcmQgaGFuZGxlcnMgdHJpZ2dlciBmaXJzdC5cbiAgcHJpb3JpdHk6IDUwLFxuICBkZWZpbmluZzogITAsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiZGl2XCIsXG4gICAgICAgIGdldEF0dHJzOiAoZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IG8gPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFt0LCBuXSBvZiBPYmplY3QuZW50cmllcyhmYSkpXG4gICAgICAgICAgICBlLmdldEF0dHJpYnV0ZShuKSAmJiAob1t0XSA9IGUuZ2V0QXR0cmlidXRlKG4pKTtcbiAgICAgICAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdHlwZVwiKSA9PT0gXCJibG9ja0NvbnRhaW5lclwiID8gbyA6ICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBlIH0pIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBvLmNsYXNzTmFtZSA9IFwiYm4tYmxvY2stb3V0ZXJcIiwgby5zZXRBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdHlwZVwiLCBcImJsb2NrT3V0ZXJcIik7XG4gICAgZm9yIChjb25zdCBbcywgaV0gb2YgT2JqZWN0LmVudHJpZXMoZSkpXG4gICAgICBzICE9PSBcImNsYXNzXCIgJiYgby5zZXRBdHRyaWJ1dGUocywgaSk7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLigociA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogci5ibG9jaykgfHwge30sXG4gICAgICAuLi5lXG4gICAgfSwgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbi5jbGFzc05hbWUgPSBZKFwiYm4tYmxvY2tcIiwgdC5jbGFzcyksIG4uc2V0QXR0cmlidXRlKFwiZGF0YS1ub2RlLXR5cGVcIiwgdGhpcy5uYW1lKTtcbiAgICBmb3IgKGNvbnN0IFtzLCBpXSBvZiBPYmplY3QuZW50cmllcyh0KSlcbiAgICAgIHMgIT09IFwiY2xhc3NcIiAmJiBuLnNldEF0dHJpYnV0ZShzLCBpKTtcbiAgICByZXR1cm4gby5hcHBlbmRDaGlsZChuKSwge1xuICAgICAgZG9tOiBvLFxuICAgICAgY29udGVudERPTTogblxuICAgIH07XG4gIH1cbn0pLCBnYSA9IHNlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmxvY2tHcm91cFwiLFxuICBncm91cDogXCJjaGlsZENvbnRhaW5lclwiLFxuICBjb250ZW50OiBcImJsb2NrR3JvdXBDaGlsZCtcIixcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkaXZcIixcbiAgICAgICAgZ2V0QXR0cnM6IChlKSA9PiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gITEgOiBlLmdldEF0dHJpYnV0ZShcImRhdGEtbm9kZS10eXBlXCIpID09PSBcImJsb2NrR3JvdXBcIiA/IG51bGwgOiAhMVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogZSB9KSB7XG4gICAgdmFyIG47XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIC4uLigobiA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogbi5ibG9ja0dyb3VwKSB8fCB7fSxcbiAgICAgIC4uLmVcbiAgICB9LCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmNsYXNzTmFtZSA9IFkoXG4gICAgICBcImJuLWJsb2NrLWdyb3VwXCIsXG4gICAgICBvLmNsYXNzXG4gICAgKSwgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdHlwZVwiLCBcImJsb2NrR3JvdXBcIik7XG4gICAgZm9yIChjb25zdCBbciwgc10gb2YgT2JqZWN0LmVudHJpZXMobykpXG4gICAgICByICE9PSBcImNsYXNzXCIgJiYgdC5zZXRBdHRyaWJ1dGUociwgcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbTogdCxcbiAgICAgIGNvbnRlbnRET006IHRcbiAgICB9O1xuICB9XG59KSwgYmEgPSBzZS5jcmVhdGUoe1xuICBuYW1lOiBcImRvY1wiLFxuICB0b3BOb2RlOiAhMCxcbiAgY29udGVudDogXCJibG9ja0dyb3VwXCJcbn0pLCBrYSA9IChlKSA9PiB7XG4gIGNvbnN0IG8gPSB7fSwgdCA9IHdhKGUpO1xuICBmb3IgKGNvbnN0IHIgb2YgdClcbiAgICBvW3IubmFtZV0gPSByO1xuICBvLmZvcm1hdHRpbmdUb29sYmFyID0gbmV3IEFpKFxuICAgIGUuZWRpdG9yXG4gICksIG8ubGlua1Rvb2xiYXIgPSBuZXcgVmkoZS5lZGl0b3IpLCBvLnNpZGVNZW51ID0gbmV3IGVhKFxuICAgIGUuZWRpdG9yLFxuICAgIGUuc2lkZU1lbnVEZXRlY3Rpb25cbiAgKSwgby5zdWdnZXN0aW9uTWVudXMgPSBuZXcgc2EoZS5lZGl0b3IpLCBvLmZpbGVQYW5lbCA9IG5ldyBQaShlLmVkaXRvciksIG8ucGxhY2Vob2xkZXIgPSBuZXcgamkoZS5lZGl0b3IsIGUucGxhY2Vob2xkZXJzKSwgKGUuYW5pbWF0aW9ucyA/PyAhMCkgJiYgKG8uYW5pbWF0aW9ucyA9IG5ldyBxaSgpKSwgZS50YWJsZUhhbmRsZXMgJiYgKG8udGFibGVIYW5kbGVzID0gbmV3IGRhKGUuZWRpdG9yKSksIG8uZHJvcEN1cnNvciA9IHtcbiAgICBwbHVnaW46IGUuZHJvcEN1cnNvcih7XG4gICAgICB3aWR0aDogNSxcbiAgICAgIGNvbG9yOiBcIiNkZGVlZmZcIixcbiAgICAgIGVkaXRvcjogZS5lZGl0b3JcbiAgICB9KVxuICB9LCBvLm5vZGVTZWxlY3Rpb25LZXlib2FyZCA9IG5ldyB6aSgpLCBvLnNob3dTZWxlY3Rpb24gPSBuZXcgS2koZS5lZGl0b3IpLCBlLmNvbW1lbnRzICYmIChvLmNvbW1lbnRzID0gbmV3IHhpKFxuICAgIGUuZWRpdG9yLFxuICAgIGUuY29tbWVudHMudGhyZWFkU3RvcmUsXG4gICAgTm8ubmFtZVxuICApKTtcbiAgY29uc3QgbiA9IGUuZGlzYWJsZUV4dGVuc2lvbnMgfHwgW107XG4gIGZvciAoY29uc3QgciBvZiBuKVxuICAgIGRlbGV0ZSBvW3JdO1xuICByZXR1cm4gbztcbn07XG5sZXQgJHQgPSAhMTtcbmNvbnN0IHdhID0gKGUpID0+IHtcbiAgY29uc3QgbyA9IFtcbiAgICB1ZS5DbGlwYm9hcmRUZXh0U2VyaWFsaXplcixcbiAgICB1ZS5Db21tYW5kcyxcbiAgICB1ZS5FZGl0YWJsZSxcbiAgICB1ZS5Gb2N1c0V2ZW50cyxcbiAgICB1ZS5UYWJpbmRleCxcbiAgICAvLyBEZXZUb29scyxcbiAgICBFbixcbiAgICAvLyBEcm9wQ3Vyc29yLFxuICAgIHZlLmNvbmZpZ3VyZSh7XG4gICAgICAvLyBldmVyeXRoaW5nIGZyb20gYm5CbG9jayBncm91cCAobm9kZXMgdGhhdCByZXByZXNlbnQgYSBCbG9ja05vdGUgYmxvY2sgc2hvdWxkIGhhdmUgYW4gaWQpXG4gICAgICB0eXBlczogW1wiYmxvY2tDb250YWluZXJcIiwgXCJjb2x1bW5MaXN0XCIsIFwiY29sdW1uXCJdLFxuICAgICAgc2V0SWRBdHRyaWJ1dGU6IGUuc2V0SWRBdHRyaWJ1dGVcbiAgICB9KSxcbiAgICBOaSxcbiAgICAvLyBDb21tZW50cyxcbiAgICAvLyBiYXNpY3M6XG4gICAgVG4sXG4gICAgLy8gbWFya3M6XG4gICAgQm4uZXh0ZW5kKHtcbiAgICAgIGluY2x1c2l2ZTogITFcbiAgICB9KS5jb25maWd1cmUoe1xuICAgICAgZGVmYXVsdFByb3RvY29sOiAkaSxcbiAgICAgIC8vIG9ubHkgY2FsbCB0aGlzIG9uY2UgaWYgd2UgaGF2ZSBtdWx0aXBsZSBlZGl0b3JzIGluc3RhbGxlZC4gT3IgZml4IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvNTQ1MFxuICAgICAgcHJvdG9jb2xzOiAkdCA/IFtdIDogVWlcbiAgICB9KSxcbiAgICAuLi5PYmplY3QudmFsdWVzKGUuc3R5bGVTcGVjcykubWFwKCh0KSA9PiB0LmltcGxlbWVudGF0aW9uLm1hcmsuY29uZmlndXJlKHtcbiAgICAgIGVkaXRvcjogZS5lZGl0b3JcbiAgICB9KSksXG4gICAgdWEsXG4gICAgdmksXG4gICAgcGEsXG4gICAgLy8gbWFrZSBzdXJlIGVzY2FwZSBibHVycyBlZGl0b3IsIHNvIHRoYXQgd2UgY2FuIHRhYiB0byBvdGhlciBlbGVtZW50cyBpbiB0aGUgaG9zdCBwYWdlIChhY2Nlc3NpYmlsaXR5KVxuICAgIEguY3JlYXRlKHtcbiAgICAgIG5hbWU6IFwiT3ZlcnJpZGVFc2NhcGVcIixcbiAgICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIEVzY2FwZTogKCkgPT4gZS5lZGl0b3Iuc3VnZ2VzdGlvbk1lbnVzLnNob3duID8gITEgOiB0aGlzLmVkaXRvci5jb21tYW5kcy5ibHVyKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBub2Rlc1xuICAgIGJhLFxuICAgIG1hLmNvbmZpZ3VyZSh7XG4gICAgICBlZGl0b3I6IGUuZWRpdG9yLFxuICAgICAgZG9tQXR0cmlidXRlczogZS5kb21BdHRyaWJ1dGVzXG4gICAgfSksXG4gICAgT2kuY29uZmlndXJlKHtcbiAgICAgIGVkaXRvcjogZS5lZGl0b3IsXG4gICAgICB0YWJCZWhhdmlvcjogZS50YWJCZWhhdmlvclxuICAgIH0pLFxuICAgIGdhLmNvbmZpZ3VyZSh7XG4gICAgICBkb21BdHRyaWJ1dGVzOiBlLmRvbUF0dHJpYnV0ZXNcbiAgICB9KSxcbiAgICAuLi5PYmplY3QudmFsdWVzKGUuaW5saW5lQ29udGVudFNwZWNzKS5maWx0ZXIoKHQpID0+IHQuY29uZmlnICE9PSBcImxpbmtcIiAmJiB0LmNvbmZpZyAhPT0gXCJ0ZXh0XCIpLm1hcCgodCkgPT4gdC5pbXBsZW1lbnRhdGlvbi5ub2RlLmNvbmZpZ3VyZSh7XG4gICAgICBlZGl0b3I6IGUuZWRpdG9yXG4gICAgfSkpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoZS5ibG9ja1NwZWNzKS5mbGF0TWFwKCh0KSA9PiBbXG4gICAgICAvLyBkZXBlbmRlbnQgbm9kZXMgKGUuZy46IHRhYmxlY2VsbCAvIHJvdylcbiAgICAgIC4uLih0LmltcGxlbWVudGF0aW9uLnJlcXVpcmVkRXh0ZW5zaW9ucyB8fCBbXSkubWFwKFxuICAgICAgICAobikgPT4gbi5jb25maWd1cmUoe1xuICAgICAgICAgIGVkaXRvcjogZS5lZGl0b3IsXG4gICAgICAgICAgZG9tQXR0cmlidXRlczogZS5kb21BdHRyaWJ1dGVzXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgLy8gdGhlIGFjdHVhbCBub2RlIGl0c2VsZlxuICAgICAgdC5pbXBsZW1lbnRhdGlvbi5ub2RlLmNvbmZpZ3VyZSh7XG4gICAgICAgIGVkaXRvcjogZS5lZGl0b3IsXG4gICAgICAgIGRvbUF0dHJpYnV0ZXM6IGUuZG9tQXR0cmlidXRlc1xuICAgICAgfSlcbiAgICBdKSxcbiAgICBDaShlLmVkaXRvciksXG4gICAgd2koXG4gICAgICBlLmVkaXRvcixcbiAgICAgIGUucGFzdGVIYW5kbGVyIHx8ICgodCkgPT4gdC5kZWZhdWx0UGFzdGVIYW5kbGVyKCkpXG4gICAgKSxcbiAgICBvaShlLmVkaXRvciksXG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgbGlzdCwgYmVjYXVzZSBLZXkgZXZlbnRzIChzdWNoIGFzIGVudGVyLCB3aGVuIHNlbGVjdGluZyBhIC9jb21tYW5kKSxcbiAgICAvLyBzaG91bGQgYmUgaGFuZGxlZCBiZWZvcmUgRW50ZXIgaGFuZGxlcnMgaW4gb3RoZXIgY29tcG9uZW50cyBsaWtlIHNwbGl0TGlzdEl0ZW1cbiAgICAuLi5lLnRyYWlsaW5nQmxvY2sgPT09IHZvaWQgMCB8fCBlLnRyYWlsaW5nQmxvY2sgPyBbaGFdIDogW10sXG4gICAgLi4uZS5jb21tZW50cyA/IFtOb10gOiBbXVxuICBdO1xuICByZXR1cm4gJHQgPSAhMCwgZS5jb2xsYWJvcmF0aW9uID8gby5wdXNoKC4uLkVpKGUuY29sbGFib3JhdGlvbikpIDogby5wdXNoKFNuKSwgbztcbn07XG5mdW5jdGlvbiB5YShlLCBvKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIGUuZm9yRWFjaCgobiwgciwgcykgPT4ge1xuICAgIHMgIT09IG8gJiYgdC5wdXNoKG4pO1xuICB9KSwgVi5mcm9tKHQpO1xufVxuZnVuY3Rpb24gQ2EoZSwgbykge1xuICBjb25zdCB0ID0gW107XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgZS5jaGlsZENvdW50OyBuKyspXG4gICAgaWYgKGUuY2hpbGQobikudHlwZS5uYW1lID09PSBcInRhYmxlUm93XCIpXG4gICAgICBpZiAodC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXS50eXBlLm5hbWUgPT09IFwidGFibGVcIikge1xuICAgICAgICBjb25zdCByID0gdFt0Lmxlbmd0aCAtIDFdLCBzID0gci5jb3B5KHIuY29udGVudC5hZGRUb0VuZChlLmNoaWxkKG4pKSk7XG4gICAgICAgIHRbdC5sZW5ndGggLSAxXSA9IHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByID0gby5ub2Rlcy50YWJsZS5jcmVhdGVDaGVja2VkKFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBlLmNoaWxkKG4pXG4gICAgICAgICk7XG4gICAgICAgIHQucHVzaChyKTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB0LnB1c2goZS5jaGlsZChuKSk7XG4gIHJldHVybiBlID0gVi5mcm9tKHQpLCBlO1xufVxuZnVuY3Rpb24gdmEoZSwgbykge1xuICBsZXQgdCA9IFYuZnJvbShlLmNvbnRlbnQpO1xuICBpZiAodCA9IENhKHQsIG8uc3RhdGUuc2NoZW1hKSwgIUVhKHQsIG8pKVxuICAgIHJldHVybiBuZXcgdGUodCwgZS5vcGVuU3RhcnQsIGUub3BlbkVuZCk7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5jaGlsZENvdW50OyBuKyspXG4gICAgaWYgKHQuY2hpbGQobikudHlwZS5zcGVjLmdyb3VwID09PSBcImJsb2NrQ29udGVudFwiKSB7XG4gICAgICBjb25zdCByID0gW3QuY2hpbGQobildO1xuICAgICAgaWYgKG4gKyAxIDwgdC5jaGlsZENvdW50ICYmIHQuY2hpbGQobiArIDEpLnR5cGUubmFtZSA9PT0gXCJibG9ja0dyb3VwXCIpIHtcbiAgICAgICAgY29uc3QgaSA9IHQuY2hpbGQobiArIDEpLmNoaWxkKDApLmNoaWxkKDApO1xuICAgICAgICAoaS50eXBlLm5hbWUgPT09IFwiYnVsbGV0TGlzdEl0ZW1cIiB8fCBpLnR5cGUubmFtZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIgfHwgaS50eXBlLm5hbWUgPT09IFwiY2hlY2tMaXN0SXRlbVwiKSAmJiAoci5wdXNoKHQuY2hpbGQobiArIDEpKSwgdCA9IHlhKHQsIG4gKyAxKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzID0gby5zdGF0ZS5zY2hlbWEubm9kZXMuYmxvY2tDb250YWluZXIuY3JlYXRlQ2hlY2tlZChcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICByXG4gICAgICApO1xuICAgICAgdCA9IHQucmVwbGFjZUNoaWxkKG4sIHMpO1xuICAgIH1cbiAgcmV0dXJuIG5ldyB0ZSh0LCBlLm9wZW5TdGFydCwgZS5vcGVuRW5kKTtcbn1cbmZ1bmN0aW9uIEVhKGUsIG8pIHtcbiAgdmFyIHMsIGk7XG4gIGNvbnN0IHQgPSBlLmNoaWxkQ291bnQgPT09IDEsIG4gPSAoKHMgPSBlLmZpcnN0Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBzLnR5cGUuc3BlYy5jb250ZW50KSA9PT0gXCJpbmxpbmUqXCIsIHIgPSAoKGkgPSBlLmZpcnN0Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBpLnR5cGUuc3BlYy5jb250ZW50KSA9PT0gXCJ0YWJsZVJvdytcIjtcbiAgaWYgKHQpIHtcbiAgICBpZiAobilcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAocikge1xuICAgICAgY29uc3QgYSA9IEMoby5zdGF0ZSk7XG4gICAgICBpZiAoYS5pc0Jsb2NrQ29udGFpbmVyKVxuICAgICAgICByZXR1cm4gIShhLmJsb2NrQ29udGVudC5ub2RlLnR5cGUuc3BlYy5jb250ZW50ID09PSBcInRhYmxlUm93K1wiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuY29uc3QgT2UgPSBjbGFzcyBPZSBleHRlbmRzIFlvIHtcbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHN1cGVyKHsgLi4udCwgY29udGVudDogdm9pZCAwIH0pO1xuICAgIHUodGhpcywgXCJfc3RhdGVcIik7XG4gICAgLyoqXG4gICAgICogTW91bnRzIC8gdW5tb3VudHMgdGhlIGVkaXRvciB0byBhIGRvbSBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBET00gZWxlbWVudCB0byBtb3VudCB0bywgdXIgbnVsbCAvIHVuZGVmaW5lZCB0byBkZXN0cm95XG4gICAgICovXG4gICAgdSh0aGlzLCBcIm1vdW50XCIsICh0LCBuLCByKSA9PiB7XG4gICAgICBuID8gKHRoaXMub3B0aW9ucy5lbGVtZW50ID0gbiwgdGhpcy5jcmVhdGVWaWV3QWx0ZXJuYXRpdmUodCwgcikpIDogdGhpcy5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgY29uc3QgciA9IHRoaXMuc2NoZW1hO1xuICAgIGxldCBzO1xuICAgIGNvbnN0IGkgPSByLm5vZGVzLmRvYy5jcmVhdGVBbmRGaWxsO1xuICAgIHIubm9kZXMuZG9jLmNyZWF0ZUFuZEZpbGwgPSAoLi4uYykgPT4ge1xuICAgICAgaWYgKHMpXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgY29uc3QgbCA9IGkuYXBwbHkoci5ub2Rlcy5kb2MsIGMpLCBkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsLnRvSlNPTigpKSk7XG4gICAgICByZXR1cm4gZC5jb250ZW50WzBdLmNvbnRlbnRbMF0uYXR0cnMuaWQgPSBcImluaXRpYWxCbG9ja0lkXCIsIHMgPSAkby5mcm9tSlNPTihyLCBkKSwgcztcbiAgICB9O1xuICAgIGxldCBhO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5jb250ZW50Lm1hcChcbiAgICAgICAgKGwpID0+IGllKGwsIHRoaXMuc2NoZW1hLCBuKS50b0pTT04oKVxuICAgICAgKTtcbiAgICAgIGEgPSBabyhcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZG9jXCIsXG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImJsb2NrR3JvdXBcIixcbiAgICAgICAgICAgICAgY29udGVudDogY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5zY2hlbWEsXG4gICAgICAgIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnNcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgdGhyb3cgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJFcnJvciBjcmVhdGluZyBkb2N1bWVudCBmcm9tIGJsb2NrcyBwYXNzZWQgYXMgYGluaXRpYWxDb250ZW50YC4gQ2F1c2VkIGJ5IGV4Y2VwdGlvbjogXCIsXG4gICAgICAgIGNcbiAgICAgICksIG5ldyBFcnJvcihcbiAgICAgICAgXCJFcnJvciBjcmVhdGluZyBkb2N1bWVudCBmcm9tIGJsb2NrcyBwYXNzZWQgYXMgYGluaXRpYWxDb250ZW50YDpcXG5cIiArICtKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IGVuLmNyZWF0ZSh7XG4gICAgICBkb2M6IGEsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hXG4gICAgICAvLyBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcgJiYgKHRoaXMuX3N0YXRlID0gdGhpcy52aWV3LnN0YXRlKSwgdGhpcy5fc3RhdGU7XG4gIH1cbiAgZGlzcGF0Y2godCkge1xuICAgIHRoaXMudmlldyA/IHRoaXMudmlldy5kaXNwYXRjaCh0KSA6IHRoaXMuX3N0YXRlID0gdGhpcy5zdGF0ZS5hcHBseSh0KTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBgY3JlYXRlVmlld2AgbWV0aG9kIHdpdGggYSBjdXN0b20gb25lIC0gd2hpY2ggd2UgY2FsbCBvbiBtb3VudFxuICAgKi9cbiAgY3JlYXRlVmlld0FsdGVybmF0aXZlKHQsIG4pIHtcbiAgICB0aGlzLmNvbnRlbnRDb21wb25lbnQgPSBuO1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIuZXh0ZW5zaW9ucy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBpLnR5cGUgPT09IFwibWFya1wiICYmIGkuY29uZmlnLmFkZE1hcmtWaWV3ICYmIChyW2kubmFtZV0gPSBpLmNvbmZpZy5hZGRNYXJrVmlldyh0KSk7XG4gICAgfSksIHRoaXMudmlldyA9IG5ldyBQbihcbiAgICAgIHsgbW91bnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50IH0sXG4gICAgICAvLyB1c2UgbW91bnQgb3B0aW9uIHNvIHRoYXQgd2UgcmV1c2UgdGhlIGV4aXN0aW5nIGVsZW1lbnQgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmVcbiAgICAgIHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgbWFya1ZpZXdzOiByLFxuICAgICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3NcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zXG4gICAgfSk7XG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHMpLCB0aGlzLmNvbW1hbmRzLmZvY3VzKFxuICAgICAgdGhpcy5vcHRpb25zLmF1dG9mb2N1cyB8fCB0aGlzLm9wdGlvbnMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJuLWF1dG9mb2N1c1wiKSA9PT0gXCJ0cnVlXCIsXG4gICAgICB7IHNjcm9sbEludG9WaWV3OiAhMSB9XG4gICAgKSwgdGhpcy5lbWl0KFwiY3JlYXRlXCIsIHsgZWRpdG9yOiB0aGlzIH0pLCB0aGlzLmlzSW5pdGlhbGl6ZWQgPSAhMDtcbiAgfVxufTtcbnUoT2UsIFwiY3JlYXRlXCIsICh0LCBuKSA9PiB7XG4gIHZhciBzLCBpO1xuICBjb25zdCByID0gKHMgPSBnbG9iYWxUaGlzID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLndpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IHMuc2V0VGltZW91dDtcbiAgdHlwZW9mICgoaSA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMud2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogaS5zZXRUaW1lb3V0KSA8IFwidVwiICYmIChnbG9iYWxUaGlzLndpbmRvdy5zZXRUaW1lb3V0ID0gKCkgPT4gMCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBPZSh0LCBuKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByICYmIChnbG9iYWxUaGlzLndpbmRvdy5zZXRUaW1lb3V0ID0gcik7XG4gIH1cbn0pO1xubGV0IERlID0gT2U7XG5EZS5wcm90b3R5cGUuY3JlYXRlVmlldyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9wdGlvbnMub25QYXN0ZSA9IHRoaXMub3B0aW9ucy5vbkRyb3AgPSB2b2lkIDA7XG59O1xuY29uc3QgU2EgPSB7XG4gIGVuYWJsZUlucHV0UnVsZXM6ICEwLFxuICBlbmFibGVQYXN0ZVJ1bGVzOiAhMCxcbiAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6ICExXG59O1xuY2xhc3MgX28gZXh0ZW5kcyBxIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHZhciBsLCBkLCBwLCBoLCBmLCBtLCBnLCBiLCBrLCB3LCB5LCBULCBGLCBqLCBCO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogVGhlIHVuZGVybHlpbmcgcHJvc2VtaXJyb3Igc2NoZW1hXG4gICAgICovXG4gICAgdSh0aGlzLCBcInBtU2NoZW1hXCIpO1xuICAgIC8qKlxuICAgICAqIGV4dGVuc2lvbnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIGVkaXRvciwgY2FuIGJlIHRpcHRhcCBleHRlbnNpb25zIG9yIHByb3NlbWlycm9yIHBsdWdpbnNcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiZXh0ZW5zaW9uc1wiLCB7fSk7XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBpbiBoZWFkbGVzcyBtb2RlLlxuICAgICAqIEhlYWRsZXNzIG1vZGUgbWVhbnMgd2UgY2FuIHVzZSBmZWF0dXJlcyBsaWtlIGltcG9ydGluZyAvIGV4cG9ydGluZyBibG9ja3MsXG4gICAgICogYnV0IHRoZXJlJ3Mgbm8gdW5kZXJseWluZyBlZGl0b3IgKFVJKSBpbnN0YW50aWF0ZWQuXG4gICAgICpcbiAgICAgKiBZb3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byBzZXQgdGhpcyBtYW51YWxseSwgYnV0IHVzZSB0aGUgYHNlcnZlci11dGlsYCBwYWNrYWdlIGluc3RlYWQgdGhhdCB1c2VzIHRoaXMgb3B0aW9uIGludGVybmFsbHlcbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiaGVhZGxlc3NcIiwgITEpO1xuICAgIHUodGhpcywgXCJfdGlwdGFwRWRpdG9yXCIpO1xuICAgIC8vIFRPRE86IFR5cGUgc2hvdWxkIGFjdHVhbGx5IHJlZmxlY3QgdGhhdCBpdCBjYW4gYmUgYHVuZGVmaW5lZGAgaW4gaGVhZGxlc3MgbW9kZVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgUmVhY3QgdG8gc3RvcmUgYSByZWZlcmVuY2UgdG8gYW4gYEVsZW1lbnRSZW5kZXJlcmAgaGVscGVyIHV0aWxpdHkgdG8gbWFrZSBzdXJlIHdlIGNhbiByZW5kZXIgUmVhY3QgZWxlbWVudHNcbiAgICAgKiBpbiB0aGUgY29ycmVjdCBjb250ZXh0ICh1c2VkIGJ5IGBSZWFjdFJlbmRlclV0aWxgKVxuICAgICAqL1xuICAgIHUodGhpcywgXCJlbGVtZW50UmVuZGVyZXJcIiwgbnVsbCk7XG4gICAgLyoqXG4gICAgICogQ2FjaGUgb2YgYWxsIGJsb2Nrcy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0IGhhdmUgdG8gXCJyZWNvbXB1dGVcIiBibG9ja3MgaWYgdW5kZXJseWluZyBQcm9zZW1pcnJvciBOb2RlcyBoYXZlbid0IGNoYW5nZWQuXG4gICAgICogVGhpcyBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc2FtZSBibG9jayBhY3Jvc3MgbXVsdGlwbGUgb3BlcmF0aW9ucyxcbiAgICAgKiB3aXRoIHRoaXMgY2FjaGUsIGJsb2NrcyBzdGF5IHRoZSBzYW1lIG9iamVjdCByZWZlcmVuY2UgKHJlZmVyZW50aWFsIGVxdWFsaXR5IHdpdGggPT09KS5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiYmxvY2tDYWNoZVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGRpY3Rpb25hcnkgY29udGFpbnMgdHJhbnNsYXRpb25zIGZvciB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJkaWN0aW9uYXJ5XCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgb2YgdGhlIGVkaXRvci4gVGhlIHNjaGVtYSBkZWZpbmVzIHdoaWNoIEJsb2NrcywgSW5saW5lQ29udGVudCwgYW5kIFN0eWxlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgdSh0aGlzLCBcInNjaGVtYVwiKTtcbiAgICB1KHRoaXMsIFwiYmxvY2tJbXBsZW1lbnRhdGlvbnNcIik7XG4gICAgdSh0aGlzLCBcImlubGluZUNvbnRlbnRJbXBsZW1lbnRhdGlvbnNcIik7XG4gICAgdSh0aGlzLCBcInN0eWxlSW1wbGVtZW50YXRpb25zXCIpO1xuICAgIHUodGhpcywgXCJmb3JtYXR0aW5nVG9vbGJhclwiKTtcbiAgICB1KHRoaXMsIFwibGlua1Rvb2xiYXJcIik7XG4gICAgdSh0aGlzLCBcInNpZGVNZW51XCIpO1xuICAgIHUodGhpcywgXCJzdWdnZXN0aW9uTWVudXNcIik7XG4gICAgdSh0aGlzLCBcImZpbGVQYW5lbFwiKTtcbiAgICB1KHRoaXMsIFwidGFibGVIYW5kbGVzXCIpO1xuICAgIHUodGhpcywgXCJjb21tZW50c1wiKTtcbiAgICB1KHRoaXMsIFwic2hvd1NlbGVjdGlvblBsdWdpblwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHVwbG9hZEZpbGVgIG1ldGhvZCBpcyB3aGF0IHRoZSBlZGl0b3IgdXNlcyB3aGVuIGZpbGVzIG5lZWQgdG8gYmUgdXBsb2FkZWQgKGZvciBleGFtcGxlIHdoZW4gc2VsZWN0aW5nIGFuIGltYWdlIHRvIHVwbG9hZCkuXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIHNldCB3aGVuIGNyZWF0aW5nIHRoZSBlZGl0b3IgYXMgdGhpcyBpcyBhcHBsaWNhdGlvbi1zcGVjaWZpYy5cbiAgICAgKlxuICAgICAqIGB1bmRlZmluZWRgIG1lYW5zIHRoZSBhcHBsaWNhdGlvbiBkb2Vzbid0IHN1cHBvcnQgZmlsZSB1cGxvYWRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgdGhhdCBzaG91bGQgYmUgdXBsb2FkZWQuXG4gICAgICogQHJldHVybnMgVGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgZmlsZSBPUiBhbiBvYmplY3QgY29udGFpbmluZyBwcm9wcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGZpbGUgYmxvY2sgKHN1Y2ggYXMgYW4gaWQpXG4gICAgICovXG4gICAgdSh0aGlzLCBcInVwbG9hZEZpbGVcIik7XG4gICAgdSh0aGlzLCBcIm9uVXBsb2FkU3RhcnRDYWxsYmFja3NcIiwgW10pO1xuICAgIHUodGhpcywgXCJvblVwbG9hZEVuZENhbGxiYWNrc1wiLCBbXSk7XG4gICAgdSh0aGlzLCBcInJlc29sdmVGaWxlVXJsXCIpO1xuICAgIHUodGhpcywgXCJyZXNvbHZlVXNlcnNcIik7XG4gICAgLyoqXG4gICAgICogRWRpdG9yIHNldHRpbmdzXG4gICAgICovXG4gICAgdSh0aGlzLCBcInNldHRpbmdzXCIpO1xuICAgIHUodGhpcywgXCJkaXNwYXRjaFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLmRpc3BhdGNoKHQpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE1vdW50IHRoZSBlZGl0b3IgdG8gYSBwYXJlbnQgRE9NIGVsZW1lbnQuIENhbGwgbW91bnQodW5kZWZpbmVkKSB0byBjbGVhbiB1cFxuICAgICAqXG4gICAgICogQHdhcm5pbmcgTm90IG5lZWRlZCB0byBjYWxsIG1hbnVhbGx5IHdoZW4gdXNpbmcgUmVhY3QsIHVzZSBCbG9ja05vdGVWaWV3IHRvIHRha2UgY2FyZSBvZiBtb3VudGluZ1xuICAgICAqL1xuICAgIHUodGhpcywgXCJtb3VudFwiLCAodCwgbikgPT4ge1xuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLm1vdW50KHRoaXMsIHQsIG4pO1xuICAgIH0pO1xuICAgIHRoaXMub3B0aW9ucyA9IHQ7XG4gICAgY29uc3QgbiA9IHQ7XG4gICAgaWYgKG4ub25FZGl0b3JDb250ZW50Q2hhbmdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIm9uRWRpdG9yQ29udGVudENoYW5nZSBpbml0aWFsaXphdGlvbiBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIDxCbG9ja05vdGVWaWV3IG9uQ2hhbmdlPXsuLi59IC8+LCB0aGUgdXNlRWRpdG9yQ2hhbmdlKC4uLikgaG9vaywgb3IgZWRpdG9yLm9uQ2hhbmdlKC4uLilcIlxuICAgICAgKTtcbiAgICBpZiAobi5vblRleHRDdXJzb3JQb3NpdGlvbkNoYW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJvblRleHRDdXJzb3JQb3NpdGlvbkNoYW5nZSBpbml0aWFsaXphdGlvbiBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIDxCbG9ja05vdGVWaWV3IG9uU2VsZWN0aW9uQ2hhbmdlPXsuLi59IC8+LCB0aGUgdXNlRWRpdG9yU2VsZWN0aW9uQ2hhbmdlKC4uLikgaG9vaywgb3IgZWRpdG9yLm9uU2VsZWN0aW9uQ2hhbmdlKC4uLilcIlxuICAgICAgKTtcbiAgICBpZiAobi5vbkVkaXRvclJlYWR5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIm9uRWRpdG9yUmVhZHkgaXMgZGVwcmVjYXRlZC4gRWRpdG9yIGlzIGltbWVkaWF0ZWx5IHJlYWR5IGZvciB1c2UgYWZ0ZXIgY3JlYXRpb24uXCJcbiAgICAgICk7XG4gICAgaWYgKG4uZWRpdGFibGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiZWRpdGFibGUgaW5pdGlhbGl6YXRpb24gb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHVzZSA8QmxvY2tOb3RlVmlldyBlZGl0YWJsZT17dHJ1ZS9mYWxzZX0gLz4sIG9yIGFsdGVybmF0aXZlbHkgZWRpdG9yLmlzRWRpdGFibGUgPSB0cnVlL2ZhbHNlXCJcbiAgICAgICk7XG4gICAgdGhpcy5kaWN0aW9uYXJ5ID0gdC5kaWN0aW9uYXJ5IHx8IEhuLCB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgdGFibGVzOiB7XG4gICAgICAgIHNwbGl0Q2VsbHM6ICgobCA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQudGFibGVzKSA9PSBudWxsID8gdm9pZCAwIDogbC5zcGxpdENlbGxzKSA/PyAhMSxcbiAgICAgICAgY2VsbEJhY2tncm91bmRDb2xvcjogKChkID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC50YWJsZXMpID09IG51bGwgPyB2b2lkIDAgOiBkLmNlbGxCYWNrZ3JvdW5kQ29sb3IpID8/ICExLFxuICAgICAgICBjZWxsVGV4dENvbG9yOiAoKHAgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LnRhYmxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHAuY2VsbFRleHRDb2xvcikgPz8gITEsXG4gICAgICAgIGhlYWRlcnM6ICgoaCA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQudGFibGVzKSA9PSBudWxsID8gdm9pZCAwIDogaC5oZWFkZXJzKSA/PyAhMVxuICAgICAgfSxcbiAgICAgIGNvZGVCbG9jazoge1xuICAgICAgICBpbmRlbnRMaW5lV2l0aFRhYjogKChmID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5jb2RlQmxvY2spID09IG51bGwgPyB2b2lkIDAgOiBmLmluZGVudExpbmVXaXRoVGFiKSA/PyAhMCxcbiAgICAgICAgZGVmYXVsdExhbmd1YWdlOiAoKG0gPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmNvZGVCbG9jaykgPT0gbnVsbCA/IHZvaWQgMCA6IG0uZGVmYXVsdExhbmd1YWdlKSA/PyBcInRleHRcIixcbiAgICAgICAgc3VwcG9ydGVkTGFuZ3VhZ2VzOiAoKGcgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmNvZGVCbG9jaykgPT0gbnVsbCA/IHZvaWQgMCA6IGcuc3VwcG9ydGVkTGFuZ3VhZ2VzKSA/PyB7fSxcbiAgICAgICAgY3JlYXRlSGlnaGxpZ2h0ZXI6ICgoYiA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY29kZUJsb2NrKSA9PSBudWxsID8gdm9pZCAwIDogYi5jcmVhdGVIaWdobGlnaHRlcikgPz8gdm9pZCAwXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByID0ge1xuICAgICAgZGVmYXVsdFN0eWxlczogITAsXG4gICAgICBzY2hlbWE6IHQuc2NoZW1hIHx8IEJlLmNyZWF0ZSgpLFxuICAgICAgX2hlYWRsZXNzOiAhMSxcbiAgICAgIC4uLnQsXG4gICAgICBwbGFjZWhvbGRlcnM6IHtcbiAgICAgICAgLi4udGhpcy5kaWN0aW9uYXJ5LnBsYWNlaG9sZGVycyxcbiAgICAgICAgLi4udC5wbGFjZWhvbGRlcnNcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyLmNvbW1lbnRzICYmICFyLnJlc29sdmVVc2VycylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc29sdmVVc2VycyBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIGNvbW1lbnRzXCIpO1xuICAgIGlmICh0aGlzLnJlc29sdmVVc2VycyA9IHIucmVzb2x2ZVVzZXJzLCB0aGlzLnNjaGVtYSA9IHIuc2NoZW1hLCB0aGlzLmJsb2NrSW1wbGVtZW50YXRpb25zID0gci5zY2hlbWEuYmxvY2tTcGVjcywgdGhpcy5pbmxpbmVDb250ZW50SW1wbGVtZW50YXRpb25zID0gci5zY2hlbWEuaW5saW5lQ29udGVudFNwZWNzLCB0aGlzLnN0eWxlSW1wbGVtZW50YXRpb25zID0gci5zY2hlbWEuc3R5bGVTcGVjcywgdGhpcy5leHRlbnNpb25zID0ga2Eoe1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgZG9tQXR0cmlidXRlczogci5kb21BdHRyaWJ1dGVzIHx8IHt9LFxuICAgICAgYmxvY2tTcGVjczogdGhpcy5zY2hlbWEuYmxvY2tTcGVjcyxcbiAgICAgIHN0eWxlU3BlY3M6IHRoaXMuc2NoZW1hLnN0eWxlU3BlY3MsXG4gICAgICBpbmxpbmVDb250ZW50U3BlY3M6IHRoaXMuc2NoZW1hLmlubGluZUNvbnRlbnRTcGVjcyxcbiAgICAgIGNvbGxhYm9yYXRpb246IHIuY29sbGFib3JhdGlvbixcbiAgICAgIHRyYWlsaW5nQmxvY2s6IHIudHJhaWxpbmdCbG9jayxcbiAgICAgIGRpc2FibGVFeHRlbnNpb25zOiByLmRpc2FibGVFeHRlbnNpb25zLFxuICAgICAgc2V0SWRBdHRyaWJ1dGU6IHIuc2V0SWRBdHRyaWJ1dGUsXG4gICAgICBhbmltYXRpb25zOiByLmFuaW1hdGlvbnMgPz8gITAsXG4gICAgICB0YWJsZUhhbmRsZXM6IEwoXCJ0YWJsZVwiLCB0aGlzKSxcbiAgICAgIGRyb3BDdXJzb3I6IHRoaXMub3B0aW9ucy5kcm9wQ3Vyc29yID8/IE5uLFxuICAgICAgcGxhY2Vob2xkZXJzOiByLnBsYWNlaG9sZGVycyxcbiAgICAgIHRhYkJlaGF2aW9yOiByLnRhYkJlaGF2aW9yLFxuICAgICAgc2lkZU1lbnVEZXRlY3Rpb246IHIuc2lkZU1lbnVEZXRlY3Rpb24gfHwgXCJ2aWV3cG9ydFwiLFxuICAgICAgY29tbWVudHM6IHIuY29tbWVudHMsXG4gICAgICBwYXN0ZUhhbmRsZXI6IHIucGFzdGVIYW5kbGVyXG4gICAgfSksICgoKGsgPSByLl90aXB0YXBPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogay5leHRlbnNpb25zKSB8fCBbXSkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgdGhpcy5leHRlbnNpb25zW3YubmFtZV0gPSB2O1xuICAgIH0pLCBPYmplY3QuZW50cmllcyhyLl9leHRlbnNpb25zIHx8IHt9KS5mb3JFYWNoKChbdiwgSV0pID0+IHtcbiAgICAgIHR5cGVvZiBJID09IFwiZnVuY3Rpb25cIiAmJiAoSSA9IEkodGhpcykpLCB0aGlzLmV4dGVuc2lvbnNbdl0gPSBJO1xuICAgIH0pLCB0aGlzLmZvcm1hdHRpbmdUb29sYmFyID0gdGhpcy5leHRlbnNpb25zLmZvcm1hdHRpbmdUb29sYmFyLCB0aGlzLmxpbmtUb29sYmFyID0gdGhpcy5leHRlbnNpb25zLmxpbmtUb29sYmFyLCB0aGlzLnNpZGVNZW51ID0gdGhpcy5leHRlbnNpb25zLnNpZGVNZW51LCB0aGlzLnN1Z2dlc3Rpb25NZW51cyA9IHRoaXMuZXh0ZW5zaW9ucy5zdWdnZXN0aW9uTWVudXMsIHRoaXMuZmlsZVBhbmVsID0gdGhpcy5leHRlbnNpb25zLmZpbGVQYW5lbCwgdGhpcy50YWJsZUhhbmRsZXMgPSB0aGlzLmV4dGVuc2lvbnMudGFibGVIYW5kbGVzLCB0aGlzLmNvbW1lbnRzID0gdGhpcy5leHRlbnNpb25zLmNvbW1lbnRzLCB0aGlzLnNob3dTZWxlY3Rpb25QbHVnaW4gPSB0aGlzLmV4dGVuc2lvbnMuc2hvd1NlbGVjdGlvbiwgci51cGxvYWRGaWxlKSB7XG4gICAgICBjb25zdCB2ID0gci51cGxvYWRGaWxlO1xuICAgICAgdGhpcy51cGxvYWRGaWxlID0gYXN5bmMgKEksIGFlKSA9PiB7XG4gICAgICAgIHRoaXMub25VcGxvYWRTdGFydENhbGxiYWNrcy5mb3JFYWNoKFxuICAgICAgICAgIChGZSkgPT4gRmUuYXBwbHkodGhpcywgW2FlXSlcbiAgICAgICAgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdihJLCBhZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5vblVwbG9hZEVuZENhbGxiYWNrcy5mb3JFYWNoKFxuICAgICAgICAgICAgKEZlKSA9PiBGZS5hcHBseSh0aGlzLCBbYWVdKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMucmVzb2x2ZUZpbGVVcmwgPSByLnJlc29sdmVGaWxlVXJsLCB0aGlzLmhlYWRsZXNzID0gci5faGVhZGxlc3M7XG4gICAgY29uc3QgcyA9IFwiY29sbGFib3JhdGlvblwiIGluIHRoaXMuZXh0ZW5zaW9ucyB8fCBcImxpdmVibG9ja3NFeHRlbnNpb25cIiBpbiB0aGlzLmV4dGVuc2lvbnM7XG4gICAgcyAmJiByLmluaXRpYWxDb250ZW50ICYmIGNvbnNvbGUud2FybihcbiAgICAgIFwiV2hlbiB1c2luZyBDb2xsYWJvcmF0aW9uLCBpbml0aWFsQ29udGVudCBtaWdodCBjYXVzZSBjb25mbGljdHMsIGJlY2F1c2UgY2hhbmdlcyBzaG91bGQgY29tZSBmcm9tIHRoZSBjb2xsYWJvcmF0aW9uIHByb3ZpZGVyXCJcbiAgICApO1xuICAgIGNvbnN0IGkgPSByLmluaXRpYWxDb250ZW50IHx8IChzID8gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICBpZDogXCJpbml0aWFsQmxvY2tJZFwiXG4gICAgICB9XG4gICAgXSA6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgaWQ6IHZlLm9wdGlvbnMuZ2VuZXJhdGVJRCgpXG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGkpIHx8IGkubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImluaXRpYWxDb250ZW50IG11c3QgYmUgYSBub24tZW1wdHkgYXJyYXkgb2YgYmxvY2tzLCByZWNlaXZlZDogXCIgKyBpXG4gICAgICApO1xuICAgIGNvbnN0IGEgPSBbXG4gICAgICAuLi5PYmplY3QuZW50cmllcyh0aGlzLmV4dGVuc2lvbnMpLm1hcCgoW3YsIEldKSA9PiB7XG4gICAgICAgIGlmIChJIGluc3RhbmNlb2YgSCB8fCBJIGluc3RhbmNlb2Ygc2UgfHwgSSBpbnN0YW5jZW9mIGtlKVxuICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICBpZiAoIUkucGx1Z2luKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiRXh0ZW5zaW9uIHNob3VsZCBlaXRoZXIgYmUgYSBUaXBUYXAgZXh0ZW5zaW9uIG9yIGEgUHJvc2VNaXJyb3IgcGx1Z2luIGluIGEgcGx1Z2luIHByb3BlcnR5XCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gSC5jcmVhdGUoe1xuICAgICAgICAgIG5hbWU6IHYsXG4gICAgICAgICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zOiAoKSA9PiBbSS5wbHVnaW5dXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICBdLCBjID0ge1xuICAgICAgLi4uU2EsXG4gICAgICAuLi5yLl90aXB0YXBPcHRpb25zLFxuICAgICAgY29udGVudDogaSxcbiAgICAgIGV4dGVuc2lvbnM6IGEsXG4gICAgICBlZGl0b3JQcm9wczoge1xuICAgICAgICAuLi4odyA9IHIuX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiB3LmVkaXRvclByb3BzLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLy8gQXMgb2YgVGlwVGFwIHYyLjUuMCB0aGUgdGFiSW5kZXggaXMgcmVtb3ZlZCB3aGVuIHRoZSBlZGl0b3IgaXMgbm90XG4gICAgICAgICAgLy8gZWRpdGFibGUsIHNvIHlvdSBjYW4ndCBmb2N1cyBpdC4gV2Ugd2FudCB0byByZXZlcnQgdGhpcyBhcyB3ZSBoYXZlXG4gICAgICAgICAgLy8gVUkgYmVoYXZpb3VyIHRoYXQgcmVsaWVzIG9uIGl0LlxuICAgICAgICAgIHRhYkluZGV4OiBcIjBcIixcbiAgICAgICAgICAuLi4oVCA9ICh5ID0gci5fdGlwdGFwT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHkuZWRpdG9yUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBULmF0dHJpYnV0ZXMsXG4gICAgICAgICAgLi4uKEYgPSByLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBGLmVkaXRvcixcbiAgICAgICAgICBjbGFzczogWShcbiAgICAgICAgICAgIFwiYm4tZWRpdG9yXCIsXG4gICAgICAgICAgICByLmRlZmF1bHRTdHlsZXMgPyBcImJuLWRlZmF1bHQtc3R5bGVzXCIgOiBcIlwiLFxuICAgICAgICAgICAgKChCID0gKGogPSByLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBqLmVkaXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IEIuY2xhc3MpIHx8IFwiXCJcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybVBhc3RlZDogdmFcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGVhZGxlc3MgPyB0aGlzLnBtU2NoZW1hID0gUW8oYy5leHRlbnNpb25zKSA6ICh0aGlzLl90aXB0YXBFZGl0b3IgPSBEZS5jcmVhdGUoXG4gICAgICBjLFxuICAgICAgdGhpcy5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgICApLCB0aGlzLnBtU2NoZW1hID0gdGhpcy5fdGlwdGFwRWRpdG9yLnNjaGVtYSksIHRoaXMuZW1pdChcImNyZWF0ZVwiKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHQgPSB7fSkge1xuICAgIHJldHVybiBuZXcgX28odCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5kZXJseWluZyBwcm9zZW1pcnJvciB2aWV3XG4gICAqL1xuICBnZXQgcHJvc2VtaXJyb3JWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3IudmlldztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB1bmRlcmx5aW5nIHByb3NlbWlycm9yIHN0YXRlXG4gICAqL1xuICBnZXQgcHJvc2VtaXJyb3JTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlO1xuICB9XG4gIGdldCBkb21FbGVtZW50KCkge1xuICAgIHZhciB0O1xuICAgIHJldHVybiAodCA9IHRoaXMucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogdC5kb207XG4gIH1cbiAgaXNGb2N1c2VkKCkge1xuICAgIHZhciB0O1xuICAgIHJldHVybiAoKHQgPSB0aGlzLnByb3NlbWlycm9yVmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGFzRm9jdXMoKSkgfHwgITE7XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLnByb3NlbWlycm9yVmlldykgPT0gbnVsbCB8fCB0LmZvY3VzKCk7XG4gIH1cbiAgb25VcGxvYWRTdGFydCh0KSB7XG4gICAgcmV0dXJuIHRoaXMub25VcGxvYWRTdGFydENhbGxiYWNrcy5wdXNoKHQpLCAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy5vblVwbG9hZFN0YXJ0Q2FsbGJhY2tzLmluZGV4T2YodCk7XG4gICAgICBuID4gLTEgJiYgdGhpcy5vblVwbG9hZFN0YXJ0Q2FsbGJhY2tzLnNwbGljZShuLCAxKTtcbiAgICB9O1xuICB9XG4gIG9uVXBsb2FkRW5kKHQpIHtcbiAgICByZXR1cm4gdGhpcy5vblVwbG9hZEVuZENhbGxiYWNrcy5wdXNoKHQpLCAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy5vblVwbG9hZEVuZENhbGxiYWNrcy5pbmRleE9mKHQpO1xuICAgICAgbiA+IC0xICYmIHRoaXMub25VcGxvYWRFbmRDYWxsYmFja3Muc3BsaWNlKG4sIDEpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkLCB1c2UgYGVkaXRvci5kb2N1bWVudGAgaW5zdGVhZFxuICAgKi9cbiAgZ2V0IHRvcExldmVsQmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc25hcHNob3Qgb2YgYWxsIHRvcC1sZXZlbCAobm9uLW5lc3RlZCkgYmxvY2tzIGluIHRoZSBlZGl0b3IuXG4gICAqIEByZXR1cm5zIEEgc25hcHNob3Qgb2YgYWxsIHRvcC1sZXZlbCAobm9uLW5lc3RlZCkgYmxvY2tzIGluIHRoZSBlZGl0b3IuXG4gICAqL1xuICBnZXQgZG9jdW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIHJldHVybiB0aGlzLnByb3NlbWlycm9yU3RhdGUuZG9jLmZpcnN0Q2hpbGQuZGVzY2VuZGFudHMoKG4pID0+ICh0LnB1c2goXG4gICAgICBFKFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgdGhpcy5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgdGhpcy5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIHRoaXMuYmxvY2tDYWNoZVxuICAgICAgKVxuICAgICksICExKSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzbmFwc2hvdCBvZiBhbiBleGlzdGluZyBibG9jayBmcm9tIHRoZSBlZGl0b3IuXG4gICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgYmxvY2sgdGhhdCBzaG91bGQgYmVcbiAgICogcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyBUaGUgYmxvY2sgdGhhdCBtYXRjaGVzIHRoZSBpZGVudGlmaWVyLCBvciBgdW5kZWZpbmVkYCBpZiBub1xuICAgKiBtYXRjaGluZyBibG9jayB3YXMgZm91bmQuXG4gICAqL1xuICBnZXRCbG9jayh0KSB7XG4gICAgcmV0dXJuIE9zKHRoaXMsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc25hcHNob3Qgb2YgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW4gZXhpc3RpbmcgYmxvY2sgZnJvbSB0aGVcbiAgICogZWRpdG9yLlxuICAgKiBAcGFyYW0gYmxvY2tJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIGJsb2NrIGZvciB3aGljaCB0aGVcbiAgICogcHJldmlvdXMgc2libGluZyBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyBUaGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgYmxvY2sgdGhhdCBtYXRjaGVzIHRoZSBpZGVudGlmaWVyLlxuICAgKiBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBibG9jayB3YXMgZm91bmQsIG9yIGl0J3MgdGhlIGZpcnN0IGNoaWxkL2Jsb2NrXG4gICAqIGluIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIGdldFByZXZCbG9jayh0KSB7XG4gICAgcmV0dXJuIF9zKHRoaXMsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc25hcHNob3Qgb2YgdGhlIG5leHQgc2libGluZyBvZiBhbiBleGlzdGluZyBibG9jayBmcm9tIHRoZSBlZGl0b3IuXG4gICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgb2YgYW4gZXhpc3RpbmcgYmxvY2sgZm9yIHdoaWNoIHRoZVxuICAgKiBuZXh0IHNpYmxpbmcgc2hvdWxkIGJlIHJldHJpZXZlZC5cbiAgICogQHJldHVybnMgVGhlIG5leHQgc2libGluZyBvZiB0aGUgYmxvY2sgdGhhdCBtYXRjaGVzIHRoZSBpZGVudGlmaWVyLlxuICAgKiBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBibG9jayB3YXMgZm91bmQsIG9yIGl0J3MgdGhlIGxhc3QgY2hpbGQvYmxvY2sgaW5cbiAgICogdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgZ2V0TmV4dEJsb2NrKHQpIHtcbiAgICByZXR1cm4gUnModGhpcywgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzbmFwc2hvdCBvZiB0aGUgcGFyZW50IG9mIGFuIGV4aXN0aW5nIGJsb2NrIGZyb20gdGhlIGVkaXRvci5cbiAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBvZiBhbiBleGlzdGluZyBibG9jayBmb3Igd2hpY2ggdGhlXG4gICAqIHBhcmVudCBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyBUaGUgcGFyZW50IG9mIHRoZSBibG9jayB0aGF0IG1hdGNoZXMgdGhlIGlkZW50aWZpZXIuIGB1bmRlZmluZWRgXG4gICAqIGlmIG5vIG1hdGNoaW5nIGJsb2NrIHdhcyBmb3VuZCwgb3IgdGhlIGJsb2NrIGlzbid0IG5lc3RlZC5cbiAgICovXG4gIGdldFBhcmVudEJsb2NrKHQpIHtcbiAgICByZXR1cm4gVnModGhpcywgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyBhbGwgYmxvY2tzIGluIHRoZSBlZGl0b3IgZGVwdGgtZmlyc3QsIGFuZCBleGVjdXRlcyBhIGNhbGxiYWNrIGZvciBlYWNoLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggYmxvY2suIFJldHVybmluZyBgZmFsc2VgIHN0b3BzIHRoZSB0cmF2ZXJzYWwuXG4gICAqIEBwYXJhbSByZXZlcnNlIFdoZXRoZXIgdGhlIGJsb2NrcyBzaG91bGQgYmUgdHJhdmVyc2VkIGluIHJldmVyc2Ugb3JkZXIuXG4gICAqL1xuICBmb3JFYWNoQmxvY2sodCwgbiA9ICExKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZG9jdW1lbnQuc2xpY2UoKTtcbiAgICBuICYmIHIucmV2ZXJzZSgpO1xuICAgIGZ1bmN0aW9uIHMoaSkge1xuICAgICAgZm9yIChjb25zdCBhIG9mIGkpIHtcbiAgICAgICAgaWYgKHQoYSkgPT09ICExKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgYyA9IG4gPyBhLmNoaWxkcmVuLnNsaWNlKCkucmV2ZXJzZSgpIDogYS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKCFzKGMpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgcyhyKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBjYWxsYmFjayB3aGVuZXZlciB0aGUgZWRpdG9yJ3MgY29udGVudHMgY2hhbmdlLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgb25DaGFuZ2VgIGluc3RlYWRcbiAgICovXG4gIG9uRWRpdG9yQ29udGVudENoYW5nZSh0KSB7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLm9uKFwidXBkYXRlXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBlZGl0b3IncyBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYG9uU2VsZWN0aW9uQ2hhbmdlYCBpbnN0ZWFkXG4gICAqL1xuICBvbkVkaXRvclNlbGVjdGlvbkNoYW5nZSh0KSB7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgdGV4dCBjdXJzb3IgcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIEEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgdGV4dCBjdXJzb3IgcG9zaXRpb24uXG4gICAqL1xuICBnZXRUZXh0Q3Vyc29yUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHpzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGN1cnNvciBwb3NpdGlvbiB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIGFuIGV4aXN0aW5nIGJsb2NrLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHRhcmdldCBibG9jayBjb3VsZFxuICAgKiBub3QgYmUgZm91bmQuXG4gICAqIEBwYXJhbSB0YXJnZXRCbG9jayBUaGUgaWRlbnRpZmllciBvZiBhbiBleGlzdGluZyBibG9jayB0aGF0IHRoZSB0ZXh0IGN1cnNvciBzaG91bGQgYmUgbW92ZWQgdG8uXG4gICAqIEBwYXJhbSBwbGFjZW1lbnQgV2hldGhlciB0aGUgdGV4dCBjdXJzb3Igc2hvdWxkIGJlIHBsYWNlZCBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBibG9jay5cbiAgICovXG4gIHNldFRleHRDdXJzb3JQb3NpdGlvbih0LCBuID0gXCJzdGFydFwiKSB7XG4gICAgVG8odGhpcywgdCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAqL1xuICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuICRzKHRoaXMpO1xuICB9XG4gIHNldFNlbGVjdGlvbih0LCBuKSB7XG4gICAgRnModGhpcywgdCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZWRpdG9yIGlzIGN1cnJlbnRseSBlZGl0YWJsZSwgb3IgaWYgaXQncyBsb2NrZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBpcyBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZ2V0IGlzRWRpdGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLl90aXB0YXBFZGl0b3IpIHtcbiAgICAgIGlmICghdGhpcy5oZWFkbGVzcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gZWRpdG9yLCBidXQgYWxzbyBub3QgaGVhZGxlc3M/XCIpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLmlzRWRpdGFibGUgPT09IHZvaWQgMCA/ICEwIDogdGhpcy5fdGlwdGFwRWRpdG9yLmlzRWRpdGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIHRoZSBlZGl0b3IgZWRpdGFibGUgb3IgbG9ja3MgaXQsIGRlcGVuZGluZyBvbiB0aGUgYXJndW1lbnQgcGFzc2VkLlxuICAgKiBAcGFyYW0gZWRpdGFibGUgVHJ1ZSB0byBtYWtlIHRoZSBlZGl0b3IgZWRpdGFibGUsIG9yIGZhbHNlIHRvIGxvY2sgaXQuXG4gICAqL1xuICBzZXQgaXNFZGl0YWJsZSh0KSB7XG4gICAgaWYgKCF0aGlzLl90aXB0YXBFZGl0b3IpIHtcbiAgICAgIGlmICghdGhpcy5oZWFkbGVzcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gZWRpdG9yLCBidXQgYWxzbyBub3QgaGVhZGxlc3M/XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aXB0YXBFZGl0b3Iub3B0aW9ucy5lZGl0YWJsZSAhPT0gdCAmJiB0aGlzLl90aXB0YXBFZGl0b3Iuc2V0RWRpdGFibGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGJsb2NrcyBpbnRvIHRoZSBlZGl0b3IuIElmIGEgYmxvY2sncyBgaWRgIGlzIHVuZGVmaW5lZCwgQmxvY2tOb3RlIGdlbmVyYXRlcyBvbmUgYXV0b21hdGljYWxseS4gVGhyb3dzIGFuXG4gICAqIGVycm9yIGlmIHRoZSByZWZlcmVuY2UgYmxvY2sgY291bGQgbm90IGJlIGZvdW5kLlxuICAgKiBAcGFyYW0gYmxvY2tzVG9JbnNlcnQgQW4gYXJyYXkgb2YgcGFydGlhbCBibG9ja3MgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSByZWZlcmVuY2VCbG9jayBBbiBpZGVudGlmaWVyIGZvciBhbiBleGlzdGluZyBibG9jaywgYXQgd2hpY2ggdGhlIG5ldyBibG9ja3Mgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0gcGxhY2VtZW50IFdoZXRoZXIgdGhlIGJsb2NrcyBzaG91bGQgYmUgaW5zZXJ0ZWQganVzdCBiZWZvcmUsIGp1c3QgYWZ0ZXIsIG9yIG5lc3RlZCBpbnNpZGUgdGhlXG4gICAqIGByZWZlcmVuY2VCbG9ja2AuXG4gICAqL1xuICBpbnNlcnRCbG9ja3ModCwgbiwgciA9IFwiYmVmb3JlXCIpIHtcbiAgICByZXR1cm4gQnModGhpcywgdCwgbiwgcik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgYmxvY2sgaW4gdGhlIGVkaXRvci4gU2luY2UgdXBkYXRlZEJsb2NrIGlzIGEgUGFydGlhbEJsb2NrIG9iamVjdCwgc29tZSBmaWVsZHMgbWlnaHQgbm90IGJlXG4gICAqIGRlZmluZWQuIFRoZXNlIHVuZGVmaW5lZCBmaWVsZHMgYXJlIGtlcHQgYXMtaXMgZnJvbSB0aGUgZXhpc3RpbmcgYmxvY2suIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYmxvY2sgdG8gdXBkYXRlIGNvdWxkXG4gICAqIG5vdCBiZSBmb3VuZC5cbiAgICogQHBhcmFtIGJsb2NrVG9VcGRhdGUgVGhlIGJsb2NrIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB1cGRhdGUgQSBwYXJ0aWFsIGJsb2NrIHdoaWNoIGRlZmluZXMgaG93IHRoZSBleGlzdGluZyBibG9jayBzaG91bGQgYmUgY2hhbmdlZC5cbiAgICovXG4gIHVwZGF0ZUJsb2NrKHQsIG4pIHtcbiAgICByZXR1cm4gdHIodGhpcywgdCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXhpc3RpbmcgYmxvY2tzIGZyb20gdGhlIGVkaXRvci4gVGhyb3dzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgYmxvY2tzIGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAgICogQHBhcmFtIGJsb2Nrc1RvUmVtb3ZlIEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIGZvciBleGlzdGluZyBibG9ja3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUJsb2Nrcyh0KSB7XG4gICAgcmV0dXJuIERzKHRoaXMsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBleGlzdGluZyBibG9ja3MgaW4gdGhlIGVkaXRvciB3aXRoIG5ldyBibG9ja3MuIElmIHRoZSBibG9ja3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBhcmUgbm90IGFkamFjZW50IG9yXG4gICAqIGFyZSBhdCBkaWZmZXJlbnQgbmVzdGluZyBsZXZlbHMsIGBibG9ja3NUb0luc2VydGAgd2lsbCBiZSBpbnNlcnRlZCBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJsb2NrIGluXG4gICAqIGBibG9ja3NUb1JlbW92ZWAuIFRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIGJsb2NrcyB0byByZW1vdmUgY291bGQgbm90IGJlIGZvdW5kLlxuICAgKiBAcGFyYW0gYmxvY2tzVG9SZW1vdmUgQW4gYXJyYXkgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0gYmxvY2tzVG9JbnNlcnQgQW4gYXJyYXkgb2YgcGFydGlhbCBibG9ja3MgdG8gcmVwbGFjZSB0aGUgb2xkIG9uZXMgd2l0aC5cbiAgICovXG4gIHJlcGxhY2VCbG9ja3ModCwgbikge1xuICAgIHJldHVybiBIcyh0aGlzLCB0LCBuKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcGllY2Ugb2YgY29udGVudCBhdCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IGNhbiBiZSBhIHN0cmluZywgb3IgYXJyYXkgb2YgcGFydGlhbCBpbmxpbmUgY29udGVudCBlbGVtZW50c1xuICAgKi9cbiAgaW5zZXJ0SW5saW5lQ29udGVudCh0KSB7XG4gICAgY29uc3QgbiA9IE8oXG4gICAgICB0LFxuICAgICAgdGhpcy5wbVNjaGVtYSxcbiAgICAgIHRoaXMuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgKTtcbiAgICBVcyhcbiAgICAgIHtcbiAgICAgICAgZnJvbTogdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tLFxuICAgICAgICB0bzogdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi50b1xuICAgICAgfSxcbiAgICAgIG4sXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aXZlIHRleHQgc3R5bGVzIGF0IHRoZSB0ZXh0IGN1cnNvciBwb3NpdGlvbiBvciBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpZiBpdCdzIGFjdGl2ZS5cbiAgICovXG4gIGdldEFjdGl2ZVN0eWxlcygpIHtcbiAgICBjb25zdCB0ID0ge30sIG4gPSB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiR0by5tYXJrcygpO1xuICAgIGZvciAoY29uc3QgciBvZiBuKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5zY2hlbWEuc3R5bGVTY2hlbWFbci50eXBlLm5hbWVdO1xuICAgICAgaWYgKCFzKSB7XG4gICAgICAgIC8vIExpbmtzIGFyZSBub3QgY29uc2lkZXJlZCBzdHlsZXMgaW4gYmxvY2tub3RlXG4gICAgICAgIHIudHlwZS5uYW1lICE9PSBcImxpbmtcIiAmJiAvLyBcImJsb2Nrbm90ZUlnbm9yZVwiIHRhZ2dlZCBtYXJrcyAoc3VjaCBhcyBjb21tZW50cykgYXJlIGFsc28gbm90IGNvbnNpZGVyZWQgQmxvY2tOb3RlIFwic3R5bGVzXCJcbiAgICAgICAgIXIudHlwZS5zcGVjLmJsb2Nrbm90ZUlnbm9yZSAmJiBjb25zb2xlLndhcm4oXCJtYXJrIG5vdCBmb3VuZCBpbiBzdHlsZXNjaGVtYVwiLCByLnR5cGUubmFtZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcy5wcm9wU2NoZW1hID09PSBcImJvb2xlYW5cIiA/IHRbcy50eXBlXSA9ICEwIDogdFtzLnR5cGVdID0gci5hdHRycy5zdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgc3R5bGVzIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29udGVudC5cbiAgICogQHBhcmFtIHN0eWxlcyBUaGUgc3R5bGVzIHRvIGFkZC5cbiAgICovXG4gIGFkZFN0eWxlcyh0KSB7XG4gICAgZm9yIChjb25zdCBbbiwgcl0gb2YgT2JqZWN0LmVudHJpZXModCkpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYVtuXTtcbiAgICAgIGlmICghcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHlsZSAke259IG5vdCBmb3VuZCBpbiBzdHlsZVNjaGVtYWApO1xuICAgICAgaWYgKHMucHJvcFNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRNYXJrKG4pO1xuICAgICAgZWxzZSBpZiAocy5wcm9wU2NoZW1hID09PSBcInN0cmluZ1wiKVxuICAgICAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuc2V0TWFyayhuLCB7IHN0cmluZ1ZhbHVlOiByIH0pO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgJChzLnByb3BTY2hlbWEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBzdHlsZXMgZnJvbSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbnRlbnQuXG4gICAqIEBwYXJhbSBzdHlsZXMgVGhlIHN0eWxlcyB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVTdHlsZXModCkge1xuICAgIGZvciAoY29uc3QgbiBvZiBPYmplY3Qua2V5cyh0KSlcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy51bnNldE1hcmsobik7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgc3R5bGVzIG9uIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29udGVudC5cbiAgICogQHBhcmFtIHN0eWxlcyBUaGUgc3R5bGVzIHRvIHRvZ2dsZS5cbiAgICovXG4gIHRvZ2dsZVN0eWxlcyh0KSB7XG4gICAgZm9yIChjb25zdCBbbiwgcl0gb2YgT2JqZWN0LmVudHJpZXModCkpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYVtuXTtcbiAgICAgIGlmICghcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHlsZSAke259IG5vdCBmb3VuZCBpbiBzdHlsZVNjaGVtYWApO1xuICAgICAgaWYgKHMucHJvcFNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy50b2dnbGVNYXJrKG4pO1xuICAgICAgZWxzZSBpZiAocy5wcm9wU2NoZW1hID09PSBcInN0cmluZ1wiKVxuICAgICAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMudG9nZ2xlTWFyayhuLCB7IHN0cmluZ1ZhbHVlOiByIH0pO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgJChzLnByb3BTY2hlbWEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuXG4gICAqL1xuICBnZXRTZWxlY3RlZFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20sXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLnRvXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgVVJMIG9mIHRoZSBsYXN0IGxpbmsgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBhcmUgbm8gbGlua3MgaW4gdGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIGdldFNlbGVjdGVkTGlua1VybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLmdldEF0dHJpYnV0ZXMoXCJsaW5rXCIpLmhyZWY7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbGluayB0byByZXBsYWNlIHRoZSBzZWxlY3RlZCBjb250ZW50LlxuICAgKiBAcGFyYW0gdXJsIFRoZSBsaW5rIFVSTC5cbiAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gZGlzcGxheSB0aGUgbGluayB3aXRoLlxuICAgKi9cbiAgY3JlYXRlTGluayh0LCBuKSB7XG4gICAgaWYgKHQgPT09IFwiXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBmcm9tOiByLCB0bzogcyB9ID0gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbiwgaSA9IHRoaXMucG1TY2hlbWEubWFyayhcImxpbmtcIiwgeyBocmVmOiB0IH0pO1xuICAgIHRoaXMuZGlzcGF0Y2goXG4gICAgICBuID8gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyLmluc2VydFRleHQobiwgciwgcykuYWRkTWFyayhyLCByICsgbi5sZW5ndGgsIGkpIDogdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyLnNldFNlbGVjdGlvbihcbiAgICAgICAgUi5jcmVhdGUodGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnRyLmRvYywgcylcbiAgICAgICkuYWRkTWFyayhyLCBzLCBpKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgYmxvY2sgY29udGFpbmluZyB0aGUgdGV4dCBjdXJzb3IgY2FuIGJlIG5lc3RlZC5cbiAgICovXG4gIGNhbk5lc3RCbG9jaygpIHtcbiAgICByZXR1cm4gQXModGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIE5lc3RzIHRoZSBibG9jayBjb250YWluaW5nIHRoZSB0ZXh0IGN1cnNvciBpbnRvIHRoZSBibG9jayBhYm92ZSBpdC5cbiAgICovXG4gIG5lc3RCbG9jaygpIHtcbiAgICBTbyh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBibG9jayBjb250YWluaW5nIHRoZSB0ZXh0IGN1cnNvciBpcyBuZXN0ZWQuXG4gICAqL1xuICBjYW5Vbm5lc3RCbG9jaygpIHtcbiAgICByZXR1cm4gTnModGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIExpZnRzIHRoZSBibG9jayBjb250YWluaW5nIHRoZSB0ZXh0IGN1cnNvciBvdXQgb2YgaXRzIHBhcmVudC5cbiAgICovXG4gIHVubmVzdEJsb2NrKCkge1xuICAgIExzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2VsZWN0ZWQgYmxvY2tzIHVwLiBJZiB0aGUgcHJldmlvdXMgYmxvY2sgaGFzIGNoaWxkcmVuLCBtb3Zlc1xuICAgKiB0aGVtIHRvIHRoZSBlbmQgb2YgaXRzIGNoaWxkcmVuLiBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBibG9jaywgYnV0IHRoZVxuICAgKiBjdXJyZW50IGJsb2NrcyBzaGFyZSBhIGNvbW1vbiBwYXJlbnQsIG1vdmVzIHRoZW0gb3V0IG9mICYgYmVmb3JlIGl0LlxuICAgKi9cbiAgbW92ZUJsb2Nrc1VwKCkge1xuICAgIE1zKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2VsZWN0ZWQgYmxvY2tzIGRvd24uIElmIHRoZSBuZXh0IGJsb2NrIGhhcyBjaGlsZHJlbiwgbW92ZXNcbiAgICogdGhlbSB0byB0aGUgc3RhcnQgb2YgaXRzIGNoaWxkcmVuLiBJZiB0aGVyZSBpcyBubyBuZXh0IGJsb2NrLCBidXQgdGhlXG4gICAqIGN1cnJlbnQgYmxvY2tzIHNoYXJlIGEgY29tbW9uIHBhcmVudCwgbW92ZXMgdGhlbSBvdXQgb2YgJiBhZnRlciBpdC5cbiAgICovXG4gIG1vdmVCbG9ja3NEb3duKCkge1xuICAgIFBzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBFeHBvcnRzIGJsb2NrcyBpbnRvIGEgc2ltcGxpZmllZCBIVE1MIHN0cmluZy4gVG8gYmV0dGVyIGNvbmZvcm0gdG8gSFRNTCBzdGFuZGFyZHMsIGNoaWxkcmVuIG9mIGJsb2NrcyB3aGljaCBhcmVuJ3QgbGlzdFxuICAgKiBpdGVtcyBhcmUgdW4tbmVzdGVkIGluIHRoZSBvdXRwdXQgSFRNTC5cbiAgICpcbiAgICogQHBhcmFtIGJsb2NrcyBBbiBhcnJheSBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCBpbnRvIEhUTUwuXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MsIHNlcmlhbGl6ZWQgYXMgYW4gSFRNTCBzdHJpbmcuXG4gICAqL1xuICBhc3luYyBibG9ja3NUb0hUTUxMb3NzeSh0ID0gdGhpcy5kb2N1bWVudCkge1xuICAgIHJldHVybiBWZSh0aGlzLnBtU2NoZW1hLCB0aGlzKS5leHBvcnRCbG9ja3ModCwge30pO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGJsb2NrcyBpbnRvIGFuIEhUTUwgc3RyaW5nIGluIHRoZSBmb3JtYXQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSByZW5kZXJlZCBieSB0aGUgZWRpdG9yLlxuICAgKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdG8gc2VydmVyLXNpZGUgcmVuZGVyIEhUTUwgKGZvciBleGFtcGxlLCBhIGJsb2cgcG9zdCB0aGF0IGhhcyBiZWVuIGVkaXRlZCBpbiBCbG9ja05vdGUpXG4gICAqIGFuZCBzZXJ2ZSBpdCB0byB1c2VycyB3aXRob3V0IGxvYWRpbmcgdGhlIGVkaXRvciBvbiB0aGUgY2xpZW50IChpLmUuOiBkaXNwbGF5aW5nIHRoZSBibG9nIHBvc3QpXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja3MgQW4gYXJyYXkgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIHNlcmlhbGl6ZWQgaW50byBIVE1MLlxuICAgKiBAcmV0dXJucyBUaGUgYmxvY2tzLCBzZXJpYWxpemVkIGFzIGFuIEhUTUwgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgYmxvY2tzVG9GdWxsSFRNTCh0KSB7XG4gICAgcmV0dXJuIGlyKHRoaXMucG1TY2hlbWEsIHRoaXMpLnNlcmlhbGl6ZUJsb2Nrcyh0LCB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBibG9ja3MgZnJvbSBhbiBIVE1MIHN0cmluZy4gVHJpZXMgdG8gY3JlYXRlIGBCbG9ja2Agb2JqZWN0cyBvdXQgb2YgYW55IEhUTUwgYmxvY2stbGV2ZWwgZWxlbWVudHMsIGFuZFxuICAgKiBgSW5saW5lTm9kZWAgb2JqZWN0cyBmcm9tIGFueSBIVE1MIGlubGluZSBlbGVtZW50cywgdGhvdWdoIG5vdCBhbGwgZWxlbWVudCB0eXBlcyBhcmUgcmVjb2duaXplZC4gSWYgQmxvY2tOb3RlXG4gICAqIGRvZXNuJ3QgcmVjb2duaXplIGFuIEhUTUwgZWxlbWVudCdzIHRhZywgaXQgd2lsbCBwYXJzZSBpdCBhcyBhIHBhcmFncmFwaCBvciBwbGFpbiB0ZXh0LlxuICAgKiBAcGFyYW0gaHRtbCBUaGUgSFRNTCBzdHJpbmcgdG8gcGFyc2UgYmxvY2tzIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MgcGFyc2VkIGZyb20gdGhlIEhUTUwgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgdHJ5UGFyc2VIVE1MVG9CbG9ja3ModCkge1xuICAgIHJldHVybiBNbyhcbiAgICAgIHQsXG4gICAgICB0aGlzLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgIHRoaXMuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgIHRoaXMucG1TY2hlbWFcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGJsb2NrcyBpbnRvIGEgTWFya2Rvd24gc3RyaW5nLiBUaGUgb3V0cHV0IGlzIHNpbXBsaWZpZWQgYXMgTWFya2Rvd24gZG9lcyBub3Qgc3VwcG9ydCBhbGwgZmVhdHVyZXMgb2ZcbiAgICogQmxvY2tOb3RlIC0gY2hpbGRyZW4gb2YgYmxvY2tzIHdoaWNoIGFyZW4ndCBsaXN0IGl0ZW1zIGFyZSB1bi1uZXN0ZWQgYW5kIGNlcnRhaW4gc3R5bGVzIGFyZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gYmxvY2tzIEFuIGFycmF5IG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkIGludG8gTWFya2Rvd24uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MsIHNlcmlhbGl6ZWQgYXMgYSBNYXJrZG93biBzdHJpbmcuXG4gICAqL1xuICBhc3luYyBibG9ja3NUb01hcmtkb3duTG9zc3kodCA9IHRoaXMuZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gR3ModCwgdGhpcy5wbVNjaGVtYSwgdGhpcywge30pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbGlzdCBvZiBibG9ja3MgZnJvbSBhIE1hcmtkb3duIHN0cmluZy4gVHJpZXMgdG8gY3JlYXRlIGBCbG9ja2AgYW5kIGBJbmxpbmVOb2RlYCBvYmplY3RzIGJhc2VkIG9uXG4gICAqIE1hcmtkb3duIHN5bnRheCwgdGhvdWdoIG5vdCBhbGwgc3ltYm9scyBhcmUgcmVjb2duaXplZC4gSWYgQmxvY2tOb3RlIGRvZXNuJ3QgcmVjb2duaXplIGEgc3ltYm9sLCBpdCB3aWxsIHBhcnNlIGl0XG4gICAqIGFzIHRleHQuXG4gICAqIEBwYXJhbSBtYXJrZG93biBUaGUgTWFya2Rvd24gc3RyaW5nIHRvIHBhcnNlIGJsb2NrcyBmcm9tLlxuICAgKiBAcmV0dXJucyBUaGUgYmxvY2tzIHBhcnNlZCBmcm9tIHRoZSBNYXJrZG93biBzdHJpbmcuXG4gICAqL1xuICBhc3luYyB0cnlQYXJzZU1hcmtkb3duVG9CbG9ja3ModCkge1xuICAgIHJldHVybiBRcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgIHRoaXMuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgIHRoaXMucG1TY2hlbWFcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGluZm8gZm9yIHRoZSBjdXJyZW50IHVzZXIgdGhhdCdzIHNob3duIHRvIG90aGVyIGNvbGxhYm9yYXRvcnMuXG4gICAqL1xuICB1cGRhdGVDb2xsYWJvcmF0aW9uVXNlckluZm8odCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmNvbGxhYm9yYXRpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHVwZGF0ZSBjb2xsYWJvcmF0aW9uIHVzZXIgaW5mbyB3aGVuIGNvbGxhYm9yYXRpb24gaXMgZGlzYWJsZWQuXCJcbiAgICAgICk7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnVwZGF0ZVVzZXIodCk7XG4gIH1cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBydW5zIHdoZW5ldmVyIHRoZSBlZGl0b3IncyBjb250ZW50cyBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZS5cbiAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0byByZW1vdmUgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25DaGFuZ2UodCkge1xuICAgIGlmICh0aGlzLmhlYWRsZXNzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSAoKSA9PiB7XG4gICAgICB0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3RpcHRhcEVkaXRvci5vbihcInVwZGF0ZVwiLCBuKSwgKCkgPT4ge1xuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLm9mZihcInVwZGF0ZVwiLCBuKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcnVucyB3aGVuZXZlciB0aGUgdGV4dCBjdXJzb3IgcG9zaXRpb24gb3Igc2VsZWN0aW9uIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZS5cbiAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0byByZW1vdmUgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25TZWxlY3Rpb25DaGFuZ2UodCwgbikge1xuICAgIGlmICh0aGlzLmhlYWRsZXNzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSAocykgPT4ge1xuICAgICAgcy50cmFuc2FjdGlvbi5nZXRNZXRhKE5lKSAmJiAhbiB8fCB0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3RpcHRhcEVkaXRvci5vbihcInNlbGVjdGlvblVwZGF0ZVwiLCByKSwgKCkgPT4ge1xuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLm9mZihcInNlbGVjdGlvblVwZGF0ZVwiLCByKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcnVucyB3aGVuIHRoZSBlZGl0b3IgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgcGx1Z2lucyB0byBpbml0aWFsaXplIHRoZW1zZWx2ZXMgYWZ0ZXIgdGhlIGVkaXRvciBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICovXG4gIG9uQ3JlYXRlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5vbihcImNyZWF0ZVwiLCB0KSwgKCkgPT4ge1xuICAgICAgdGhpcy5vZmYoXCJjcmVhdGVcIiwgdCk7XG4gICAgfTtcbiAgfVxuICBnZXRTZWxlY3Rpb25Cb3VuZGluZ0JveCgpIHtcbiAgICB2YXIgYTtcbiAgICBpZiAoIXRoaXMucHJvc2VtaXJyb3JWaWV3KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSAoYSA9IHRoaXMucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogYS5zdGF0ZSwgeyBzZWxlY3Rpb246IG4gfSA9IHQsIHsgcmFuZ2VzOiByIH0gPSBuLCBzID0gTWF0aC5taW4oLi4uci5tYXAoKGMpID0+IGMuJGZyb20ucG9zKSksIGkgPSBNYXRoLm1heCguLi5yLm1hcCgoYykgPT4gYy4kdG8ucG9zKSk7XG4gICAgaWYgKFhlKG4pKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5wcm9zZW1pcnJvclZpZXcubm9kZURPTShzKTtcbiAgICAgIGlmIChjKVxuICAgICAgICByZXR1cm4gYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIEFlKHRoaXMucHJvc2VtaXJyb3JWaWV3LCBzLCBpKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5kb2N1bWVudDtcbiAgICByZXR1cm4gdC5sZW5ndGggPT09IDAgfHwgdC5sZW5ndGggPT09IDEgJiYgdFswXS50eXBlID09PSBcInBhcmFncmFwaFwiICYmIHRbMF0uY29udGVudC5sZW5ndGggPT09IDA7XG4gIH1cbiAgb3BlblN1Z2dlc3Rpb25NZW51KHQsIG4pIHtcbiAgICB2YXIgaTtcbiAgICBjb25zdCByID0gKGkgPSB0aGlzLnByb3NlbWlycm9yVmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IGkuc3RhdGUudHI7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBuICYmIG4uZGVsZXRlVHJpZ2dlckNoYXJhY3RlciA/IHIuaW5zZXJ0VGV4dCh0KSA6IHI7XG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZm9jdXMoKSwgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICBzLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YSh0aGlzLnN1Z2dlc3Rpb25NZW51cy5wbHVnaW4sIHtcbiAgICAgICAgdHJpZ2dlckNoYXJhY3RlcjogdCxcbiAgICAgICAgZGVsZXRlVHJpZ2dlckNoYXJhY3RlcjogKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uZGVsZXRlVHJpZ2dlckNoYXJhY3RlcikgfHwgITEsXG4gICAgICAgIGlnbm9yZVF1ZXJ5TGVuZ3RoOiAobiA9PSBudWxsID8gdm9pZCAwIDogbi5pZ25vcmVRdWVyeUxlbmd0aCkgfHwgITFcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvLyBgZm9yY2VTZWxlY3Rpb25WaXNpYmxlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGVkaXRvciBzZWxlY3Rpb24gaXMgc2hvd3NcbiAgLy8gZXZlbiB3aGVuIHRoZSBlZGl0b3IgaXMgbm90IGZvY3VzZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBlLmcuIGNyZWF0aW5nIG5ld1xuICAvLyBsaW5rcywgc28gdGhlIHVzZXIgc3RpbGwgc2VlcyB0aGUgYWZmZWN0ZWQgY29udGVudCB3aGVuIGFuIGlucHV0IGZpZWxkIGlzXG4gIC8vIGZvY3VzZWQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgbmFtaW5nP1xuICBnZXRGb3JjZVNlbGVjdGlvblZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvd1NlbGVjdGlvblBsdWdpbi5nZXRFbmFibGVkKCk7XG4gIH1cbiAgc2V0Rm9yY2VTZWxlY3Rpb25WaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNob3dTZWxlY3Rpb25QbHVnaW4uc2V0RW5hYmxlZCh0KTtcbiAgfVxuICAvKipcbiAgICogVGhpcyB3aWxsIGNvbnZlcnQgSFRNTCBpbnRvIGEgZm9ybWF0IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIEJsb2NrTm90ZS5cbiAgICovXG4gIGNvbnZlcnRIdG1sVG9CbG9ja05vdGVIdG1sKHQpIHtcbiAgICByZXR1cm4geG8odC50cmltKCkpLmlubmVySFRNTDtcbiAgfVxuICAvKipcbiAgICogUGFzdGUgSFRNTCBpbnRvIHRoZSBlZGl0b3IuIERlZmF1bHRzIHRvIGNvbnZlcnRpbmcgSFRNTCB0byBCbG9ja05vdGUgSFRNTC5cbiAgICogQHBhcmFtIGh0bWwgVGhlIEhUTUwgdG8gcGFzdGUuXG4gICAqIEBwYXJhbSByYXcgV2hldGhlciB0byBwYXN0ZSB0aGUgSFRNTCBhcyBpcywgb3IgdG8gY29udmVydCBpdCB0byBCbG9ja05vdGUgSFRNTC5cbiAgICovXG4gIHBhc3RlSFRNTCh0LCBuID0gITEpIHtcbiAgICB2YXIgcztcbiAgICBsZXQgciA9IHQ7XG4gICAgbiB8fCAociA9IHRoaXMuY29udmVydEh0bWxUb0Jsb2NrTm90ZUh0bWwodCkpLCByICYmICgocyA9IHRoaXMucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsIHx8IHMucGFzdGVIVE1MKHIpKTtcbiAgfVxuICAvKipcbiAgICogUGFzdGUgdGV4dCBpbnRvIHRoZSBlZGl0b3IuIERlZmF1bHRzIHRvIGludGVycHJldGluZyB0ZXh0IGFzIG1hcmtkb3duLlxuICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBwYXN0ZS5cbiAgICovXG4gIHBhc3RlVGV4dCh0KSB7XG4gICAgdmFyIG47XG4gICAgcmV0dXJuIChuID0gdGhpcy5wcm9zZW1pcnJvclZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBuLnBhc3RlVGV4dCh0KTtcbiAgfVxuICAvKipcbiAgICogUGFzdGUgbWFya2Rvd24gaW50byB0aGUgZWRpdG9yLlxuICAgKiBAcGFyYW0gbWFya2Rvd24gVGhlIG1hcmtkb3duIHRvIHBhc3RlLlxuICAgKi9cbiAgYXN5bmMgcGFzdGVNYXJrZG93bih0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFzdGVIVE1MKGF3YWl0IFBvKHQpKTtcbiAgfVxufVxuY29uc3Qga2MgPSB7XG4gIGdyYXk6IHtcbiAgICB0ZXh0OiBcIiM5YjlhOTdcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiNlYmVjZWRcIlxuICB9LFxuICBicm93bjoge1xuICAgIHRleHQ6IFwiIzY0NDczYVwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2U5ZTVlM1wiXG4gIH0sXG4gIHJlZDoge1xuICAgIHRleHQ6IFwiI2UwM2UzZVwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2ZiZTRlNFwiXG4gIH0sXG4gIG9yYW5nZToge1xuICAgIHRleHQ6IFwiI2Q5NzMwZFwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2Y2ZTlkOVwiXG4gIH0sXG4gIHllbGxvdzoge1xuICAgIHRleHQ6IFwiI2RmYWIwMVwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2ZiZjNkYlwiXG4gIH0sXG4gIGdyZWVuOiB7XG4gICAgdGV4dDogXCIjNGQ2NDYxXCIsXG4gICAgYmFja2dyb3VuZDogXCIjZGRlZGVhXCJcbiAgfSxcbiAgYmx1ZToge1xuICAgIHRleHQ6IFwiIzBiNmU5OVwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2RkZWJmMVwiXG4gIH0sXG4gIHB1cnBsZToge1xuICAgIHRleHQ6IFwiIzY5NDBhNVwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2VhZTRmMlwiXG4gIH0sXG4gIHBpbms6IHtcbiAgICB0ZXh0OiBcIiNhZDFhNzJcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiNmNGRmZWJcIlxuICB9XG59LCB3YyA9IHtcbiAgZ3JheToge1xuICAgIHRleHQ6IFwiI2JlYmRiOFwiLFxuICAgIGJhY2tncm91bmQ6IFwiIzliOWE5N1wiXG4gIH0sXG4gIGJyb3duOiB7XG4gICAgdGV4dDogXCIjOGU2NTUyXCIsXG4gICAgYmFja2dyb3VuZDogXCIjNjQ0NzNhXCJcbiAgfSxcbiAgcmVkOiB7XG4gICAgdGV4dDogXCIjZWM0MDQwXCIsXG4gICAgYmFja2dyb3VuZDogXCIjYmUzNDM0XCJcbiAgfSxcbiAgb3JhbmdlOiB7XG4gICAgdGV4dDogXCIjZTM3OTBkXCIsXG4gICAgYmFja2dyb3VuZDogXCIjYjc2MDBhXCJcbiAgfSxcbiAgeWVsbG93OiB7XG4gICAgdGV4dDogXCIjZGZhYjAxXCIsXG4gICAgYmFja2dyb3VuZDogXCIjYjU4YjAwXCJcbiAgfSxcbiAgZ3JlZW46IHtcbiAgICB0ZXh0OiBcIiM2YjhiODdcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiM0ZDY0NjFcIlxuICB9LFxuICBibHVlOiB7XG4gICAgdGV4dDogXCIjMGU4N2JjXCIsXG4gICAgYmFja2dyb3VuZDogXCIjMGI2ZTk5XCJcbiAgfSxcbiAgcHVycGxlOiB7XG4gICAgdGV4dDogXCIjODU1MmQ3XCIsXG4gICAgYmFja2dyb3VuZDogXCIjNjk0MGE1XCJcbiAgfSxcbiAgcGluazoge1xuICAgIHRleHQ6IFwiI2RhMjA4ZlwiLFxuICAgIGJhY2tncm91bmQ6IFwiI2FkMWE3MlwiXG4gIH1cbn07XG5jbGFzcyB5YyB7XG4gIGNvbnN0cnVjdG9yKG8sIHQsIG4pIHtcbiAgICB0aGlzLm1hcHBpbmdzID0gdCwgdGhpcy5vcHRpb25zID0gbjtcbiAgfVxuICBhc3luYyByZXNvbHZlRmlsZShvKSB7XG4gICAgdmFyIG47XG4gICAgaWYgKCEoKG4gPSB0aGlzLm9wdGlvbnMpICE9IG51bGwgJiYgbi5yZXNvbHZlRmlsZVVybCkpXG4gICAgICByZXR1cm4gKGF3YWl0IGZldGNoKG8pKS5ibG9iKCk7XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMub3B0aW9ucy5yZXNvbHZlRmlsZVVybChvKTtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIEJsb2IgPyB0IDogKGF3YWl0IGZldGNoKHQpKS5ibG9iKCk7XG4gIH1cbiAgbWFwU3R5bGVzKG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMobykubWFwKChbbiwgcl0pID0+IHRoaXMubWFwcGluZ3Muc3R5bGVNYXBwaW5nW25dKHIsIHRoaXMpKTtcbiAgfVxuICBtYXBJbmxpbmVDb250ZW50KG8pIHtcbiAgICByZXR1cm4gdGhpcy5tYXBwaW5ncy5pbmxpbmVDb250ZW50TWFwcGluZ1tvLnR5cGVdKFxuICAgICAgbyxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG4gIHRyYW5zZm9ybUlubGluZUNvbnRlbnQobykge1xuICAgIHJldHVybiBvLm1hcCgodCkgPT4gdGhpcy5tYXBJbmxpbmVDb250ZW50KHQpKTtcbiAgfVxuICBhc3luYyBtYXBCbG9jayhvLCB0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZ3MuYmxvY2tNYXBwaW5nW28udHlwZV0oXG4gICAgICBvLFxuICAgICAgdGhpcyxcbiAgICAgIHQsXG4gICAgICBuXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gQ2MoZSkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUJsb2NrTWFwcGluZzogKG8pID0+IG8sXG4gICAgY3JlYXRlSW5saW5lQ29udGVudE1hcHBpbmc6IChvKSA9PiBvLFxuICAgIGNyZWF0ZVN0eWxlTWFwcGluZzogKG8pID0+IG9cbiAgfTtcbn1cbmxldCBJZTtcbmFzeW5jIGZ1bmN0aW9uIEJhKCkge1xuICByZXR1cm4gSWUgfHwgKEllID0gKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBbZSwgb10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBpbXBvcnQoXCJlbW9qaS1tYXJ0XCIpLFxuICAgICAgLy8gdXNlIGEgZHluYW1pYyBpbXBvcnQgdG8gZW5jb3VyYWdlIGJ1bmRsZS1zcGxpdHRpbmdcbiAgICAgIC8vIGFuZCBhIHNtYWxsZXIgaW5pdGlhbCBjbGllbnQgYnVuZGxlIHNpemVcbiAgICAgIGltcG9ydChcIkBlbW9qaS1tYXJ0L2RhdGFcIilcbiAgICBdKSwgdCA9IFwiZGVmYXVsdFwiIGluIGUgPyBlLmRlZmF1bHQgOiBlLCBuID0gXCJkZWZhdWx0XCIgaW4gbyA/IG8uZGVmYXVsdCA6IG87XG4gICAgcmV0dXJuIGF3YWl0IHQuaW5pdCh7IGRhdGE6IG4gfSksIHsgZW1vamlNYXJ0OiB0LCBlbW9qaURhdGE6IG4gfTtcbiAgfSkoKSwgSWUpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmMoZSwgbykge1xuICBpZiAoIXlzKFwidGV4dFwiLCBlKSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHsgZW1vamlEYXRhOiB0LCBlbW9qaU1hcnQ6IG4gfSA9IGF3YWl0IEJhKCk7XG4gIHJldHVybiAoby50cmltKCkgPT09IFwiXCIgPyBPYmplY3QudmFsdWVzKHQuZW1vamlzKSA6IGF3YWl0IG4uU2VhcmNoSW5kZXguc2VhcmNoKG8pKS5tYXAoKHMpID0+ICh7XG4gICAgaWQ6IHMuc2tpbnNbMF0ubmF0aXZlLFxuICAgIG9uSXRlbUNsaWNrOiAoKSA9PiBlLmluc2VydElubGluZUNvbnRlbnQocy5za2luc1swXS5uYXRpdmUgKyBcIiBcIilcbiAgfSkpO1xufVxuZnVuY3Rpb24gRWMoZSwgLi4ubykge1xuICBjb25zdCB0ID0gWy4uLmVdO1xuICBmb3IgKGNvbnN0IG4gb2YgbylcbiAgICBmb3IgKGNvbnN0IHIgb2Ygbikge1xuICAgICAgY29uc3QgcyA9IHQuZmluZExhc3RJbmRleChcbiAgICAgICAgKGkpID0+IGkuZ3JvdXAgPT09IHIuZ3JvdXBcbiAgICAgICk7XG4gICAgICBzID09PSAtMSA/IHQucHVzaChyKSA6IHQuc3BsaWNlKHMgKyAxLCAwLCByKTtcbiAgICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gcWUoZSA9IFwiXCIpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBbXG4gICAge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBlLFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgXSA6IGU7XG59XG5mdW5jdGlvbiBwZShlKSB7XG4gIHZhciBvLCB0LCBuLCByLCBzO1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHFlKGUpIDogQXJyYXkuaXNBcnJheShlKSA/IGUuZmxhdE1hcCgoaSkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IHFlKGkpIDogaXQoaSkgPyB7XG4gICAgLi4uaSxcbiAgICBjb250ZW50OiBxZShpLmNvbnRlbnQpXG4gIH0gOiBKKGkpID8gaSA6IHtcbiAgICBwcm9wczoge30sXG4gICAgLi4uaSxcbiAgICBjb250ZW50OiBwZShpLmNvbnRlbnQpXG4gIH0pIDogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudHlwZSkgPT09IFwidGFibGVDb250ZW50XCIgPyB7XG4gICAgdHlwZTogXCJ0YWJsZUNvbnRlbnRcIixcbiAgICBjb2x1bW5XaWR0aHM6IGUuY29sdW1uV2lkdGhzLFxuICAgIGhlYWRlclJvd3M6IGUuaGVhZGVyUm93cyxcbiAgICBoZWFkZXJDb2xzOiBlLmhlYWRlckNvbHMsXG4gICAgcm93czogZS5yb3dzLm1hcCgoaSkgPT4gKHtcbiAgICAgIC4uLmksXG4gICAgICBjZWxsczogaS5jZWxscy5tYXAoXG4gICAgICAgIChhKSA9PiBwZShhKVxuICAgICAgKVxuICAgIH0pKVxuICB9IDogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudHlwZSkgPT09IFwidGFibGVDZWxsXCIgPyB7XG4gICAgdHlwZTogXCJ0YWJsZUNlbGxcIixcbiAgICBjb250ZW50OiBwZShlLmNvbnRlbnQpLFxuICAgIHByb3BzOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICgobyA9IGUucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBvLmJhY2tncm91bmRDb2xvcikgPz8gXCJkZWZhdWx0XCIsXG4gICAgICB0ZXh0Q29sb3I6ICgodCA9IGUucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiB0LnRleHRDb2xvcikgPz8gXCJkZWZhdWx0XCIsXG4gICAgICB0ZXh0QWxpZ25tZW50OiAoKG4gPSBlLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogbi50ZXh0QWxpZ25tZW50KSA/PyBcImxlZnRcIixcbiAgICAgIGNvbHNwYW46ICgociA9IGUucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiByLmNvbHNwYW4pID8/IDEsXG4gICAgICByb3dzcGFuOiAoKHMgPSBlLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcy5yb3dzcGFuKSA/PyAxXG4gICAgfVxuICB9IDogZTtcbn1cbmZ1bmN0aW9uIFNjKGUsIG8pIHtcbiAgcmV0dXJuIG8ubWFwKFxuICAgICh0KSA9PiBSbyhlLmJsb2NrU2NoZW1hLCB0KVxuICApO1xufVxuZnVuY3Rpb24gUm8oZSwgbykge1xuICB2YXIgcjtcbiAgY29uc3QgdCA9IGVbby50eXBlXS5jb250ZW50LCBuID0ge1xuICAgIGlkOiBcIlwiLFxuICAgIHR5cGU6IG8udHlwZSxcbiAgICBwcm9wczoge30sXG4gICAgY29udGVudDogdCA9PT0gXCJpbmxpbmVcIiA/IFtdIDogdCA9PT0gXCJ0YWJsZVwiID8ge1xuICAgICAgdHlwZTogXCJ0YWJsZUNvbnRlbnRcIixcbiAgICAgIGNvbHVtbldpZHRoczogdm9pZCAwLFxuICAgICAgaGVhZGVyUm93czogdm9pZCAwLFxuICAgICAgaGVhZGVyQ29sczogdm9pZCAwLFxuICAgICAgcm93czogW11cbiAgICB9IDogdm9pZCAwLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICAuLi5vXG4gIH07XG4gIGlmIChPYmplY3QuZW50cmllcyhlW28udHlwZV0ucHJvcFNjaGVtYSkuZm9yRWFjaChcbiAgICAoW3MsIGldKSA9PiB7XG4gICAgICBuLnByb3BzW3NdID09PSB2b2lkIDAgJiYgaS5kZWZhdWx0ICE9PSB2b2lkIDAgJiYgKG4ucHJvcHNbc10gPSBpLmRlZmF1bHQpO1xuICAgIH1cbiAgKSwgdCA9PT0gXCJpbmxpbmVcIikge1xuICAgIGNvbnN0IHMgPSBuLmNvbnRlbnQ7XG4gICAgbi5jb250ZW50ID0gcGUocyk7XG4gIH0gZWxzZSBpZiAodCA9PT0gXCJ0YWJsZVwiKSB7XG4gICAgY29uc3QgcyA9IG4uY29udGVudDtcbiAgICBuLmNvbnRlbnQgPSB7XG4gICAgICB0eXBlOiBcInRhYmxlQ29udGVudFwiLFxuICAgICAgY29sdW1uV2lkdGhzOiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5jb2x1bW5XaWR0aHMpIHx8ICgociA9IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMucm93c1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY2VsbHMubWFwKCgpID0+IHtcbiAgICAgIH0pKSB8fCBbXSxcbiAgICAgIGhlYWRlclJvd3M6IChzID09IG51bGwgPyB2b2lkIDAgOiBzLmhlYWRlclJvd3MpIHx8IHZvaWQgMCxcbiAgICAgIGhlYWRlckNvbHM6IChzID09IG51bGwgPyB2b2lkIDAgOiBzLmhlYWRlckNvbHMpIHx8IHZvaWQgMCxcbiAgICAgIHJvd3M6IChzID09IG51bGwgPyB2b2lkIDAgOiBzLnJvd3MubWFwKChpKSA9PiAoe1xuICAgICAgICBjZWxsczogaS5jZWxscy5tYXAoKGEpID0+IHBlKGEpKVxuICAgICAgfSkpKSB8fCBbXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5uLFxuICAgIGNvbnRlbnQ6IHBlKG4uY29udGVudCksXG4gICAgY2hpbGRyZW46IG4uY2hpbGRyZW4ubWFwKChzKSA9PiBSbyhlLCBzKSlcbiAgfTtcbn1cbmZ1bmN0aW9uIFRhKGUpIHtcbiAgZS5pZCB8fCAoZS5pZCA9IHZlLm9wdGlvbnMuZ2VuZXJhdGVJRCgpKSwgZS5jaGlsZHJlbiAmJiB4YShlLmNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHhhKGUpIHtcbiAgZm9yIChjb25zdCBvIG9mIGUpXG4gICAgVGEobyk7XG59XG5leHBvcnQge1xuICBnciBhcyBBdWRpb0Jsb2NrLFxuICBfbyBhcyBCbG9ja05vdGVFZGl0b3IsXG4gIEJlIGFzIEJsb2NrTm90ZVNjaGVtYSxcbiAgd2MgYXMgQ09MT1JTX0RBUktfTU9ERV9ERUZBVUxULFxuICBrYyBhcyBDT0xPUlNfREVGQVVMVCxcbiAgd3IgYXMgQ29kZUJsb2NrLFxuICAkaSBhcyBERUZBVUxUX0xJTktfUFJPVE9DT0wsXG4gIGFjIGFzIEVNUFRZX0NFTExfSEVJR0hULFxuICBtbyBhcyBFTVBUWV9DRUxMX1dJRFRILFxuICB5YyBhcyBFeHBvcnRlcixcbiAgZHIgYXMgRklMRV9BVURJT19JQ09OX1NWRyxcbiAgY3IgYXMgRklMRV9JQ09OX1NWRyxcbiAgVHIgYXMgRklMRV9JTUFHRV9JQ09OX1NWRyxcbiAgcHMgYXMgRklMRV9WSURFT19JQ09OX1NWRyxcbiAgQnIgYXMgRmlsZUJsb2NrLFxuICBQaSBhcyBGaWxlUGFuZWxQcm9zZW1pcnJvclBsdWdpbixcbiAgTWkgYXMgRmlsZVBhbmVsVmlldyxcbiAgQWkgYXMgRm9ybWF0dGluZ1Rvb2xiYXJQcm9zZW1pcnJvclBsdWdpbixcbiAgSWkgYXMgRm9ybWF0dGluZ1Rvb2xiYXJWaWV3LFxuICBNbyBhcyBIVE1MVG9CbG9ja3MsXG4gIEFyIGFzIEltYWdlQmxvY2ssXG4gIFZpIGFzIExpbmtUb29sYmFyUHJvc2VtaXJyb3JQbHVnaW4sXG4gIF9yIGFzIFBhZ2VCcmVhayxcbiAgZWEgYXMgU2lkZU1lbnVQcm9zZW1pcnJvclBsdWdpbixcbiAgWmkgYXMgU2lkZU1lbnVWaWV3LFxuICBzYSBhcyBTdWdnZXN0aW9uTWVudVByb3NlTWlycm9yUGx1Z2luLFxuICBkYSBhcyBUYWJsZUhhbmRsZXNQcm9zZW1pcnJvclBsdWdpbixcbiAgbGEgYXMgVGFibGVIYW5kbGVzVmlldyxcbiAgdmUgYXMgVW5pcXVlSUQsXG4gICQgYXMgVW5yZWFjaGFibGVDYXNlRXJyb3IsXG4gIFVpIGFzIFZBTElEX0xJTktfUFJPVE9DT0xTLFxuICBicyBhcyBWaWRlb0Jsb2NrLFxuICBUYSBhcyBhZGRJZHNUb0Jsb2NrLFxuICB4YSBhcyBhZGRJZHNUb0Jsb2NrcyxcbiAgQ3QgYXMgYWRkSW5saW5lQ29udGVudEF0dHJpYnV0ZXMsXG4gICRuIGFzIGFkZElubGluZUNvbnRlbnRLZXlib2FyZFNob3J0Y3V0cyxcbiAgR24gYXMgYWRkU3R5bGVBdHRyaWJ1dGVzLFxuICBWbiBhcyBhcHBseU5vblNlbGVjdGFibGVCbG9ja0ZpeCxcbiAgdGMgYXMgYXNzZXJ0RW1wdHksXG4gIHVyIGFzIGF1ZGlvQmxvY2tDb25maWcsXG4gIGZyIGFzIGF1ZGlvUGFyc2UsXG4gIHByIGFzIGF1ZGlvUHJvcFNjaGVtYSxcbiAgaHIgYXMgYXVkaW9SZW5kZXIsXG4gIG1yIGFzIGF1ZGlvVG9FeHRlcm5hbEhUTUwsXG4gIGllIGFzIGJsb2NrVG9Ob2RlLFxuICBHcyBhcyBibG9ja3NUb01hcmtkb3duLFxuICBIZSBhcyBjYW1lbFRvRGF0YUtlYmFiLFxuICB1YyBhcyBjaGVja0Jsb2NrSGFzRGVmYXVsdFByb3AsXG4gIENzIGFzIGNoZWNrQmxvY2tJc0RlZmF1bHRUeXBlLFxuICBsYyBhcyBjaGVja0Jsb2NrSXNGaWxlQmxvY2ssXG4gIHBjIGFzIGNoZWNrQmxvY2tJc0ZpbGVCbG9ja1dpdGhQbGFjZWhvbGRlcixcbiAgZGMgYXMgY2hlY2tCbG9ja0lzRmlsZUJsb2NrV2l0aFByZXZpZXcsXG4gIHZzIGFzIGNoZWNrQmxvY2tUeXBlSGFzRGVmYXVsdFByb3AsXG4gIEwgYXMgY2hlY2tEZWZhdWx0QmxvY2tUeXBlSW5TY2hlbWEsXG4gIHlzIGFzIGNoZWNrRGVmYXVsdElubGluZUNvbnRlbnRUeXBlSW5TY2hlbWEsXG4gIFNzIGFzIGNoZWNrUGFnZUJyZWFrQmxvY2tzSW5TY2hlbWEsXG4gIGh0IGFzIGNsZWFuSFRNTFRvTWFya2Rvd24sXG4gIEVjIGFzIGNvbWJpbmVCeUdyb3VwLFxuICBfZSBhcyBjb250ZW50Tm9kZVRvSW5saW5lQ29udGVudCxcbiAgSnQgYXMgY29udGVudE5vZGVUb1RhYmxlQ29udGVudCxcbiAgYXIgYXMgY3JlYXRlQWRkRmlsZUJ1dHRvbixcbiAgU2UgYXMgY3JlYXRlQmxvY2tTcGVjLFxuICBaIGFzIGNyZWF0ZUJsb2NrU3BlY0Zyb21TdHJvbmdseVR5cGVkVGlwdGFwTm9kZSxcbiAgeiBhcyBjcmVhdGVEZWZhdWx0QmxvY2tET01PdXRwdXRTcGVjLFxuICBWZSBhcyBjcmVhdGVFeHRlcm5hbEhUTUxFeHBvcnRlcixcbiAgZHQgYXMgY3JlYXRlRmlndXJlV2l0aENhcHRpb24sXG4gIGx0IGFzIGNyZWF0ZUZpbGVCbG9ja1dyYXBwZXIsXG4gIGxyIGFzIGNyZWF0ZUZpbGVOYW1lV2l0aEljb24sXG4gIHJjIGFzIGNyZWF0ZUlubGluZUNvbnRlbnRTcGVjLFxuICB6biBhcyBjcmVhdGVJbmxpbmVDb250ZW50U3BlY0Zyb21UaXBUYXBOb2RlLFxuICBLdCBhcyBjcmVhdGVJbnRlcm5hbEJsb2NrU3BlYyxcbiAgaXIgYXMgY3JlYXRlSW50ZXJuYWxIVE1MU2VyaWFsaXplcixcbiAgRm4gYXMgY3JlYXRlSW50ZXJuYWxJbmxpbmVDb250ZW50U3BlYyxcbiAgWnQgYXMgY3JlYXRlSW50ZXJuYWxTdHlsZVNwZWMsXG4gICRlIGFzIGNyZWF0ZUxpbmtXaXRoQ2FwdGlvbixcbiAgbG8gYXMgY3JlYXRlUmVzaXphYmxlRmlsZUJsb2NrV3JhcHBlcixcbiAgVyBhcyBjcmVhdGVTdHJvbmdseVR5cGVkVGlwdGFwTm9kZSxcbiAgc2MgYXMgY3JlYXRlU3R5bGVTcGVjLFxuICBlZSBhcyBjcmVhdGVTdHlsZVNwZWNGcm9tVGlwVGFwTWFyayxcbiAgYmMgYXMgY3JlYXRlU3VnZ2VzdGlvbk1lbnUsXG4gIGtzIGFzIGRlZmF1bHRCbG9ja1NjaGVtYSxcbiAgZ28gYXMgZGVmYXVsdEJsb2NrU3BlY3MsXG4gIHl0IGFzIGRlZmF1bHRCbG9ja1RvSFRNTCxcbiAgYnIgYXMgZGVmYXVsdENvZGVCbG9ja1Byb3BTY2hlbWEsXG4gIHdzIGFzIGRlZmF1bHRJbmxpbmVDb250ZW50U2NoZW1hLFxuICBrbyBhcyBkZWZhdWx0SW5saW5lQ29udGVudFNwZWNzLFxuICBTIGFzIGRlZmF1bHRQcm9wcyxcbiAgY2MgYXMgZGVmYXVsdFN0eWxlU2NoZW1hLFxuICBibyBhcyBkZWZhdWx0U3R5bGVTcGVjcyxcbiAgY2UgYXMgZXNtRGVwZW5kZW5jaWVzLFxuICBDciBhcyBmaWxlQmxvY2tDb25maWcsXG4gIEVyIGFzIGZpbGVQYXJzZSxcbiAgeXIgYXMgZmlsZVByb3BTY2hlbWEsXG4gIHZyIGFzIGZpbGVSZW5kZXIsXG4gIFNyIGFzIGZpbGVUb0V4dGVybmFsSFRNTCxcbiAgbmMgYXMgZmlsZW5hbWVGcm9tVVJMLFxuICBmYyBhcyBmaWx0ZXJTdWdnZXN0aW9uSXRlbXMsXG4gIEsgYXMgZm9ybWF0S2V5Ym9hcmRTaG9ydGN1dCxcbiAgTGkgYXMgZm9ybWF0dGluZ1Rvb2xiYXJQbHVnaW5LZXksXG4gIFJuIGFzIGdldEJsb2NrRnJvbVBvcyxcbiAgbmUgYXMgZ2V0QmxvY2tJbmZvLFxuICBDZSBhcyBnZXRCbG9ja0luZm9Gcm9tUmVzb2x2ZWRQb3MsXG4gIEMgYXMgZ2V0QmxvY2tJbmZvRnJvbVNlbGVjdGlvbixcbiAgc3QgYXMgZ2V0QmxvY2tJbmZvV2l0aE1hbnVhbE9mZnNldCxcbiAga2EgYXMgZ2V0QmxvY2tOb3RlRXh0ZW5zaW9ucyxcbiAgWHQgYXMgZ2V0QmxvY2tTY2hlbWFGcm9tU3BlY3MsXG4gIGdlIGFzIGdldENvbHNwYW4sXG4gIHZjIGFzIGdldERlZmF1bHRFbW9qaVBpY2tlckl0ZW1zLFxuICBoYyBhcyBnZXREZWZhdWx0U2xhc2hNZW51SXRlbXMsXG4gIFduIGFzIGdldElubGluZUNvbnRlbnRQYXJzZVJ1bGVzLFxuICBZdCBhcyBnZXRJbmxpbmVDb250ZW50U2NoZW1hRnJvbVNwZWNzLFxuICBYIGFzIGdldE5lYXJlc3RCbG9ja1BvcyxcbiAgRCBhcyBnZXROb2RlQnlJZCxcbiAgZ2MgYXMgZ2V0UGFnZUJyZWFrU2xhc2hNZW51SXRlbXMsXG4gIFVuIGFzIGdldFBhcnNlUnVsZXMsXG4gIFllIGFzIGdldFJvd3NwYW4sXG4gIHFuIGFzIGdldFN0eWxlUGFyc2VSdWxlcyxcbiAgUXQgYXMgZ2V0U3R5bGVTY2hlbWFGcm9tU3BlY3MsXG4gIE1yIGFzIGltYWdlQmxvY2tDb25maWcsXG4gIElyIGFzIGltYWdlUGFyc2UsXG4gIHhyIGFzIGltYWdlUHJvcFNjaGVtYSxcbiAgUHIgYXMgaW1hZ2VSZW5kZXIsXG4gIExyIGFzIGltYWdlVG9FeHRlcm5hbEhUTUwsXG4gIHF0IGFzIGluaGVyaXRlZFByb3BzLFxuICB1dCBhcyBpbml0aWFsaXplRVNNRGVwZW5kZW5jaWVzLFxuICBPIGFzIGlubGluZUNvbnRlbnRUb05vZGVzLFxuICBQIGFzIGluc2VydE9yVXBkYXRlQmxvY2ssXG4gIF9uIGFzIGlzQXBwbGVPUyxcbiAgd3QgYXMgaXNMaW5rSW5saW5lQ29udGVudCxcbiAgaXQgYXMgaXNQYXJ0aWFsTGlua0lubGluZUNvbnRlbnQsXG4gIG1lIGFzIGlzUGFydGlhbFRhYmxlQ2VsbCxcbiAgb2MgYXMgaXNTYWZhcmksXG4gIEogYXMgaXNTdHlsZWRUZXh0SW5saW5lQ29udGVudCxcbiAgYXQgYXMgaXNUYWJsZUNlbGwsXG4gIEl0IGFzIGlzVGFibGVDZWxsU2VsZWN0aW9uLFxuICBSaSBhcyBsaW5rVG9vbGJhclBsdWdpbktleSxcbiAgSmUgYXMgbWFwVGFibGVDZWxsLFxuICBDYyBhcyBtYXBwaW5nRmFjdG9yeSxcbiAgUXMgYXMgbWFya2Rvd25Ub0Jsb2NrcyxcbiAgUG8gYXMgbWFya2Rvd25Ub0hUTUwsXG4gIFkgYXMgbWVyZ2VDU1NDbGFzc2VzLFxuICBFIGFzIG5vZGVUb0Jsb2NrLFxuICBaZSBhcyBub2RlVG9DdXN0b21JbmxpbmVDb250ZW50LFxuICBOciBhcyBwYWdlQnJlYWtDb25maWcsXG4gIERyIGFzIHBhZ2VCcmVha1BhcnNlLFxuICBIciBhcyBwYWdlQnJlYWtSZW5kZXIsXG4gIHdvIGFzIHBhZ2VCcmVha1NjaGVtYSxcbiAgT3IgYXMgcGFnZUJyZWFrVG9FeHRlcm5hbEhUTUwsXG4gIHh0IGFzIHBhcnNlRW1iZWRFbGVtZW50LFxuICBVZSBhcyBwYXJzZUZpZ3VyZUVsZW1lbnQsXG4gIFJvIGFzIHBhcnRpYWxCbG9ja1RvQmxvY2tGb3JUZXN0aW5nLFxuICBTYyBhcyBwYXJ0aWFsQmxvY2tzVG9CbG9ja3NGb3JUZXN0aW5nLFxuICBFZSBhcyBwcm9wc1RvQXR0cmlidXRlcyxcbiAgV2UgYXMgc2hpa2lIaWdobGlnaHRlclByb21pc2VTeW1ib2wsXG4gIEJ0IGFzIHNoaWtpUGFyc2VyU3ltYm9sLFxuICBRaSBhcyBzaWRlTWVudVBsdWdpbktleSxcbiAgam4gYXMgc3R5bGVQcm9wc1RvQXR0cmlidXRlcyxcbiAgUmUgYXMgdGFibGVDb250ZW50VG9Ob2RlcyxcbiAgZmUgYXMgdGFibGVIYW5kbGVzUGx1Z2luS2V5LFxuICB0ciBhcyB1cGRhdGVCbG9jayxcbiAgeCBhcyB1cGRhdGVCbG9ja0NvbW1hbmQsXG4gIGljIGFzIHVwbG9hZFRvVG1wRmlsZXNEb3RPcmdfREVWX09OTFksXG4gIGhzIGFzIHZpZGVvQmxvY2tDb25maWcsXG4gIG1zIGFzIHZpZGVvUGFyc2UsXG4gIHVzIGFzIHZpZGVvUHJvcFNjaGVtYSxcbiAgZnMgYXMgdmlkZW9SZW5kZXIsXG4gIGdzIGFzIHZpZGVvVG9FeHRlcm5hbEhUTUwsXG4gIG1jIGFzIHdpdGhQYWdlQnJlYWssXG4gIFRlIGFzIHdyYXBJbkJsb2NrU3RydWN0dXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2tub3RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@blocknote/core/dist/blocknote.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@blocknote/core/dist/en-B7ycW7c8.js":
/*!**********************************************************!*\
  !*** ./node_modules/@blocknote/core/dist/en-B7ycW7c8.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   e: () => (/* binding */ t)\n/* harmony export */ });\nconst t = {\n  slash_menu: {\n    heading: {\n      title: \"Heading 1\",\n      subtext: \"Top-level heading\",\n      aliases: [\"h\", \"heading1\", \"h1\"],\n      group: \"Headings\"\n    },\n    heading_2: {\n      title: \"Heading 2\",\n      subtext: \"Key section heading\",\n      aliases: [\"h2\", \"heading2\", \"subheading\"],\n      group: \"Headings\"\n    },\n    heading_3: {\n      title: \"Heading 3\",\n      subtext: \"Subsection and group heading\",\n      aliases: [\"h3\", \"heading3\", \"subheading\"],\n      group: \"Headings\"\n    },\n    quote: {\n      title: \"Quote\",\n      subtext: \"Quote or excerpt\",\n      aliases: [\"quotation\", \"blockquote\", \"bq\"],\n      group: \"Basic blocks\"\n    },\n    numbered_list: {\n      title: \"Numbered List\",\n      subtext: \"List with ordered items\",\n      aliases: [\"ol\", \"li\", \"list\", \"numberedlist\", \"numbered list\"],\n      group: \"Basic blocks\"\n    },\n    bullet_list: {\n      title: \"Bullet List\",\n      subtext: \"List with unordered items\",\n      aliases: [\"ul\", \"li\", \"list\", \"bulletlist\", \"bullet list\"],\n      group: \"Basic blocks\"\n    },\n    check_list: {\n      title: \"Check List\",\n      subtext: \"List with checkboxes\",\n      aliases: [\n        \"ul\",\n        \"li\",\n        \"list\",\n        \"checklist\",\n        \"check list\",\n        \"checked list\",\n        \"checkbox\"\n      ],\n      group: \"Basic blocks\"\n    },\n    paragraph: {\n      title: \"Paragraph\",\n      subtext: \"The body of your document\",\n      aliases: [\"p\", \"paragraph\"],\n      group: \"Basic blocks\"\n    },\n    code_block: {\n      title: \"Code Block\",\n      subtext: \"Code block with syntax highlighting\",\n      aliases: [\"code\", \"pre\"],\n      group: \"Basic blocks\"\n    },\n    page_break: {\n      title: \"Page Break\",\n      subtext: \"Page separator\",\n      aliases: [\"page\", \"break\", \"separator\"],\n      group: \"Basic blocks\"\n    },\n    table: {\n      title: \"Table\",\n      subtext: \"Table with editable cells\",\n      aliases: [\"table\"],\n      group: \"Advanced\"\n    },\n    image: {\n      title: \"Image\",\n      subtext: \"Resizable image with caption\",\n      aliases: [\n        \"image\",\n        \"imageUpload\",\n        \"upload\",\n        \"img\",\n        \"picture\",\n        \"media\",\n        \"url\"\n      ],\n      group: \"Media\"\n    },\n    video: {\n      title: \"Video\",\n      subtext: \"Resizable video with caption\",\n      aliases: [\n        \"video\",\n        \"videoUpload\",\n        \"upload\",\n        \"mp4\",\n        \"film\",\n        \"media\",\n        \"url\"\n      ],\n      group: \"Media\"\n    },\n    audio: {\n      title: \"Audio\",\n      subtext: \"Embedded audio with caption\",\n      aliases: [\n        \"audio\",\n        \"audioUpload\",\n        \"upload\",\n        \"mp3\",\n        \"sound\",\n        \"media\",\n        \"url\"\n      ],\n      group: \"Media\"\n    },\n    file: {\n      title: \"File\",\n      subtext: \"Embedded file\",\n      aliases: [\"file\", \"upload\", \"embed\", \"media\", \"url\"],\n      group: \"Media\"\n    },\n    emoji: {\n      title: \"Emoji\",\n      subtext: \"Search for and insert an emoji\",\n      aliases: [\"emoji\", \"emote\", \"emotion\", \"face\"],\n      group: \"Others\"\n    }\n  },\n  placeholders: {\n    default: \"Enter text or type '/' for commands\",\n    heading: \"Heading\",\n    bulletListItem: \"List\",\n    numberedListItem: \"List\",\n    checkListItem: \"List\",\n    emptyDocument: void 0,\n    new_comment: \"Write a comment...\",\n    edit_comment: \"Edit comment...\",\n    comment_reply: \"Add comment...\"\n  },\n  file_blocks: {\n    image: {\n      add_button_text: \"Add image\"\n    },\n    video: {\n      add_button_text: \"Add video\"\n    },\n    audio: {\n      add_button_text: \"Add audio\"\n    },\n    file: {\n      add_button_text: \"Add file\"\n    }\n  },\n  // from react package:\n  side_menu: {\n    add_block_label: \"Add block\",\n    drag_handle_label: \"Open block menu\"\n  },\n  drag_handle: {\n    delete_menuitem: \"Delete\",\n    colors_menuitem: \"Colors\",\n    header_row_menuitem: \"Header row\",\n    header_column_menuitem: \"Header column\"\n  },\n  table_handle: {\n    delete_column_menuitem: \"Delete column\",\n    delete_row_menuitem: \"Delete row\",\n    add_left_menuitem: \"Add column left\",\n    add_right_menuitem: \"Add column right\",\n    add_above_menuitem: \"Add row above\",\n    add_below_menuitem: \"Add row below\",\n    split_cell_menuitem: \"Split cell\",\n    merge_cells_menuitem: \"Merge cells\",\n    background_color_menuitem: \"Background color\"\n  },\n  suggestion_menu: {\n    no_items_title: \"No items found\",\n    loading: \"Loading…\"\n  },\n  color_picker: {\n    text_title: \"Text\",\n    background_title: \"Background\",\n    colors: {\n      default: \"Default\",\n      gray: \"Gray\",\n      brown: \"Brown\",\n      red: \"Red\",\n      orange: \"Orange\",\n      yellow: \"Yellow\",\n      green: \"Green\",\n      blue: \"Blue\",\n      purple: \"Purple\",\n      pink: \"Pink\"\n    }\n  },\n  formatting_toolbar: {\n    bold: {\n      tooltip: \"Bold\",\n      secondary_tooltip: \"Mod+B\"\n    },\n    italic: {\n      tooltip: \"Italic\",\n      secondary_tooltip: \"Mod+I\"\n    },\n    underline: {\n      tooltip: \"Underline\",\n      secondary_tooltip: \"Mod+U\"\n    },\n    strike: {\n      tooltip: \"Strike\",\n      secondary_tooltip: \"Mod+Shift+S\"\n    },\n    code: {\n      tooltip: \"Code\",\n      secondary_tooltip: \"\"\n    },\n    colors: {\n      tooltip: \"Colors\"\n    },\n    link: {\n      tooltip: \"Create link\",\n      secondary_tooltip: \"Mod+K\"\n    },\n    file_caption: {\n      tooltip: \"Edit caption\",\n      input_placeholder: \"Edit caption\"\n    },\n    file_replace: {\n      tooltip: {\n        image: \"Replace image\",\n        video: \"Replace video\",\n        audio: \"Replace audio\",\n        file: \"Replace file\"\n      }\n    },\n    file_rename: {\n      tooltip: {\n        image: \"Rename image\",\n        video: \"Rename video\",\n        audio: \"Rename audio\",\n        file: \"Rename file\"\n      },\n      input_placeholder: {\n        image: \"Rename image\",\n        video: \"Rename video\",\n        audio: \"Rename audio\",\n        file: \"Rename file\"\n      }\n    },\n    file_download: {\n      tooltip: {\n        image: \"Download image\",\n        video: \"Download video\",\n        audio: \"Download audio\",\n        file: \"Download file\"\n      }\n    },\n    file_delete: {\n      tooltip: {\n        image: \"Delete image\",\n        video: \"Delete video\",\n        audio: \"Delete audio\",\n        file: \"Delete file\"\n      }\n    },\n    file_preview_toggle: {\n      tooltip: \"Toggle preview\"\n    },\n    nest: {\n      tooltip: \"Nest block\",\n      secondary_tooltip: \"Tab\"\n    },\n    unnest: {\n      tooltip: \"Unnest block\",\n      secondary_tooltip: \"Shift+Tab\"\n    },\n    align_left: {\n      tooltip: \"Align text left\"\n    },\n    align_center: {\n      tooltip: \"Align text center\"\n    },\n    align_right: {\n      tooltip: \"Align text right\"\n    },\n    align_justify: {\n      tooltip: \"Justify text\"\n    },\n    table_cell_merge: {\n      tooltip: \"Merge cells\"\n    },\n    comment: {\n      tooltip: \"Add comment\"\n    }\n  },\n  file_panel: {\n    upload: {\n      title: \"Upload\",\n      file_placeholder: {\n        image: \"Upload image\",\n        video: \"Upload video\",\n        audio: \"Upload audio\",\n        file: \"Upload file\"\n      },\n      upload_error: \"Error: Upload failed\"\n    },\n    embed: {\n      title: \"Embed\",\n      embed_button: {\n        image: \"Embed image\",\n        video: \"Embed video\",\n        audio: \"Embed audio\",\n        file: \"Embed file\"\n      },\n      url_placeholder: \"Enter URL\"\n    }\n  },\n  link_toolbar: {\n    delete: {\n      tooltip: \"Remove link\"\n    },\n    edit: {\n      text: \"Edit link\",\n      tooltip: \"Edit\"\n    },\n    open: {\n      tooltip: \"Open in new tab\"\n    },\n    form: {\n      title_placeholder: \"Edit title\",\n      url_placeholder: \"Edit URL\"\n    }\n  },\n  comments: {\n    actions: {\n      add_reaction: \"Add reaction\",\n      resolve: \"Resolve\",\n      edit_comment: \"Edit comment\",\n      delete_comment: \"Delete comment\",\n      more_actions: \"More actions\"\n    },\n    reactions: {\n      reacted_by: \"Reacted by\"\n    },\n    sidebar: {\n      marked_as_resolved: \"Marked as resolved\",\n      more_replies: (e) => `${e} more replies`\n    }\n  },\n  generic: {\n    ctrl_shortcut: \"Ctrl\"\n  }\n};\n\n//# sourceMappingURL=en-B7ycW7c8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmxvY2tub3RlL2NvcmUvZGlzdC9lbi1CN3ljVzdjOC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixHQUFHO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEBibG9ja25vdGVcXGNvcmVcXGRpc3RcXGVuLUI3eWNXN2M4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHQgPSB7XG4gIHNsYXNoX21lbnU6IHtcbiAgICBoZWFkaW5nOiB7XG4gICAgICB0aXRsZTogXCJIZWFkaW5nIDFcIixcbiAgICAgIHN1YnRleHQ6IFwiVG9wLWxldmVsIGhlYWRpbmdcIixcbiAgICAgIGFsaWFzZXM6IFtcImhcIiwgXCJoZWFkaW5nMVwiLCBcImgxXCJdLFxuICAgICAgZ3JvdXA6IFwiSGVhZGluZ3NcIlxuICAgIH0sXG4gICAgaGVhZGluZ18yOiB7XG4gICAgICB0aXRsZTogXCJIZWFkaW5nIDJcIixcbiAgICAgIHN1YnRleHQ6IFwiS2V5IHNlY3Rpb24gaGVhZGluZ1wiLFxuICAgICAgYWxpYXNlczogW1wiaDJcIiwgXCJoZWFkaW5nMlwiLCBcInN1YmhlYWRpbmdcIl0sXG4gICAgICBncm91cDogXCJIZWFkaW5nc1wiXG4gICAgfSxcbiAgICBoZWFkaW5nXzM6IHtcbiAgICAgIHRpdGxlOiBcIkhlYWRpbmcgM1wiLFxuICAgICAgc3VidGV4dDogXCJTdWJzZWN0aW9uIGFuZCBncm91cCBoZWFkaW5nXCIsXG4gICAgICBhbGlhc2VzOiBbXCJoM1wiLCBcImhlYWRpbmczXCIsIFwic3ViaGVhZGluZ1wiXSxcbiAgICAgIGdyb3VwOiBcIkhlYWRpbmdzXCJcbiAgICB9LFxuICAgIHF1b3RlOiB7XG4gICAgICB0aXRsZTogXCJRdW90ZVwiLFxuICAgICAgc3VidGV4dDogXCJRdW90ZSBvciBleGNlcnB0XCIsXG4gICAgICBhbGlhc2VzOiBbXCJxdW90YXRpb25cIiwgXCJibG9ja3F1b3RlXCIsIFwiYnFcIl0sXG4gICAgICBncm91cDogXCJCYXNpYyBibG9ja3NcIlxuICAgIH0sXG4gICAgbnVtYmVyZWRfbGlzdDoge1xuICAgICAgdGl0bGU6IFwiTnVtYmVyZWQgTGlzdFwiLFxuICAgICAgc3VidGV4dDogXCJMaXN0IHdpdGggb3JkZXJlZCBpdGVtc1wiLFxuICAgICAgYWxpYXNlczogW1wib2xcIiwgXCJsaVwiLCBcImxpc3RcIiwgXCJudW1iZXJlZGxpc3RcIiwgXCJudW1iZXJlZCBsaXN0XCJdLFxuICAgICAgZ3JvdXA6IFwiQmFzaWMgYmxvY2tzXCJcbiAgICB9LFxuICAgIGJ1bGxldF9saXN0OiB7XG4gICAgICB0aXRsZTogXCJCdWxsZXQgTGlzdFwiLFxuICAgICAgc3VidGV4dDogXCJMaXN0IHdpdGggdW5vcmRlcmVkIGl0ZW1zXCIsXG4gICAgICBhbGlhc2VzOiBbXCJ1bFwiLCBcImxpXCIsIFwibGlzdFwiLCBcImJ1bGxldGxpc3RcIiwgXCJidWxsZXQgbGlzdFwiXSxcbiAgICAgIGdyb3VwOiBcIkJhc2ljIGJsb2Nrc1wiXG4gICAgfSxcbiAgICBjaGVja19saXN0OiB7XG4gICAgICB0aXRsZTogXCJDaGVjayBMaXN0XCIsXG4gICAgICBzdWJ0ZXh0OiBcIkxpc3Qgd2l0aCBjaGVja2JveGVzXCIsXG4gICAgICBhbGlhc2VzOiBbXG4gICAgICAgIFwidWxcIixcbiAgICAgICAgXCJsaVwiLFxuICAgICAgICBcImxpc3RcIixcbiAgICAgICAgXCJjaGVja2xpc3RcIixcbiAgICAgICAgXCJjaGVjayBsaXN0XCIsXG4gICAgICAgIFwiY2hlY2tlZCBsaXN0XCIsXG4gICAgICAgIFwiY2hlY2tib3hcIlxuICAgICAgXSxcbiAgICAgIGdyb3VwOiBcIkJhc2ljIGJsb2Nrc1wiXG4gICAgfSxcbiAgICBwYXJhZ3JhcGg6IHtcbiAgICAgIHRpdGxlOiBcIlBhcmFncmFwaFwiLFxuICAgICAgc3VidGV4dDogXCJUaGUgYm9keSBvZiB5b3VyIGRvY3VtZW50XCIsXG4gICAgICBhbGlhc2VzOiBbXCJwXCIsIFwicGFyYWdyYXBoXCJdLFxuICAgICAgZ3JvdXA6IFwiQmFzaWMgYmxvY2tzXCJcbiAgICB9LFxuICAgIGNvZGVfYmxvY2s6IHtcbiAgICAgIHRpdGxlOiBcIkNvZGUgQmxvY2tcIixcbiAgICAgIHN1YnRleHQ6IFwiQ29kZSBibG9jayB3aXRoIHN5bnRheCBoaWdobGlnaHRpbmdcIixcbiAgICAgIGFsaWFzZXM6IFtcImNvZGVcIiwgXCJwcmVcIl0sXG4gICAgICBncm91cDogXCJCYXNpYyBibG9ja3NcIlxuICAgIH0sXG4gICAgcGFnZV9icmVhazoge1xuICAgICAgdGl0bGU6IFwiUGFnZSBCcmVha1wiLFxuICAgICAgc3VidGV4dDogXCJQYWdlIHNlcGFyYXRvclwiLFxuICAgICAgYWxpYXNlczogW1wicGFnZVwiLCBcImJyZWFrXCIsIFwic2VwYXJhdG9yXCJdLFxuICAgICAgZ3JvdXA6IFwiQmFzaWMgYmxvY2tzXCJcbiAgICB9LFxuICAgIHRhYmxlOiB7XG4gICAgICB0aXRsZTogXCJUYWJsZVwiLFxuICAgICAgc3VidGV4dDogXCJUYWJsZSB3aXRoIGVkaXRhYmxlIGNlbGxzXCIsXG4gICAgICBhbGlhc2VzOiBbXCJ0YWJsZVwiXSxcbiAgICAgIGdyb3VwOiBcIkFkdmFuY2VkXCJcbiAgICB9LFxuICAgIGltYWdlOiB7XG4gICAgICB0aXRsZTogXCJJbWFnZVwiLFxuICAgICAgc3VidGV4dDogXCJSZXNpemFibGUgaW1hZ2Ugd2l0aCBjYXB0aW9uXCIsXG4gICAgICBhbGlhc2VzOiBbXG4gICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAgXCJpbWFnZVVwbG9hZFwiLFxuICAgICAgICBcInVwbG9hZFwiLFxuICAgICAgICBcImltZ1wiLFxuICAgICAgICBcInBpY3R1cmVcIixcbiAgICAgICAgXCJtZWRpYVwiLFxuICAgICAgICBcInVybFwiXG4gICAgICBdLFxuICAgICAgZ3JvdXA6IFwiTWVkaWFcIlxuICAgIH0sXG4gICAgdmlkZW86IHtcbiAgICAgIHRpdGxlOiBcIlZpZGVvXCIsXG4gICAgICBzdWJ0ZXh0OiBcIlJlc2l6YWJsZSB2aWRlbyB3aXRoIGNhcHRpb25cIixcbiAgICAgIGFsaWFzZXM6IFtcbiAgICAgICAgXCJ2aWRlb1wiLFxuICAgICAgICBcInZpZGVvVXBsb2FkXCIsXG4gICAgICAgIFwidXBsb2FkXCIsXG4gICAgICAgIFwibXA0XCIsXG4gICAgICAgIFwiZmlsbVwiLFxuICAgICAgICBcIm1lZGlhXCIsXG4gICAgICAgIFwidXJsXCJcbiAgICAgIF0sXG4gICAgICBncm91cDogXCJNZWRpYVwiXG4gICAgfSxcbiAgICBhdWRpbzoge1xuICAgICAgdGl0bGU6IFwiQXVkaW9cIixcbiAgICAgIHN1YnRleHQ6IFwiRW1iZWRkZWQgYXVkaW8gd2l0aCBjYXB0aW9uXCIsXG4gICAgICBhbGlhc2VzOiBbXG4gICAgICAgIFwiYXVkaW9cIixcbiAgICAgICAgXCJhdWRpb1VwbG9hZFwiLFxuICAgICAgICBcInVwbG9hZFwiLFxuICAgICAgICBcIm1wM1wiLFxuICAgICAgICBcInNvdW5kXCIsXG4gICAgICAgIFwibWVkaWFcIixcbiAgICAgICAgXCJ1cmxcIlxuICAgICAgXSxcbiAgICAgIGdyb3VwOiBcIk1lZGlhXCJcbiAgICB9LFxuICAgIGZpbGU6IHtcbiAgICAgIHRpdGxlOiBcIkZpbGVcIixcbiAgICAgIHN1YnRleHQ6IFwiRW1iZWRkZWQgZmlsZVwiLFxuICAgICAgYWxpYXNlczogW1wiZmlsZVwiLCBcInVwbG9hZFwiLCBcImVtYmVkXCIsIFwibWVkaWFcIiwgXCJ1cmxcIl0sXG4gICAgICBncm91cDogXCJNZWRpYVwiXG4gICAgfSxcbiAgICBlbW9qaToge1xuICAgICAgdGl0bGU6IFwiRW1vamlcIixcbiAgICAgIHN1YnRleHQ6IFwiU2VhcmNoIGZvciBhbmQgaW5zZXJ0IGFuIGVtb2ppXCIsXG4gICAgICBhbGlhc2VzOiBbXCJlbW9qaVwiLCBcImVtb3RlXCIsIFwiZW1vdGlvblwiLCBcImZhY2VcIl0sXG4gICAgICBncm91cDogXCJPdGhlcnNcIlxuICAgIH1cbiAgfSxcbiAgcGxhY2Vob2xkZXJzOiB7XG4gICAgZGVmYXVsdDogXCJFbnRlciB0ZXh0IG9yIHR5cGUgJy8nIGZvciBjb21tYW5kc1wiLFxuICAgIGhlYWRpbmc6IFwiSGVhZGluZ1wiLFxuICAgIGJ1bGxldExpc3RJdGVtOiBcIkxpc3RcIixcbiAgICBudW1iZXJlZExpc3RJdGVtOiBcIkxpc3RcIixcbiAgICBjaGVja0xpc3RJdGVtOiBcIkxpc3RcIixcbiAgICBlbXB0eURvY3VtZW50OiB2b2lkIDAsXG4gICAgbmV3X2NvbW1lbnQ6IFwiV3JpdGUgYSBjb21tZW50Li4uXCIsXG4gICAgZWRpdF9jb21tZW50OiBcIkVkaXQgY29tbWVudC4uLlwiLFxuICAgIGNvbW1lbnRfcmVwbHk6IFwiQWRkIGNvbW1lbnQuLi5cIlxuICB9LFxuICBmaWxlX2Jsb2Nrczoge1xuICAgIGltYWdlOiB7XG4gICAgICBhZGRfYnV0dG9uX3RleHQ6IFwiQWRkIGltYWdlXCJcbiAgICB9LFxuICAgIHZpZGVvOiB7XG4gICAgICBhZGRfYnV0dG9uX3RleHQ6IFwiQWRkIHZpZGVvXCJcbiAgICB9LFxuICAgIGF1ZGlvOiB7XG4gICAgICBhZGRfYnV0dG9uX3RleHQ6IFwiQWRkIGF1ZGlvXCJcbiAgICB9LFxuICAgIGZpbGU6IHtcbiAgICAgIGFkZF9idXR0b25fdGV4dDogXCJBZGQgZmlsZVwiXG4gICAgfVxuICB9LFxuICAvLyBmcm9tIHJlYWN0IHBhY2thZ2U6XG4gIHNpZGVfbWVudToge1xuICAgIGFkZF9ibG9ja19sYWJlbDogXCJBZGQgYmxvY2tcIixcbiAgICBkcmFnX2hhbmRsZV9sYWJlbDogXCJPcGVuIGJsb2NrIG1lbnVcIlxuICB9LFxuICBkcmFnX2hhbmRsZToge1xuICAgIGRlbGV0ZV9tZW51aXRlbTogXCJEZWxldGVcIixcbiAgICBjb2xvcnNfbWVudWl0ZW06IFwiQ29sb3JzXCIsXG4gICAgaGVhZGVyX3Jvd19tZW51aXRlbTogXCJIZWFkZXIgcm93XCIsXG4gICAgaGVhZGVyX2NvbHVtbl9tZW51aXRlbTogXCJIZWFkZXIgY29sdW1uXCJcbiAgfSxcbiAgdGFibGVfaGFuZGxlOiB7XG4gICAgZGVsZXRlX2NvbHVtbl9tZW51aXRlbTogXCJEZWxldGUgY29sdW1uXCIsXG4gICAgZGVsZXRlX3Jvd19tZW51aXRlbTogXCJEZWxldGUgcm93XCIsXG4gICAgYWRkX2xlZnRfbWVudWl0ZW06IFwiQWRkIGNvbHVtbiBsZWZ0XCIsXG4gICAgYWRkX3JpZ2h0X21lbnVpdGVtOiBcIkFkZCBjb2x1bW4gcmlnaHRcIixcbiAgICBhZGRfYWJvdmVfbWVudWl0ZW06IFwiQWRkIHJvdyBhYm92ZVwiLFxuICAgIGFkZF9iZWxvd19tZW51aXRlbTogXCJBZGQgcm93IGJlbG93XCIsXG4gICAgc3BsaXRfY2VsbF9tZW51aXRlbTogXCJTcGxpdCBjZWxsXCIsXG4gICAgbWVyZ2VfY2VsbHNfbWVudWl0ZW06IFwiTWVyZ2UgY2VsbHNcIixcbiAgICBiYWNrZ3JvdW5kX2NvbG9yX21lbnVpdGVtOiBcIkJhY2tncm91bmQgY29sb3JcIlxuICB9LFxuICBzdWdnZXN0aW9uX21lbnU6IHtcbiAgICBub19pdGVtc190aXRsZTogXCJObyBpdGVtcyBmb3VuZFwiLFxuICAgIGxvYWRpbmc6IFwiTG9hZGluZ+KAplwiXG4gIH0sXG4gIGNvbG9yX3BpY2tlcjoge1xuICAgIHRleHRfdGl0bGU6IFwiVGV4dFwiLFxuICAgIGJhY2tncm91bmRfdGl0bGU6IFwiQmFja2dyb3VuZFwiLFxuICAgIGNvbG9yczoge1xuICAgICAgZGVmYXVsdDogXCJEZWZhdWx0XCIsXG4gICAgICBncmF5OiBcIkdyYXlcIixcbiAgICAgIGJyb3duOiBcIkJyb3duXCIsXG4gICAgICByZWQ6IFwiUmVkXCIsXG4gICAgICBvcmFuZ2U6IFwiT3JhbmdlXCIsXG4gICAgICB5ZWxsb3c6IFwiWWVsbG93XCIsXG4gICAgICBncmVlbjogXCJHcmVlblwiLFxuICAgICAgYmx1ZTogXCJCbHVlXCIsXG4gICAgICBwdXJwbGU6IFwiUHVycGxlXCIsXG4gICAgICBwaW5rOiBcIlBpbmtcIlxuICAgIH1cbiAgfSxcbiAgZm9ybWF0dGluZ190b29sYmFyOiB7XG4gICAgYm9sZDoge1xuICAgICAgdG9vbHRpcDogXCJCb2xkXCIsXG4gICAgICBzZWNvbmRhcnlfdG9vbHRpcDogXCJNb2QrQlwiXG4gICAgfSxcbiAgICBpdGFsaWM6IHtcbiAgICAgIHRvb2x0aXA6IFwiSXRhbGljXCIsXG4gICAgICBzZWNvbmRhcnlfdG9vbHRpcDogXCJNb2QrSVwiXG4gICAgfSxcbiAgICB1bmRlcmxpbmU6IHtcbiAgICAgIHRvb2x0aXA6IFwiVW5kZXJsaW5lXCIsXG4gICAgICBzZWNvbmRhcnlfdG9vbHRpcDogXCJNb2QrVVwiXG4gICAgfSxcbiAgICBzdHJpa2U6IHtcbiAgICAgIHRvb2x0aXA6IFwiU3RyaWtlXCIsXG4gICAgICBzZWNvbmRhcnlfdG9vbHRpcDogXCJNb2QrU2hpZnQrU1wiXG4gICAgfSxcbiAgICBjb2RlOiB7XG4gICAgICB0b29sdGlwOiBcIkNvZGVcIixcbiAgICAgIHNlY29uZGFyeV90b29sdGlwOiBcIlwiXG4gICAgfSxcbiAgICBjb2xvcnM6IHtcbiAgICAgIHRvb2x0aXA6IFwiQ29sb3JzXCJcbiAgICB9LFxuICAgIGxpbms6IHtcbiAgICAgIHRvb2x0aXA6IFwiQ3JlYXRlIGxpbmtcIixcbiAgICAgIHNlY29uZGFyeV90b29sdGlwOiBcIk1vZCtLXCJcbiAgICB9LFxuICAgIGZpbGVfY2FwdGlvbjoge1xuICAgICAgdG9vbHRpcDogXCJFZGl0IGNhcHRpb25cIixcbiAgICAgIGlucHV0X3BsYWNlaG9sZGVyOiBcIkVkaXQgY2FwdGlvblwiXG4gICAgfSxcbiAgICBmaWxlX3JlcGxhY2U6IHtcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgaW1hZ2U6IFwiUmVwbGFjZSBpbWFnZVwiLFxuICAgICAgICB2aWRlbzogXCJSZXBsYWNlIHZpZGVvXCIsXG4gICAgICAgIGF1ZGlvOiBcIlJlcGxhY2UgYXVkaW9cIixcbiAgICAgICAgZmlsZTogXCJSZXBsYWNlIGZpbGVcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZmlsZV9yZW5hbWU6IHtcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgaW1hZ2U6IFwiUmVuYW1lIGltYWdlXCIsXG4gICAgICAgIHZpZGVvOiBcIlJlbmFtZSB2aWRlb1wiLFxuICAgICAgICBhdWRpbzogXCJSZW5hbWUgYXVkaW9cIixcbiAgICAgICAgZmlsZTogXCJSZW5hbWUgZmlsZVwiXG4gICAgICB9LFxuICAgICAgaW5wdXRfcGxhY2Vob2xkZXI6IHtcbiAgICAgICAgaW1hZ2U6IFwiUmVuYW1lIGltYWdlXCIsXG4gICAgICAgIHZpZGVvOiBcIlJlbmFtZSB2aWRlb1wiLFxuICAgICAgICBhdWRpbzogXCJSZW5hbWUgYXVkaW9cIixcbiAgICAgICAgZmlsZTogXCJSZW5hbWUgZmlsZVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBmaWxlX2Rvd25sb2FkOiB7XG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGltYWdlOiBcIkRvd25sb2FkIGltYWdlXCIsXG4gICAgICAgIHZpZGVvOiBcIkRvd25sb2FkIHZpZGVvXCIsXG4gICAgICAgIGF1ZGlvOiBcIkRvd25sb2FkIGF1ZGlvXCIsXG4gICAgICAgIGZpbGU6IFwiRG93bmxvYWQgZmlsZVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBmaWxlX2RlbGV0ZToge1xuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBpbWFnZTogXCJEZWxldGUgaW1hZ2VcIixcbiAgICAgICAgdmlkZW86IFwiRGVsZXRlIHZpZGVvXCIsXG4gICAgICAgIGF1ZGlvOiBcIkRlbGV0ZSBhdWRpb1wiLFxuICAgICAgICBmaWxlOiBcIkRlbGV0ZSBmaWxlXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbGVfcHJldmlld190b2dnbGU6IHtcbiAgICAgIHRvb2x0aXA6IFwiVG9nZ2xlIHByZXZpZXdcIlxuICAgIH0sXG4gICAgbmVzdDoge1xuICAgICAgdG9vbHRpcDogXCJOZXN0IGJsb2NrXCIsXG4gICAgICBzZWNvbmRhcnlfdG9vbHRpcDogXCJUYWJcIlxuICAgIH0sXG4gICAgdW5uZXN0OiB7XG4gICAgICB0b29sdGlwOiBcIlVubmVzdCBibG9ja1wiLFxuICAgICAgc2Vjb25kYXJ5X3Rvb2x0aXA6IFwiU2hpZnQrVGFiXCJcbiAgICB9LFxuICAgIGFsaWduX2xlZnQ6IHtcbiAgICAgIHRvb2x0aXA6IFwiQWxpZ24gdGV4dCBsZWZ0XCJcbiAgICB9LFxuICAgIGFsaWduX2NlbnRlcjoge1xuICAgICAgdG9vbHRpcDogXCJBbGlnbiB0ZXh0IGNlbnRlclwiXG4gICAgfSxcbiAgICBhbGlnbl9yaWdodDoge1xuICAgICAgdG9vbHRpcDogXCJBbGlnbiB0ZXh0IHJpZ2h0XCJcbiAgICB9LFxuICAgIGFsaWduX2p1c3RpZnk6IHtcbiAgICAgIHRvb2x0aXA6IFwiSnVzdGlmeSB0ZXh0XCJcbiAgICB9LFxuICAgIHRhYmxlX2NlbGxfbWVyZ2U6IHtcbiAgICAgIHRvb2x0aXA6IFwiTWVyZ2UgY2VsbHNcIlxuICAgIH0sXG4gICAgY29tbWVudDoge1xuICAgICAgdG9vbHRpcDogXCJBZGQgY29tbWVudFwiXG4gICAgfVxuICB9LFxuICBmaWxlX3BhbmVsOiB7XG4gICAgdXBsb2FkOiB7XG4gICAgICB0aXRsZTogXCJVcGxvYWRcIixcbiAgICAgIGZpbGVfcGxhY2Vob2xkZXI6IHtcbiAgICAgICAgaW1hZ2U6IFwiVXBsb2FkIGltYWdlXCIsXG4gICAgICAgIHZpZGVvOiBcIlVwbG9hZCB2aWRlb1wiLFxuICAgICAgICBhdWRpbzogXCJVcGxvYWQgYXVkaW9cIixcbiAgICAgICAgZmlsZTogXCJVcGxvYWQgZmlsZVwiXG4gICAgICB9LFxuICAgICAgdXBsb2FkX2Vycm9yOiBcIkVycm9yOiBVcGxvYWQgZmFpbGVkXCJcbiAgICB9LFxuICAgIGVtYmVkOiB7XG4gICAgICB0aXRsZTogXCJFbWJlZFwiLFxuICAgICAgZW1iZWRfYnV0dG9uOiB7XG4gICAgICAgIGltYWdlOiBcIkVtYmVkIGltYWdlXCIsXG4gICAgICAgIHZpZGVvOiBcIkVtYmVkIHZpZGVvXCIsXG4gICAgICAgIGF1ZGlvOiBcIkVtYmVkIGF1ZGlvXCIsXG4gICAgICAgIGZpbGU6IFwiRW1iZWQgZmlsZVwiXG4gICAgICB9LFxuICAgICAgdXJsX3BsYWNlaG9sZGVyOiBcIkVudGVyIFVSTFwiXG4gICAgfVxuICB9LFxuICBsaW5rX3Rvb2xiYXI6IHtcbiAgICBkZWxldGU6IHtcbiAgICAgIHRvb2x0aXA6IFwiUmVtb3ZlIGxpbmtcIlxuICAgIH0sXG4gICAgZWRpdDoge1xuICAgICAgdGV4dDogXCJFZGl0IGxpbmtcIixcbiAgICAgIHRvb2x0aXA6IFwiRWRpdFwiXG4gICAgfSxcbiAgICBvcGVuOiB7XG4gICAgICB0b29sdGlwOiBcIk9wZW4gaW4gbmV3IHRhYlwiXG4gICAgfSxcbiAgICBmb3JtOiB7XG4gICAgICB0aXRsZV9wbGFjZWhvbGRlcjogXCJFZGl0IHRpdGxlXCIsXG4gICAgICB1cmxfcGxhY2Vob2xkZXI6IFwiRWRpdCBVUkxcIlxuICAgIH1cbiAgfSxcbiAgY29tbWVudHM6IHtcbiAgICBhY3Rpb25zOiB7XG4gICAgICBhZGRfcmVhY3Rpb246IFwiQWRkIHJlYWN0aW9uXCIsXG4gICAgICByZXNvbHZlOiBcIlJlc29sdmVcIixcbiAgICAgIGVkaXRfY29tbWVudDogXCJFZGl0IGNvbW1lbnRcIixcbiAgICAgIGRlbGV0ZV9jb21tZW50OiBcIkRlbGV0ZSBjb21tZW50XCIsXG4gICAgICBtb3JlX2FjdGlvbnM6IFwiTW9yZSBhY3Rpb25zXCJcbiAgICB9LFxuICAgIHJlYWN0aW9uczoge1xuICAgICAgcmVhY3RlZF9ieTogXCJSZWFjdGVkIGJ5XCJcbiAgICB9LFxuICAgIHNpZGViYXI6IHtcbiAgICAgIG1hcmtlZF9hc19yZXNvbHZlZDogXCJNYXJrZWQgYXMgcmVzb2x2ZWRcIixcbiAgICAgIG1vcmVfcmVwbGllczogKGUpID0+IGAke2V9IG1vcmUgcmVwbGllc2BcbiAgICB9XG4gIH0sXG4gIGdlbmVyaWM6IHtcbiAgICBjdHJsX3Nob3J0Y3V0OiBcIkN0cmxcIlxuICB9XG59O1xuZXhwb3J0IHtcbiAgdCBhcyBlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW4tQjd5Y1c3YzguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@blocknote/core/dist/en-B7ycW7c8.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@blocknote/react/dist/blocknote-react.js":
/*!***************************************************************!*\
  !*** ./node_modules/@blocknote/react/dist/blocknote-react.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddBlockButton: () => (/* binding */ dr),\n/* harmony export */   AddButton: () => (/* binding */ Je),\n/* harmony export */   AddCommentButton: () => (/* binding */ Xo),\n/* harmony export */   AddFileButton: () => (/* binding */ ci),\n/* harmony export */   AddTiptapCommentButton: () => (/* binding */ Yo),\n/* harmony export */   AudioBlock: () => (/* binding */ ui),\n/* harmony export */   AudioPreview: () => (/* binding */ si),\n/* harmony export */   AudioToExternalHTML: () => (/* binding */ di),\n/* harmony export */   BasicTextStyleButton: () => (/* binding */ ne),\n/* harmony export */   BlockColorsItem: () => (/* binding */ mr),\n/* harmony export */   BlockContentWrapper: () => (/* binding */ pe),\n/* harmony export */   BlockNoteContext: () => (/* binding */ dt),\n/* harmony export */   BlockNoteDefaultUI: () => (/* binding */ Kr),\n/* harmony export */   BlockNoteViewEditor: () => (/* binding */ oi),\n/* harmony export */   BlockNoteViewRaw: () => (/* binding */ Fi),\n/* harmony export */   BlockTypeSelect: () => (/* binding */ Ko),\n/* harmony export */   ColorPickerButton: () => (/* binding */ zr),\n/* harmony export */   ColorStyleButton: () => (/* binding */ Zo),\n/* harmony export */   Comment: () => (/* binding */ Lo),\n/* harmony export */   Comments: () => (/* binding */ Eo),\n/* harmony export */   ComponentsContext: () => (/* binding */ On),\n/* harmony export */   CreateLinkButton: () => (/* binding */ Ao),\n/* harmony export */   DeleteButton: () => (/* binding */ _r),\n/* harmony export */   DeleteLinkButton: () => (/* binding */ rr),\n/* harmony export */   DragHandleButton: () => (/* binding */ Cr),\n/* harmony export */   DragHandleMenu: () => (/* binding */ br),\n/* harmony export */   EditLinkButton: () => (/* binding */ ir),\n/* harmony export */   EditLinkMenuItems: () => (/* binding */ Vt),\n/* harmony export */   EmbedTab: () => (/* binding */ _o),\n/* harmony export */   ExperimentalMobileFormattingToolbarController: () => (/* binding */ Wi),\n/* harmony export */   ExtendButton: () => (/* binding */ Rr),\n/* harmony export */   FigureWithCaption: () => (/* binding */ Pe),\n/* harmony export */   FileBlock: () => (/* binding */ hi),\n/* harmony export */   FileBlockWrapper: () => (/* binding */ Oe),\n/* harmony export */   FileCaptionButton: () => (/* binding */ Go),\n/* harmony export */   FileDeleteButton: () => (/* binding */ Uo),\n/* harmony export */   FileDownloadButton: () => (/* binding */ Jo),\n/* harmony export */   FileNameWithIcon: () => (/* binding */ ai),\n/* harmony export */   FilePanel: () => (/* binding */ Bt),\n/* harmony export */   FilePanelController: () => (/* binding */ No),\n/* harmony export */   FilePreviewButton: () => (/* binding */ Qo),\n/* harmony export */   FileRenameButton: () => (/* binding */ zo),\n/* harmony export */   FileReplaceButton: () => (/* binding */ jo),\n/* harmony export */   FileToExternalHTML: () => (/* binding */ mi),\n/* harmony export */   FloatingComposer: () => (/* binding */ Fn),\n/* harmony export */   FloatingComposerController: () => (/* binding */ An),\n/* harmony export */   FloatingThreadController: () => (/* binding */ Ro),\n/* harmony export */   FormattingToolbar: () => (/* binding */ St),\n/* harmony export */   FormattingToolbarController: () => (/* binding */ or),\n/* harmony export */   GridSuggestionMenuController: () => (/* binding */ xr),\n/* harmony export */   GridSuggestionMenuWrapper: () => (/* binding */ Mr),\n/* harmony export */   ImageBlock: () => (/* binding */ bi),\n/* harmony export */   ImagePreview: () => (/* binding */ fi),\n/* harmony export */   ImageToExternalHTML: () => (/* binding */ gi),\n/* harmony export */   InlineContentWrapper: () => (/* binding */ Bi),\n/* harmony export */   LinkToolbar: () => (/* binding */ cr),\n/* harmony export */   LinkToolbarController: () => (/* binding */ ar),\n/* harmony export */   LinkWithCaption: () => (/* binding */ fe),\n/* harmony export */   NestBlockButton: () => (/* binding */ Wo),\n/* harmony export */   OpenLinkButton: () => (/* binding */ lr),\n/* harmony export */   ReactAudioBlock: () => (/* binding */ Ai),\n/* harmony export */   ReactFileBlock: () => (/* binding */ Gi),\n/* harmony export */   ReactImageBlock: () => (/* binding */ Ui),\n/* harmony export */   ReactVideoBlock: () => (/* binding */ ji),\n/* harmony export */   RemoveBlockItem: () => (/* binding */ hr),\n/* harmony export */   ResizableFileBlockWrapper: () => (/* binding */ It),\n/* harmony export */   SideMenu: () => (/* binding */ pr),\n/* harmony export */   SideMenuController: () => (/* binding */ kr),\n/* harmony export */   SplitButton: () => (/* binding */ jr),\n/* harmony export */   SuggestionMenuController: () => (/* binding */ Lr),\n/* harmony export */   SuggestionMenuWrapper: () => (/* binding */ Vr),\n/* harmony export */   TableCellButton: () => (/* binding */ $r),\n/* harmony export */   TableCellMenu: () => (/* binding */ Wr),\n/* harmony export */   TableCellMergeButton: () => (/* binding */ er),\n/* harmony export */   TableColumnHeaderItem: () => (/* binding */ gr),\n/* harmony export */   TableHandle: () => (/* binding */ Dr),\n/* harmony export */   TableHandleMenu: () => (/* binding */ Or),\n/* harmony export */   TableHandlesController: () => (/* binding */ qr),\n/* harmony export */   TableRowHeaderItem: () => (/* binding */ fr),\n/* harmony export */   TextAlignButton: () => (/* binding */ be),\n/* harmony export */   Thread: () => (/* binding */ xt),\n/* harmony export */   ThreadsSidebar: () => (/* binding */ $i),\n/* harmony export */   UnnestBlockButton: () => (/* binding */ $o),\n/* harmony export */   UploadTab: () => (/* binding */ Io),\n/* harmony export */   VideoBlock: () => (/* binding */ vi),\n/* harmony export */   VideoPreview: () => (/* binding */ ki),\n/* harmony export */   VideoToExternalHTML: () => (/* binding */ wi),\n/* harmony export */   blockTypeSelectItems: () => (/* binding */ qo),\n/* harmony export */   createReactBlockSpec: () => (/* binding */ he),\n/* harmony export */   createReactInlineContentSpec: () => (/* binding */ Yi),\n/* harmony export */   createReactStyleSpec: () => (/* binding */ Ji),\n/* harmony export */   elementOverflow: () => (/* binding */ Qi),\n/* harmony export */   getDefaultReactEmojiPickerItems: () => (/* binding */ wr),\n/* harmony export */   getDefaultReactSlashMenuItems: () => (/* binding */ Tr),\n/* harmony export */   getFormattingToolbarItems: () => (/* binding */ nr),\n/* harmony export */   getPageBreakReactSlashMenuItems: () => (/* binding */ zi),\n/* harmony export */   getReferenceText: () => (/* binding */ tt),\n/* harmony export */   mergeRefs: () => (/* binding */ Po),\n/* harmony export */   useActiveStyles: () => (/* binding */ qi),\n/* harmony export */   useBlockNote: () => (/* binding */ Oi),\n/* harmony export */   useBlockNoteContext: () => (/* binding */ D),\n/* harmony export */   useBlockNoteEditor: () => (/* binding */ b),\n/* harmony export */   useCloseSuggestionMenuNoItems: () => (/* binding */ Lt),\n/* harmony export */   useComponentsContext: () => (/* binding */ C),\n/* harmony export */   useCreateBlockNote: () => (/* binding */ de),\n/* harmony export */   useDictionary: () => (/* binding */ M),\n/* harmony export */   useEditorChange: () => (/* binding */ ue),\n/* harmony export */   useEditorContentOrSelectionChange: () => (/* binding */ U),\n/* harmony export */   useEditorForceUpdate: () => (/* binding */ Ki),\n/* harmony export */   useEditorSelectionChange: () => (/* binding */ se),\n/* harmony export */   useExtendButtonsPositioning: () => (/* binding */ Zr),\n/* harmony export */   useFocusWithin: () => (/* binding */ Xi),\n/* harmony export */   useGridSuggestionMenuKeyboardNavigation: () => (/* binding */ Hr),\n/* harmony export */   useLoadSuggestionMenuItems: () => (/* binding */ Et),\n/* harmony export */   usePrefersColorScheme: () => (/* binding */ Xr),\n/* harmony export */   useResolveUrl: () => (/* binding */ Ne),\n/* harmony export */   useSelectedBlocks: () => (/* binding */ R),\n/* harmony export */   useSuggestionMenuKeyboardNavigation: () => (/* binding */ Br),\n/* harmony export */   useTableHandlesPositioning: () => (/* binding */ Ur),\n/* harmony export */   useThreads: () => (/* binding */ yt),\n/* harmony export */   useUser: () => (/* binding */ So),\n/* harmony export */   useUsers: () => (/* binding */ Ie)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react */ \"(app-pages-browser)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react */ \"(app-pages-browser)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _blocknote_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @blocknote/core */ \"(app-pages-browser)/./node_modules/@blocknote/core/dist/blocknote.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/react */ \"(app-pages-browser)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/react */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\");\nvar Zt = Object.defineProperty;\nvar De = (e) => {\n  throw TypeError(e);\n};\nvar Ft = (e, t, n) => t in e ? Zt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar L = (e, t, n) => Ft(e, typeof t != \"symbol\" ? t + \"\" : t, n), At = (e, t, n) => t.has(e) || De(\"Cannot \" + n);\nvar Ze = (e, t, n) => t.has(e) ? De(\"Cannot add the same private member more than once\") : t instanceof WeakSet ? t.add(e) : t.set(e, n);\nvar ge = (e, t, n) => (At(e, t, \"access private method\"), n);\n\n\n\n\n\n\n\nconst dt = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction D(e) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(dt);\n}\nfunction b(e) {\n  const t = D();\n  if (!(t != null && t.editor))\n    throw new Error(\n      \"useBlockNoteEditor was called outside of a BlockNoteContext provider or BlockNoteView component\"\n    );\n  return t.editor;\n}\nfunction se(e, t, n) {\n  const o = D();\n  t || (t = o == null ? void 0 : o.editor), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!t)\n      throw new Error(\n        \"'editor' is required, either from BlockNoteContext or as a function argument\"\n      );\n    return t.onSelectionChange(e, n);\n  }, [e, t, n]);\n}\nfunction Pn(e, t) {\n  const n = b();\n  t = t || n;\n  const [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    if (e)\n      return t.getSelectionBoundingBox();\n  }), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (!e)\n      return;\n    const c = t.getSelectionBoundingBox();\n    r(c);\n  }, [t, e]);\n  return se(l, t, !0), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    r(e ? t.getSelectionBoundingBox() : void 0);\n  }, [e, t]), o;\n}\nfunction G(e, t, n, o) {\n  const { refs: r, update: l, context: c, floatingStyles: s } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useFloating)({\n    open: e,\n    ...o\n  }), { isMounted: d, styles: a } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useTransitionStyles)(c), u = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useDismiss)(c), { getReferenceProps: m, getFloatingProps: h } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useInteractions)([u]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    l();\n  }, [t, l]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t !== null && r.setReference({\n      getBoundingClientRect: () => t\n    });\n  }, [t, r]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    isMounted: d,\n    ref: r.setFloating,\n    setReference: r.setReference,\n    style: {\n      display: \"flex\",\n      ...a,\n      ...s,\n      zIndex: n\n    },\n    getFloatingProps: h,\n    getReferenceProps: m\n  }), [\n    s,\n    d,\n    r.setFloating,\n    r.setReference,\n    a,\n    n,\n    h,\n    m\n  ]);\n}\nfunction P(e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e((o) => {\n    n({ ...o });\n  }), [e]), t;\n}\nconst On = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(\n  void 0\n);\nfunction C() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(On);\n}\nconst de = (e = {}, t = []) => (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n  const n = _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.BlockNoteEditor.create(e);\n  return window && (window.ProseMirror = n._tiptapEditor), n;\n}, t), Oi = de;\nfunction M() {\n  return D().editor.dictionary;\n}\nfunction ue(e, t) {\n  const n = D();\n  t || (t = n == null ? void 0 : n.editor), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!t)\n      throw new Error(\n        \"'editor' is required, either from BlockNoteContext or as a function argument\"\n      );\n    return t.onChange(e);\n  }, [e, t]);\n}\nconst Le = (e) => {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e.editor.isEmpty), l = C();\n  ue(() => {\n    r(e.editor.isEmpty);\n  }, e.editor);\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n(!0);\n  }, []), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n(!1);\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    e.editable && e.autoFocus && e.editor.focus();\n  }, [e.autoFocus, e.editable, e.editor]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      l.Comments.Editor,\n      {\n        autoFocus: e.autoFocus,\n        className: \"bn-comment-editor\",\n        editor: e.editor,\n        onFocus: c,\n        onBlur: s,\n        editable: e.editable\n      }\n    ),\n    e.actions && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-comment-actions-wrapper\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(e.actions, { isFocused: t, isEmpty: o }) })\n  ] });\n}, Dn = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.createBlockSpecFromStronglyTypedTiptapNode)(\n  (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.createStronglyTypedTiptapNode)(\n    _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.defaultBlockSpecs.paragraph.implementation.node.config\n  ),\n  // disable default props on paragraph (such as textalignment and colors)\n  {}\n), { textColor: Di, backgroundColor: Zi, ...Zn } = _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.defaultStyleSpecs, Ee = _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.BlockNoteSchema.create({\n  blockSpecs: {\n    paragraph: Dn\n  },\n  styleSpecs: Zn\n});\nfunction Fn() {\n  const e = b();\n  if (!e.comments)\n    throw new Error(\"Comments plugin not found\");\n  const t = e.comments, n = C(), o = M(), r = de({\n    trailingBlock: !1,\n    dictionary: {\n      ...o,\n      placeholders: {\n        emptyDocument: o.placeholders.new_comment\n      }\n    },\n    schema: Ee,\n    sideMenuDetection: \"editor\"\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(n.Comments.Card, { className: \"bn-thread\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    Le,\n    {\n      autoFocus: !0,\n      editable: !0,\n      editor: r,\n      actions: ({ isEmpty: l }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        n.Generic.Toolbar.Root,\n        {\n          className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n            \"bn-action-toolbar\",\n            \"bn-comment-actions\"\n          ),\n          variant: \"action-toolbar\",\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            n.Generic.Toolbar.Button,\n            {\n              className: \"bn-button\",\n              mainTooltip: \"Save\",\n              variant: \"compact\",\n              isDisabled: l,\n              onClick: async () => {\n                await t.createThread({\n                  initialComment: {\n                    body: r.document\n                  }\n                }), t.stopPendingComment();\n              },\n              children: \"Save\"\n            }\n          )\n        }\n      )\n    }\n  ) });\n}\nconst An = (e) => {\n  const t = b();\n  if (!t.comments)\n    throw new Error(\n      \"FloatingComposerController can only be used when BlockNote editor has enabled comments\"\n    );\n  const n = t.comments;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const u = n.onUpdate(\n      (m) => t.setForceSelectionVisible(m.pendingComment)\n    );\n    return () => u();\n  }, [n, t]);\n  const o = P(n.onUpdate.bind(n)), r = Pn(o == null ? void 0 : o.pendingComment), { isMounted: l, ref: c, style: s, getFloatingProps: d } = G(\n    (o == null ? void 0 : o.pendingComment) || !1,\n    r || null,\n    5e3,\n    {\n      placement: \"bottom\",\n      middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.shift)(), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)()],\n      onOpenChange: (u) => {\n        u || (n.stopPendingComment(), t.focus());\n      },\n      ...e.floatingOptions\n    }\n  );\n  if (!l || !o)\n    return null;\n  const a = e.floatingComposer || Fn;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: c, style: s, ...d(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(a, {}) });\n};\nvar ut = {\n  color: void 0,\n  size: void 0,\n  className: void 0,\n  style: void 0,\n  attr: void 0\n}, Ge = react__WEBPACK_IMPORTED_MODULE_0__.createContext && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(ut), Gn = [\"attr\", \"size\", \"title\"];\nfunction Un(e, t) {\n  if (e == null) return {};\n  var n = zn(e, t), o, r;\n  if (Object.getOwnPropertySymbols) {\n    var l = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < l.length; r++)\n      o = l[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);\n  }\n  return n;\n}\nfunction zn(e, t) {\n  if (e == null) return {};\n  var n = {};\n  for (var o in e)\n    if (Object.prototype.hasOwnProperty.call(e, o)) {\n      if (t.indexOf(o) >= 0) continue;\n      n[o] = e[o];\n    }\n  return n;\n}\nfunction oe() {\n  return oe = Object.assign ? Object.assign.bind() : function(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n      for (var o in n)\n        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n    return e;\n  }, oe.apply(this, arguments);\n}\nfunction Ue(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    t && (o = o.filter(function(r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), n.push.apply(n, o);\n  }\n  return n;\n}\nfunction re(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = arguments[t] != null ? arguments[t] : {};\n    t % 2 ? Ue(Object(n), !0).forEach(function(o) {\n      jn(e, o, n[o]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ue(Object(n)).forEach(function(o) {\n      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));\n    });\n  }\n  return e;\n}\nfunction jn(e, t, n) {\n  return t = Wn(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;\n}\nfunction Wn(e) {\n  var t = $n(e, \"string\");\n  return typeof t == \"symbol\" ? t : t + \"\";\n}\nfunction $n(e, t) {\n  if (typeof e != \"object\" || !e) return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var o = n.call(e, t);\n    if (typeof o != \"object\") return o;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction mt(e) {\n  return e && e.map((t, n) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(t.tag, re({\n    key: n\n  }, t.attr), mt(t.child)));\n}\nfunction p(e) {\n  return (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(qn, oe({\n    attr: re({}, e.attr)\n  }, t), mt(e.child));\n}\nfunction qn(e) {\n  var t = (n) => {\n    var {\n      attr: o,\n      size: r,\n      title: l\n    } = e, c = Un(e, Gn), s = r || n.size || \"1em\", d;\n    return n.className && (d = n.className), e.className && (d = (d ? d + \" \" : \"\") + e.className), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", oe({\n      stroke: \"currentColor\",\n      fill: \"currentColor\",\n      strokeWidth: \"0\"\n    }, n.attr, o, c, {\n      className: d,\n      style: re(re({\n        color: e.color || n.color\n      }, n.style), e.style),\n      height: s,\n      width: s,\n      xmlns: \"http://www.w3.org/2000/svg\"\n    }), l && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", null, l), e.children);\n  };\n  return Ge !== void 0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ge.Consumer, null, (n) => t(n)) : t(ut);\n}\nfunction Kn(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M8 7V11L2 6L8 1V5H13C17.4183 5 21 8.58172 21 13C21 17.4183 17.4183 21 13 21H4V19H13C16.3137 19 19 16.3137 19 13C19 9.68629 16.3137 7 13 7H8Z\" }, child: [] }] })(e);\n}\nfunction ht(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M7.29117 20.8242L2 22L3.17581 16.7088C2.42544 15.3056 2 13.7025 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C10.2975 22 8.6944 21.5746 7.29117 20.8242ZM7.58075 18.711L8.23428 19.0605C9.38248 19.6745 10.6655 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 13.3345 4.32549 14.6175 4.93949 15.7657L5.28896 16.4192L4.63416 19.3658L7.58075 18.711Z\" }, child: [] }] })(e);\n}\nfunction Xn(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M7.24264 17.9967H3V13.754L14.435 2.319C14.8256 1.92848 15.4587 1.92848 15.8492 2.319L18.6777 5.14743C19.0682 5.53795 19.0682 6.17112 18.6777 6.56164L7.24264 17.9967ZM3 19.9967H21V21.9967H3V19.9967Z\" }, child: [] }] })(e);\n}\nfunction Yn(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M23 12L15.9289 19.0711L14.5147 17.6569L20.1716 12L14.5147 6.34317L15.9289 4.92896L23 12ZM3.82843 12L9.48528 17.6569L8.07107 19.0711L1 12L8.07107 4.92896L9.48528 6.34317L3.82843 12Z\" }, child: [] }] })(e);\n}\nfunction Re(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z\" }, child: [] }] })(e);\n}\nfunction Jn(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM5 19H19V21H5V19ZM3 14H21V16H3V14ZM5 9H19V11H5V9Z\" }, child: [] }] })(e);\n}\nfunction Qn(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H21V21H3V19ZM3 14H21V16H3V14ZM3 9H21V11H3V9Z\" }, child: [] }] })(e);\n}\nfunction eo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H17V21H3V19ZM3 14H21V16H3V14ZM3 9H17V11H3V9Z\" }, child: [] }] })(e);\n}\nfunction to(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM7 19H21V21H7V19ZM3 14H21V16H3V14ZM7 9H21V11H7V9Z\" }, child: [] }] })(e);\n}\nfunction no(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M8 11H12.5C13.8807 11 15 9.88071 15 8.5C15 7.11929 13.8807 6 12.5 6H8V11ZM18 15.5C18 17.9853 15.9853 20 13.5 20H6V4H12.5C14.9853 4 17 6.01472 17 8.5C17 9.70431 16.5269 10.7981 15.7564 11.6058C17.0979 12.3847 18 13.837 18 15.5ZM8 13V18H13.5C14.8807 18 16 16.8807 16 15.5C16 14.1193 14.8807 13 13.5 13H8Z\" }, child: [] }] })(e);\n}\nfunction oo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3.41436 5.99995L5.70726 3.70706L4.29304 2.29285L0.585938 5.99995L4.29304 9.70706L5.70726 8.29285L3.41436 5.99995ZM9.58594 5.99995L7.29304 3.70706L8.70726 2.29285L12.4144 5.99995L8.70726 9.70706L7.29304 8.29285L9.58594 5.99995ZM14.0002 2.99995H21.0002C21.5524 2.99995 22.0002 3.44767 22.0002 3.99995V20C22.0002 20.5522 21.5524 21 21.0002 21H3.00015C2.44787 21 2.00015 20.5522 2.00015 20V12H4.00015V19H20.0002V4.99995H14.0002V2.99995Z\" }, child: [] }] })(e);\n}\nfunction ze(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M5.55397 22H3.3999L10.9999 3H12.9999L20.5999 22H18.4458L16.0458 16H7.95397L5.55397 22ZM8.75397 14H15.2458L11.9999 5.88517L8.75397 14Z\" }, child: [] }] })(e);\n}\nfunction ft(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM21.0005 8V20H19.0005L19 10.204L17 10.74V8.67L19.5005 8H21.0005Z\" }, child: [] }] })(e);\n}\nfunction gt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 8C20.5711 8 22.25 9.67893 22.25 11.75C22.25 12.6074 21.9623 13.3976 21.4781 14.0292L21.3302 14.2102L18.0343 18H22V20H15L14.9993 18.444L19.8207 12.8981C20.0881 12.5908 20.25 12.1893 20.25 11.75C20.25 10.7835 19.4665 10 18.5 10C17.5818 10 16.8288 10.7071 16.7558 11.6065L16.75 11.75H14.75C14.75 9.67893 16.4289 8 18.5 8Z\" }, child: [] }] })(e);\n}\nfunction bt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M22 8L21.9984 10L19.4934 12.883C21.0823 13.3184 22.25 14.7728 22.25 16.5C22.25 18.5711 20.5711 20.25 18.5 20.25C16.674 20.25 15.1528 18.9449 14.8184 17.2166L16.7821 16.8352C16.9384 17.6413 17.6481 18.25 18.5 18.25C19.4665 18.25 20.25 17.4665 20.25 16.5C20.25 15.5335 19.4665 14.75 18.5 14.75C18.214 14.75 17.944 14.8186 17.7056 14.9403L16.3992 13.3932L19.3484 10H15V8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z\" }, child: [] }] })(e);\n}\nfunction ro(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM3 12.5L7 9V16L3 12.5Z\" }, child: [] }] })(e);\n}\nfunction io(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM7 12.5L3 16V9L7 12.5Z\" }, child: [] }] })(e);\n}\nfunction je(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M8 5H11V19H8V21H16V19H13V5H16V3H8V5ZM2 7C1.44772 7 1 7.44772 1 8V16C1 16.5523 1.44772 17 2 17H8V15H3V9H8V7H2ZM16 9H21V15H16V17H22C22.5523 17 23 16.5523 23 16V8C23 7.44772 22.5523 7 22 7H16V9Z\" }, child: [] }] })(e);\n}\nfunction lo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M15 20H7V18H9.92661L12.0425 6H9V4H17V6H14.0734L11.9575 18H15V20Z\" }, child: [] }] })(e);\n}\nfunction co(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z\" }, child: [] }] })(e);\n}\nfunction Ct(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M18.3638 15.5355L16.9496 14.1213L18.3638 12.7071C20.3164 10.7545 20.3164 7.58866 18.3638 5.63604C16.4112 3.68341 13.2453 3.68341 11.2927 5.63604L9.87849 7.05025L8.46428 5.63604L9.87849 4.22182C12.6122 1.48815 17.0443 1.48815 19.778 4.22182C22.5117 6.95549 22.5117 11.3876 19.778 14.1213L18.3638 15.5355ZM15.5353 18.364L14.1211 19.7782C11.3875 22.5118 6.95531 22.5118 4.22164 19.7782C1.48797 17.0445 1.48797 12.6123 4.22164 9.87868L5.63585 8.46446L7.05007 9.87868L5.63585 11.2929C3.68323 13.2455 3.68323 16.4113 5.63585 18.364C7.58847 20.3166 10.7543 20.3166 12.7069 18.364L14.1211 16.9497L15.5353 18.364ZM14.8282 7.75736L16.2425 9.17157L9.17139 16.2426L7.75717 14.8284L14.8282 7.75736Z\" }, child: [] }] })(e);\n}\nfunction pt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M8.00008 6V9H5.00008V6H8.00008ZM3.00008 4V11H10.0001V4H3.00008ZM13.0001 4H21.0001V6H13.0001V4ZM13.0001 11H21.0001V13H13.0001V11ZM13.0001 18H21.0001V20H13.0001V18ZM10.7072 16.2071L9.29297 14.7929L6.00008 18.0858L4.20718 16.2929L2.79297 17.7071L6.00008 20.9142L10.7072 16.2071Z\" }, child: [] }] })(e);\n}\nfunction kt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M8 4H21V6H8V4ZM5 3V6H6V7H3V6H4V4H3V3H5ZM3 14V11.5H5V11H3V10H6V12.5H4V13H6V14H3ZM5 19.5H3V18.5H5V18H3V17H6V21H3V20H5V19.5ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z\" }, child: [] }] })(e);\n}\nfunction wt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M8 4H21V6H8V4ZM4.5 6.5C3.67157 6.5 3 5.82843 3 5C3 4.17157 3.67157 3.5 4.5 3.5C5.32843 3.5 6 4.17157 6 5C6 5.82843 5.32843 6.5 4.5 6.5ZM4.5 13.5C3.67157 13.5 3 12.8284 3 12C3 11.1716 3.67157 10.5 4.5 10.5C5.32843 10.5 6 11.1716 6 12C6 12.8284 5.32843 13.5 4.5 13.5ZM4.5 20.4C3.67157 20.4 3 19.7284 3 18.9C3 18.0716 3.67157 17.4 4.5 17.4C5.32843 17.4 6 18.0716 6 18.9C6 19.7284 5.32843 20.4 4.5 20.4ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z\" }, child: [] }] })(e);\n}\nfunction ao(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M20 3C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM11 5H5V10.999H7V9L10 12L7 15V13H5V19H11V17H13V19H19V13H17V15L14 12L17 9V10.999H19V5H13V7H11V5ZM13 13V15H11V13H13ZM13 9V11H11V9H13Z\" }, child: [] }] })(e);\n}\nfunction so(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M21 20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20C20.5523 3 21 3.44772 21 4V20ZM19 11V5H13.001V7H15L12 10L9 7H11V5H5V11H7V13H5V19H11V17H9L12 14L15 17H13.001V19H19V13H17V11H19ZM11 13H9V11H11V13ZM15 13H13V11H15V13Z\" }, child: [] }] })(e);\n}\nfunction vt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M21 4H3V6H21V4ZM21 11H8V13H21V11ZM21 18H8V20H21V18ZM5 11H3V20H5V11Z\" }, child: [] }] })(e);\n}\nfunction uo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M17.1538 14C17.3846 14.5161 17.5 15.0893 17.5 15.7196C17.5 17.0625 16.9762 18.1116 15.9286 18.867C14.8809 19.6223 13.4335 20 11.5862 20C9.94674 20 8.32335 19.6185 6.71592 18.8555V16.6009C8.23538 17.4783 9.7908 17.917 11.3822 17.917C13.9333 17.917 15.2128 17.1846 15.2208 15.7196C15.2208 15.0939 15.0049 14.5598 14.5731 14.1173C14.5339 14.0772 14.4939 14.0381 14.4531 14H3V12H21V14H17.1538ZM13.076 11H7.62908C7.4566 10.8433 7.29616 10.6692 7.14776 10.4778C6.71592 9.92084 6.5 9.24559 6.5 8.45207C6.5 7.21602 6.96583 6.165 7.89749 5.299C8.82916 4.43299 10.2706 4 12.2219 4C13.6934 4 15.1009 4.32808 16.4444 4.98426V7.13591C15.2448 6.44921 13.9293 6.10587 12.4978 6.10587C10.0187 6.10587 8.77917 6.88793 8.77917 8.45207C8.77917 8.87172 8.99709 9.23796 9.43293 9.55079C9.86878 9.86362 10.4066 10.1135 11.0463 10.3004C11.6665 10.4816 12.3431 10.7148 13.076 11H13.076Z\" }, child: [] }] })(e);\n}\nfunction mo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M13 10V14H19V10H13ZM11 10H5V14H11V10ZM13 19H19V16H13V19ZM11 19V16H5V19H11ZM13 5V8H19V5H13ZM11 5H5V8H11V5ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z\" }, child: [] }] })(e);\n}\nfunction _e(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M13 6V21H11V6H5V4H19V6H13Z\" }, child: [] }] })(e);\n}\nfunction ho(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M8 3V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V3H18V12C18 15.3137 15.3137 18 12 18C8.68629 18 6 15.3137 6 12V3H8ZM4 20H20V22H4V20Z\" }, child: [] }] })(e);\n}\nfunction fo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z\" }, child: [] }] })(e);\n}\nfunction Ht(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z\" }, child: [] }] })(e);\n}\nfunction go(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M21 15V18H24V20H21V23H19V20H16V18H19V15H21ZM21.0082 3C21.556 3 22 3.44495 22 3.9934L22.0007 13.3417C21.3749 13.1204 20.7015 13 20 13V5H4L4.001 19L13.2929 9.70715C13.6528 9.34604 14.22 9.31823 14.6123 9.62322L14.7065 9.70772L18.2521 13.2586C15.791 14.0069 14 16.2943 14 19C14 19.7015 14.1204 20.3749 14.3417 21.0007L2.9918 21C2.44405 21 2 20.5551 2 20.0066V3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082ZM8 7C9.10457 7 10 7.89543 10 9C10 10.1046 9.10457 11 8 11C6.89543 11 6 10.1046 6 9C6 7.89543 6.89543 7 8 7Z\" }, child: [] }] })(e);\n}\nfunction bo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M20 3C20.5523 3 21 3.44772 21 4V5.757L19 7.757V5H5V13.1L9 9.1005L13.328 13.429L12.0012 14.7562L11.995 18.995L16.2414 19.0012L17.571 17.671L18.8995 19H19V16.242L21 14.242V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM21.7782 7.80761L23.1924 9.22183L15.4142 17L13.9979 16.9979L14 15.5858L21.7782 7.80761ZM15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7Z\" }, child: [] }] })(e);\n}\nfunction Co(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M3 3.9934C3 3.44476 3.44495 3 3.9934 3H20.0066C20.5552 3 21 3.44495 21 3.9934V20.0066C21 20.5552 20.5551 21 20.0066 21H3.9934C3.44476 21 3 20.5551 3 20.0066V3.9934ZM10.6219 8.41459C10.5562 8.37078 10.479 8.34741 10.4 8.34741C10.1791 8.34741 10 8.52649 10 8.74741V15.2526C10 15.3316 10.0234 15.4088 10.0672 15.4745C10.1897 15.6583 10.4381 15.708 10.6219 15.5854L15.5008 12.3328C15.5447 12.3035 15.5824 12.2658 15.6117 12.2219C15.7343 12.0381 15.6846 11.7897 15.5008 11.6672L10.6219 8.41459Z\" }, child: [] }] })(e);\n}\nfunction Mt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z\" }, child: [] }] })(e);\n}\nfunction po(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M11 11V5H13V11H19V13H13V19H11V13H5V11H11Z\" }, child: [] }] })(e);\n}\nfunction ko(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M9.9997 15.1709L19.1921 5.97852L20.6063 7.39273L9.9997 17.9993L3.63574 11.6354L5.04996 10.2212L9.9997 15.1709Z\" }, child: [] }] })(e);\n}\nfunction wo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM18 8H6V20H18V8ZM9 4V6H15V4H9Z\" }, child: [] }] })(e);\n}\nfunction vo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM9 11V17H11V11H9ZM13 11V17H15V11H13ZM9 4V6H15V4H9Z\" }, child: [] }] })(e);\n}\nfunction Ho(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M4 19H20V12H22V20C22 20.5523 21.5523 21 21 21H3C2.44772 21 2 20.5523 2 20V12H4V19ZM14 9H19L12 16L5 9H10V3H14V9Z\" }, child: [] }] })(e);\n}\nfunction Mo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M10 6V8H5V19H16V14H18V20C18 20.5523 17.5523 21 17 21H4C3.44772 21 3 20.5523 3 20V7C3 6.44772 3.44772 6 4 6H10ZM21 3V12L17.206 8.207L11.2071 14.2071L9.79289 12.7929L15.792 6.793L12 3H21Z\" }, child: [] }] })(e);\n}\nfunction xo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M5 10C3.9 10 3 10.9 3 12C3 13.1 3.9 14 5 14C6.1 14 7 13.1 7 12C7 10.9 6.1 10 5 10ZM19 10C17.9 10 17 10.9 17 12C17 13.1 17.9 14 19 14C20.1 14 21 13.1 21 12C21 10.9 20.1 10 19 10ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10Z\" }, child: [] }] })(e);\n}\nfunction yo(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM8 13C8 15.2091 9.79086 17 12 17C14.2091 17 16 15.2091 16 13H8ZM8 11C8.82843 11 9.5 10.3284 9.5 9.5C9.5 8.67157 8.82843 8 8 8C7.17157 8 6.5 8.67157 6.5 9.5C6.5 10.3284 7.17157 11 8 11ZM16 11C16.8284 11 17.5 10.3284 17.5 9.5C17.5 8.67157 16.8284 8 16 8C15.1716 8 14.5 8.67157 14.5 9.5C14.5 10.3284 15.1716 11 16 11Z\" }, child: [] }] })(e);\n}\nfunction We(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"currentColor\" }, child: [{ tag: \"path\", attr: { d: \"M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM8 13H16C16 15.2091 14.2091 17 12 17C9.79086 17 8 15.2091 8 13ZM8 11C7.17157 11 6.5 10.3284 6.5 9.5C6.5 8.67157 7.17157 8 8 8C8.82843 8 9.5 8.67157 9.5 9.5C9.5 10.3284 8.82843 11 8 11ZM16 11C15.1716 11 14.5 10.3284 14.5 9.5C14.5 8.67157 15.1716 8 16 8C16.8284 8 17.5 8.67157 17.5 9.5C17.5 10.3284 16.8284 11 16 11Z\" }, child: [] }] })(e);\n}\nlet te;\nasync function Bo() {\n  return te || (te = (async () => {\n    const [e, t] = await Promise.all([\n      __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_emoji-mart_dist_module_js\").then(__webpack_require__.bind(__webpack_require__, /*! emoji-mart */ \"(app-pages-browser)/./node_modules/emoji-mart/dist/module.js\")),\n      // use a dynamic import to encourage bundle-splitting\n      // and a smaller initial client bundle size\n      __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_emoji-mart_data_sets_15_native_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @emoji-mart/data */ \"(app-pages-browser)/./node_modules/@emoji-mart/data/sets/15/native.json\", 17))\n    ]), n = \"default\" in e ? e.default : e, o = \"default\" in t ? t.default : t;\n    return await n.init({ data: o }), { emojiMart: n, emojiData: o };\n  })(), te);\n}\nfunction Vo(e) {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return n.current && n.current.update(e), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => ((async () => {\n    const { emojiMart: o } = await Bo();\n    n.current = new o.Picker({ ...e, ref: t });\n  })(), () => {\n    n.current = null;\n  }), []), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: t });\n}\nconst $e = (e) => {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), o = C(), r = D();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(o.Generic.Popover.Root, { opened: t, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(o.Generic.Popover.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"div\",\n      {\n        onClick: (l) => {\n          l.preventDefault(), l.stopPropagation(), n(!t);\n        },\n        style: {\n          display: \"flex\",\n          justifyContent: \"center\",\n          alignItems: \"center\"\n        },\n        children: e.children\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(o.Generic.Popover.Content, { variant: \"panel-popover\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      Vo,\n      {\n        perLine: 7,\n        onClickOutside: () => n(!1),\n        onEmojiSelect: (l) => {\n          e.onEmojiSelect(l), n(!1);\n        },\n        theme: r == null ? void 0 : r.colorSchemePreference\n      }\n    ) })\n  ] });\n};\nfunction So(e, t) {\n  return Ie(e, [t]).get(t);\n}\nfunction Ie(e, t) {\n  const n = e.comments;\n  if (!n)\n    throw new Error(\"Comments plugin not found\");\n  const o = n.userStore, r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const s = /* @__PURE__ */ new Map();\n    for (const d of t) {\n      const a = o.getUser(d);\n      a && s.set(d, a);\n    }\n    return s;\n  }, [o, t]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    current: r()\n  }), [r]), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (s) => {\n      const d = o.subscribe((a) => {\n        l.current = r(), s();\n      });\n      return o.loadUsers(t), d;\n    },\n    [o, r, t, l]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(c, () => l.current);\n}\nconst To = (e) => {\n  const t = C(), n = M(), o = b();\n  if (!o.comments)\n    throw new Error(\n      \"ReactionBadge must be used inside a BlockNote editor with comments enabled\"\n    );\n  const r = e.comment.reactions.find(\n    (d) => d.emoji === e.emoji\n  );\n  if (!r)\n    throw new Error(\n      \"Trying to render reaction badge for non-existing reaction\"\n    );\n  const [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), s = Ie(o, l);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Badge.Root,\n    {\n      className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\"bn-badge\", \"bn-comment-reaction\"),\n      text: r.userIds.length.toString(),\n      icon: r.emoji,\n      isSelected: o.comments.threadStore.auth.canDeleteReaction(\n        e.comment,\n        r.emoji\n      ),\n      onClick: () => e.onReactionSelect(r.emoji),\n      onMouseEnter: () => c(r.userIds),\n      mainTooltip: n.comments.reactions.reacted_by,\n      secondaryTooltip: `${Array.from(s.values()).map((d) => d.username).join(`\n`)}`\n    },\n    r.emoji\n  );\n}, Lo = ({\n  comment: e,\n  thread: t,\n  showResolveButton: n\n}) => {\n  const o = M(), r = de(\n    {\n      initialContent: e.body,\n      trailingBlock: !1,\n      dictionary: {\n        ...o,\n        placeholders: {\n          emptyDocument: o.placeholders.edit_comment\n        }\n      },\n      schema: Ee,\n      sideMenuDetection: \"editor\"\n    },\n    [e.body]\n  ), l = C(), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), d = b();\n  if (!d.comments)\n    throw new Error(\"Comments plugin not found\");\n  const a = d.comments.threadStore, u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    s(!0);\n  }, []), m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    r.replaceBlocks(r.document, e.body), s(!1);\n  }, [r, e.body]), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (E) => {\n      await a.updateComment({\n        commentId: e.id,\n        comment: {\n          body: r.document\n        },\n        threadId: t.id\n      }), s(!1);\n    },\n    [e, t.id, r, a]\n  ), f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    await a.deleteComment({\n      commentId: e.id,\n      threadId: t.id\n    });\n  }, [e, t.id, a]), w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (E) => {\n      a.auth.canAddReaction(e, E) ? await a.addReaction({\n        threadId: t.id,\n        commentId: e.id,\n        emoji: E\n      }) : a.auth.canDeleteReaction(e, E) && await a.deleteReaction({\n        threadId: t.id,\n        commentId: e.id,\n        emoji: E\n      });\n    },\n    [a, e, t.id]\n  ), H = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    await a.resolveThread({\n      threadId: t.id\n    });\n  }, [t.id, a]), B = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    await a.unresolveThread({\n      threadId: t.id\n    });\n  }, [t.id, a]), V = So(d, e.userId);\n  if (!e.body)\n    return null;\n  let S;\n  const O = a.auth.canAddReaction(e), z = a.auth.canDeleteComment(e), j = a.auth.canUpdateComment(e), Z = n && (t.resolved ? a.auth.canUnresolveThread(t) : a.auth.canResolveThread(t));\n  c || (S = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    l.Generic.Toolbar.Root,\n    {\n      className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\"bn-action-toolbar\", \"bn-comment-actions\"),\n      variant: \"action-toolbar\",\n      children: [\n        O && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          $e,\n          {\n            onEmojiSelect: (E) => w(E.native),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              l.Generic.Toolbar.Button,\n              {\n                mainTooltip: o.comments.actions.add_reaction,\n                variant: \"compact\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(We, { size: 16 })\n              },\n              \"add-reaction\"\n            )\n          }\n        ),\n        Z && (t.resolved ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          l.Generic.Toolbar.Button,\n          {\n            mainTooltip: \"Re-open\",\n            variant: \"compact\",\n            onClick: B,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Kn, { size: 16 })\n          },\n          \"reopen\"\n        ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          l.Generic.Toolbar.Button,\n          {\n            mainTooltip: o.comments.actions.resolve,\n            variant: \"compact\",\n            onClick: H,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ko, { size: 16 })\n          },\n          \"resolve\"\n        )),\n        (z || j) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(l.Generic.Menu.Root, { position: \"bottom-start\", children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(l.Generic.Menu.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            l.Generic.Toolbar.Button,\n            {\n              mainTooltip: o.comments.actions.more_actions,\n              variant: \"compact\",\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(xo, { size: 16 })\n            },\n            \"more-actions\"\n          ) }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(l.Generic.Menu.Dropdown, { className: \"bn-menu-dropdown\", children: [\n            j && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              l.Generic.Menu.Item,\n              {\n                icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Xn, {}),\n                onClick: u,\n                children: o.comments.actions.edit_comment\n              },\n              \"edit-comment\"\n            ),\n            z && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              l.Generic.Menu.Item,\n              {\n                icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(vo, {}),\n                onClick: f,\n                children: o.comments.actions.delete_comment\n              },\n              \"delete-comment\"\n            )\n          ] })\n        ] })\n      ]\n    }\n  ));\n  const $ = e.createdAt.toLocaleDateString(void 0, {\n    month: \"short\",\n    day: \"numeric\"\n  });\n  if (!e.body)\n    throw new Error(\"soft deletes are not yet supported\");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    l.Comments.Comment,\n    {\n      authorInfo: V ?? \"loading\",\n      timeString: $,\n      edited: e.updatedAt.getTime() !== e.createdAt.getTime(),\n      showActions: \"hover\",\n      actions: S,\n      className: \"bn-thread-comment\",\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        Le,\n        {\n          autoFocus: c,\n          editor: r,\n          editable: c,\n          actions: e.reactions.length > 0 || c ? ({ isEmpty: E }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n            e.reactions.length > 0 && !c && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n              l.Generic.Badge.Group,\n              {\n                className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n                  \"bn-badge-group\",\n                  \"bn-comment-reactions\"\n                ),\n                children: [\n                  e.reactions.map((F) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                    To,\n                    {\n                      comment: e,\n                      emoji: F.emoji,\n                      onReactionSelect: w\n                    },\n                    F.emoji\n                  )),\n                  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                    $e,\n                    {\n                      onEmojiSelect: (F) => w(F.native),\n                      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                        l.Generic.Badge.Root,\n                        {\n                          className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n                            \"bn-badge\",\n                            \"bn-comment-add-reaction\"\n                          ),\n                          text: \"+\",\n                          icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(We, { size: 16 }),\n                          mainTooltip: o.comments.actions.add_reaction\n                        }\n                      )\n                    }\n                  )\n                ]\n              }\n            ),\n            c && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n              l.Generic.Toolbar.Root,\n              {\n                variant: \"action-toolbar\",\n                className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n                  \"bn-action-toolbar\",\n                  \"bn-comment-actions\"\n                ),\n                children: [\n                  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                    l.Generic.Toolbar.Button,\n                    {\n                      mainTooltip: \"Save\",\n                      variant: \"compact\",\n                      onClick: h,\n                      isDisabled: E,\n                      children: \"Save\"\n                    }\n                  ),\n                  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                    l.Generic.Toolbar.Button,\n                    {\n                      className: \"bn-button\",\n                      mainTooltip: \"Cancel\",\n                      variant: \"compact\",\n                      onClick: m,\n                      children: \"Cancel\"\n                    }\n                  )\n                ]\n              }\n            )\n          ] }) : void 0\n        }\n      )\n    }\n  );\n}, Eo = ({\n  thread: e,\n  maxCommentsBeforeCollapse: t\n}) => {\n  const n = C(), o = M(), r = b(), l = Ie(r, e.resolvedBy ? [e.resolvedBy] : []), c = e.comments.map((s, d) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    Lo,\n    {\n      thread: e,\n      comment: s,\n      showResolveButton: d === 0\n    },\n    s.id\n  ));\n  if (e.resolved && e.resolvedUpdatedAt && e.resolvedBy) {\n    if (!l.get(e.resolvedBy))\n      throw new Error(\n        `User ${e.resolvedBy} resolved thread ${e.id}, but their data could not be found.`\n      );\n    const d = e.comments.findLastIndex(\n      (a) => e.resolvedUpdatedAt.getTime() > a.createdAt.getTime()\n    ) + 1;\n    c.splice(\n      d,\n      0,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        n.Comments.Comment,\n        {\n          className: \"bn-thread-comment\",\n          authorInfo: e.resolvedBy && l.get(e.resolvedBy) || \"loading\",\n          timeString: e.resolvedUpdatedAt.toLocaleDateString(void 0, {\n            month: \"short\",\n            day: \"numeric\"\n          }),\n          edited: !1,\n          showActions: !1,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-resolved-text\", children: o.comments.sidebar.marked_as_resolved })\n        },\n        \"resolved-comment\"\n      )\n    );\n  }\n  return t && c.length > t && c.splice(\n    1,\n    c.length - 2,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      n.Comments.ExpandSectionsPrompt,\n      {\n        className: \"bn-thread-expand-prompt\",\n        children: o.comments.sidebar.more_replies(e.comments.length - 2)\n      },\n      \"expand-prompt\"\n    )\n  ), c;\n}, xt = ({\n  thread: e,\n  selected: t,\n  referenceText: n,\n  maxCommentsBeforeCollapse: o,\n  onFocus: r,\n  onBlur: l,\n  tabIndex: c\n}) => {\n  const s = C(), d = M(), u = b().comments;\n  if (!u)\n    throw new Error(\"Comments plugin not found\");\n  const m = de({\n    trailingBlock: !1,\n    dictionary: {\n      ...d,\n      placeholders: {\n        emptyDocument: d.placeholders.comment_reply\n      }\n    },\n    schema: Ee,\n    sideMenuDetection: \"editor\"\n  }), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    await u.threadStore.addComment({\n      comment: {\n        body: m.document\n      },\n      threadId: e.id\n    }), m.removeBlocks(m.document);\n  }, [u, m, e.id]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    s.Comments.Card,\n    {\n      className: \"bn-thread\",\n      headerText: n,\n      onFocus: r,\n      onBlur: l,\n      selected: t,\n      tabIndex: c,\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(s.Comments.CardSection, { className: \"bn-thread-comments\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          Eo,\n          {\n            thread: e,\n            maxCommentsBeforeCollapse: t ? void 0 : o || 5\n          }\n        ) }),\n        t && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(s.Comments.CardSection, { className: \"bn-thread-composer\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          Le,\n          {\n            autoFocus: !1,\n            editable: !0,\n            editor: m,\n            actions: ({ isEmpty: f }) => f ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              s.Generic.Toolbar.Root,\n              {\n                variant: \"action-toolbar\",\n                className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n                  \"bn-action-toolbar\",\n                  \"bn-comment-actions\"\n                ),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                  s.Generic.Toolbar.Button,\n                  {\n                    mainTooltip: \"Save\",\n                    variant: \"compact\",\n                    isDisabled: f,\n                    onClick: h,\n                    children: \"Save\"\n                  }\n                )\n              }\n            )\n          }\n        ) })\n      ]\n    }\n  );\n};\nfunction yt(e) {\n  const t = e.comments;\n  if (!t)\n    throw new Error(\"Comments plugin not found\");\n  const n = t.threadStore, o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  o.current || (o.current = n.getThreads());\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (l) => n.subscribe((c) => {\n      o.current = c, l();\n    }),\n    [n]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(r, () => o.current);\n}\nconst Ro = (e) => {\n  const t = b();\n  if (!t.comments)\n    throw new Error(\n      \"FloatingComposerController can only be used when BlockNote editor has enabled comments\"\n    );\n  const n = P(\n    t.comments.onUpdate.bind(t.comments)\n  ), { isMounted: o, ref: r, style: l, getFloatingProps: c, setReference: s } = G(!!(n != null && n.selectedThreadId), null, 5e3, {\n    placement: \"bottom\",\n    middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.shift)(), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)()],\n    onOpenChange: (m) => {\n      var h;\n      m || ((h = t.comments) == null || h.selectThread(void 0), t.focus());\n    },\n    ...e.floatingOptions\n  }), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    var h;\n    if (!(n != null && n.selectedThreadId))\n      return;\n    const m = (h = t.domElement) == null ? void 0 : h.querySelector(\n      `[data-bn-thread-id=\"${n == null ? void 0 : n.selectedThreadId}\"]`\n    );\n    m && s(m);\n  }, [s, t, n == null ? void 0 : n.selectedThreadId]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (n != null && n.selectedThreadId)\n      return t.onChange(() => {\n        d();\n      });\n  }, [t, d, n == null ? void 0 : n.selectedThreadId]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(d, [d]);\n  const a = yt(t);\n  if (!o || !n || !n.selectedThreadId)\n    return null;\n  const u = e.floatingThread || xt;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: r, style: l, ...c(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    u,\n    {\n      thread: a.get(n.selectedThreadId),\n      selected: !0\n    }\n  ) });\n}, _o = (e) => {\n  const t = C(), n = M(), { block: o } = e, r = b(), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (u) => {\n      c(u.currentTarget.value);\n    },\n    []\n  ), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (u) => {\n      u.key === \"Enter\" && (u.preventDefault(), r.updateBlock(o, {\n        props: {\n          name: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.filenameFromURL)(l),\n          url: l\n        }\n      }));\n    },\n    [r, o, l]\n  ), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    r.updateBlock(o, {\n      props: {\n        name: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.filenameFromURL)(l),\n        url: l\n      }\n    });\n  }, [r, o, l]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.FilePanel.TabPanel, { className: \"bn-tab-panel\", children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FilePanel.TextInput,\n      {\n        className: \"bn-text-input\",\n        placeholder: n.file_panel.embed.url_placeholder,\n        value: l,\n        onChange: s,\n        onKeyDown: d,\n        \"data-test\": \"embed-input\"\n      }\n    ),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FilePanel.Button,\n      {\n        className: \"bn-button\",\n        onClick: a,\n        \"data-test\": \"embed-input-button\",\n        children: n.file_panel.embed.embed_button[o.type] || n.file_panel.embed.embed_button.file\n      }\n    )\n  ] });\n}, Io = (e) => {\n  var m;\n  const t = C(), n = M(), { block: o, setLoading: r } = e, l = b(), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c && setTimeout(() => {\n      s(!1);\n    }, 3e3);\n  }, [c]);\n  const d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (h) => {\n      if (h === null)\n        return;\n      async function f(w) {\n        if (r(!0), l.uploadFile !== void 0)\n          try {\n            let H = await l.uploadFile(w);\n            typeof H == \"string\" && (H = {\n              props: {\n                name: w.name,\n                url: H\n              }\n            }), l.updateBlock(o, H);\n          } catch {\n            s(!0);\n          } finally {\n            r(!1);\n          }\n      }\n      f(h);\n    },\n    [o, l, r]\n  ), a = l.schema.blockSchema[o.type], u = a.isFileBlock && ((m = a.fileBlockAccept) != null && m.length) ? a.fileBlockAccept.join(\",\") : \"*/*\";\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.FilePanel.TabPanel, { className: \"bn-tab-panel\", children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FilePanel.FileInput,\n      {\n        className: \"bn-file-input\",\n        \"data-test\": \"upload-input\",\n        accept: u,\n        placeholder: n.file_panel.upload.file_placeholder[o.type] || n.file_panel.upload.file_placeholder.file,\n        value: null,\n        onChange: d\n      }\n    ),\n    c && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-error-text\", children: n.file_panel.upload.upload_error })\n  ] });\n}, Bt = (e) => {\n  const t = C(), n = M(), o = b(), [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), c = e.tabs ?? [\n    ...o.uploadFile !== void 0 ? [\n      {\n        name: n.file_panel.upload.title,\n        tabPanel: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Io, { block: e.block, setLoading: l })\n      }\n    ] : [],\n    {\n      name: n.file_panel.embed.title,\n      tabPanel: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_o, { block: e.block })\n    }\n  ], [s, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.defaultOpenTab || c[0].name\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FilePanel.Root,\n    {\n      className: \"bn-panel\",\n      defaultOpenTab: s,\n      openTab: s,\n      setOpenTab: d,\n      tabs: c,\n      loading: r\n    }\n  );\n}, No = (e) => {\n  const t = b();\n  if (!t.filePanel)\n    throw new Error(\n      \"FileToolbarController can only be used when BlockNote editor schema contains file block\"\n    );\n  const n = P(\n    t.filePanel.onUpdate.bind(t.filePanel)\n  ), { isMounted: o, ref: r, style: l, getFloatingProps: c } = G(\n    (n == null ? void 0 : n.show) || !1,\n    (n == null ? void 0 : n.referencePos) || null,\n    5e3,\n    {\n      placement: \"bottom\",\n      middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)()],\n      onOpenChange: (m) => {\n        m || (t.filePanel.closeMenu(), t.focus());\n      },\n      ...e.floatingOptions\n    }\n  );\n  if (!o || !n)\n    return null;\n  const { show: s, referencePos: d, ...a } = n, u = e.filePanel || Bt;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: r, style: l, ...c(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(u, { ...a }) });\n};\nfunction U(e, t) {\n  ue(e, t), se(e, t);\n}\nfunction Po(e) {\n  return (t) => {\n    e.forEach((n) => {\n      typeof n == \"function\" ? n(t) : n != null && (n.current = t);\n    });\n  };\n}\nfunction R(e) {\n  const t = D();\n  if (e || (e = t == null ? void 0 : t.editor), !e)\n    throw new Error(\n      \"'editor' is required, either from BlockNoteContext or as a function argument\"\n    );\n  const n = e, [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    var l;\n    return ((l = n.getSelection()) == null ? void 0 : l.blocks) || [n.getTextCursorPosition().block];\n  });\n  return U(\n    () => {\n      var l;\n      return r(\n        ((l = n.getSelection()) == null ? void 0 : l.blocks) || [n.getTextCursorPosition().block]\n      );\n    },\n    n\n  ), o;\n}\nconst Oo = {\n  bold: no,\n  italic: lo,\n  underline: ho,\n  strike: uo,\n  code: Yn\n};\nfunction Do(e, t) {\n  return e in t.schema.styleSchema && t.schema.styleSchema[e].type === e && t.schema.styleSchema[e].propSchema === \"boolean\";\n}\nconst ne = (e) => {\n  const t = M(), n = C(), o = b(), r = Do(\n    e.basicTextStyle,\n    o\n  ), l = R(o), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.basicTextStyle in o.getActiveStyles()\n  );\n  U(() => {\n    r && s(e.basicTextStyle in o.getActiveStyles());\n  }, o);\n  const d = (m) => {\n    if (o.focus(), !!r) {\n      if (o.schema.styleSchema[m].propSchema !== \"boolean\")\n        throw new Error(\"can only toggle boolean styles\");\n      o.toggleStyles({ [m]: !0 });\n    }\n  };\n  if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => r ? !!l.find((m) => m.content !== void 0) : !1, [r, l]) || !o.isEditable)\n    return null;\n  const u = Oo[e.basicTextStyle];\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    n.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      \"data-test\": e.basicTextStyle,\n      onClick: () => d(e.basicTextStyle),\n      isSelected: c,\n      label: t.formatting_toolbar[e.basicTextStyle].tooltip,\n      mainTooltip: t.formatting_toolbar[e.basicTextStyle].tooltip,\n      secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.formatKeyboardShortcut)(\n        t.formatting_toolbar[e.basicTextStyle].secondary_tooltip,\n        t.generic.ctrl_shortcut\n      ),\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(u, {})\n    }\n  );\n}, we = (e) => {\n  const t = e.textColor || \"default\", n = e.backgroundColor || \"default\", o = e.size || 16, r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      pointerEvents: \"none\",\n      fontSize: (o * 0.75).toString() + \"px\",\n      height: o.toString() + \"px\",\n      lineHeight: o.toString() + \"px\",\n      textAlign: \"center\",\n      width: o.toString() + \"px\"\n    }),\n    [o]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"div\",\n    {\n      className: \"bn-color-icon\",\n      \"data-background-color\": n,\n      \"data-text-color\": t,\n      style: r,\n      children: \"A\"\n    }\n  );\n}, qe = [\n  \"default\",\n  \"gray\",\n  \"brown\",\n  \"red\",\n  \"orange\",\n  \"yellow\",\n  \"green\",\n  \"blue\",\n  \"purple\",\n  \"pink\"\n], me = (e) => {\n  const t = C(), n = M();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(() => e.text ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Label, { children: n.color_picker.text_title }),\n      qe.map((l) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        t.Generic.Menu.Item,\n        {\n          onClick: () => {\n            e.onClick && e.onClick(), e.text.setColor(l);\n          },\n          \"data-test\": \"text-color-\" + l,\n          icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(we, { textColor: l, size: e.iconSize }),\n          checked: e.text.color === l,\n          children: n.color_picker.colors[l]\n        },\n        \"text-color-\" + l\n      ))\n    ] }) : null, {}),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(() => e.background ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Label, { children: n.color_picker.background_title }),\n      qe.map((l) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        t.Generic.Menu.Item,\n        {\n          onClick: () => {\n            e.onClick && e.onClick(), e.background.setColor(l);\n          },\n          \"data-test\": \"background-color-\" + l,\n          icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(we, { backgroundColor: l, size: e.iconSize }),\n          checked: e.background.color === l,\n          children: n.color_picker.colors[l]\n        },\n        \"background-color-\" + l\n      ))\n    ] }) : null, {})\n  ] });\n};\nfunction Ke(e, t) {\n  return `${e}Color` in t.schema.styleSchema && t.schema.styleSchema[`${e}Color`].type === `${e}Color` && t.schema.styleSchema[`${e}Color`].propSchema === \"string\";\n}\nconst Zo = () => {\n  const e = C(), t = M(), n = b(), o = Ke(\"text\", n), r = Ke(\"background\", n), l = R(n), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    o && n.getActiveStyles().textColor || \"default\"\n  ), [d, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    r && n.getActiveStyles().backgroundColor || \"default\"\n  );\n  U(() => {\n    o && s(n.getActiveStyles().textColor || \"default\"), r && a(\n      n.getActiveStyles().backgroundColor || \"default\"\n    );\n  }, n);\n  const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (f) => {\n      if (!o)\n        throw Error(\n          \"Tried to set text color, but style does not exist in editor schema.\"\n        );\n      f === \"default\" ? n.removeStyles({ textColor: f }) : n.addStyles({ textColor: f }), setTimeout(() => {\n        n.focus();\n      });\n    },\n    [n, o]\n  ), m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (f) => {\n      if (!r)\n        throw Error(\n          \"Tried to set background color, but style does not exist in editor schema.\"\n        );\n      f === \"default\" ? n.removeStyles({ backgroundColor: f }) : n.addStyles({ backgroundColor: f }), setTimeout(() => {\n        n.focus();\n      });\n    },\n    [r, n]\n  );\n  return !(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!o && !r)\n      return !1;\n    for (const f of l)\n      if (f.content !== void 0)\n        return !0;\n    return !1;\n  }, [r, l, o]) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(e.Generic.Menu.Root, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(e.Generic.Menu.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      e.FormattingToolbar.Button,\n      {\n        className: \"bn-button\",\n        \"data-test\": \"colors\",\n        label: t.formatting_toolbar.colors.tooltip,\n        mainTooltip: t.formatting_toolbar.colors.tooltip,\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          we,\n          {\n            textColor: c,\n            backgroundColor: d,\n            size: 20\n          }\n        )\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      e.Generic.Menu.Dropdown,\n      {\n        className: \"bn-menu-dropdown bn-color-picker-dropdown\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          me,\n          {\n            text: o ? {\n              color: c,\n              setColor: u\n            } : void 0,\n            background: r ? {\n              color: d,\n              setColor: m\n            } : void 0\n          }\n        )\n      }\n    )\n  ] });\n}, Xe = (e) => {\n  for (const t of _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.VALID_LINK_PROTOCOLS)\n    if (e.startsWith(t))\n      return e;\n  return `${_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_LINK_PROTOCOL}://${e}`;\n}, Vt = (e) => {\n  const t = C(), n = M(), { url: o, text: r, editLink: l, showTextField: c } = e, [s, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(o), [a, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(r);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    d(o), u(r);\n  }, [r, o]);\n  const m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (H) => {\n      H.key === \"Enter\" && (H.preventDefault(), l(Xe(s), a));\n    },\n    [l, s, a]\n  ), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (H) => d(H.currentTarget.value),\n    []\n  ), f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (H) => u(H.currentTarget.value),\n    []\n  ), w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => l(Xe(s), a),\n    [l, s, a]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Form.Root, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Form.TextInput,\n      {\n        className: \"bn-text-input\",\n        name: \"url\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Ct, {}),\n        autoFocus: !0,\n        placeholder: n.link_toolbar.form.url_placeholder,\n        value: s,\n        onKeyDown: m,\n        onChange: h,\n        onSubmit: w\n      }\n    ),\n    c !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Form.TextInput,\n      {\n        className: \"bn-text-input\",\n        name: \"title\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_e, {}),\n        placeholder: n.link_toolbar.form.title_placeholder,\n        value: a,\n        onKeyDown: m,\n        onChange: f,\n        onSubmit: w\n      }\n    )\n  ] });\n};\nfunction Fo(e) {\n  return \"link\" in e.schema.inlineContentSchema && e.schema.inlineContentSchema.link === \"link\";\n}\nconst Ao = () => {\n  var f;\n  const e = b(), t = C(), n = M(), o = Fo(e), r = R(e), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [s, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e.getSelectedLinkUrl() || \"\"), [a, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e.getSelectedText());\n  U(() => {\n    c(!1), u(e.getSelectedText() || \"\"), d(e.getSelectedLinkUrl() || \"\");\n  }, e), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var H;\n    const w = (B) => {\n      (B.ctrlKey || B.metaKey) && B.key === \"k\" && (c(!0), B.preventDefault());\n    };\n    return (H = e.prosemirrorView) == null || H.dom.addEventListener(\"keydown\", w), () => {\n      var B;\n      (B = e.prosemirrorView) == null || B.dom.removeEventListener(\"keydown\", w);\n    };\n  }, [(f = e.prosemirrorView) == null ? void 0 : f.dom]);\n  const m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (w) => {\n      e.createLink(w), e.focus();\n    },\n    [e]\n  );\n  return !(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!o)\n      return !1;\n    for (const w of r)\n      if (w.content === void 0)\n        return !1;\n    return !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.isTableCellSelection)(e.prosemirrorState.selection);\n  }, [o, r, e.prosemirrorState.selection]) || !(\"link\" in e.schema.inlineContentSchema) || !e.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Popover.Root, { opened: l, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FormattingToolbar.Button,\n      {\n        className: \"bn-button\",\n        \"data-test\": \"createLink\",\n        label: n.formatting_toolbar.link.tooltip,\n        mainTooltip: n.formatting_toolbar.link.tooltip,\n        secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.formatKeyboardShortcut)(\n          n.formatting_toolbar.link.secondary_tooltip,\n          n.generic.ctrl_shortcut\n        ),\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Ct, {}),\n        onClick: () => c(!0)\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Popover.Content,\n      {\n        className: \"bn-popover-content bn-form-popover\",\n        variant: \"form-popover\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          Vt,\n          {\n            url: s,\n            text: a,\n            editLink: m,\n            showTextField: !1\n          }\n        )\n      }\n    )\n  ] });\n}, Go = () => {\n  const e = M(), t = C(), n = b(), [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), l = R(n), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (l.length !== 1)\n      return;\n    const a = l[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlock)(a, n))\n      return r(a.props.caption), a;\n  }, [n, l]), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a) => {\n      c && a.key === \"Enter\" && (a.preventDefault(), n.updateBlock(c, {\n        props: {\n          caption: o\n          // TODO\n        }\n      }));\n    },\n    [o, n, c]\n  ), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a) => r(a.currentTarget.value),\n    []\n  );\n  return !c || (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlockWithPlaceholder)(c, n) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Popover.Root, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FormattingToolbar.Button,\n      {\n        className: \"bn-button\",\n        label: e.formatting_toolbar.file_caption.tooltip,\n        mainTooltip: e.formatting_toolbar.file_caption.tooltip,\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(je, {}),\n        isSelected: c.props.caption !== \"\"\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Popover.Content,\n      {\n        className: \"bn-popover-content bn-form-popover\",\n        variant: \"form-popover\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Form.Root, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.Generic.Form.TextInput,\n          {\n            name: \"file-caption\",\n            icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(je, {}),\n            value: o || \"\",\n            autoFocus: !0,\n            placeholder: e.formatting_toolbar.file_caption.input_placeholder,\n            onKeyDown: s,\n            onChange: d\n          }\n        ) })\n      }\n    )\n  ] });\n}, Uo = () => {\n  const e = M(), t = C(), n = b(), o = R(n), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (o.length !== 1)\n      return;\n    const c = o[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlock)(c, n))\n      return c;\n  }, [n, o]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n.focus(), n.removeBlocks([r]);\n  }, [n, r]);\n  return !r || (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlockWithPlaceholder)(r, n) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      label: e.formatting_toolbar.file_delete.tooltip[r.type] || e.formatting_toolbar.file_delete.tooltip.file,\n      mainTooltip: e.formatting_toolbar.file_delete.tooltip[r.type] || e.formatting_toolbar.file_delete.tooltip.file,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(wo, {}),\n      onClick: l\n    }\n  );\n}, zo = () => {\n  const e = M(), t = C(), n = b(), [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), l = R(n), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (l.length !== 1)\n      return;\n    const a = l[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlock)(a, n))\n      return r(a.props.name), a;\n  }, [n, l]), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a) => {\n      c && a.key === \"Enter\" && (a.preventDefault(), n.updateBlock(c, {\n        props: {\n          name: o\n          // TODO\n        }\n      }));\n    },\n    [o, n, c]\n  ), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a) => r(a.currentTarget.value),\n    []\n  );\n  return !c || (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlockWithPlaceholder)(c, n) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Popover.Root, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FormattingToolbar.Button,\n      {\n        className: \"bn-button\",\n        label: e.formatting_toolbar.file_rename.tooltip[c.type] || e.formatting_toolbar.file_rename.tooltip.file,\n        mainTooltip: e.formatting_toolbar.file_rename.tooltip[c.type] || e.formatting_toolbar.file_rename.tooltip.file,\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ze, {})\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Popover.Content,\n      {\n        className: \"bn-popover-content bn-form-popover\",\n        variant: \"form-popover\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Form.Root, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.Generic.Form.TextInput,\n          {\n            name: \"file-name\",\n            icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ze, {}),\n            value: o || \"\",\n            autoFocus: !0,\n            placeholder: e.formatting_toolbar.file_rename.input_placeholder[c.type] || e.formatting_toolbar.file_rename.input_placeholder.file,\n            onKeyDown: s,\n            onChange: d\n          }\n        ) })\n      }\n    )\n  ] });\n}, jo = () => {\n  const e = M(), t = C(), n = b(), o = R(n), [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    l(!1);\n  }, [o]);\n  const c = o.length === 1 ? o[0] : void 0;\n  return c === void 0 || !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlock)(c, n) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Popover.Root, { opened: r, position: \"bottom\", children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FormattingToolbar.Button,\n      {\n        className: \"bn-button\",\n        onClick: () => l(!r),\n        isSelected: r,\n        mainTooltip: e.formatting_toolbar.file_replace.tooltip[c.type] || e.formatting_toolbar.file_replace.tooltip.file,\n        label: e.formatting_toolbar.file_replace.tooltip[c.type] || e.formatting_toolbar.file_replace.tooltip.file,\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(bo, {})\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Popover.Content,\n      {\n        className: \"bn-popover-content bn-panel-popover\",\n        variant: \"panel-popover\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Bt, { block: c })\n      }\n    )\n  ] });\n}, Wo = () => {\n  const e = M(), t = C(), n = b(), o = R(n), [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => n.canNestBlock()\n  );\n  U(() => {\n    l(n.canNestBlock());\n  }, n);\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n.focus(), n.nestBlock();\n  }, [n]);\n  return !(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => !o.find(\n    (d) => n.schema.blockSchema[d.type].content !== \"inline\"\n  ), [n.schema.blockSchema, o]) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      \"data-test\": \"nestBlock\",\n      onClick: c,\n      isDisabled: !r,\n      label: e.formatting_toolbar.nest.tooltip,\n      mainTooltip: e.formatting_toolbar.nest.tooltip,\n      secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.formatKeyboardShortcut)(\n        e.formatting_toolbar.nest.secondary_tooltip,\n        e.generic.ctrl_shortcut\n      ),\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(io, {})\n    }\n  );\n}, $o = () => {\n  const e = M(), t = C(), n = b(), o = R(n), [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => n.canUnnestBlock()\n  );\n  U(() => {\n    l(n.canUnnestBlock());\n  }, n);\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n.focus(), n.unnestBlock();\n  }, [n]);\n  return !(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => !o.find(\n    (d) => n.schema.blockSchema[d.type].content !== \"inline\"\n  ), [n.schema.blockSchema, o]) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      \"data-test\": \"unnestBlock\",\n      onClick: c,\n      isDisabled: !r,\n      label: e.formatting_toolbar.unnest.tooltip,\n      mainTooltip: e.formatting_toolbar.unnest.tooltip,\n      secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.formatKeyboardShortcut)(\n        e.formatting_toolbar.unnest.secondary_tooltip,\n        e.generic.ctrl_shortcut\n      ),\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ro, {})\n    }\n  );\n}, qo = (e) => [\n  {\n    name: e.slash_menu.paragraph.title,\n    type: \"paragraph\",\n    icon: _e,\n    isSelected: (t) => t.type === \"paragraph\"\n  },\n  {\n    name: e.slash_menu.heading.title,\n    type: \"heading\",\n    props: { level: 1 },\n    icon: ft,\n    isSelected: (t) => t.type === \"heading\" && \"level\" in t.props && t.props.level === 1\n  },\n  {\n    name: e.slash_menu.heading_2.title,\n    type: \"heading\",\n    props: { level: 2 },\n    icon: gt,\n    isSelected: (t) => t.type === \"heading\" && \"level\" in t.props && t.props.level === 2\n  },\n  {\n    name: e.slash_menu.heading_3.title,\n    type: \"heading\",\n    props: { level: 3 },\n    icon: bt,\n    isSelected: (t) => t.type === \"heading\" && \"level\" in t.props && t.props.level === 3\n  },\n  {\n    name: e.slash_menu.quote.title,\n    type: \"quote\",\n    icon: vt,\n    isSelected: (t) => t.type === \"quote\"\n  },\n  {\n    name: e.slash_menu.bullet_list.title,\n    type: \"bulletListItem\",\n    icon: wt,\n    isSelected: (t) => t.type === \"bulletListItem\"\n  },\n  {\n    name: e.slash_menu.numbered_list.title,\n    type: \"numberedListItem\",\n    icon: kt,\n    isSelected: (t) => t.type === \"numberedListItem\"\n  },\n  {\n    name: e.slash_menu.check_list.title,\n    type: \"checkListItem\",\n    icon: pt,\n    isSelected: (t) => t.type === \"checkListItem\"\n  }\n], Ko = (e) => {\n  const t = C(), n = M(), o = b(), r = R(o), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(o.getTextCursorPosition().block), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (e.items || qo(n)).filter(\n    (u) => u.type in o.schema.blockSchema\n  ), [o, n, e.items]), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => s.find((u) => u.type === l.type) !== void 0,\n    [l.type, s]\n  ), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const u = (m) => {\n      o.focus();\n      for (const h of r)\n        o.updateBlock(h, {\n          type: m.type,\n          props: m.props\n        });\n    };\n    return s.map((m) => {\n      const h = m.icon;\n      return {\n        text: m.name,\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(h, { size: 16 }),\n        onClick: () => u(m),\n        isSelected: m.isSelected(l)\n      };\n    });\n  }, [l, s, o, r]);\n  return U(() => {\n    c(o.getTextCursorPosition().block);\n  }, o), !d || !o.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Select,\n    {\n      className: \"bn-select\",\n      items: a\n    }\n  );\n}, Xo = () => {\n  const e = M(), t = C(), n = b(), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    var r;\n    (r = n.comments) == null || r.startPendingComment(), n.formattingToolbar.closeMenu();\n  }, [n]);\n  return n.comments ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      label: e.formatting_toolbar.comment.tooltip,\n      mainTooltip: e.formatting_toolbar.comment.tooltip,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ht, {}),\n      onClick: o\n    }\n  ) : null;\n}, Yo = () => {\n  const e = M(), t = C(), n = b(), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n._tiptapEditor.chain().focus().addPendingComment().run();\n  }, [n]);\n  return (\n    // We manually check if a comment extension (like liveblocks) is installed\n    // By adding default support for this, the user doesn't need to customize the formatting toolbar\n    !n._tiptapEditor.commands.addPendingComment || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.FormattingToolbar.Button,\n      {\n        className: \"bn-button\",\n        label: e.formatting_toolbar.comment.tooltip,\n        mainTooltip: e.formatting_toolbar.comment.tooltip,\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ht, {}),\n        onClick: o\n      }\n    )\n  );\n};\nfunction ve(e, t) {\n  try {\n    const n = new URL(e, t);\n    if (n.protocol !== \"javascript:\")\n      return n.href;\n  } catch {\n  }\n  return \"#\";\n}\nconst Jo = () => {\n  const e = M(), t = C(), n = b(), o = R(n), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (o.length !== 1)\n      return;\n    const c = o[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlock)(c, n))\n      return c;\n  }, [n, o]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    r && r.props.url && (n.focus(), n.resolveFileUrl ? n.resolveFileUrl(r.props.url).then(\n      (c) => window.open(ve(c, window.location.href))\n    ) : window.open(ve(r.props.url, window.location.href)));\n  }, [n, r]);\n  return !r || (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlockWithPlaceholder)(r, n) ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      label: e.formatting_toolbar.file_download.tooltip[r.type] || e.formatting_toolbar.file_download.tooltip.file,\n      mainTooltip: e.formatting_toolbar.file_download.tooltip[r.type] || e.formatting_toolbar.file_download.tooltip.file,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Ho, {}),\n      onClick: l\n    }\n  );\n}, Qo = () => {\n  const e = M(), t = C(), n = b(), o = R(n), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (o.length !== 1)\n      return;\n    const c = o[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlockWithPreview)(c, n))\n      return c;\n  }, [n, o]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    r && n.updateBlock(r, {\n      props: {\n        showPreview: !r.props.showPreview\n        // TODO\n      }\n    });\n  }, [n, r]);\n  return !r || (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockIsFileBlockWithPlaceholder)(r, n) || !n.isEditable ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      label: \"Toggle preview\",\n      mainTooltip: e.formatting_toolbar.file_preview_toggle.tooltip,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(go, {}),\n      isSelected: r.props.showPreview,\n      onClick: l\n    }\n  );\n}, er = () => {\n  const e = M(), t = C(), n = b(), o = R(n), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    var s;\n    if (o.length !== 1)\n      return;\n    const c = o[0];\n    if (c.type === \"table\")\n      return (s = n.tableHandles) == null ? void 0 : s.getMergeDirection(c);\n  }, [n, o]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    var c;\n    (c = n.tableHandles) == null || c.mergeCells();\n  }, [n]);\n  return !n.isEditable || r === void 0 || !n.settings.tables.splitCells ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      label: e.formatting_toolbar.table_cell_merge.tooltip,\n      mainTooltip: e.formatting_toolbar.table_cell_merge.tooltip,\n      icon: r === \"horizontal\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ao, {}) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(so, {}),\n      onClick: l\n    }\n  );\n}, tr = {\n  left: eo,\n  center: Jn,\n  right: to,\n  justify: Qn\n}, be = (e) => {\n  const t = C(), n = M(), o = b(), r = R(o), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    var u;\n    const a = r[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockHasDefaultProp)(\"textAlignment\", a, o))\n      return a.props.textAlignment;\n    if (a.type === \"table\") {\n      const m = (u = o.tableHandles) == null ? void 0 : u.getCellSelection();\n      if (!m)\n        return;\n      const h = m.cells.map(\n        ({ row: w, col: H }) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mapTableCell)(\n          a.content.rows[w].cells[H]\n        ).props.textAlignment\n      ), f = h[0];\n      if (h.every((w) => w === f))\n        return f;\n    }\n  }, [o, r]), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a) => {\n      var u;\n      o.focus();\n      for (const m of r)\n        if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockTypeHasDefaultProp)(\"textAlignment\", m.type, o))\n          o.updateBlock(m, {\n            props: { textAlignment: a }\n          });\n        else if (m.type === \"table\") {\n          const h = (u = o.tableHandles) == null ? void 0 : u.getCellSelection();\n          if (!h)\n            continue;\n          const f = m.content.rows.map(\n            (w) => ({\n              ...w,\n              cells: w.cells.map((H) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mapTableCell)(H))\n            })\n          );\n          h.cells.forEach(({ row: w, col: H }) => {\n            f[w].cells[H].props.textAlignment = a;\n          }), o.updateBlock(m, {\n            type: \"table\",\n            content: {\n              ...m.content,\n              type: \"tableContent\",\n              rows: f\n            }\n          }), o.setTextCursorPosition(m);\n        }\n    },\n    [o, r]\n  );\n  if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => !!r.find(\n    (a) => \"textAlignment\" in a.props || a.type === \"table\" && a.children\n  ), [r]) || !o.isEditable)\n    return null;\n  const d = tr[e.textAlignment];\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Button,\n    {\n      className: \"bn-button\",\n      \"data-test\": `alignText${e.textAlignment.slice(0, 1).toUpperCase() + e.textAlignment.slice(1)}`,\n      onClick: () => c(e.textAlignment),\n      isSelected: l === e.textAlignment,\n      label: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,\n      mainTooltip: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(d, {})\n    }\n  );\n}, nr = (e) => [\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Ko, { items: e }, \"blockTypeSelect\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(er, {}, \"tableCellMergeButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Go, {}, \"fileCaptionButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(jo, {}, \"replaceFileButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(zo, {}, \"fileRenameButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Uo, {}, \"fileDeleteButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Jo, {}, \"fileDownloadButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Qo, {}, \"filePreviewButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ne, { basicTextStyle: \"bold\" }, \"boldStyleButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ne, { basicTextStyle: \"italic\" }, \"italicStyleButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    ne,\n    {\n      basicTextStyle: \"underline\"\n    },\n    \"underlineStyleButton\"\n  ),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ne, { basicTextStyle: \"strike\" }, \"strikeStyleButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(be, { textAlignment: \"left\" }, \"textAlignLeftButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(be, { textAlignment: \"center\" }, \"textAlignCenterButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(be, { textAlignment: \"right\" }, \"textAlignRightButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Zo, {}, \"colorStyleButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Wo, {}, \"nestBlockButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)($o, {}, \"unnestBlockButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Ao, {}, \"createLinkButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Xo, {}, \"addCommentButton\"),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Yo, {}, \"addTiptapCommentButton\")\n], St = (e) => {\n  const t = C();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.FormattingToolbar.Root,\n    {\n      className: \"bn-toolbar bn-formatting-toolbar\",\n      children: e.children || nr(e.blockTypeSelectItems)\n    }\n  );\n}, Ye = (e) => {\n  switch (e) {\n    case \"left\":\n      return \"top-start\";\n    case \"center\":\n      return \"top\";\n    case \"right\":\n      return \"top-end\";\n    default:\n      return \"top-start\";\n  }\n}, or = (e) => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), n = b(), [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => {\n      const h = n.getTextCursorPosition().block;\n      return \"textAlignment\" in h.props ? Ye(\n        h.props.textAlignment\n      ) : \"top-start\";\n    }\n  );\n  U(() => {\n    const h = n.getTextCursorPosition().block;\n    \"textAlignment\" in h.props ? r(\n      Ye(\n        h.props.textAlignment\n      )\n    ) : r(\"top-start\");\n  }, n);\n  const l = P(\n    n.formattingToolbar.onUpdate.bind(n.formattingToolbar)\n  ), { isMounted: c, ref: s, style: d, getFloatingProps: a } = G(\n    (l == null ? void 0 : l.show) || !1,\n    (l == null ? void 0 : l.referencePos) || null,\n    3e3,\n    {\n      placement: o,\n      middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.shift)(), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)()],\n      onOpenChange: (h, f) => {\n        h || (n.formattingToolbar.closeMenu(), n.focus());\n      },\n      ...e.floatingOptions\n    }\n  ), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => Po([t, s]), [t, s]);\n  if (!c || !l)\n    return null;\n  if (!l.show && t.current)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"div\",\n      {\n        ref: u,\n        style: d,\n        dangerouslySetInnerHTML: { __html: t.current.innerHTML }\n      }\n    );\n  const m = e.formattingToolbar || St;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: u, style: d, ...a(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(m, {}) });\n}, rr = (e) => {\n  const t = C(), n = M();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.LinkToolbar.Button,\n    {\n      className: \"bn-button\",\n      label: n.link_toolbar.delete.tooltip,\n      mainTooltip: n.link_toolbar.delete.tooltip,\n      isSelected: !1,\n      onClick: e.deleteLink,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(co, {})\n    }\n  );\n}, ir = (e) => {\n  const t = C(), n = M();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Popover.Root, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.LinkToolbar.Button,\n      {\n        className: \"bn-button\",\n        mainTooltip: n.link_toolbar.edit.tooltip,\n        isSelected: !1,\n        children: n.link_toolbar.edit.text\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Popover.Content,\n      {\n        className: \"bn-popover-content bn-form-popover\",\n        variant: \"form-popover\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Vt, { ...e })\n      }\n    )\n  ] });\n}, lr = (e) => {\n  const t = C(), n = M();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.LinkToolbar.Button,\n    {\n      className: \"bn-button\",\n      mainTooltip: n.link_toolbar.open.tooltip,\n      label: n.link_toolbar.open.tooltip,\n      isSelected: !1,\n      onClick: () => {\n        window.open(ve(e.url, window.location.href), \"_blank\");\n      },\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Mo, {})\n    }\n  );\n}, cr = (e) => {\n  const t = C();\n  return e.children ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.LinkToolbar.Root, { className: \"bn-toolbar bn-link-toolbar\", children: e.children }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    t.LinkToolbar.Root,\n    {\n      className: \"bn-toolbar bn-link-toolbar\",\n      onMouseEnter: e.stopHideTimer,\n      onMouseLeave: e.startHideTimer,\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          ir,\n          {\n            url: e.url,\n            text: e.text,\n            editLink: e.editLink\n          }\n        ),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(lr, { url: e.url }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(rr, { deleteLink: e.deleteLink })\n      ]\n    }\n  );\n}, ar = (e) => {\n  const t = b(), n = {\n    deleteLink: t.linkToolbar.deleteLink,\n    editLink: t.linkToolbar.editLink,\n    startHideTimer: t.linkToolbar.startHideTimer,\n    stopHideTimer: t.linkToolbar.stopHideTimer\n  }, o = P(\n    t.linkToolbar.onUpdate.bind(t.linkToolbar)\n  ), { isMounted: r, ref: l, style: c, getFloatingProps: s } = G(\n    (o == null ? void 0 : o.show) || !1,\n    (o == null ? void 0 : o.referencePos) || null,\n    4e3,\n    {\n      placement: \"top-start\",\n      middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)()],\n      onOpenChange: (h) => {\n        h || (t.linkToolbar.closeMenu(), t.focus());\n      },\n      ...e.floatingOptions\n    }\n  );\n  if (!r || !o)\n    return null;\n  const { show: d, referencePos: a, ...u } = o, m = e.linkToolbar || cr;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: l, style: c, ...s(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(m, { ...u, ...n }) });\n};\nfunction sr(e) {\n  return p({ attr: { viewBox: \"0 0 1024 1024\" }, child: [{ tag: \"path\", attr: { d: \"M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8Z\" }, child: [] }, { tag: \"path\", attr: { d: \"M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8Z\" }, child: [] }] })(e);\n}\nconst dr = (e) => {\n  const t = C(), n = M(), o = b(), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const l = e.block.content;\n    if (l !== void 0 && Array.isArray(l) && l.length === 0)\n      o.setTextCursorPosition(e.block), o.openSuggestionMenu(\"/\");\n    else {\n      const s = o.insertBlocks(\n        [{ type: \"paragraph\" }],\n        e.block,\n        \"after\"\n      )[0];\n      o.setTextCursorPosition(s), o.openSuggestionMenu(\"/\");\n    }\n  }, [o, e.block]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.SideMenu.Button,\n    {\n      className: \"bn-button\",\n      label: n.side_menu.add_block_label,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(sr, { size: 24, onClick: r, \"data-test\": \"dragHandleAdd\" })\n    }\n  );\n};\nfunction Tt(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0V0z\" }, child: [] }, { tag: \"path\", attr: { d: \"M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\" }, child: [] }] })(e);\n}\nfunction ur(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0z\" }, child: [] }, { tag: \"path\", attr: { d: \"m7 10 5 5 5-5z\" }, child: [] }] })(e);\n}\nconst mr = (e) => {\n  const t = C(), n = b();\n  return !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockTypeHasDefaultProp)(\"textColor\", e.block.type, n) && !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockTypeHasDefaultProp)(\"backgroundColor\", e.block.type, n) ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Menu.Root, { position: \"right\", sub: !0, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Trigger, { sub: !0, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Menu.Item,\n      {\n        className: \"bn-menu-item\",\n        subTrigger: !0,\n        children: e.children\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Menu.Dropdown,\n      {\n        sub: !0,\n        className: \"bn-menu-dropdown bn-color-picker-dropdown\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          me,\n          {\n            iconSize: 18,\n            text: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockTypeHasDefaultProp)(\n              \"textColor\",\n              e.block.type,\n              n\n            ) && (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockHasDefaultProp)(\"textColor\", e.block, n) ? {\n              color: e.block.props.textColor,\n              setColor: (o) => n.updateBlock(e.block, {\n                type: e.block.type,\n                props: { textColor: o }\n              })\n            } : void 0,\n            background: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockTypeHasDefaultProp)(\n              \"backgroundColor\",\n              e.block.type,\n              n\n            ) && (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.checkBlockHasDefaultProp)(\"backgroundColor\", e.block, n) ? {\n              color: e.block.props.backgroundColor,\n              setColor: (o) => n.updateBlock(e.block, {\n                props: { backgroundColor: o }\n              })\n            } : void 0\n          }\n        )\n      }\n    )\n  ] });\n}, hr = (e) => {\n  const t = C(), n = b();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      className: \"bn-menu-item\",\n      onClick: () => n.removeBlocks([e.block]),\n      children: e.children\n    }\n  );\n}, fr = (e) => {\n  const t = C(), n = b();\n  if (e.block.type !== \"table\" || !n.settings.tables.headers)\n    return null;\n  const o = !!e.block.content.headerRows;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      className: \"bn-menu-item\",\n      checked: o,\n      onClick: () => {\n        const r = n.getBlock(e.block.id);\n        r && n.updateBlock(r, {\n          ...r,\n          content: {\n            ...r.content,\n            headerRows: o ? void 0 : 1\n          }\n        });\n      },\n      children: e.children\n    }\n  );\n}, gr = (e) => {\n  const t = C(), n = b();\n  if (e.block.type !== \"table\" || !n.settings.tables.headers)\n    return null;\n  const o = !!e.block.content.headerCols;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      className: \"bn-menu-item\",\n      checked: o,\n      onClick: () => {\n        n.updateBlock(e.block, {\n          type: \"table\",\n          content: {\n            ...e.block.content,\n            type: \"tableContent\",\n            headerCols: o ? void 0 : 1\n          }\n        });\n      },\n      children: e.children\n    }\n  );\n}, br = (e) => {\n  const t = C(), n = M();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Dropdown,\n    {\n      className: \"bn-menu-dropdown bn-drag-handle-menu\",\n      children: e.children || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(hr, { ...e, children: n.drag_handle.delete_menuitem }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(mr, { ...e, children: n.drag_handle.colors_menuitem }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(fr, { ...e, children: n.drag_handle.header_row_menuitem }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(gr, { ...e, children: n.drag_handle.header_column_menuitem })\n      ] })\n    }\n  );\n}, Cr = (e) => {\n  const t = C(), n = M(), o = e.dragHandleMenu || br;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    t.Generic.Menu.Root,\n    {\n      onOpenChange: (r) => {\n        r ? e.freezeMenu() : e.unfreezeMenu();\n      },\n      position: \"left\",\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.SideMenu.Button,\n          {\n            label: n.side_menu.drag_handle_label,\n            draggable: !0,\n            onDragStart: (r) => e.blockDragStart(r, e.block),\n            onDragEnd: e.blockDragEnd,\n            className: \"bn-button\",\n            icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Tt, { size: 24, \"data-test\": \"dragHandle\" })\n          }\n        ) }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(o, { block: e.block, children: e.children })\n      ]\n    }\n  );\n}, pr = (e) => {\n  const t = C(), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const o = {\n      \"data-block-type\": e.block.type\n    };\n    return e.block.type === \"heading\" && (o[\"data-level\"] = e.block.props.level.toString()), e.editor.schema.blockSchema[e.block.type].isFileBlock && (e.block.props.url ? o[\"data-url\"] = \"true\" : o[\"data-url\"] = \"false\"), o;\n  }, [e.block, e.editor.schema.blockSchema]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.SideMenu.Root, { className: \"bn-side-menu\", ...n, children: e.children || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(dr, { ...e }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Cr, { ...e })\n  ] }) });\n}, kr = (e) => {\n  const t = b(), n = {\n    blockDragStart: t.sideMenu.blockDragStart,\n    blockDragEnd: t.sideMenu.blockDragEnd,\n    freezeMenu: t.sideMenu.freezeMenu,\n    unfreezeMenu: t.sideMenu.unfreezeMenu\n  }, o = P(\n    t.sideMenu.onUpdate.bind(t.sideMenu)\n  ), { isMounted: r, ref: l, style: c, getFloatingProps: s } = G(\n    (o == null ? void 0 : o.show) || !1,\n    (o == null ? void 0 : o.referencePos) || null,\n    1e3,\n    {\n      placement: \"left-start\",\n      ...e.floatingOptions\n    }\n  );\n  if (!r || !o)\n    return null;\n  const { show: d, referencePos: a, ...u } = o, m = e.sideMenu || pr;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: l, style: c, ...s(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(m, { ...u, ...n, editor: t }) });\n};\nasync function wr(e, t) {\n  return (await (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getDefaultEmojiPickerItems)(e, t)).map(\n    ({ id: n, onItemClick: o }) => ({\n      id: n,\n      onItemClick: o,\n      icon: n\n    })\n  );\n}\nfunction vr(e) {\n  const t = C(), n = M(), { items: o, loadingState: r, selectedIndex: l, onItemClick: c, columns: s } = e, d = r === \"loading-initial\" || r === \"loading\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.GridSuggestionMenu.Loader,\n    {\n      className: \"bn-grid-suggestion-menu-loader\",\n      columns: s,\n      children: n.suggestion_menu.loading\n    }\n  ) : null, a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const u = [];\n    for (let m = 0; m < o.length; m++) {\n      const h = o[m];\n      u.push(\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.GridSuggestionMenu.Item,\n          {\n            className: \"bn-grid-suggestion-menu-item\",\n            item: h,\n            id: `bn-grid-suggestion-menu-item-${m}`,\n            isSelected: m === l,\n            onClick: () => c == null ? void 0 : c(h)\n          },\n          h.id\n        )\n      );\n    }\n    return u;\n  }, [t, o, c, l]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    t.GridSuggestionMenu.Root,\n    {\n      id: \"bn-grid-suggestion-menu\",\n      columns: s,\n      className: \"bn-grid-suggestion-menu\",\n      children: [\n        d,\n        a,\n        a.length === 0 && e.loadingState === \"loaded\" && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.GridSuggestionMenu.EmptyItem,\n          {\n            className: \"bn-grid-suggestion-menu-empty-item\",\n            columns: s,\n            children: n.suggestion_menu.no_items_title\n          }\n        )\n      ]\n    }\n  );\n}\nfunction Lt(e, t, n, o = 3) {\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t !== void 0 && (e.length > 0 ? r.current = t.length : t.length - r.current > o && n());\n  }, [n, o, e.length, t]);\n}\nfunction Et(e, t) {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const d = e;\n    c.current = e, l(!0), t(e).then((a) => {\n      c.current === d && (o(a), l(!1), s.current = d);\n    });\n  }, [e, t]), {\n    items: n || [],\n    // The query that was used to retrieve the last set of items may not be the\n    // same as the current query as the items from the current query may not\n    // have been retrieved yet. This is useful when using the returns of this\n    // hook in other hooks.\n    usedQuery: s.current,\n    loadingState: s.current === void 0 ? \"loading-initial\" : r ? \"loading\" : \"loaded\"\n  };\n}\nfunction Hr(e, t, n, o, r) {\n  const [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), s = o !== void 0 && o > 1;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var a;\n    const d = (u) => (u.key === \"ArrowLeft\" && (u.preventDefault(), n.length && c((l - 1 + n.length) % n.length)), u.key === \"ArrowRight\" && (u.preventDefault(), n.length && c((l + 1 + n.length) % n.length)), u.key === \"ArrowUp\" ? (u.preventDefault(), n.length && c(\n      (l - o + n.length) % n.length\n    ), !0) : u.key === \"ArrowDown\" ? (u.preventDefault(), n.length && c((l + o) % n.length), !0) : u.key === \"Enter\" && !u.isComposing ? (u.preventDefault(), n.length && (r == null || r(n[l])), !0) : !1);\n    return (a = e.domElement) == null || a.addEventListener(\n      \"keydown\",\n      d,\n      !0\n    ), () => {\n      var u;\n      (u = e.domElement) == null || u.removeEventListener(\n        \"keydown\",\n        d,\n        !0\n      );\n    };\n  }, [e.domElement, n, l, r, o, s]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c(0);\n  }, [t]), {\n    selectedIndex: n.length === 0 ? void 0 : l\n  };\n}\nfunction Mr(e) {\n  const n = D().setContentEditableProps, o = b(), {\n    getItems: r,\n    gridSuggestionMenuComponent: l,\n    query: c,\n    clearQuery: s,\n    closeMenu: d,\n    onItemClick: a,\n    columns: u\n  } = e, m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (V) => {\n      d(), s(), a == null || a(V);\n    },\n    [a, d, s]\n  ), { items: h, usedQuery: f, loadingState: w } = Et(\n    c,\n    r\n  );\n  Lt(h, f, d);\n  const { selectedIndex: H } = Hr(\n    o,\n    c,\n    h,\n    u,\n    m\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (n((V) => ({\n    ...V,\n    \"aria-expanded\": !0,\n    \"aria-controls\": \"bn-suggestion-menu\"\n  })), () => {\n    n((V) => ({\n      ...V,\n      \"aria-expanded\": !1,\n      \"aria-controls\": void 0\n    }));\n  }), [n]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (n((V) => ({\n    ...V,\n    \"aria-activedescendant\": H ? \"bn-suggestion-menu-item-\" + H : void 0\n  })), () => {\n    n((V) => ({\n      ...V,\n      \"aria-activedescendant\": void 0\n    }));\n  }), [n, H]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    l,\n    {\n      items: h,\n      onItemClick: m,\n      loadingState: w,\n      selectedIndex: H,\n      columns: u\n    }\n  );\n}\nfunction xr(e) {\n  const t = b(), {\n    triggerCharacter: n,\n    gridSuggestionMenuComponent: o,\n    columns: r,\n    minQueryLength: l,\n    onItemClick: c,\n    getItems: s,\n    floatingOptions: d\n  } = e, a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => c || ((S) => {\n    S.onItemClick(t);\n  }), [t, c]), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => s || (async (S) => await wr(\n    t,\n    S\n  )), [t, s]), m = {\n    closeMenu: t.suggestionMenus.closeMenu,\n    clearQuery: t.suggestionMenus.clearQuery\n  }, h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (S) => t.suggestionMenus.onUpdate(n, S),\n    [t.suggestionMenus, n]\n  ), f = P(h), { isMounted: w, ref: H, style: B, getFloatingProps: V } = G(\n    (f == null ? void 0 : f.show) || !1,\n    (f == null ? void 0 : f.referencePos) || null,\n    2e3,\n    {\n      placement: \"bottom-start\",\n      middleware: [\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(10),\n        // Flips the menu placement to maximize the space available, and prevents\n        // the menu from being cut off by the confines of the screen.\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)(),\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.size)({\n          apply({ availableHeight: S, elements: O }) {\n            Object.assign(O.floating.style, {\n              maxHeight: `${S - 10}px`\n            });\n          }\n        })\n      ],\n      onOpenChange(S) {\n        S || t.suggestionMenus.closeMenu();\n      },\n      ...d\n    }\n  );\n  return !w || !f || !(f != null && f.ignoreQueryLength) && l && (f.query.startsWith(\" \") || f.query.length < l) ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: H, style: B, ...V(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    Mr,\n    {\n      query: f.query,\n      closeMenu: m.closeMenu,\n      clearQuery: m.clearQuery,\n      getItems: u,\n      columns: r,\n      gridSuggestionMenuComponent: o || vr,\n      onItemClick: a\n    }\n  ) });\n}\nfunction yr(e) {\n  const t = C(), n = M(), { items: o, loadingState: r, selectedIndex: l, onItemClick: c } = e, s = r === \"loading-initial\" || r === \"loading\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.SuggestionMenu.Loader, { className: \"bn-suggestion-menu-loader\", children: n.suggestion_menu.loading }) : null, d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let a;\n    const u = [];\n    for (let m = 0; m < o.length; m++) {\n      const h = o[m];\n      h.group !== a && (a = h.group, u.push(\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.SuggestionMenu.Label,\n          {\n            className: \"bn-suggestion-menu-label\",\n            children: a\n          },\n          a\n        )\n      )), u.push(\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.SuggestionMenu.Item,\n          {\n            className: \"bn-suggestion-menu-item\",\n            item: h,\n            id: `bn-suggestion-menu-item-${m}`,\n            isSelected: m === l,\n            onClick: () => c == null ? void 0 : c(h)\n          },\n          h.title\n        )\n      );\n    }\n    return u;\n  }, [t, o, c, l]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    t.SuggestionMenu.Root,\n    {\n      id: \"bn-suggestion-menu\",\n      className: \"bn-suggestion-menu\",\n      children: [\n        d,\n        d.length === 0 && (e.loadingState === \"loading\" || e.loadingState === \"loaded\") && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.SuggestionMenu.EmptyItem,\n          {\n            className: \"bn-suggestion-menu-item\",\n            children: n.suggestion_menu.no_items_title\n          }\n        ),\n        s\n      ]\n    }\n  );\n}\nfunction Br(e, t, n, o) {\n  const [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var s;\n    const c = (d) => d.key === \"ArrowUp\" ? (d.preventDefault(), n.length && l((r - 1 + n.length) % n.length), !0) : d.key === \"ArrowDown\" ? (d.preventDefault(), n.length && l((r + 1) % n.length), !0) : d.key === \"Enter\" && !d.isComposing ? (d.preventDefault(), d.stopPropagation(), n.length && (o == null || o(n[r])), !0) : !1;\n    return (s = e.domElement) == null || s.addEventListener(\n      \"keydown\",\n      c,\n      !0\n    ), () => {\n      var d;\n      (d = e.domElement) == null || d.removeEventListener(\n        \"keydown\",\n        c,\n        !0\n      );\n    };\n  }, [e.domElement, n, r, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    l(0);\n  }, [t]), {\n    selectedIndex: n.length === 0 ? void 0 : r\n  };\n}\nfunction Vr(e) {\n  const n = D().setContentEditableProps, o = b(), {\n    getItems: r,\n    suggestionMenuComponent: l,\n    query: c,\n    clearQuery: s,\n    closeMenu: d,\n    onItemClick: a\n  } = e, u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (B) => {\n      d(), s(), a == null || a(B);\n    },\n    [a, d, s]\n  ), { items: m, usedQuery: h, loadingState: f } = Et(\n    c,\n    r\n  );\n  Lt(m, h, d);\n  const { selectedIndex: w } = Br(\n    o,\n    c,\n    m,\n    u\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (n((B) => ({\n    ...B,\n    \"aria-expanded\": !0,\n    \"aria-controls\": \"bn-suggestion-menu\"\n  })), () => {\n    n((B) => ({\n      ...B,\n      \"aria-expanded\": !1,\n      \"aria-controls\": void 0\n    }));\n  }), [n]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (n((B) => ({\n    ...B,\n    \"aria-activedescendant\": w ? \"bn-suggestion-menu-item-\" + w : void 0\n  })), () => {\n    n((B) => ({\n      ...B,\n      \"aria-activedescendant\": void 0\n    }));\n  }), [n, w]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    l,\n    {\n      items: m,\n      onItemClick: u,\n      loadingState: f,\n      selectedIndex: w\n    }\n  );\n}\nconst Sr = {\n  heading: ft,\n  heading_2: gt,\n  heading_3: bt,\n  quote: vt,\n  numbered_list: kt,\n  bullet_list: wt,\n  check_list: pt,\n  paragraph: _e,\n  table: mo,\n  image: Ht,\n  video: fo,\n  audio: Mt,\n  file: Re,\n  emoji: yo,\n  code_block: oo\n};\nfunction Tr(e) {\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getDefaultSlashMenuItems)(e).map((t) => {\n    const n = Sr[t.key];\n    return {\n      ...t,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(n, { size: 18 })\n    };\n  });\n}\nfunction Lr(e) {\n  const t = b(), {\n    triggerCharacter: n,\n    suggestionMenuComponent: o,\n    minQueryLength: r,\n    onItemClick: l,\n    getItems: c,\n    floatingOptions: s\n  } = e, d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => l || ((V) => {\n    V.onItemClick(t);\n  }), [t, l]), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => c || (async (V) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.filterSuggestionItems)(\n    Tr(t),\n    V\n  )), [t, c]), u = {\n    closeMenu: t.suggestionMenus.closeMenu,\n    clearQuery: t.suggestionMenus.clearQuery\n  }, m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (V) => t.suggestionMenus.onUpdate(n, V),\n    [t.suggestionMenus, n]\n  ), h = P(m), { isMounted: f, ref: w, style: H, getFloatingProps: B } = G(\n    (h == null ? void 0 : h.show) || !1,\n    (h == null ? void 0 : h.referencePos) || null,\n    2e3,\n    {\n      placement: \"bottom-start\",\n      middleware: [\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(10),\n        // Flips the menu placement to maximize the space available, and prevents\n        // the menu from being cut off by the confines of the screen.\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.flip)({\n          mainAxis: !0,\n          crossAxis: !1\n        }),\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.shift)(),\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.size)({\n          apply({ availableHeight: V, elements: S }) {\n            Object.assign(S.floating.style, {\n              maxHeight: `${V - 10}px`\n            });\n          }\n        })\n      ],\n      onOpenChange(V) {\n        V || t.suggestionMenus.closeMenu();\n      },\n      ...s\n    }\n  );\n  return !f || !h || !(h != null && h.ignoreQueryLength) && r && (h.query.startsWith(\" \") || h.query.length < r) ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: w, style: H, ...B(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    Vr,\n    {\n      query: h.query,\n      closeMenu: u.closeMenu,\n      clearQuery: u.clearQuery,\n      getItems: a,\n      suggestionMenuComponent: o || yr,\n      onItemClick: d\n    }\n  ) });\n}\nconst Er = (e, t = 0.3) => {\n  const n = Math.floor(e) + t, o = Math.ceil(e) - t;\n  return e >= n && e <= o ? Math.round(e) : e < n ? Math.floor(e) : Math.ceil(e);\n}, Rr = (e) => {\n  const t = C(), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (s) => {\n      e.onMouseDown(), r({\n        originalContent: e.block.content,\n        originalCroppedContent: {\n          rows: e.editor.tableHandles.cropEmptyRowsOrColumns(\n            e.block,\n            e.orientation === \"addOrRemoveColumns\" ? \"columns\" : \"rows\"\n          )\n        },\n        startPos: e.orientation === \"addOrRemoveColumns\" ? s.clientX : s.clientY\n      }), n.current = !1, s.preventDefault();\n    },\n    [e]\n  ), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n.current || e.editor.updateBlock(e.block, {\n      type: \"table\",\n      content: {\n        ...e.block.content,\n        rows: e.orientation === \"addOrRemoveColumns\" ? e.editor.tableHandles.addRowsOrColumns(\n          e.block,\n          \"columns\",\n          1\n        ) : e.editor.tableHandles.addRowsOrColumns(\n          e.block,\n          \"rows\",\n          1\n        )\n      }\n    });\n  }, [e.block, e.orientation, e.editor]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const s = (d) => {\n      var w, H;\n      if (!o)\n        throw new Error(\"editingState is undefined\");\n      n.current = !0;\n      const a = (e.orientation === \"addOrRemoveColumns\" ? d.clientX : d.clientY) - o.startPos, u = e.orientation === \"addOrRemoveColumns\" ? ((w = o.originalCroppedContent.rows[0]) == null ? void 0 : w.cells.length) ?? 0 : o.originalCroppedContent.rows.length, m = e.orientation === \"addOrRemoveColumns\" ? ((H = o.originalContent.rows[0]) == null ? void 0 : H.cells.length) ?? 0 : o.originalContent.rows.length, h = e.orientation === \"addOrRemoveColumns\" ? e.block.content.rows[0].cells.length : e.block.content.rows.length, f = m + Er(\n        a / (e.orientation === \"addOrRemoveColumns\" ? _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.EMPTY_CELL_WIDTH : _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.EMPTY_CELL_HEIGHT),\n        0.3\n      );\n      f >= u && f > 0 && f !== h && (e.editor.updateBlock(e.block, {\n        type: \"table\",\n        content: {\n          ...e.block.content,\n          rows: e.orientation === \"addOrRemoveColumns\" ? e.editor.tableHandles.addRowsOrColumns(\n            {\n              type: \"table\",\n              content: o.originalCroppedContent\n            },\n            \"columns\",\n            f - u\n          ) : e.editor.tableHandles.addRowsOrColumns(\n            {\n              type: \"table\",\n              content: o.originalCroppedContent\n            },\n            \"rows\",\n            f - u\n          )\n        }\n      }), e.block.content && e.editor.setTextCursorPosition(e.block));\n    };\n    return o && window.addEventListener(\"mousemove\", s), () => {\n      window.removeEventListener(\"mousemove\", s);\n    };\n  }, [o, e.block, e.editor, e.orientation]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const s = e.onMouseUp, d = () => {\n      r(void 0), s();\n    };\n    return o && window.addEventListener(\"mouseup\", d), () => {\n      window.removeEventListener(\"mouseup\", d);\n    };\n  }, [o, e.onMouseUp]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.TableHandle.ExtendButton,\n    {\n      className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n        \"bn-extend-button\",\n        e.orientation === \"addOrRemoveColumns\" ? \"bn-extend-button-add-remove-columns\" : \"bn-extend-button-add-remove-rows\",\n        o !== null ? \"bn-extend-button-editing\" : \"\"\n      ),\n      onClick: c,\n      onMouseDown: l,\n      children: e.children || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(po, { size: 18, \"data-test\": \"extendButton\" })\n    }\n  );\n}, Je = (e) => {\n  const t = C(), n = M(), r = b().tableHandles;\n  return r ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      onClick: () => {\n        r.addRowOrColumn(\n          e.index,\n          e.orientation === \"row\" ? { orientation: \"row\", side: e.side } : { orientation: \"column\", side: e.side }\n        );\n      },\n      children: n.table_handle[`add_${e.side}_menuitem`]\n    }\n  ) : null;\n}, _r = (e) => {\n  const t = C(), n = M(), r = b().tableHandles;\n  return r ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      onClick: () => {\n        r.removeRowOrColumn(e.index, e.orientation);\n      },\n      children: e.orientation === \"row\" ? n.table_handle.delete_row_menuitem : n.table_handle.delete_column_menuitem\n    }\n  ) : null;\n}, Ir = (e) => {\n  const t = C(), n = M(), o = b(), r = o.tableHandles, l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => !r || !e.block ? [] : e.orientation === \"row\" ? r.getCellsAtRowHandle(e.block, e.index) : r.getCellsAtColumnHandle(e.block, e.index), [e.block, e.index, e.orientation, r]), c = (d, a) => {\n    const u = e.block.content.rows.map((m) => ({\n      ...m,\n      cells: m.cells.map((h) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mapTableCell)(h))\n    }));\n    l.forEach(({ row: m, col: h }) => {\n      a === \"text\" ? u[m].cells[h].props.textColor = d : u[m].cells[h].props.backgroundColor = d;\n    }), o.updateBlock(e.block, {\n      type: \"table\",\n      content: {\n        ...e.block.content,\n        rows: u\n      }\n    }), o.setTextCursorPosition(e.block);\n  };\n  if (!l || !l[0] || !r || o.settings.tables.cellTextColor === !1 && o.settings.tables.cellBackgroundColor === !1)\n    return null;\n  const s = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mapTableCell)(l[0].cell);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Menu.Root, { position: \"right\", sub: !0, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Trigger, { sub: !0, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Menu.Item,\n      {\n        className: \"bn-menu-item\",\n        subTrigger: !0,\n        children: e.children || n.drag_handle.colors_menuitem\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Menu.Dropdown,\n      {\n        sub: !0,\n        className: \"bn-menu-dropdown bn-color-picker-dropdown\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          me,\n          {\n            iconSize: 18,\n            text: o.settings.tables.cellTextColor ? {\n              // All cells have the same text color\n              color: l.every(\n                ({ cell: d }) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.isTableCell)(d) && d.props.textColor === s.props.textColor\n              ) ? s.props.textColor : \"default\",\n              setColor: (d) => {\n                c(d, \"text\");\n              }\n            } : void 0,\n            background: o.settings.tables.cellBackgroundColor ? {\n              color: l.every(\n                ({ cell: d }) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.isTableCell)(d) && d.props.backgroundColor === s.props.backgroundColor\n              ) ? s.props.backgroundColor : \"default\",\n              setColor: (d) => c(d, \"background\")\n            } : void 0\n          }\n        )\n      }\n    )\n  ] });\n}, Nr = (e) => {\n  const t = C(), n = M(), o = b();\n  if (!o.tableHandles || e.index !== 0 || e.orientation !== \"row\" || !o.settings.tables.headers)\n    return null;\n  const l = !!e.block.content.headerRows;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      className: \"bn-menu-item\",\n      checked: l,\n      onClick: () => {\n        const c = o.getBlock(e.block.id);\n        c && o.updateBlock(c, {\n          ...c,\n          content: {\n            ...c.content,\n            headerRows: l ? void 0 : 1\n          }\n        });\n      },\n      children: n.drag_handle.header_row_menuitem\n    }\n  );\n}, Pr = (e) => {\n  const t = C(), n = M(), o = b();\n  if (!o.tableHandles || e.index !== 0 || e.orientation !== \"column\" || !o.settings.tables.headers)\n    return null;\n  const l = !!e.block.content.headerCols;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      className: \"bn-menu-item\",\n      checked: l,\n      onClick: () => {\n        const c = o.getBlock(e.block.id);\n        c && o.updateBlock(c, {\n          ...c,\n          content: {\n            ...c.content,\n            headerCols: l ? void 0 : 1\n          }\n        });\n      },\n      children: n.drag_handle.header_column_menuitem\n    }\n  );\n}, Or = (e) => {\n  const t = C();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Dropdown, { className: \"bn-table-handle-menu\", children: e.children || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      _r,\n      {\n        orientation: e.orientation,\n        block: e.block,\n        index: e.index\n      }\n    ),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      Je,\n      {\n        orientation: e.orientation,\n        block: e.block,\n        index: e.index,\n        side: e.orientation === \"row\" ? \"above\" : \"left\"\n      }\n    ),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      Je,\n      {\n        orientation: e.orientation,\n        block: e.block,\n        index: e.index,\n        side: e.orientation === \"row\" ? \"below\" : \"right\"\n      }\n    ),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      Nr,\n      {\n        orientation: e.orientation,\n        block: e.block,\n        index: e.index\n      }\n    ),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      Pr,\n      {\n        orientation: e.orientation,\n        block: e.block,\n        index: e.index\n      }\n    ),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      Ir,\n      {\n        orientation: e.orientation,\n        block: e.block,\n        index: e.index\n      }\n    )\n  ] }) });\n}, Dr = (e) => {\n  const t = C(), [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), r = e.tableHandleMenu || Or, l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const c = e.editor.tableHandles;\n    return !c || !e.block ? !1 : e.orientation === \"column\" ? c.getCellsAtColumnHandle(e.block, e.index).every(({ cell: s }) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getColspan)(s) === 1) : c.getCellsAtRowHandle(e.block, e.index).every(({ cell: s }) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getRowspan)(s) === 1);\n  }, [e.block, e.editor.tableHandles, e.index, e.orientation]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    t.Generic.Menu.Root,\n    {\n      onOpenChange: (c) => {\n        c ? (e.freezeHandles(), e.hideOtherSide()) : (e.unfreezeHandles(), e.showOtherSide(), e.editor.focus());\n      },\n      position: \"right\",\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          t.TableHandle.Root,\n          {\n            className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n              \"bn-table-handle\",\n              n ? \"bn-table-handle-dragging\" : \"\",\n              l ? \"\" : \"bn-table-handle-not-draggable\"\n            ),\n            draggable: l,\n            onDragStart: (c) => {\n              o(!0), e.dragStart(c);\n            },\n            onDragEnd: () => {\n              e.dragEnd(), o(!1);\n            },\n            style: e.orientation === \"column\" ? { transform: \"rotate(0.25turn)\" } : void 0,\n            children: e.children || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Tt, { size: 24, \"data-test\": \"tableHandle\" })\n          }\n        ) }),\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            r,\n            {\n              orientation: e.orientation,\n              block: e.block,\n              index: e.index\n            }\n          ),\n          e.menuContainer\n        )\n      ]\n    }\n  );\n};\nfunction Qe(e, t, n) {\n  const { refs: o, update: r, context: l, floatingStyles: c } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useFloating)({\n    open: t,\n    placement: e === \"addOrRemoveColumns\" ? \"right\" : \"bottom\",\n    middleware: [\n      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.size)({\n        apply({ rects: a, elements: u }) {\n          Object.assign(\n            u.floating.style,\n            e === \"addOrRemoveColumns\" ? {\n              height: `${a.reference.height}px`\n            } : {\n              width: `${a.reference.width}px`\n            }\n          );\n        }\n      })\n    ]\n  }), { isMounted: s, styles: d } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useTransitionStyles)(l);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    r();\n  }, [n, r]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n !== null && o.setReference({\n      getBoundingClientRect: () => n\n    });\n  }, [e, n, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      isMounted: s,\n      ref: o.setFloating,\n      style: {\n        display: \"flex\",\n        ...d,\n        ...c\n      }\n    }),\n    [c, s, o.setFloating, d]\n  );\n}\nfunction Zr(e, t, n) {\n  const o = Qe(\n    \"addOrRemoveRows\",\n    t,\n    n\n  ), r = Qe(\n    \"addOrRemoveColumns\",\n    e,\n    n\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      addOrRemoveRowsButton: o,\n      addOrRemoveColumnsButton: r\n    }),\n    [r, o]\n  );\n}\nfunction Fr(e, t, n) {\n  return n && n.draggedCellOrientation === \"row\" ? new DOMRect(\n    t.x,\n    n.mousePos,\n    t.width,\n    0\n  ) : new DOMRect(\n    t.x,\n    e.y,\n    t.width,\n    e.height\n  );\n}\nfunction Ar(e, t, n) {\n  return n && n.draggedCellOrientation === \"col\" ? new DOMRect(\n    n.mousePos,\n    t.y,\n    0,\n    t.height\n  ) : new DOMRect(\n    e.x,\n    t.y,\n    e.width,\n    t.height\n  );\n}\nfunction Gr(e) {\n  return new DOMRect(\n    e.x,\n    e.y,\n    e.width,\n    0\n  );\n}\nfunction Ce(e, t, n, o, r) {\n  const { refs: l, update: c, context: s, floatingStyles: d } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useFloating)({\n    open: t,\n    placement: e === \"row\" ? \"left\" : e === \"col\" ? \"top\" : \"bottom-end\",\n    middleware: [\n      (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(\n        e === \"row\" ? -10 : e === \"col\" ? -12 : { mainAxis: 1, crossAxis: -1 }\n      )\n    ]\n  }), { isMounted: a, styles: u } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useTransitionStyles)(s);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c();\n  }, [n, o, c]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n === null || o === null || // Ignore cell handle when dragging\n    r && e === \"cell\" || l.setReference({\n      getBoundingClientRect: () => (e === \"row\" ? Fr : e === \"col\" ? Ar : Gr)(n, o, r)\n    });\n  }, [r, e, n, o, l]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      isMounted: a,\n      ref: l.setFloating,\n      style: {\n        display: \"flex\",\n        ...u,\n        ...d\n      }\n    }),\n    [d, a, l.setFloating, u]\n  );\n}\nfunction Ur(e, t, n, o) {\n  const r = Ce(\n    \"row\",\n    e,\n    t,\n    n,\n    o\n  ), l = Ce(\n    \"col\",\n    e,\n    t,\n    n,\n    o\n  ), c = Ce(\n    \"cell\",\n    e,\n    t,\n    n,\n    o\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      rowHandle: r,\n      colHandle: l,\n      cellHandle: c\n    }),\n    [l, r, c]\n  );\n}\nconst zr = (e) => {\n  var c, s;\n  const t = C(), n = M(), o = b(), r = (d, a) => {\n    const u = e.block.content.rows.map((m) => ({\n      ...m,\n      cells: m.cells.map((h) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mapTableCell)(h))\n    }));\n    a === \"text\" ? u[e.rowIndex].cells[e.colIndex].props.textColor = d : u[e.rowIndex].cells[e.colIndex].props.backgroundColor = d, o.updateBlock(e.block, {\n      type: \"table\",\n      content: {\n        ...e.block.content,\n        rows: u\n      }\n    }), o.setTextCursorPosition(e.block);\n  }, l = (s = (c = e.block.content.rows[e.rowIndex]) == null ? void 0 : c.cells) == null ? void 0 : s[e.colIndex];\n  return !l || o.settings.tables.cellTextColor === !1 && o.settings.tables.cellBackgroundColor === !1 ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(t.Generic.Menu.Root, { position: \"right\", sub: !0, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Trigger, { sub: !0, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Menu.Item,\n      {\n        className: \"bn-menu-item\",\n        subTrigger: !0,\n        children: e.children || n.drag_handle.colors_menuitem\n      }\n    ) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      t.Generic.Menu.Dropdown,\n      {\n        sub: !0,\n        className: \"bn-menu-dropdown bn-color-picker-dropdown\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          me,\n          {\n            iconSize: 18,\n            text: o.settings.tables.cellTextColor ? {\n              color: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.isTableCell)(l) ? l.props.textColor : \"default\",\n              setColor: (d) => r(d, \"text\")\n            } : void 0,\n            background: o.settings.tables.cellBackgroundColor ? {\n              color: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.isTableCell)(l) ? l.props.backgroundColor : \"default\",\n              setColor: (d) => r(d, \"background\")\n            } : void 0\n          }\n        )\n      }\n    )\n  ] });\n}, jr = (e) => {\n  var l, c;\n  const t = C(), n = M(), o = b(), r = (c = (l = e.block.content.rows[e.rowIndex]) == null ? void 0 : l.cells) == null ? void 0 : c[e.colIndex];\n  return !r || !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.isTableCell)(r) || (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getRowspan)(r) === 1 && (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getColspan)(r) === 1 || !o.settings.tables.splitCells ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Item,\n    {\n      onClick: () => {\n        var s;\n        (s = o.tableHandles) == null || s.splitCell({\n          row: e.rowIndex,\n          col: e.colIndex\n        });\n      },\n      children: n.table_handle.split_cell_menuitem\n    }\n  );\n}, Wr = (e) => {\n  const t = C();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    t.Generic.Menu.Dropdown,\n    {\n      className: \"bn-menu-dropdown bn-drag-handle-menu\",\n      children: e.children || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          jr,\n          {\n            block: e.block,\n            rowIndex: e.rowIndex,\n            colIndex: e.colIndex\n          }\n        ),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          zr,\n          {\n            block: e.block,\n            rowIndex: e.rowIndex,\n            colIndex: e.colIndex\n          }\n        )\n      ] })\n    }\n  );\n}, $r = (e) => {\n  const t = C(), n = e.tableCellMenu || Wr;\n  return !e.editor.settings.tables.splitCells && !e.editor.settings.tables.cellBackgroundColor && !e.editor.settings.tables.cellTextColor ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    t.Generic.Menu.Root,\n    {\n      onOpenChange: (o) => {\n        o ? e.freezeHandles() : (e.unfreezeHandles(), e.editor.focus());\n      },\n      position: \"right\",\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Trigger, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(t.Generic.Menu.Button, { className: \"bn-table-cell-handle\", children: e.children || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ur, { size: 12, \"data-test\": \"tableCellHandle\" }) }) }),\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            n,\n            {\n              block: e.block,\n              rowIndex: e.rowIndex,\n              colIndex: e.colIndex\n            }\n          ),\n          e.menuContainer\n        )\n      ]\n    }\n  );\n}, qr = (e) => {\n  var $, E;\n  const t = b(), [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  if (!t.tableHandles)\n    throw new Error(\n      \"TableHandlesController can only be used when BlockNote editor schema contains table block\"\n    );\n  const r = {\n    rowDragStart: t.tableHandles.rowDragStart,\n    colDragStart: t.tableHandles.colDragStart,\n    dragEnd: t.tableHandles.dragEnd,\n    freezeHandles: t.tableHandles.freezeHandles,\n    unfreezeHandles: t.tableHandles.unfreezeHandles\n  }, { freezeHandles: l, unfreezeHandles: c } = r, s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    l(), O(!0), V(!0);\n  }, [l]), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    c(), O(!1), V(!1);\n  }, [c]), a = P(\n    t.tableHandles.onUpdate.bind(t.tableHandles)\n  ), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    var F, ee;\n    return a != null && a.draggingState ? {\n      draggedCellOrientation: (F = a == null ? void 0 : a.draggingState) == null ? void 0 : F.draggedCellOrientation,\n      mousePos: (ee = a == null ? void 0 : a.draggingState) == null ? void 0 : ee.mousePos\n    } : void 0;\n  }, [\n    a == null ? void 0 : a.draggingState,\n    ($ = a == null ? void 0 : a.draggingState) == null ? void 0 : $.draggedCellOrientation,\n    (E = a == null ? void 0 : a.draggingState) == null ? void 0 : E.mousePos\n  ]), { rowHandle: m, colHandle: h, cellHandle: f } = Ur(\n    (a == null ? void 0 : a.show) || !1,\n    (a == null ? void 0 : a.referencePosCell) || null,\n    (a == null ? void 0 : a.referencePosTable) || null,\n    u\n  ), { addOrRemoveColumnsButton: w, addOrRemoveRowsButton: H } = Zr(\n    (a == null ? void 0 : a.showAddOrRemoveColumnsButton) || !1,\n    (a == null ? void 0 : a.showAddOrRemoveRowsButton) || !1,\n    (a == null ? void 0 : a.referencePosTable) || null\n  ), [B, V] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [S, O] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  if (!a)\n    return null;\n  const z = e.tableHandle || Dr, j = e.extendButton || Rr, Z = e.tableCellHandle || $r;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: o }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.FloatingPortal, { root: a.widgetContainer, children: [\n      !B && n && m.isMounted && a.rowIndex !== void 0 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: m.ref, style: m.style, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        z,\n        {\n          editor: t,\n          orientation: \"row\",\n          showOtherSide: () => O(!1),\n          hideOtherSide: () => O(!0),\n          index: a.rowIndex,\n          block: a.block,\n          dragStart: r.rowDragStart,\n          dragEnd: r.dragEnd,\n          freezeHandles: r.freezeHandles,\n          unfreezeHandles: r.unfreezeHandles,\n          menuContainer: n\n        }\n      ) }),\n      !S && n && h.isMounted && a.colIndex !== void 0 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: h.ref, style: h.style, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        z,\n        {\n          editor: t,\n          orientation: \"column\",\n          showOtherSide: () => V(!1),\n          hideOtherSide: () => V(!0),\n          index: a.colIndex,\n          block: a.block,\n          dragStart: r.colDragStart,\n          dragEnd: r.dragEnd,\n          freezeHandles: r.freezeHandles,\n          unfreezeHandles: r.unfreezeHandles,\n          menuContainer: n\n        }\n      ) }),\n      n && f.isMounted && a.colIndex !== void 0 && a.rowIndex !== void 0 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: f.ref, style: f.style, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        Z,\n        {\n          editor: t,\n          block: a.block,\n          rowIndex: a.rowIndex,\n          colIndex: a.colIndex,\n          menuContainer: n,\n          freezeHandles: r.freezeHandles,\n          unfreezeHandles: r.unfreezeHandles\n        }\n      ) }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        \"div\",\n        {\n          ref: H.ref,\n          style: H.style,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            j,\n            {\n              editor: t,\n              orientation: \"addOrRemoveRows\",\n              block: a.block,\n              onMouseDown: s,\n              onMouseUp: d\n            }\n          )\n        }\n      ),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        \"div\",\n        {\n          ref: w.ref,\n          style: w.style,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            j,\n            {\n              editor: t,\n              orientation: \"addOrRemoveColumns\",\n              block: a.block,\n              onMouseDown: s,\n              onMouseUp: d\n            }\n          )\n        }\n      )\n    ] })\n  ] });\n};\nfunction Kr(e) {\n  const t = b();\n  if (!t)\n    throw new Error(\n      \"BlockNoteDefaultUI must be used within a BlockNoteContext.Provider\"\n    );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    e.formattingToolbar !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(or, {}),\n    e.linkToolbar !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ar, {}),\n    e.slashMenu !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Lr, { triggerCharacter: \"/\" }),\n    e.emojiPicker !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      xr,\n      {\n        triggerCharacter: \":\",\n        columns: 10,\n        minQueryLength: 2\n      }\n    ),\n    e.sideMenu !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(kr, {}),\n    t.filePanel && e.filePanel !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(No, {}),\n    t.tableHandles && e.tableHandles !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(qr, {}),\n    t.comments && e.comments !== !1 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(An, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Ro, {})\n    ] })\n  ] });\n}\nconst Xr = () => {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      var c;\n      return (c = window.matchMedia) == null ? void 0 : c.call(window, \"(prefers-color-scheme: dark)\");\n    },\n    []\n  ), t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      var c;\n      return (c = window.matchMedia) == null ? void 0 : c.call(window, \"(prefers-color-scheme: light)\");\n    },\n    []\n  ), n = e == null ? void 0 : e.matches, o = t == null ? void 0 : t.matches, [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(n ? \"dark\" : o ? \"light\" : \"no-preference\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    l(n ? \"dark\" : o ? \"light\" : \"no-preference\");\n  }, [n, o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (typeof (e == null ? void 0 : e.addEventListener) == \"function\") {\n      const c = ({ matches: d }) => d && l(\"dark\"), s = ({ matches: d }) => d && l(\"light\");\n      return e == null || e.addEventListener(\"change\", c), t == null || t.addEventListener(\"change\", s), () => {\n        e == null || e.removeEventListener(\"change\", c), t == null || t.removeEventListener(\"change\", s);\n      };\n    } else {\n      const c = () => l(\n        e.matches ? \"dark\" : t.matches ? \"light\" : \"no-preference\"\n      );\n      return e == null || e.addEventListener(\"change\", c), t == null || t.addEventListener(\"change\", c), () => {\n        e == null || e.removeEventListener(\"change\", c), t == null || t.removeEventListener(\"change\", c);\n      };\n    }\n  }, [e, t]), typeof window.matchMedia != \"function\", r;\n}, Rt = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction Yr() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Rt);\n}\nfunction Jr() {\n  const e = /* @__PURE__ */ new Set();\n  let t = {};\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(n) {\n      return e.add(n), () => {\n        e.delete(n);\n      };\n    },\n    getSnapshot() {\n      return t;\n    },\n    getServerSnapshot() {\n      return t;\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(n, o) {\n      t = {\n        ...t,\n        [n]: (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(o.reactElement, o.element, n)\n      }, e.forEach((r) => r());\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(n) {\n      const o = { ...t };\n      delete o[n], t = o, e.forEach((r) => r());\n    }\n  };\n}\nconst Qr = ({\n  contentComponent: e\n}) => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    e.subscribe,\n    e.getSnapshot,\n    e.getServerSnapshot\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: Object.values(t) });\n}, ei = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(\n    t,\n    () => (r, l) => {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => {\n        o({ node: r, container: l });\n      }), o(void 0);\n    },\n    []\n  ), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: n && (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(n.node, n.container) });\n}), et = () => {\n};\nfunction ti(e, t) {\n  const {\n    editor: n,\n    className: o,\n    theme: r,\n    children: l,\n    editable: c,\n    onSelectionChange: s,\n    onChange: d,\n    formattingToolbar: a,\n    linkToolbar: u,\n    slashMenu: m,\n    emojiPicker: h,\n    sideMenu: f,\n    filePanel: w,\n    tableHandles: H,\n    comments: B,\n    autoFocus: V,\n    renderEditor: S = !n.headless,\n    ...O\n  } = e, [z, j] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), Z = D(), $ = Xr(), E = (Z == null ? void 0 : Z.colorSchemePreference) || $, F = r || (E === \"dark\" ? \"dark\" : \"light\");\n  ue(d || et, n), se(s || et, n), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n.isEditable = c !== !1;\n  }, [c, n]);\n  const ee = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (Dt) => {\n      n.elementRenderer = Dt;\n    },\n    [n]\n  ), Nt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    ...Z,\n    editor: n,\n    setContentEditableProps: j\n  }), [Z, n]), Pt = {\n    formattingToolbar: a,\n    linkToolbar: u,\n    slashMenu: m,\n    emojiPicker: h,\n    sideMenu: f,\n    filePanel: w,\n    tableHandles: H,\n    comments: B\n  }, Ot = {\n    autoFocus: V,\n    contentEditableProps: z\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(dt.Provider, { value: Nt, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    Rt.Provider,\n    {\n      value: {\n        editorProps: Ot,\n        defaultUIProps: Pt\n      },\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ei, { ref: ee }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          ni,\n          {\n            className: o,\n            renderEditor: S,\n            editorColorScheme: F,\n            ref: t,\n            ...O,\n            children: l\n          }\n        )\n      ]\n    }\n  ) });\n}\nconst ni = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ className: e, renderEditor: t, editorColorScheme: n, children: o, ...r }, l) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n  \"div\",\n  {\n    className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\"bn-container\", n, e),\n    \"data-color-scheme\": n,\n    ...r,\n    ref: l,\n    children: t ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(oi, { children: o }) : o\n  }\n)), Fi = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(ti), oi = (e) => {\n  const t = Yr(), n = b(), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => Jr(), []), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (l) => {\n      n.mount(l, o);\n    },\n    [n, o]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Qr, { contentComponent: o }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ri, { ...t.editorProps, ...e, mount: r }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Kr, { ...t.defaultUIProps }),\n    e.children\n  ] });\n}, ri = (e) => {\n  const { autoFocus: t, mount: n, contentEditableProps: o } = e;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"div\",\n    {\n      \"aria-autocomplete\": \"list\",\n      \"aria-haspopup\": \"listbox\",\n      \"data-bn-autofocus\": t,\n      ref: n,\n      ...o\n    }\n  );\n};\nfunction ie(e, t) {\n  let n;\n  const o = document.createElement(\"div\");\n  let r;\n  if (t != null && t.elementRenderer)\n    t.elementRenderer(\n      e((d) => n = d || void 0),\n      o\n    );\n  else {\n    if (!(t != null && t.headless))\n      throw new Error(\n        \"elementRenderer not available, expected headless editor\"\n      );\n    r = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_3__.createRoot)(o), (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => {\n      r.render(e((d) => n = d || void 0));\n    });\n  }\n  if (!o.childElementCount)\n    return console.warn(\"ReactInlineContentSpec: renderHTML() failed\"), {\n      dom: document.createElement(\"span\")\n    };\n  n == null || n.setAttribute(\"data-tmp-find\", \"true\");\n  const l = o.cloneNode(!0), c = l.firstElementChild, s = l.querySelector(\n    \"[data-tmp-find]\"\n  );\n  return s == null || s.removeAttribute(\"data-tmp-find\"), r == null || r.unmount(), {\n    dom: c,\n    contentDOM: s || void 0\n  };\n}\nfunction pe(e) {\n  var t;\n  return (\n    // Creates `blockContent` element\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      _tiptap_react__WEBPACK_IMPORTED_MODULE_7__.NodeViewWrapper,\n      {\n        onDragOver: (n) => n.preventDefault(),\n        ...Object.fromEntries(\n          Object.entries(e.domAttributes || {}).filter(\n            ([n]) => n !== \"class\"\n          )\n        ),\n        className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.mergeCSSClasses)(\n          \"bn-block-content\",\n          ((t = e.domAttributes) == null ? void 0 : t.class) || \"\"\n        ),\n        \"data-content-type\": e.blockType,\n        ...Object.fromEntries(\n          Object.entries(e.blockProps).filter(([n, o]) => {\n            const r = e.propSchema[n];\n            return !_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.inheritedProps.includes(n) && o !== r.default;\n          }).map(([n, o]) => [(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.camelToDataKebab)(n), o])\n        ),\n        \"data-file-block\": e.isFileBlock === !0 || void 0,\n        children: e.children\n      }\n    )\n  );\n}\nfunction he(e, t) {\n  const n = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.createStronglyTypedTiptapNode)({\n    name: e.type,\n    content: e.content === \"inline\" ? \"inline*\" : \"\",\n    group: \"blockContent\",\n    selectable: e.isSelectable ?? !0,\n    isolating: !0,\n    addAttributes() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.propsToAttributes)(e.propSchema);\n    },\n    parseHTML() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getParseRules)(e, t.parse);\n    },\n    renderHTML({ HTMLAttributes: o }) {\n      const r = document.createElement(\"div\");\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.wrapInBlockStructure)(\n        {\n          dom: r,\n          contentDOM: e.content === \"inline\" ? r : void 0\n        },\n        e.type,\n        {},\n        e.propSchema,\n        e.isFileBlock,\n        o\n      );\n    },\n    addNodeView() {\n      return (o) => {\n        const r = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_7__.ReactNodeViewRenderer)(\n          (l) => {\n            var m;\n            const c = this.options.editor, s = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getBlockFromPos)(\n              l.getPos,\n              c,\n              this.editor,\n              e.type\n            ), d = ((m = this.options.domAttributes) == null ? void 0 : m.blockContent) || {}, a = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_7__.useReactNodeView)().nodeViewContentRef;\n            if (!a)\n              throw new Error(\"nodeViewContentRef is not set\");\n            const u = t.render;\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              pe,\n              {\n                blockType: s.type,\n                blockProps: s.props,\n                propSchema: e.propSchema,\n                isFileBlock: e.isFileBlock,\n                domAttributes: d,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                  u,\n                  {\n                    block: s,\n                    editor: c,\n                    contentRef: a\n                  }\n                )\n              }\n            );\n          },\n          {\n            className: \"bn-react-node-view-renderer\"\n          }\n        )(o);\n        return e.isSelectable === !1 && (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.applyNonSelectableBlockFix)(r, this.editor), r;\n      };\n    }\n  });\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.createInternalBlockSpec)(e, {\n    node: n,\n    toInternalHTML: (o, r) => {\n      var d, a;\n      const l = ((d = n.options.domAttributes) == null ? void 0 : d.blockContent) || {}, c = t.render, s = ie(\n        (u) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          pe,\n          {\n            blockType: o.type,\n            blockProps: o.props,\n            propSchema: e.propSchema,\n            domAttributes: l,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              c,\n              {\n                block: o,\n                editor: r,\n                contentRef: u\n              }\n            )\n          }\n        ),\n        r\n      );\n      return (a = s.contentDOM) == null || a.setAttribute(\"data-editable\", \"\"), s;\n    },\n    toExternalHTML: (o, r) => {\n      var d, a;\n      const l = ((d = n.options.domAttributes) == null ? void 0 : d.blockContent) || {}, c = t.toExternalHTML || t.render, s = ie((u) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        pe,\n        {\n          blockType: o.type,\n          blockProps: o.props,\n          propSchema: e.propSchema,\n          domAttributes: l,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            c,\n            {\n              block: o,\n              editor: r,\n              contentRef: u\n            }\n          )\n        }\n      ), r);\n      return (a = s.contentDOM) == null || a.setAttribute(\"data-editable\", \"\"), s;\n    }\n  });\n}\nfunction Ne(e) {\n  const t = b(), [n, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"loading\"), [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  if ((0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let c = !0;\n    return (async () => {\n      let s = \"\";\n      o(\"loading\");\n      try {\n        s = t.resolveFileUrl ? await t.resolveFileUrl(e) : e;\n      } catch {\n        o(\"error\");\n        return;\n      }\n      c && (o(\"loaded\"), l(s));\n    })(), () => {\n      c = !1;\n    };\n  }, [t, e]), n !== \"loaded\")\n    return {\n      loadingState: n\n    };\n  if (!r)\n    throw new Error(\"Finished fetching file but did not get download URL.\");\n  return {\n    loadingState: n,\n    downloadUrl: r\n  };\n}\nconst Pe = (e) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"figure\", { children: [\n  e.children,\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"figcaption\", { children: e.caption })\n] });\nfunction ii(e) {\n  const t = b();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => t.onUploadEnd(e), [e, t]);\n}\nfunction li(e) {\n  const t = b();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => t.onUploadStart(e), [e, t]);\n}\nfunction _t(e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  return li((o) => {\n    o === e && n(!0);\n  }), ii((o) => {\n    o === e && n(!1);\n  }), t;\n}\nconst ci = (e) => {\n  const t = M(), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (r) => {\n      r.preventDefault();\n    },\n    []\n  ), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    e.editor.dispatch(\n      e.editor._tiptapEditor.state.tr.setMeta(\n        e.editor.filePanel.plugin,\n        {\n          block: e.block\n        }\n      )\n    );\n  }, [e.block, e.editor]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n    \"div\",\n    {\n      className: \"bn-add-file-button\",\n      onMouseDown: n,\n      onClick: o,\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-add-file-button-icon\", children: e.buttonIcon || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Re, { size: 24 }) }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-add-file-button-text\", children: e.buttonText || t.file_blocks.file.add_button_text })\n      ]\n    }\n  );\n}, ai = (e) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n  \"div\",\n  {\n    className: \"bn-file-name-with-icon\",\n    contentEditable: !1,\n    draggable: !1,\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-file-icon\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Re, { size: 24 }) }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", { className: \"bn-file-name\", children: e.block.props.name })\n    ]\n  }\n), Oe = (e) => {\n  const t = _t(e.block.id);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"div\",\n    {\n      className: \"bn-file-block-content-wrapper\",\n      onMouseEnter: e.onMouseEnter,\n      onMouseLeave: e.onMouseLeave,\n      style: e.style,\n      children: t ? (\n        // Show loader while a file is being uploaded.\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-file-loading-preview\", children: \"Loading...\" })\n      ) : e.block.props.url === \"\" ? (\n        // Show the add file button if the file has not been uploaded yet.\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ci, { ...e })\n      ) : (\n        // Show the file preview, or the file name and icon.\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n          e.block.props.showPreview === !1 || !e.children ? (\n            // Show file name and icon.\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ai, { ...e })\n          ) : (\n            // Show preview.\n            e.children\n          ),\n          e.block.props.caption && // Show the caption if there is one.\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", { className: \"bn-file-caption\", children: e.block.props.caption })\n        ] })\n      )\n    }\n  );\n}, fe = (e) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { children: [\n  e.children,\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", { children: e.caption })\n] }), si = (e) => {\n  const t = Ne(e.block.props.url);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"audio\",\n    {\n      className: \"bn-audio\",\n      src: t.loadingState === \"loading\" ? e.block.props.url : t.downloadUrl,\n      controls: !0,\n      contentEditable: !1,\n      draggable: !1\n    }\n  );\n}, di = (e) => {\n  if (!e.block.props.url)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", { children: \"Add audio\" });\n  const t = e.block.props.showPreview ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", { src: e.block.props.url }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"a\", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });\n  return e.block.props.caption ? e.block.props.showPreview ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Pe, { caption: e.block.props.caption, children: t }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(fe, { caption: e.block.props.caption, children: t }) : t;\n}, ui = (e) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n  Oe,\n  {\n    ...e,\n    buttonText: e.editor.dictionary.file_blocks.audio.add_button_text,\n    buttonIcon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Mt, { size: 24 }),\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(si, { ...e })\n  }\n), Ai = he(_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.audioBlockConfig, {\n  render: ui,\n  parse: _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.audioParse,\n  toExternalHTML: di\n}), mi = (e) => {\n  if (!e.block.props.url)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", { children: \"Add file\" });\n  const t = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"a\", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });\n  return e.block.props.caption ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(fe, { caption: e.block.props.caption, children: t }) : t;\n}, hi = (e) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Oe, { ...e }), Gi = he(_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.fileBlockConfig, {\n  render: hi,\n  parse: _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.fileParse,\n  toExternalHTML: mi\n}), It = (e) => {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0), [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e.block.props.previewWidth), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const f = (H) => {\n      let B;\n      e.block.props.textAlignment === \"center\" ? t.handleUsed === \"left\" ? B = t.initialWidth + (t.initialClientX - H.clientX) * 2 : B = t.initialWidth + (H.clientX - t.initialClientX) * 2 : t.handleUsed === \"left\" ? B = t.initialWidth + t.initialClientX - H.clientX : B = t.initialWidth + H.clientX - t.initialClientX;\n      const V = 64;\n      B < V ? r(V) : r(B);\n    }, w = () => {\n      n(void 0), e.editor.updateBlock(e.block, {\n        props: {\n          previewWidth: o\n        }\n      });\n    };\n    return t && (window.addEventListener(\"mousemove\", f), window.addEventListener(\"mouseup\", w)), () => {\n      window.removeEventListener(\"mousemove\", f), window.removeEventListener(\"mouseup\", w);\n    };\n  }, [e, t, o]);\n  const d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    e.editor.isEditable && c(!0);\n  }, [e.editor.isEditable]), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    c(!1);\n  }, []), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (f) => {\n      f.preventDefault(), n({\n        handleUsed: \"left\",\n        initialWidth: s.current.clientWidth,\n        initialClientX: f.clientX\n      });\n    },\n    []\n  ), m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (f) => {\n      f.preventDefault(), n({\n        handleUsed: \"right\",\n        initialWidth: s.current.clientWidth,\n        initialClientX: f.clientX\n      });\n    },\n    []\n  ), h = _t(e.block.id);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    Oe,\n    {\n      ...e,\n      onMouseEnter: d,\n      onMouseLeave: a,\n      style: e.block.props.url && !h && e.block.props.showPreview ? { width: `${o}px` } : void 0,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { className: \"bn-visual-media-wrapper\", ref: s, children: [\n        e.children,\n        (l || t) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            \"div\",\n            {\n              className: \"bn-resize-handle\",\n              style: { left: \"4px\" },\n              onMouseDown: u\n            }\n          ),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            \"div\",\n            {\n              className: \"bn-resize-handle\",\n              style: { right: \"4px\" },\n              onMouseDown: m\n            }\n          )\n        ] })\n      ] })\n    }\n  );\n}, fi = (e) => {\n  const t = Ne(e.block.props.url);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"img\",\n    {\n      className: \"bn-visual-media\",\n      src: t.loadingState === \"loading\" ? e.block.props.url : t.downloadUrl,\n      alt: e.block.props.caption || \"BlockNote image\",\n      contentEditable: !1,\n      draggable: !1\n    }\n  );\n}, gi = (e) => {\n  if (!e.block.props.url)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", { children: \"Add image\" });\n  const t = e.block.props.showPreview ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"img\",\n    {\n      src: e.block.props.url,\n      alt: e.block.props.name || e.block.props.caption || \"BlockNote image\",\n      width: e.block.props.previewWidth\n    }\n  ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"a\", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });\n  return e.block.props.caption ? e.block.props.showPreview ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Pe, { caption: e.block.props.caption, children: t }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(fe, { caption: e.block.props.caption, children: t }) : t;\n}, bi = (e) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n  It,\n  {\n    ...e,\n    buttonText: e.editor.dictionary.file_blocks.image.add_button_text,\n    buttonIcon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Ht, { size: 24 }),\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(fi, { ...e })\n  }\n), Ui = he(_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.imageBlockConfig, {\n  render: bi,\n  parse: _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.imageParse,\n  toExternalHTML: gi\n});\nfunction Ci(e) {\n  return p({ attr: { viewBox: \"0 0 24 24\", fill: \"none\", stroke: \"currentColor\", strokeWidth: \"2\", strokeLinecap: \"round\", strokeLinejoin: \"round\" }, child: [{ tag: \"path\", attr: { d: \"M14 3v4a1 1 0 0 0 1 1h4\" }, child: [] }, { tag: \"path\", attr: { d: \"M19 18v1a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-1\" }, child: [] }, { tag: \"path\", attr: { d: \"M3 14h3m4.5 0h3m4.5 0h3\" }, child: [] }, { tag: \"path\", attr: { d: \"M5 10v-5a2 2 0 0 1 2 -2h7l5 5v2\" }, child: [] }] })(e);\n}\nconst pi = {\n  page_break: Ci\n};\nfunction zi(e) {\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getPageBreakSlashMenuItems)(e).map((t) => {\n    const n = pi[t.key];\n    return {\n      ...t,\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(n, { size: 18 })\n    };\n  });\n}\nconst ki = (e) => {\n  const t = Ne(e.block.props.url);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"video\",\n    {\n      className: \"bn-visual-media\",\n      src: t.loadingState === \"loading\" ? e.block.props.url : t.downloadUrl,\n      controls: !0,\n      contentEditable: !1,\n      draggable: !1\n    }\n  );\n}, wi = (e) => {\n  if (!e.block.props.url)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", { children: \"Add video\" });\n  const t = e.block.props.showPreview ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", { src: e.block.props.url }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"a\", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });\n  return e.block.props.caption ? e.block.props.showPreview ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Pe, { caption: e.block.props.caption, children: t }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(fe, { caption: e.block.props.caption, children: t }) : t;\n}, vi = (e) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n  It,\n  {\n    ...e,\n    buttonText: e.editor.dictionary.file_blocks.video.add_button_text,\n    buttonIcon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Co, { size: 24 }),\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ki, { ...e })\n  }\n), ji = he(_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.videoBlockConfig, {\n  render: vi,\n  parse: _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.videoParse,\n  toExternalHTML: wi\n}), Wi = (e) => {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"none\"), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), r = b(), l = P(\n    r.formattingToolbar.onUpdate.bind(r.formattingToolbar)\n  ), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    display: \"flex\",\n    position: \"fixed\",\n    bottom: 0,\n    zIndex: 3e3,\n    transform: t\n  }), [t]);\n  if ((0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const d = window.visualViewport;\n    function a() {\n      const u = document.body, m = d.offsetLeft, h = d.height - u.getBoundingClientRect().height + d.offsetTop;\n      n(\n        `translate(${m}px, ${h}px) scale(${1 / d.scale})`\n      );\n    }\n    return window.visualViewport.addEventListener(\"scroll\", a), window.visualViewport.addEventListener(\"resize\", a), a(), () => {\n      window.visualViewport.removeEventListener(\"scroll\", a), window.visualViewport.removeEventListener(\"resize\", a);\n    };\n  }, []), !l)\n    return null;\n  if (!l.show && o.current)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"div\",\n      {\n        ref: o,\n        style: c,\n        dangerouslySetInnerHTML: { __html: o.current.innerHTML }\n      }\n    );\n  const s = e.formattingToolbar || St;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: o, style: c, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(s, {}) });\n}, Hi = react__WEBPACK_IMPORTED_MODULE_0__.memo(\n  ({\n    thread: e,\n    selectedThreadId: t,\n    editor: n,\n    maxCommentsBeforeCollapse: o,\n    referenceText: r\n  }) => {\n    const l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (s) => {\n        var d;\n        s.target.closest(\".bn-action-toolbar\") || (d = n.comments) == null || d.selectThread(e.id);\n      },\n      [n.comments, e.id]\n    ), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (s) => {\n        var u;\n        if (!s.relatedTarget || s.relatedTarget.closest(\".bn-action-toolbar\"))\n          return;\n        const d = s.target instanceof Node ? s.target : null, a = s.relatedTarget instanceof Node ? s.relatedTarget.closest(\".bn-thread\") : null;\n        (!d || !a || !a.contains(d)) && ((u = n.comments) == null || u.selectThread(void 0));\n      },\n      [n.comments]\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      xt,\n      {\n        thread: e,\n        selected: e.id === t,\n        referenceText: r,\n        maxCommentsBeforeCollapse: o,\n        onFocus: l,\n        onBlur: c,\n        tabIndex: 0\n      }\n    );\n  }\n);\nfunction Mi(e, t, n) {\n  if (t === \"recent-activity\")\n    return e.sort(\n      (o, r) => r.comments[r.comments.length - 1].createdAt.getTime() - o.comments[o.comments.length - 1].createdAt.getTime()\n    );\n  if (t === \"oldest\")\n    return e.sort(\n      (o, r) => o.createdAt.getTime() - r.createdAt.getTime()\n    );\n  if (t === \"position\")\n    return e.sort((o, r) => {\n      var s, d;\n      const l = ((s = n == null ? void 0 : n.get(o.id)) == null ? void 0 : s.from) || Number.MAX_VALUE, c = ((d = n == null ? void 0 : n.get(r.id)) == null ? void 0 : d.from) || Number.MAX_VALUE;\n      return l - c;\n    });\n  throw new _blocknote_core__WEBPACK_IMPORTED_MODULE_5__.UnreachableCaseError(t);\n}\nfunction tt(e, t) {\n  if (!t)\n    return \"Original content deleted\";\n  if (e.prosemirrorState.doc.nodeSize < t.to)\n    return \"\";\n  const n = e.prosemirrorState.doc.textBetween(\n    t.from,\n    t.to\n  );\n  return n.length > 15 ? `${n.slice(0, 15)}…` : n;\n}\nfunction $i(e) {\n  const t = b();\n  if (!t.comments)\n    throw new Error(\"Comments plugin not found\");\n  const n = P(\n    t.comments.onUpdate.bind(t.comments)\n  ), o = n == null ? void 0 : n.selectedThreadId, r = yt(t), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const c = Array.from(r.values()), s = Mi(\n      c,\n      e.sort || \"position\",\n      n == null ? void 0 : n.threadPositions\n    ), d = [];\n    for (const a of s)\n      a.resolved ? (e.filter === \"resolved\" || e.filter === \"all\") && d.push({\n        thread: a,\n        referenceText: tt(\n          t,\n          n == null ? void 0 : n.threadPositions.get(a.id)\n        )\n      }) : (e.filter === \"open\" || e.filter === \"all\") && d.push({\n        thread: a,\n        referenceText: tt(\n          t,\n          n == null ? void 0 : n.threadPositions.get(a.id)\n        )\n      });\n    return d;\n  }, [r, n == null ? void 0 : n.threadPositions, e.filter, e.sort, t]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"bn-threads-sidebar\", children: l.map((c) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    Hi,\n    {\n      thread: c.thread,\n      selectedThreadId: o,\n      editor: t,\n      referenceText: c.referenceText,\n      maxCommentsBeforeCollapse: e.maxCommentsBeforeCollapse\n    },\n    c.thread.id\n  )) });\n}\nfunction qi(e) {\n  const t = D();\n  if (e || (e = t == null ? void 0 : t.editor), !e)\n    throw new Error(\n      \"'editor' is required, either from BlockNoteContext or as a function argument\"\n    );\n  const n = e, [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => n.getActiveStyles());\n  return ue(() => {\n    r(n.getActiveStyles());\n  }, n), se(() => {\n    r(n.getActiveStyles());\n  }, n), o;\n}\nfunction xi() {\n  const [, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  return () => e((t) => t + 1);\n}\nconst Ki = (e) => {\n  const t = xi();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const n = () => {\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          t();\n        });\n      });\n    };\n    return e.on(\"transaction\", n), () => {\n      e.off(\"transaction\", n);\n    };\n  }, [e]);\n};\nfunction yi(e) {\n  return e.currentTarget instanceof HTMLElement && e.relatedTarget instanceof HTMLElement ? e.currentTarget.contains(e.relatedTarget) : !1;\n}\nfunction Xi({\n  onBlur: e,\n  onFocus: t\n} = {}) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [o, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), c = (a) => {\n    r(a), l.current = a;\n  }, s = (a) => {\n    l.current || (c(!0), t == null || t(a));\n  }, d = (a) => {\n    l.current && !yi(a) && (c(!1), e == null || e(a));\n  };\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const a = n.current;\n    if (a)\n      return a.addEventListener(\"focusin\", s), a.addEventListener(\"focusout\", d), () => {\n        a == null || a.removeEventListener(\"focusin\", s), a == null || a.removeEventListener(\"focusout\", d);\n      };\n  }, [s, d]), { ref: n, focused: o };\n}\nfunction Bi(e) {\n  return (\n    // Creates inline content section element\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      _tiptap_react__WEBPACK_IMPORTED_MODULE_7__.NodeViewWrapper,\n      {\n        as: \"span\",\n        className: \"bn-inline-content-section\",\n        \"data-inline-content-type\": e.inlineContentType,\n        ...Object.fromEntries(\n          Object.entries(e.inlineContentProps).filter(([t, n]) => {\n            const o = e.propSchema[t];\n            return n !== o.default;\n          }).map(([t, n]) => [(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.camelToDataKebab)(t), n])\n        ),\n        children: e.children\n      }\n    )\n  );\n}\nfunction Yi(e, t) {\n  const n = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.createStronglyTypedTiptapNode)({\n    name: e.type,\n    inline: !0,\n    group: \"inline\",\n    selectable: e.content === \"styled\",\n    atom: e.content === \"none\",\n    content: e.content === \"styled\" ? \"inline*\" : \"\",\n    addAttributes() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.propsToAttributes)(e.propSchema);\n    },\n    addKeyboardShortcuts() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.addInlineContentKeyboardShortcuts)(e);\n    },\n    parseHTML() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getInlineContentParseRules)(e);\n    },\n    renderHTML({ node: o }) {\n      const r = this.options.editor, l = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.nodeToCustomInlineContent)(\n        o,\n        r.schema.inlineContentSchema,\n        r.schema.styleSchema\n      ), c = t.render, s = ie(\n        (d) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n          c,\n          {\n            inlineContent: l,\n            updateInlineContent: () => {\n            },\n            contentRef: d\n          }\n        ),\n        r\n      );\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.addInlineContentAttributes)(\n        s,\n        e.type,\n        o.attrs,\n        e.propSchema\n      );\n    },\n    // TODO: needed?\n    addNodeView() {\n      const o = this.options.editor;\n      return (r) => (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_7__.ReactNodeViewRenderer)(\n        (l) => {\n          const c = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_7__.useReactNodeView)().nodeViewContentRef;\n          if (!c)\n            throw new Error(\"nodeViewContentRef is not set\");\n          const s = t.render;\n          return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n            Bi,\n            {\n              inlineContentProps: l.node.attrs,\n              inlineContentType: e.type,\n              propSchema: e.propSchema,\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n                s,\n                {\n                  contentRef: c,\n                  inlineContent: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.nodeToCustomInlineContent)(\n                    l.node,\n                    o.schema.inlineContentSchema,\n                    o.schema.styleSchema\n                  ),\n                  updateInlineContent: (d) => {\n                    const a = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.inlineContentToNodes)(\n                      [d],\n                      o._tiptapEditor.schema,\n                      o.schema.styleSchema\n                    );\n                    o.dispatch(\n                      o.prosemirrorView.state.tr.replaceWith(\n                        l.getPos(),\n                        l.getPos() + l.node.nodeSize,\n                        a\n                      )\n                    );\n                  }\n                }\n              )\n            }\n          );\n        },\n        {\n          className: \"bn-ic-react-node-view-renderer\",\n          as: \"span\"\n          // contentDOMElementTag: \"span\", (requires tt upgrade)\n        }\n      )(r);\n    }\n  });\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.createInternalInlineContentSpec)(e, {\n    node: n\n  });\n}\nvar Y, He;\nclass Vi {\n  constructor({\n    mark: t,\n    view: n,\n    inline: o,\n    options: r,\n    editor: l\n    // BlockNote specific\n  }) {\n    Ze(this, Y);\n    L(this, \"dom\");\n    L(this, \"contentDOM\");\n    L(this, \"mark\");\n    L(this, \"view\");\n    L(this, \"inline\");\n    L(this, \"options\");\n    L(this, \"editor\");\n    L(this, \"shouldIgnoreMutation\", (t) => !this.dom || !this.contentDOM ? !0 : t.type === \"selection\" ? !1 : this.contentDOM === t.target && t.type === \"attributes\" ? !0 : !this.contentDOM.contains(t.target));\n    L(this, \"ignoreMutation\", (t) => {\n      if (!this.dom || !this.contentDOM) return !0;\n      let n;\n      const o = this.options.ignoreMutation;\n      return o && (n = o(t)), typeof n != \"boolean\" && (n = this.shouldIgnoreMutation(t)), n;\n    });\n    this.mark = t, this.view = n, this.inline = o, this.options = r, this.editor = l, this.dom = this.createDOM(r.as), this.contentDOM = r.contentAs ? this.createContentDOM(r.contentAs) : void 0, this.dom.setAttribute(\"data-mark-view-root\", \"true\"), this.contentDOM && (this.contentDOM.setAttribute(\"data-mark-view-content\", \"true\"), this.contentDOM.style.whiteSpace = \"inherit\");\n  }\n  createDOM(t) {\n    return ge(this, Y, He).call(this, t);\n  }\n  createContentDOM(t) {\n    return ge(this, Y, He).call(this, t);\n  }\n  get component() {\n    return this.options.component;\n  }\n  destroy() {\n    var t, n, o;\n    (n = (t = this.options).destroy) == null || n.call(t), this.dom.remove(), (o = this.contentDOM) == null || o.remove();\n  }\n}\nY = new WeakSet(), He = function(t) {\n  const { inline: n, mark: o } = this;\n  return t == null ? document.createElement(n ? \"span\" : \"div\") : t instanceof HTMLElement ? t : t instanceof Function ? t(o) : document.createElement(t);\n};\nclass Si extends Vi {\n  constructor() {\n    super(...arguments);\n    // implements ReactRenderer<MarkViewContext>\n    // key: string = nanoid();\n    L(this, \"id\", Math.floor(Math.random() * 4294967295).toString());\n    L(this, \"context\", {\n      contentRef: (n) => {\n        n && this.contentDOM && n.firstChild !== this.contentDOM && n.appendChild(this.contentDOM);\n      },\n      view: this.view,\n      mark: this.mark\n    });\n    L(this, \"updateContext\", () => {\n      Object.assign(this.context, {\n        mark: this.mark\n      });\n    });\n    // render = () => {\n    //   const UserComponent = this.component;\n    //   return createPortal(\n    //     <markViewContext.Provider value={this.context}>\n    //       <UserComponent />\n    //     </markViewContext.Provider>,\n    //     this.dom,\n    //     this.key\n    //   );\n    // };\n    L(this, \"render\", () => {\n      this.editor._tiptapEditor.contentComponent.setRenderer(\n        this.id,\n        this.renderer()\n      );\n    });\n    L(this, \"destroy\", () => {\n      super.destroy(), this.editor._tiptapEditor.contentComponent.removeRenderer(this.id);\n    });\n    L(this, \"renderer\", () => {\n      const n = this.component, o = {};\n      return this.mark.attrs.stringValue && (o.value = this.mark.attrs.stringValue), {\n        reactElement: (\n          // <markViewContext.Provider value={this.context}>\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(n, { contentRef: this.context.contentRef, ...o })\n        ),\n        element: this.dom\n      };\n    });\n  }\n}\nfunction Ji(e, t) {\n  const n = _tiptap_react__WEBPACK_IMPORTED_MODULE_8__.Mark.create({\n    name: e.type,\n    addAttributes() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.stylePropsToAttributes)(e.propSchema);\n    },\n    parseHTML() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.getStyleParseRules)(e);\n    },\n    renderHTML({ mark: o }) {\n      const r = {};\n      e.propSchema === \"string\" && (r.value = o.attrs.stringValue);\n      const l = t.render, c = ie(\n        (s) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(l, { ...r, contentRef: s }),\n        this.options.editor\n      );\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.addStyleAttributes)(\n        c,\n        e.type,\n        o.attrs.stringValue,\n        e.propSchema\n      );\n    }\n  });\n  return n.config.addMarkView = (o) => (r, l) => {\n    const c = new Si({\n      editor: o,\n      inline: !0,\n      mark: r,\n      options: {\n        component: t.render,\n        contentAs: \"span\"\n      },\n      view: l\n    });\n    return c.render(), c;\n  }, (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_5__.createInternalStyleSpec)(e, {\n    mark: n\n  });\n}\nfunction Qi(e, t) {\n  const n = e.getBoundingClientRect(), o = t.getBoundingClientRect(), r = n.top < o.top, l = n.bottom > o.bottom;\n  return r && l ? \"both\" : r ? \"top\" : l ? \"bottom\" : \"none\";\n}\n\n//# sourceMappingURL=blocknote-react.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmxvY2tub3RlL3JlYWN0L2Rpc3QvYmxvY2tub3RlLXJlYWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ0E7QUFDQTtBQUM2TztBQUN0SztBQUMySDtBQUN1ekM7QUFDejdDO0FBQ3VEO0FBQ25FO0FBQ3BELFdBQVcsb0RBQUU7QUFDYjtBQUNBLFNBQVMsaURBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdEQUFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUM7QUFDbEI7QUFDQTtBQUNBLEdBQUcsT0FBTyxrREFBQztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixnREFBQztBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxvREFBb0QsRUFBRSwrREFBRTtBQUNsRTtBQUNBO0FBQ0EsR0FBRyxLQUFLLDBCQUEwQixFQUFFLHVFQUFFLFNBQVMsOERBQUUsT0FBTyw0Q0FBNEMsRUFBRSxtRUFBRTtBQUN4RyxTQUFTLGdEQUFDO0FBQ1Y7QUFDQSxHQUFHLFdBQVcsZ0RBQUM7QUFDZjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsV0FBVyw4Q0FBQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0QsMEJBQTBCLHNEQUFDLE1BQU0sMkNBQTJDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFFO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsdUVBQUU7QUFDZixLQUFLO0FBQ0w7QUFDQSxhQUFhLG1FQUFFO0FBQ2YsS0FBSztBQUNMLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBQyxNQUFNLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0EsYUFBYSxtRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxFQUFFLHdFQUFFO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTRIRTtBQUNGIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQGJsb2Nrbm90ZVxccmVhY3RcXGRpc3RcXGJsb2Nrbm90ZS1yZWFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgWnQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgRGUgPSAoZSkgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IoZSk7XG59O1xudmFyIEZ0ID0gKGUsIHQsIG4pID0+IHQgaW4gZSA/IFp0KGUsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IG4gfSkgOiBlW3RdID0gbjtcbnZhciBMID0gKGUsIHQsIG4pID0+IEZ0KGUsIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIG4pLCBBdCA9IChlLCB0LCBuKSA9PiB0LmhhcyhlKSB8fCBEZShcIkNhbm5vdCBcIiArIG4pO1xudmFyIFplID0gKGUsIHQsIG4pID0+IHQuaGFzKGUpID8gRGUoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogdCBpbnN0YW5jZW9mIFdlYWtTZXQgPyB0LmFkZChlKSA6IHQuc2V0KGUsIG4pO1xudmFyIGdlID0gKGUsIHQsIG4pID0+IChBdChlLCB0LCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgbik7XG5pbXBvcnQgTiwgeyBjcmVhdGVDb250ZXh0IGFzIE1lLCB1c2VDb250ZXh0IGFzIHhlLCB1c2VFZmZlY3QgYXMgeSwgdXNlU3RhdGUgYXMgaywgdXNlQ2FsbGJhY2sgYXMgZywgdXNlTWVtbyBhcyB4LCB1c2VSZWYgYXMgXywgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgeWUsIHVzZUxheW91dEVmZmVjdCBhcyBHdCwgZm9yd2FyZFJlZiBhcyBVdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB6dCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4cyBhcyB2LCBGcmFnbWVudCBhcyBULCBqc3ggYXMgaSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlRmxvYXRpbmcgYXMgQmUsIHVzZVRyYW5zaXRpb25TdHlsZXMgYXMgVmUsIHVzZURpc21pc3MgYXMganQsIHVzZUludGVyYWN0aW9ucyBhcyBXdCwgb2Zmc2V0IGFzIEEsIHNoaWZ0IGFzIGxlLCBmbGlwIGFzIFcsIHNpemUgYXMgU2UsIEZsb2F0aW5nUG9ydGFsIGFzICR0IH0gZnJvbSBcIkBmbG9hdGluZy11aS9yZWFjdFwiO1xuaW1wb3J0IHsgQmxvY2tOb3RlRWRpdG9yIGFzIHF0LCBCbG9ja05vdGVTY2hlbWEgYXMgS3QsIGRlZmF1bHRTdHlsZVNwZWNzIGFzIFh0LCBjcmVhdGVCbG9ja1NwZWNGcm9tU3Ryb25nbHlUeXBlZFRpcHRhcE5vZGUgYXMgWXQsIGNyZWF0ZVN0cm9uZ2x5VHlwZWRUaXB0YXBOb2RlIGFzIFRlLCBkZWZhdWx0QmxvY2tTcGVjcyBhcyBKdCwgbWVyZ2VDU1NDbGFzc2VzIGFzIEksIGZpbGVuYW1lRnJvbVVSTCBhcyBGZSwgZm9ybWF0S2V5Ym9hcmRTaG9ydGN1dCBhcyBjZSwgVkFMSURfTElOS19QUk9UT0NPTFMgYXMgUXQsIERFRkFVTFRfTElOS19QUk9UT0NPTCBhcyBlbiwgaXNUYWJsZUNlbGxTZWxlY3Rpb24gYXMgdG4sIGNoZWNrQmxvY2tJc0ZpbGVCbG9jayBhcyBKLCBjaGVja0Jsb2NrSXNGaWxlQmxvY2tXaXRoUGxhY2Vob2xkZXIgYXMgUSwgY2hlY2tCbG9ja0lzRmlsZUJsb2NrV2l0aFByZXZpZXcgYXMgbm4sIGNoZWNrQmxvY2tIYXNEZWZhdWx0UHJvcCBhcyBrZSwgbWFwVGFibGVDZWxsIGFzIEssIGNoZWNrQmxvY2tUeXBlSGFzRGVmYXVsdFByb3AgYXMgcSwgZ2V0RGVmYXVsdEVtb2ppUGlja2VySXRlbXMgYXMgb24sIGdldERlZmF1bHRTbGFzaE1lbnVJdGVtcyBhcyBybiwgZmlsdGVyU3VnZ2VzdGlvbkl0ZW1zIGFzIGxuLCBFTVBUWV9DRUxMX1dJRFRIIGFzIGNuLCBFTVBUWV9DRUxMX0hFSUdIVCBhcyBhbiwgaXNUYWJsZUNlbGwgYXMgWCwgZ2V0Q29sc3BhbiBhcyBudCwgZ2V0Um93c3BhbiBhcyBvdCwgZ2V0QmxvY2tGcm9tUG9zIGFzIHNuLCBhcHBseU5vblNlbGVjdGFibGVCbG9ja0ZpeCBhcyBkbiwgd3JhcEluQmxvY2tTdHJ1Y3R1cmUgYXMgdW4sIGdldFBhcnNlUnVsZXMgYXMgbW4sIHByb3BzVG9BdHRyaWJ1dGVzIGFzIHJ0LCBjcmVhdGVJbnRlcm5hbEJsb2NrU3BlYyBhcyBobiwgaW5oZXJpdGVkUHJvcHMgYXMgZm4sIGNhbWVsVG9EYXRhS2ViYWIgYXMgaXQsIGF1ZGlvUGFyc2UgYXMgZ24sIGF1ZGlvQmxvY2tDb25maWcgYXMgYm4sIGZpbGVQYXJzZSBhcyBDbiwgZmlsZUJsb2NrQ29uZmlnIGFzIHBuLCBpbWFnZVBhcnNlIGFzIGtuLCBpbWFnZUJsb2NrQ29uZmlnIGFzIHduLCBnZXRQYWdlQnJlYWtTbGFzaE1lbnVJdGVtcyBhcyB2biwgdmlkZW9QYXJzZSBhcyBIbiwgdmlkZW9CbG9ja0NvbmZpZyBhcyBNbiwgVW5yZWFjaGFibGVDYXNlRXJyb3IgYXMgeG4sIG5vZGVUb0N1c3RvbUlubGluZUNvbnRlbnQgYXMgQWUsIGlubGluZUNvbnRlbnRUb05vZGVzIGFzIHluLCBhZGRJbmxpbmVDb250ZW50QXR0cmlidXRlcyBhcyBCbiwgZ2V0SW5saW5lQ29udGVudFBhcnNlUnVsZXMgYXMgVm4sIGFkZElubGluZUNvbnRlbnRLZXlib2FyZFNob3J0Y3V0cyBhcyBTbiwgY3JlYXRlSW50ZXJuYWxJbmxpbmVDb250ZW50U3BlYyBhcyBUbiwgYWRkU3R5bGVBdHRyaWJ1dGVzIGFzIExuLCBnZXRTdHlsZVBhcnNlUnVsZXMgYXMgRW4sIHN0eWxlUHJvcHNUb0F0dHJpYnV0ZXMgYXMgUm4sIGNyZWF0ZUludGVybmFsU3R5bGVTcGVjIGFzIF9uIH0gZnJvbSBcIkBibG9ja25vdGUvY29yZVwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIGFzIGFlLCBmbHVzaFN5bmMgYXMgbHQgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyBSZWFjdE5vZGVWaWV3UmVuZGVyZXIgYXMgY3QsIHVzZVJlYWN0Tm9kZVZpZXcgYXMgYXQsIE5vZGVWaWV3V3JhcHBlciBhcyBzdCwgTWFyayBhcyBJbiB9IGZyb20gXCJAdGlwdGFwL3JlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVSb290IGFzIE5uIH0gZnJvbSBcInJlYWN0LWRvbS9jbGllbnRcIjtcbmNvbnN0IGR0ID0gTWUodm9pZCAwKTtcbmZ1bmN0aW9uIEQoZSkge1xuICByZXR1cm4geGUoZHQpO1xufVxuZnVuY3Rpb24gYihlKSB7XG4gIGNvbnN0IHQgPSBEKCk7XG4gIGlmICghKHQgIT0gbnVsbCAmJiB0LmVkaXRvcikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ1c2VCbG9ja05vdGVFZGl0b3Igd2FzIGNhbGxlZCBvdXRzaWRlIG9mIGEgQmxvY2tOb3RlQ29udGV4dCBwcm92aWRlciBvciBCbG9ja05vdGVWaWV3IGNvbXBvbmVudFwiXG4gICAgKTtcbiAgcmV0dXJuIHQuZWRpdG9yO1xufVxuZnVuY3Rpb24gc2UoZSwgdCwgbikge1xuICBjb25zdCBvID0gRCgpO1xuICB0IHx8ICh0ID0gbyA9PSBudWxsID8gdm9pZCAwIDogby5lZGl0b3IpLCB5KCgpID0+IHtcbiAgICBpZiAoIXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiJ2VkaXRvcicgaXMgcmVxdWlyZWQsIGVpdGhlciBmcm9tIEJsb2NrTm90ZUNvbnRleHQgb3IgYXMgYSBmdW5jdGlvbiBhcmd1bWVudFwiXG4gICAgICApO1xuICAgIHJldHVybiB0Lm9uU2VsZWN0aW9uQ2hhbmdlKGUsIG4pO1xuICB9LCBbZSwgdCwgbl0pO1xufVxuZnVuY3Rpb24gUG4oZSwgdCkge1xuICBjb25zdCBuID0gYigpO1xuICB0ID0gdCB8fCBuO1xuICBjb25zdCBbbywgcl0gPSBrKCgpID0+IHtcbiAgICBpZiAoZSlcbiAgICAgIHJldHVybiB0LmdldFNlbGVjdGlvbkJvdW5kaW5nQm94KCk7XG4gIH0pLCBsID0gZygoKSA9PiB7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGMgPSB0LmdldFNlbGVjdGlvbkJvdW5kaW5nQm94KCk7XG4gICAgcihjKTtcbiAgfSwgW3QsIGVdKTtcbiAgcmV0dXJuIHNlKGwsIHQsICEwKSwgeSgoKSA9PiB7XG4gICAgcihlID8gdC5nZXRTZWxlY3Rpb25Cb3VuZGluZ0JveCgpIDogdm9pZCAwKTtcbiAgfSwgW2UsIHRdKSwgbztcbn1cbmZ1bmN0aW9uIEcoZSwgdCwgbiwgbykge1xuICBjb25zdCB7IHJlZnM6IHIsIHVwZGF0ZTogbCwgY29udGV4dDogYywgZmxvYXRpbmdTdHlsZXM6IHMgfSA9IEJlKHtcbiAgICBvcGVuOiBlLFxuICAgIC4uLm9cbiAgfSksIHsgaXNNb3VudGVkOiBkLCBzdHlsZXM6IGEgfSA9IFZlKGMpLCB1ID0ganQoYyksIHsgZ2V0UmVmZXJlbmNlUHJvcHM6IG0sIGdldEZsb2F0aW5nUHJvcHM6IGggfSA9IFd0KFt1XSk7XG4gIHJldHVybiB5KCgpID0+IHtcbiAgICBsKCk7XG4gIH0sIFt0LCBsXSksIHkoKCkgPT4ge1xuICAgIHQgIT09IG51bGwgJiYgci5zZXRSZWZlcmVuY2Uoe1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiB0XG4gICAgfSk7XG4gIH0sIFt0LCByXSksIHgoKCkgPT4gKHtcbiAgICBpc01vdW50ZWQ6IGQsXG4gICAgcmVmOiByLnNldEZsb2F0aW5nLFxuICAgIHNldFJlZmVyZW5jZTogci5zZXRSZWZlcmVuY2UsXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgLi4uYSxcbiAgICAgIC4uLnMsXG4gICAgICB6SW5kZXg6IG5cbiAgICB9LFxuICAgIGdldEZsb2F0aW5nUHJvcHM6IGgsXG4gICAgZ2V0UmVmZXJlbmNlUHJvcHM6IG1cbiAgfSksIFtcbiAgICBzLFxuICAgIGQsXG4gICAgci5zZXRGbG9hdGluZyxcbiAgICByLnNldFJlZmVyZW5jZSxcbiAgICBhLFxuICAgIG4sXG4gICAgaCxcbiAgICBtXG4gIF0pO1xufVxuZnVuY3Rpb24gUChlKSB7XG4gIGNvbnN0IFt0LCBuXSA9IGsoKTtcbiAgcmV0dXJuIHkoKCkgPT4gZSgobykgPT4ge1xuICAgIG4oeyAuLi5vIH0pO1xuICB9KSwgW2VdKSwgdDtcbn1cbmNvbnN0IE9uID0gTWUoXG4gIHZvaWQgMFxuKTtcbmZ1bmN0aW9uIEMoKSB7XG4gIHJldHVybiB4ZShPbik7XG59XG5jb25zdCBkZSA9IChlID0ge30sIHQgPSBbXSkgPT4geCgoKSA9PiB7XG4gIGNvbnN0IG4gPSBxdC5jcmVhdGUoZSk7XG4gIHJldHVybiB3aW5kb3cgJiYgKHdpbmRvdy5Qcm9zZU1pcnJvciA9IG4uX3RpcHRhcEVkaXRvciksIG47XG59LCB0KSwgT2kgPSBkZTtcbmZ1bmN0aW9uIE0oKSB7XG4gIHJldHVybiBEKCkuZWRpdG9yLmRpY3Rpb25hcnk7XG59XG5mdW5jdGlvbiB1ZShlLCB0KSB7XG4gIGNvbnN0IG4gPSBEKCk7XG4gIHQgfHwgKHQgPSBuID09IG51bGwgPyB2b2lkIDAgOiBuLmVkaXRvciksIHkoKCkgPT4ge1xuICAgIGlmICghdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCInZWRpdG9yJyBpcyByZXF1aXJlZCwgZWl0aGVyIGZyb20gQmxvY2tOb3RlQ29udGV4dCBvciBhcyBhIGZ1bmN0aW9uIGFyZ3VtZW50XCJcbiAgICAgICk7XG4gICAgcmV0dXJuIHQub25DaGFuZ2UoZSk7XG4gIH0sIFtlLCB0XSk7XG59XG5jb25zdCBMZSA9IChlKSA9PiB7XG4gIGNvbnN0IFt0LCBuXSA9IGsoITEpLCBbbywgcl0gPSBrKGUuZWRpdG9yLmlzRW1wdHkpLCBsID0gQygpO1xuICB1ZSgoKSA9PiB7XG4gICAgcihlLmVkaXRvci5pc0VtcHR5KTtcbiAgfSwgZS5lZGl0b3IpO1xuICBjb25zdCBjID0gZygoKSA9PiB7XG4gICAgbighMCk7XG4gIH0sIFtdKSwgcyA9IGcoKCkgPT4ge1xuICAgIG4oITEpO1xuICB9LCBbXSk7XG4gIHJldHVybiB5KCgpID0+IHtcbiAgICBlLmVkaXRhYmxlICYmIGUuYXV0b0ZvY3VzICYmIGUuZWRpdG9yLmZvY3VzKCk7XG4gIH0sIFtlLmF1dG9Gb2N1cywgZS5lZGl0YWJsZSwgZS5lZGl0b3JdKSwgLyogQF9fUFVSRV9fICovIHYoVCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgbC5Db21tZW50cy5FZGl0b3IsXG4gICAgICB7XG4gICAgICAgIGF1dG9Gb2N1czogZS5hdXRvRm9jdXMsXG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1jb21tZW50LWVkaXRvclwiLFxuICAgICAgICBlZGl0b3I6IGUuZWRpdG9yLFxuICAgICAgICBvbkZvY3VzOiBjLFxuICAgICAgICBvbkJsdXI6IHMsXG4gICAgICAgIGVkaXRhYmxlOiBlLmVkaXRhYmxlXG4gICAgICB9XG4gICAgKSxcbiAgICBlLmFjdGlvbnMgJiYgLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYm4tY29tbWVudC1hY3Rpb25zLXdyYXBwZXJcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKGUuYWN0aW9ucywgeyBpc0ZvY3VzZWQ6IHQsIGlzRW1wdHk6IG8gfSkgfSlcbiAgXSB9KTtcbn0sIERuID0gWXQoXG4gIFRlKFxuICAgIEp0LnBhcmFncmFwaC5pbXBsZW1lbnRhdGlvbi5ub2RlLmNvbmZpZ1xuICApLFxuICAvLyBkaXNhYmxlIGRlZmF1bHQgcHJvcHMgb24gcGFyYWdyYXBoIChzdWNoIGFzIHRleHRhbGlnbm1lbnQgYW5kIGNvbG9ycylcbiAge31cbiksIHsgdGV4dENvbG9yOiBEaSwgYmFja2dyb3VuZENvbG9yOiBaaSwgLi4uWm4gfSA9IFh0LCBFZSA9IEt0LmNyZWF0ZSh7XG4gIGJsb2NrU3BlY3M6IHtcbiAgICBwYXJhZ3JhcGg6IERuXG4gIH0sXG4gIHN0eWxlU3BlY3M6IFpuXG59KTtcbmZ1bmN0aW9uIEZuKCkge1xuICBjb25zdCBlID0gYigpO1xuICBpZiAoIWUuY29tbWVudHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudHMgcGx1Z2luIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgdCA9IGUuY29tbWVudHMsIG4gPSBDKCksIG8gPSBNKCksIHIgPSBkZSh7XG4gICAgdHJhaWxpbmdCbG9jazogITEsXG4gICAgZGljdGlvbmFyeToge1xuICAgICAgLi4ubyxcbiAgICAgIHBsYWNlaG9sZGVyczoge1xuICAgICAgICBlbXB0eURvY3VtZW50OiBvLnBsYWNlaG9sZGVycy5uZXdfY29tbWVudFxuICAgICAgfVxuICAgIH0sXG4gICAgc2NoZW1hOiBFZSxcbiAgICBzaWRlTWVudURldGVjdGlvbjogXCJlZGl0b3JcIlxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKG4uQ29tbWVudHMuQ2FyZCwgeyBjbGFzc05hbWU6IFwiYm4tdGhyZWFkXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICBMZSxcbiAgICB7XG4gICAgICBhdXRvRm9jdXM6ICEwLFxuICAgICAgZWRpdGFibGU6ICEwLFxuICAgICAgZWRpdG9yOiByLFxuICAgICAgYWN0aW9uczogKHsgaXNFbXB0eTogbCB9KSA9PiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgbi5HZW5lcmljLlRvb2xiYXIuUm9vdCxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogSShcbiAgICAgICAgICAgIFwiYm4tYWN0aW9uLXRvb2xiYXJcIixcbiAgICAgICAgICAgIFwiYm4tY29tbWVudC1hY3Rpb25zXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHZhcmlhbnQ6IFwiYWN0aW9uLXRvb2xiYXJcIixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgICBuLkdlbmVyaWMuVG9vbGJhci5CdXR0b24sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJibi1idXR0b25cIixcbiAgICAgICAgICAgICAgbWFpblRvb2x0aXA6IFwiU2F2ZVwiLFxuICAgICAgICAgICAgICB2YXJpYW50OiBcImNvbXBhY3RcIixcbiAgICAgICAgICAgICAgaXNEaXNhYmxlZDogbCxcbiAgICAgICAgICAgICAgb25DbGljazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHQuY3JlYXRlVGhyZWFkKHtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxDb21tZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHIuZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgdC5zdG9wUGVuZGluZ0NvbW1lbnQoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiU2F2ZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICApIH0pO1xufVxuY29uc3QgQW4gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gYigpO1xuICBpZiAoIXQuY29tbWVudHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJGbG9hdGluZ0NvbXBvc2VyQ29udHJvbGxlciBjYW4gb25seSBiZSB1c2VkIHdoZW4gQmxvY2tOb3RlIGVkaXRvciBoYXMgZW5hYmxlZCBjb21tZW50c1wiXG4gICAgKTtcbiAgY29uc3QgbiA9IHQuY29tbWVudHM7XG4gIHkoKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBuLm9uVXBkYXRlKFxuICAgICAgKG0pID0+IHQuc2V0Rm9yY2VTZWxlY3Rpb25WaXNpYmxlKG0ucGVuZGluZ0NvbW1lbnQpXG4gICAgKTtcbiAgICByZXR1cm4gKCkgPT4gdSgpO1xuICB9LCBbbiwgdF0pO1xuICBjb25zdCBvID0gUChuLm9uVXBkYXRlLmJpbmQobikpLCByID0gUG4obyA9PSBudWxsID8gdm9pZCAwIDogby5wZW5kaW5nQ29tbWVudCksIHsgaXNNb3VudGVkOiBsLCByZWY6IGMsIHN0eWxlOiBzLCBnZXRGbG9hdGluZ1Byb3BzOiBkIH0gPSBHKFxuICAgIChvID09IG51bGwgPyB2b2lkIDAgOiBvLnBlbmRpbmdDb21tZW50KSB8fCAhMSxcbiAgICByIHx8IG51bGwsXG4gICAgNWUzLFxuICAgIHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICAgIG1pZGRsZXdhcmU6IFtBKDEwKSwgbGUoKSwgVygpXSxcbiAgICAgIG9uT3BlbkNoYW5nZTogKHUpID0+IHtcbiAgICAgICAgdSB8fCAobi5zdG9wUGVuZGluZ0NvbW1lbnQoKSwgdC5mb2N1cygpKTtcbiAgICAgIH0sXG4gICAgICAuLi5lLmZsb2F0aW5nT3B0aW9uc1xuICAgIH1cbiAgKTtcbiAgaWYgKCFsIHx8ICFvKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBhID0gZS5mbG9hdGluZ0NvbXBvc2VyIHx8IEZuO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyByZWY6IGMsIHN0eWxlOiBzLCAuLi5kKCksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShhLCB7fSkgfSk7XG59O1xudmFyIHV0ID0ge1xuICBjb2xvcjogdm9pZCAwLFxuICBzaXplOiB2b2lkIDAsXG4gIGNsYXNzTmFtZTogdm9pZCAwLFxuICBzdHlsZTogdm9pZCAwLFxuICBhdHRyOiB2b2lkIDBcbn0sIEdlID0gTi5jcmVhdGVDb250ZXh0ICYmIC8qIEBfX1BVUkVfXyAqLyBOLmNyZWF0ZUNvbnRleHQodXQpLCBHbiA9IFtcImF0dHJcIiwgXCJzaXplXCIsIFwidGl0bGVcIl07XG5mdW5jdGlvbiBVbihlLCB0KSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIG4gPSB6bihlLCB0KSwgbywgcjtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChyID0gMDsgciA8IGwubGVuZ3RoOyByKyspXG4gICAgICBvID0gbFtyXSwgISh0LmluZGV4T2YobykgPj0gMCkgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChuW29dID0gZVtvXSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB6bihlLCB0KSB7XG4gIGlmIChlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIG4gPSB7fTtcbiAgZm9yICh2YXIgbyBpbiBlKVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgbykpIHtcbiAgICAgIGlmICh0LmluZGV4T2YobykgPj0gMCkgY29udGludWU7XG4gICAgICBuW29dID0gZVtvXTtcbiAgICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gb2UoKSB7XG4gIHJldHVybiBvZSA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciBvIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBvKSAmJiAoZVtvXSA9IG5bb10pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgb2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIFVlKGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCBuLnB1c2guYXBwbHkobiwgbyk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiByZShlKSB7XG4gIGZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbdF0gIT0gbnVsbCA/IGFyZ3VtZW50c1t0XSA6IHt9O1xuICAgIHQgJSAyID8gVWUoT2JqZWN0KG4pLCAhMCkuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICBqbihlLCBvLCBuW29dKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpIDogVWUoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBvLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIG8pKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGpuKGUsIHQsIG4pIHtcbiAgcmV0dXJuIHQgPSBXbih0KSwgdCBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHsgdmFsdWU6IG4sIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3RdID0gbiwgZTtcbn1cbmZ1bmN0aW9uIFduKGUpIHtcbiAgdmFyIHQgPSAkbihlLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3ltYm9sXCIgPyB0IDogdCArIFwiXCI7XG59XG5mdW5jdGlvbiAkbihlLCB0KSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcIm9iamVjdFwiIHx8ICFlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICB2YXIgbyA9IG4uY2FsbChlLCB0KTtcbiAgICBpZiAodHlwZW9mIG8gIT0gXCJvYmplY3RcIikgcmV0dXJuIG87XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoZSk7XG59XG5mdW5jdGlvbiBtdChlKSB7XG4gIHJldHVybiBlICYmIGUubWFwKCh0LCBuKSA9PiAvKiBAX19QVVJFX18gKi8gTi5jcmVhdGVFbGVtZW50KHQudGFnLCByZSh7XG4gICAga2V5OiBuXG4gIH0sIHQuYXR0ciksIG10KHQuY2hpbGQpKSk7XG59XG5mdW5jdGlvbiBwKGUpIHtcbiAgcmV0dXJuICh0KSA9PiAvKiBAX19QVVJFX18gKi8gTi5jcmVhdGVFbGVtZW50KHFuLCBvZSh7XG4gICAgYXR0cjogcmUoe30sIGUuYXR0cilcbiAgfSwgdCksIG10KGUuY2hpbGQpKTtcbn1cbmZ1bmN0aW9uIHFuKGUpIHtcbiAgdmFyIHQgPSAobikgPT4ge1xuICAgIHZhciB7XG4gICAgICBhdHRyOiBvLFxuICAgICAgc2l6ZTogcixcbiAgICAgIHRpdGxlOiBsXG4gICAgfSA9IGUsIGMgPSBVbihlLCBHbiksIHMgPSByIHx8IG4uc2l6ZSB8fCBcIjFlbVwiLCBkO1xuICAgIHJldHVybiBuLmNsYXNzTmFtZSAmJiAoZCA9IG4uY2xhc3NOYW1lKSwgZS5jbGFzc05hbWUgJiYgKGQgPSAoZCA/IGQgKyBcIiBcIiA6IFwiXCIpICsgZS5jbGFzc05hbWUpLCAvKiBAX19QVVJFX18gKi8gTi5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIG9lKHtcbiAgICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIwXCJcbiAgICB9LCBuLmF0dHIsIG8sIGMsIHtcbiAgICAgIGNsYXNzTmFtZTogZCxcbiAgICAgIHN0eWxlOiByZShyZSh7XG4gICAgICAgIGNvbG9yOiBlLmNvbG9yIHx8IG4uY29sb3JcbiAgICAgIH0sIG4uc3R5bGUpLCBlLnN0eWxlKSxcbiAgICAgIGhlaWdodDogcyxcbiAgICAgIHdpZHRoOiBzLFxuICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgIH0pLCBsICYmIC8qIEBfX1BVUkVfXyAqLyBOLmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBsKSwgZS5jaGlsZHJlbik7XG4gIH07XG4gIHJldHVybiBHZSAhPT0gdm9pZCAwID8gLyogQF9fUFVSRV9fICovIE4uY3JlYXRlRWxlbWVudChHZS5Db25zdW1lciwgbnVsbCwgKG4pID0+IHQobikpIDogdCh1dCk7XG59XG5mdW5jdGlvbiBLbihlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggN1YxMUwyIDZMOCAxVjVIMTNDMTcuNDE4MyA1IDIxIDguNTgxNzIgMjEgMTNDMjEgMTcuNDE4MyAxNy40MTgzIDIxIDEzIDIxSDRWMTlIMTNDMTYuMzEzNyAxOSAxOSAxNi4zMTM3IDE5IDEzQzE5IDkuNjg2MjkgMTYuMzEzNyA3IDEzIDdIOFpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBodChlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTcuMjkxMTcgMjAuODI0MkwyIDIyTDMuMTc1ODEgMTYuNzA4OEMyLjQyNTQ0IDE1LjMwNTYgMiAxMy43MDI1IDIgMTJDMiA2LjQ3NzE1IDYuNDc3MTUgMiAxMiAyQzE3LjUyMjggMiAyMiA2LjQ3NzE1IDIyIDEyQzIyIDE3LjUyMjggMTcuNTIyOCAyMiAxMiAyMkMxMC4yOTc1IDIyIDguNjk0NCAyMS41NzQ2IDcuMjkxMTcgMjAuODI0MlpNNy41ODA3NSAxOC43MTFMOC4yMzQyOCAxOS4wNjA1QzkuMzgyNDggMTkuNjc0NSAxMC42NjU1IDIwIDEyIDIwQzE2LjQxODMgMjAgMjAgMTYuNDE4MyAyMCAxMkMyMCA3LjU4MTcyIDE2LjQxODMgNCAxMiA0QzcuNTgxNzIgNCA0IDcuNTgxNzIgNCAxMkM0IDEzLjMzNDUgNC4zMjU0OSAxNC42MTc1IDQuOTM5NDkgMTUuNzY1N0w1LjI4ODk2IDE2LjQxOTJMNC42MzQxNiAxOS4zNjU4TDcuNTgwNzUgMTguNzExWlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIFhuKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNNy4yNDI2NCAxNy45OTY3SDNWMTMuNzU0TDE0LjQzNSAyLjMxOUMxNC44MjU2IDEuOTI4NDggMTUuNDU4NyAxLjkyODQ4IDE1Ljg0OTIgMi4zMTlMMTguNjc3NyA1LjE0NzQzQzE5LjA2ODIgNS41Mzc5NSAxOS4wNjgyIDYuMTcxMTIgMTguNjc3NyA2LjU2MTY0TDcuMjQyNjQgMTcuOTk2N1pNMyAxOS45OTY3SDIxVjIxLjk5NjdIM1YxOS45OTY3WlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIFluKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMjMgMTJMMTUuOTI4OSAxOS4wNzExTDE0LjUxNDcgMTcuNjU2OUwyMC4xNzE2IDEyTDE0LjUxNDcgNi4zNDMxN0wxNS45Mjg5IDQuOTI4OTZMMjMgMTJaTTMuODI4NDMgMTJMOS40ODUyOCAxNy42NTY5TDguMDcxMDcgMTkuMDcxMUwxIDEyTDguMDcxMDcgNC45Mjg5Nkw5LjQ4NTI4IDYuMzQzMTdMMy44Mjg0MyAxMlpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBSZShlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgOEw5LjAwMzE5IDJIMTkuOTk3OEMyMC41NTEzIDIgMjEgMi40NTUzMSAyMSAyLjk5MThWMjEuMDA4MkMyMSAyMS41NTYgMjAuNTU1MSAyMiAyMC4wMDY2IDIySDMuOTkzNEMzLjQ0NDc2IDIyIDMgMjEuNTUwMSAzIDIwLjk5MzJWOFpNMTAgNFY5SDVWMjBIMTlWNEgxMFpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBKbihlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgNEgyMVY2SDNWNFpNNSAxOUgxOVYyMUg1VjE5Wk0zIDE0SDIxVjE2SDNWMTRaTTUgOUgxOVYxMUg1VjlaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gUW4oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDRIMjFWNkgzVjRaTTMgMTlIMjFWMjFIM1YxOVpNMyAxNEgyMVYxNkgzVjE0Wk0zIDlIMjFWMTFIM1Y5WlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIGVvKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMyA0SDIxVjZIM1Y0Wk0zIDE5SDE3VjIxSDNWMTlaTTMgMTRIMjFWMTZIM1YxNFpNMyA5SDE3VjExSDNWOVpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiB0byhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgNEgyMVY2SDNWNFpNNyAxOUgyMVYyMUg3VjE5Wk0zIDE0SDIxVjE2SDNWMTRaTTcgOUgyMVYxMUg3VjlaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gbm8oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk04IDExSDEyLjVDMTMuODgwNyAxMSAxNSA5Ljg4MDcxIDE1IDguNUMxNSA3LjExOTI5IDEzLjg4MDcgNiAxMi41IDZIOFYxMVpNMTggMTUuNUMxOCAxNy45ODUzIDE1Ljk4NTMgMjAgMTMuNSAyMEg2VjRIMTIuNUMxNC45ODUzIDQgMTcgNi4wMTQ3MiAxNyA4LjVDMTcgOS43MDQzMSAxNi41MjY5IDEwLjc5ODEgMTUuNzU2NCAxMS42MDU4QzE3LjA5NzkgMTIuMzg0NyAxOCAxMy44MzcgMTggMTUuNVpNOCAxM1YxOEgxMy41QzE0Ljg4MDcgMTggMTYgMTYuODgwNyAxNiAxNS41QzE2IDE0LjExOTMgMTQuODgwNyAxMyAxMy41IDEzSDhaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gb28oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zLjQxNDM2IDUuOTk5OTVMNS43MDcyNiAzLjcwNzA2TDQuMjkzMDQgMi4yOTI4NUwwLjU4NTkzOCA1Ljk5OTk1TDQuMjkzMDQgOS43MDcwNkw1LjcwNzI2IDguMjkyODVMMy40MTQzNiA1Ljk5OTk1Wk05LjU4NTk0IDUuOTk5OTVMNy4yOTMwNCAzLjcwNzA2TDguNzA3MjYgMi4yOTI4NUwxMi40MTQ0IDUuOTk5OTVMOC43MDcyNiA5LjcwNzA2TDcuMjkzMDQgOC4yOTI4NUw5LjU4NTk0IDUuOTk5OTVaTTE0LjAwMDIgMi45OTk5NUgyMS4wMDAyQzIxLjU1MjQgMi45OTk5NSAyMi4wMDAyIDMuNDQ3NjcgMjIuMDAwMiAzLjk5OTk1VjIwQzIyLjAwMDIgMjAuNTUyMiAyMS41NTI0IDIxIDIxLjAwMDIgMjFIMy4wMDAxNUMyLjQ0Nzg3IDIxIDIuMDAwMTUgMjAuNTUyMiAyLjAwMDE1IDIwVjEySDQuMDAwMTVWMTlIMjAuMDAwMlY0Ljk5OTk1SDE0LjAwMDJWMi45OTk5NVpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiB6ZShlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTUuNTUzOTcgMjJIMy4zOTk5TDEwLjk5OTkgM0gxMi45OTk5TDIwLjU5OTkgMjJIMTguNDQ1OEwxNi4wNDU4IDE2SDcuOTUzOTdMNS41NTM5NyAyMlpNOC43NTM5NyAxNEgxNS4yNDU4TDExLjk5OTkgNS44ODUxN0w4Ljc1Mzk3IDE0WlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIGZ0KGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTMgMjBIMTFWMTNINFYyMEgyVjRINFYxMUgxMVY0SDEzVjIwWk0yMS4wMDA1IDhWMjBIMTkuMDAwNUwxOSAxMC4yMDRMMTcgMTAuNzRWOC42N0wxOS41MDA1IDhIMjEuMDAwNVpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBndChlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTQgNFYxMUgxMVY0SDEzVjIwSDExVjEzSDRWMjBIMlY0SDRaTTE4LjUgOEMyMC41NzExIDggMjIuMjUgOS42Nzg5MyAyMi4yNSAxMS43NUMyMi4yNSAxMi42MDc0IDIxLjk2MjMgMTMuMzk3NiAyMS40NzgxIDE0LjAyOTJMMjEuMzMwMiAxNC4yMTAyTDE4LjAzNDMgMThIMjJWMjBIMTVMMTQuOTk5MyAxOC40NDRMMTkuODIwNyAxMi44OTgxQzIwLjA4ODEgMTIuNTkwOCAyMC4yNSAxMi4xODkzIDIwLjI1IDExLjc1QzIwLjI1IDEwLjc4MzUgMTkuNDY2NSAxMCAxOC41IDEwQzE3LjU4MTggMTAgMTYuODI4OCAxMC43MDcxIDE2Ljc1NTggMTEuNjA2NUwxNi43NSAxMS43NUgxNC43NUMxNC43NSA5LjY3ODkzIDE2LjQyODkgOCAxOC41IDhaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gYnQoZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0yMiA4TDIxLjk5ODQgMTBMMTkuNDkzNCAxMi44ODNDMjEuMDgyMyAxMy4zMTg0IDIyLjI1IDE0Ljc3MjggMjIuMjUgMTYuNUMyMi4yNSAxOC41NzExIDIwLjU3MTEgMjAuMjUgMTguNSAyMC4yNUMxNi42NzQgMjAuMjUgMTUuMTUyOCAxOC45NDQ5IDE0LjgxODQgMTcuMjE2NkwxNi43ODIxIDE2LjgzNTJDMTYuOTM4NCAxNy42NDEzIDE3LjY0ODEgMTguMjUgMTguNSAxOC4yNUMxOS40NjY1IDE4LjI1IDIwLjI1IDE3LjQ2NjUgMjAuMjUgMTYuNUMyMC4yNSAxNS41MzM1IDE5LjQ2NjUgMTQuNzUgMTguNSAxNC43NUMxOC4yMTQgMTQuNzUgMTcuOTQ0IDE0LjgxODYgMTcuNzA1NiAxNC45NDAzTDE2LjM5OTIgMTMuMzkzMkwxOS4zNDg0IDEwSDE1VjhIMjJaTTQgNFYxMUgxMVY0SDEzVjIwSDExVjEzSDRWMjBIMlY0SDRaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gcm8oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDRIMjFWNkgzVjRaTTMgMTlIMjFWMjFIM1YxOVpNMTEgMTRIMjFWMTZIMTFWMTRaTTExIDlIMjFWMTFIMTFWOVpNMyAxMi41TDcgOVYxNkwzIDEyLjVaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gaW8oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDRIMjFWNkgzVjRaTTMgMTlIMjFWMjFIM1YxOVpNMTEgMTRIMjFWMTZIMTFWMTRaTTExIDlIMjFWMTFIMTFWOVpNNyAxMi41TDMgMTZWOUw3IDEyLjVaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gamUoZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk04IDVIMTFWMTlIOFYyMUgxNlYxOUgxM1Y1SDE2VjNIOFY1Wk0yIDdDMS40NDc3MiA3IDEgNy40NDc3MiAxIDhWMTZDMSAxNi41NTIzIDEuNDQ3NzIgMTcgMiAxN0g4VjE1SDNWOUg4VjdIMlpNMTYgOUgyMVYxNUgxNlYxN0gyMkMyMi41NTIzIDE3IDIzIDE2LjU1MjMgMjMgMTZWOEMyMyA3LjQ0NzcyIDIyLjU1MjMgNyAyMiA3SDE2VjlaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gbG8oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xNSAyMEg3VjE4SDkuOTI2NjFMMTIuMDQyNSA2SDlWNEgxN1Y2SDE0LjA3MzRMMTEuOTU3NSAxOEgxNVYyMFpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBjbyhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTE3IDE3SDIyVjE5SDE5VjIySDE3VjE3Wk03IDdIMlY1SDVWMkg3VjdaTTE4LjM2NCAxNS41MzU1TDE2Ljk0OTcgMTQuMTIxM0wxOC4zNjQgMTIuNzA3MUMyMC4zMTY2IDEwLjc1NDUgMjAuMzE2NiA3LjU4ODY2IDE4LjM2NCA1LjYzNjA0QzE2LjQxMTMgMy42ODM0MiAxMy4yNDU1IDMuNjgzNDIgMTEuMjkyOSA1LjYzNjA0TDkuODc4NjggNy4wNTAyNUw4LjQ2NDQ3IDUuNjM2MDRMOS44Nzg2OCA0LjIyMTgzQzEyLjYxMjMgMS40ODgxNiAxNy4wNDQ1IDEuNDg4MTYgMTkuNzc4MiA0LjIyMTgzQzIyLjUxMTggNi45NTU1IDIyLjUxMTggMTEuMzg3NyAxOS43NzgyIDE0LjEyMTNMMTguMzY0IDE1LjUzNTVaTTE1LjUzNTUgMTguMzY0TDE0LjEyMTMgMTkuNzc4MkMxMS4zODc3IDIyLjUxMTggNi45NTU1IDIyLjUxMTggNC4yMjE4MyAxOS43NzgyQzEuNDg4MTYgMTcuMDQ0NSAxLjQ4ODE2IDEyLjYxMjMgNC4yMjE4MyA5Ljg3ODY4TDUuNjM2MDQgOC40NjQ0N0w3LjA1MDI1IDkuODc4NjhMNS42MzYwNCAxMS4yOTI5QzMuNjgzNDIgMTMuMjQ1NSAzLjY4MzQyIDE2LjQxMTMgNS42MzYwNCAxOC4zNjRDNy41ODg2NiAyMC4zMTY2IDEwLjc1NDUgMjAuMzE2NiAxMi43MDcxIDE4LjM2NEwxNC4xMjEzIDE2Ljk0OTdMMTUuNTM1NSAxOC4zNjRaTTE0LjgyODQgNy43NTczNkwxNi4yNDI2IDkuMTcxNTdMOS4xNzE1NyAxNi4yNDI2TDcuNzU3MzYgMTQuODI4NEwxNC44Mjg0IDcuNzU3MzZaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gQ3QoZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xOC4zNjM4IDE1LjUzNTVMMTYuOTQ5NiAxNC4xMjEzTDE4LjM2MzggMTIuNzA3MUMyMC4zMTY0IDEwLjc1NDUgMjAuMzE2NCA3LjU4ODY2IDE4LjM2MzggNS42MzYwNEMxNi40MTEyIDMuNjgzNDEgMTMuMjQ1MyAzLjY4MzQxIDExLjI5MjcgNS42MzYwNEw5Ljg3ODQ5IDcuMDUwMjVMOC40NjQyOCA1LjYzNjA0TDkuODc4NDkgNC4yMjE4MkMxMi42MTIyIDEuNDg4MTUgMTcuMDQ0MyAxLjQ4ODE1IDE5Ljc3OCA0LjIyMTgyQzIyLjUxMTcgNi45NTU0OSAyMi41MTE3IDExLjM4NzYgMTkuNzc4IDE0LjEyMTNMMTguMzYzOCAxNS41MzU1Wk0xNS41MzUzIDE4LjM2NEwxNC4xMjExIDE5Ljc3ODJDMTEuMzg3NSAyMi41MTE4IDYuOTU1MzEgMjIuNTExOCA0LjIyMTY0IDE5Ljc3ODJDMS40ODc5NyAxNy4wNDQ1IDEuNDg3OTcgMTIuNjEyMyA0LjIyMTY0IDkuODc4NjhMNS42MzU4NSA4LjQ2NDQ2TDcuMDUwMDcgOS44Nzg2OEw1LjYzNTg1IDExLjI5MjlDMy42ODMyMyAxMy4yNDU1IDMuNjgzMjMgMTYuNDExMyA1LjYzNTg1IDE4LjM2NEM3LjU4ODQ3IDIwLjMxNjYgMTAuNzU0MyAyMC4zMTY2IDEyLjcwNjkgMTguMzY0TDE0LjEyMTEgMTYuOTQ5N0wxNS41MzUzIDE4LjM2NFpNMTQuODI4MiA3Ljc1NzM2TDE2LjI0MjUgOS4xNzE1N0w5LjE3MTM5IDE2LjI0MjZMNy43NTcxNyAxNC44Mjg0TDE0LjgyODIgNy43NTczNlpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBwdChlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTguMDAwMDggNlY5SDUuMDAwMDhWNkg4LjAwMDA4Wk0zLjAwMDA4IDRWMTFIMTAuMDAwMVY0SDMuMDAwMDhaTTEzLjAwMDEgNEgyMS4wMDAxVjZIMTMuMDAwMVY0Wk0xMy4wMDAxIDExSDIxLjAwMDFWMTNIMTMuMDAwMVYxMVpNMTMuMDAwMSAxOEgyMS4wMDAxVjIwSDEzLjAwMDFWMThaTTEwLjcwNzIgMTYuMjA3MUw5LjI5Mjk3IDE0Ljc5MjlMNi4wMDAwOCAxOC4wODU4TDQuMjA3MTggMTYuMjkyOUwyLjc5Mjk3IDE3LjcwNzFMNi4wMDAwOCAyMC45MTQyTDEwLjcwNzIgMTYuMjA3MVpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBrdChlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggNEgyMVY2SDhWNFpNNSAzVjZINlY3SDNWNkg0VjRIM1YzSDVaTTMgMTRWMTEuNUg1VjExSDNWMTBINlYxMi41SDRWMTNINlYxNEgzWk01IDE5LjVIM1YxOC41SDVWMThIM1YxN0g2VjIxSDNWMjBINVYxOS41Wk04IDExSDIxVjEzSDhWMTFaTTggMThIMjFWMjBIOFYxOFpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiB3dChlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggNEgyMVY2SDhWNFpNNC41IDYuNUMzLjY3MTU3IDYuNSAzIDUuODI4NDMgMyA1QzMgNC4xNzE1NyAzLjY3MTU3IDMuNSA0LjUgMy41QzUuMzI4NDMgMy41IDYgNC4xNzE1NyA2IDVDNiA1LjgyODQzIDUuMzI4NDMgNi41IDQuNSA2LjVaTTQuNSAxMy41QzMuNjcxNTcgMTMuNSAzIDEyLjgyODQgMyAxMkMzIDExLjE3MTYgMy42NzE1NyAxMC41IDQuNSAxMC41QzUuMzI4NDMgMTAuNSA2IDExLjE3MTYgNiAxMkM2IDEyLjgyODQgNS4zMjg0MyAxMy41IDQuNSAxMy41Wk00LjUgMjAuNEMzLjY3MTU3IDIwLjQgMyAxOS43Mjg0IDMgMTguOUMzIDE4LjA3MTYgMy42NzE1NyAxNy40IDQuNSAxNy40QzUuMzI4NDMgMTcuNCA2IDE4LjA3MTYgNiAxOC45QzYgMTkuNzI4NCA1LjMyODQzIDIwLjQgNC41IDIwLjRaTTggMTFIMjFWMTNIOFYxMVpNOCAxOEgyMVYyMEg4VjE4WlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIGFvKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMjAgM0MyMC41NTIzIDMgMjEgMy40NDc3MiAyMSA0VjIwQzIxIDIwLjU1MjMgMjAuNTUyMyAyMSAyMCAyMUg0QzMuNDQ3NzIgMjEgMyAyMC41NTIzIDMgMjBWNEMzIDMuNDQ3NzIgMy40NDc3MiAzIDQgM0gyMFpNMTEgNUg1VjEwLjk5OUg3VjlMMTAgMTJMNyAxNVYxM0g1VjE5SDExVjE3SDEzVjE5SDE5VjEzSDE3VjE1TDE0IDEyTDE3IDlWMTAuOTk5SDE5VjVIMTNWN0gxMVY1Wk0xMyAxM1YxNUgxMVYxM0gxM1pNMTMgOVYxMUgxMVY5SDEzWlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIHNvKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMjEgMjBDMjEgMjAuNTUyMyAyMC41NTIzIDIxIDIwIDIxSDRDMy40NDc3MiAyMSAzIDIwLjU1MjMgMyAyMFY0QzMgMy40NDc3MiAzLjQ0NzcyIDMgNCAzSDIwQzIwLjU1MjMgMyAyMSAzLjQ0NzcyIDIxIDRWMjBaTTE5IDExVjVIMTMuMDAxVjdIMTVMMTIgMTBMOSA3SDExVjVINVYxMUg3VjEzSDVWMTlIMTFWMTdIOUwxMiAxNEwxNSAxN0gxMy4wMDFWMTlIMTlWMTNIMTdWMTFIMTlaTTExIDEzSDlWMTFIMTFWMTNaTTE1IDEzSDEzVjExSDE1VjEzWlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIHZ0KGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMjEgNEgzVjZIMjFWNFpNMjEgMTFIOFYxM0gyMVYxMVpNMjEgMThIOFYyMEgyMVYxOFpNNSAxMUgzVjIwSDVWMTFaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gdW8oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xNy4xNTM4IDE0QzE3LjM4NDYgMTQuNTE2MSAxNy41IDE1LjA4OTMgMTcuNSAxNS43MTk2QzE3LjUgMTcuMDYyNSAxNi45NzYyIDE4LjExMTYgMTUuOTI4NiAxOC44NjdDMTQuODgwOSAxOS42MjIzIDEzLjQzMzUgMjAgMTEuNTg2MiAyMEM5Ljk0Njc0IDIwIDguMzIzMzUgMTkuNjE4NSA2LjcxNTkyIDE4Ljg1NTVWMTYuNjAwOUM4LjIzNTM4IDE3LjQ3ODMgOS43OTA4IDE3LjkxNyAxMS4zODIyIDE3LjkxN0MxMy45MzMzIDE3LjkxNyAxNS4yMTI4IDE3LjE4NDYgMTUuMjIwOCAxNS43MTk2QzE1LjIyMDggMTUuMDkzOSAxNS4wMDQ5IDE0LjU1OTggMTQuNTczMSAxNC4xMTczQzE0LjUzMzkgMTQuMDc3MiAxNC40OTM5IDE0LjAzODEgMTQuNDUzMSAxNEgzVjEySDIxVjE0SDE3LjE1MzhaTTEzLjA3NiAxMUg3LjYyOTA4QzcuNDU2NiAxMC44NDMzIDcuMjk2MTYgMTAuNjY5MiA3LjE0Nzc2IDEwLjQ3NzhDNi43MTU5MiA5LjkyMDg0IDYuNSA5LjI0NTU5IDYuNSA4LjQ1MjA3QzYuNSA3LjIxNjAyIDYuOTY1ODMgNi4xNjUgNy44OTc0OSA1LjI5OUM4LjgyOTE2IDQuNDMyOTkgMTAuMjcwNiA0IDEyLjIyMTkgNEMxMy42OTM0IDQgMTUuMTAwOSA0LjMyODA4IDE2LjQ0NDQgNC45ODQyNlY3LjEzNTkxQzE1LjI0NDggNi40NDkyMSAxMy45MjkzIDYuMTA1ODcgMTIuNDk3OCA2LjEwNTg3QzEwLjAxODcgNi4xMDU4NyA4Ljc3OTE3IDYuODg3OTMgOC43NzkxNyA4LjQ1MjA3QzguNzc5MTcgOC44NzE3MiA4Ljk5NzA5IDkuMjM3OTYgOS40MzI5MyA5LjU1MDc5QzkuODY4NzggOS44NjM2MiAxMC40MDY2IDEwLjExMzUgMTEuMDQ2MyAxMC4zMDA0QzExLjY2NjUgMTAuNDgxNiAxMi4zNDMxIDEwLjcxNDggMTMuMDc2IDExSDEzLjA3NlpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBtbyhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTEzIDEwVjE0SDE5VjEwSDEzWk0xMSAxMEg1VjE0SDExVjEwWk0xMyAxOUgxOVYxNkgxM1YxOVpNMTEgMTlWMTZINVYxOUgxMVpNMTMgNVY4SDE5VjVIMTNaTTExIDVINVY4SDExVjVaTTQgM0gyMEMyMC41NTIzIDMgMjEgMy40NDc3MiAyMSA0VjIwQzIxIDIwLjU1MjMgMjAuNTUyMyAyMSAyMCAyMUg0QzMuNDQ3NzIgMjEgMyAyMC41NTIzIDMgMjBWNEMzIDMuNDQ3NzIgMy40NDc3MiAzIDQgM1pcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBfZShlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTEzIDZWMjFIMTFWNkg1VjRIMTlWNkgxM1pcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBobyhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggM1YxMkM4IDE0LjIwOTEgOS43OTA4NiAxNiAxMiAxNkMxNC4yMDkxIDE2IDE2IDE0LjIwOTEgMTYgMTJWM0gxOFYxMkMxOCAxNS4zMTM3IDE1LjMxMzcgMTggMTIgMThDOC42ODYyOSAxOCA2IDE1LjMxMzcgNiAxMlYzSDhaTTQgMjBIMjBWMjJINFYyMFpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBmbyhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTIgMy45OTM0QzIgMy40NDQ3NiAyLjQ1NTMxIDMgMi45OTE4IDNIMjEuMDA4MkMyMS41NTYgMyAyMiAzLjQ0NDk1IDIyIDMuOTkzNFYyMC4wMDY2QzIyIDIwLjU1NTIgMjEuNTQ0NyAyMSAyMS4wMDgyIDIxSDIuOTkxOEMyLjQ0NDA1IDIxIDIgMjAuNTU1MSAyIDIwLjAwNjZWMy45OTM0Wk04IDVWMTlIMTZWNUg4Wk00IDVWN0g2VjVINFpNMTggNVY3SDIwVjVIMThaTTQgOVYxMUg2VjlINFpNMTggOVYxMUgyMFY5SDE4Wk00IDEzVjE1SDZWMTNINFpNMTggMTNWMTVIMjBWMTNIMThaTTQgMTdWMTlINlYxN0g0Wk0xOCAxN1YxOUgyMFYxN0gxOFpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBIdChlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTUgMTEuMTAwNUw3IDkuMTAwNUwxMi41IDE0LjYwMDVMMTYgMTEuMTAwNUwxOSAxNC4xMDA1VjVINVYxMS4xMDA1Wk00IDNIMjBDMjAuNTUyMyAzIDIxIDMuNDQ3NzIgMjEgNFYyMEMyMSAyMC41NTIzIDIwLjU1MjMgMjEgMjAgMjFINEMzLjQ0NzcyIDIxIDMgMjAuNTUyMyAzIDIwVjRDMyAzLjQ0NzcyIDMuNDQ3NzIgMyA0IDNaTTE1LjUgMTBDMTQuNjcxNiAxMCAxNCA5LjMyODQzIDE0IDguNUMxNCA3LjY3MTU3IDE0LjY3MTYgNyAxNS41IDdDMTYuMzI4NCA3IDE3IDcuNjcxNTcgMTcgOC41QzE3IDkuMzI4NDMgMTYuMzI4NCAxMCAxNS41IDEwWlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIGdvKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMjEgMTVWMThIMjRWMjBIMjFWMjNIMTlWMjBIMTZWMThIMTlWMTVIMjFaTTIxLjAwODIgM0MyMS41NTYgMyAyMiAzLjQ0NDk1IDIyIDMuOTkzNEwyMi4wMDA3IDEzLjM0MTdDMjEuMzc0OSAxMy4xMjA0IDIwLjcwMTUgMTMgMjAgMTNWNUg0TDQuMDAxIDE5TDEzLjI5MjkgOS43MDcxNUMxMy42NTI4IDkuMzQ2MDQgMTQuMjIgOS4zMTgyMyAxNC42MTIzIDkuNjIzMjJMMTQuNzA2NSA5LjcwNzcyTDE4LjI1MjEgMTMuMjU4NkMxNS43OTEgMTQuMDA2OSAxNCAxNi4yOTQzIDE0IDE5QzE0IDE5LjcwMTUgMTQuMTIwNCAyMC4zNzQ5IDE0LjM0MTcgMjEuMDAwN0wyLjk5MTggMjFDMi40NDQwNSAyMSAyIDIwLjU1NTEgMiAyMC4wMDY2VjMuOTkzNEMyIDMuNDQ0NzYgMi40NTUzMSAzIDIuOTkxOCAzSDIxLjAwODJaTTggN0M5LjEwNDU3IDcgMTAgNy44OTU0MyAxMCA5QzEwIDEwLjEwNDYgOS4xMDQ1NyAxMSA4IDExQzYuODk1NDMgMTEgNiAxMC4xMDQ2IDYgOUM2IDcuODk1NDMgNi44OTU0MyA3IDggN1pcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBibyhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTIwIDNDMjAuNTUyMyAzIDIxIDMuNDQ3NzIgMjEgNFY1Ljc1N0wxOSA3Ljc1N1Y1SDVWMTMuMUw5IDkuMTAwNUwxMy4zMjggMTMuNDI5TDEyLjAwMTIgMTQuNzU2MkwxMS45OTUgMTguOTk1TDE2LjI0MTQgMTkuMDAxMkwxNy41NzEgMTcuNjcxTDE4Ljg5OTUgMTlIMTlWMTYuMjQyTDIxIDE0LjI0MlYyMEMyMSAyMC41NTIzIDIwLjU1MjMgMjEgMjAgMjFINEMzLjQ0NzcyIDIxIDMgMjAuNTUyMyAzIDIwVjRDMyAzLjQ0NzcyIDMuNDQ3NzIgMyA0IDNIMjBaTTIxLjc3ODIgNy44MDc2MUwyMy4xOTI0IDkuMjIxODNMMTUuNDE0MiAxN0wxMy45OTc5IDE2Ljk5NzlMMTQgMTUuNTg1OEwyMS43NzgyIDcuODA3NjFaTTE1LjUgN0MxNi4zMjg0IDcgMTcgNy42NzE1NyAxNyA4LjVDMTcgOS4zMjg0MyAxNi4zMjg0IDEwIDE1LjUgMTBDMTQuNjcxNiAxMCAxNCA5LjMyODQzIDE0IDguNUMxNCA3LjY3MTU3IDE0LjY3MTYgNyAxNS41IDdaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gQ28oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDMuOTkzNEMzIDMuNDQ0NzYgMy40NDQ5NSAzIDMuOTkzNCAzSDIwLjAwNjZDMjAuNTU1MiAzIDIxIDMuNDQ0OTUgMjEgMy45OTM0VjIwLjAwNjZDMjEgMjAuNTU1MiAyMC41NTUxIDIxIDIwLjAwNjYgMjFIMy45OTM0QzMuNDQ0NzYgMjEgMyAyMC41NTUxIDMgMjAuMDA2NlYzLjk5MzRaTTEwLjYyMTkgOC40MTQ1OUMxMC41NTYyIDguMzcwNzggMTAuNDc5IDguMzQ3NDEgMTAuNCA4LjM0NzQxQzEwLjE3OTEgOC4zNDc0MSAxMCA4LjUyNjQ5IDEwIDguNzQ3NDFWMTUuMjUyNkMxMCAxNS4zMzE2IDEwLjAyMzQgMTUuNDA4OCAxMC4wNjcyIDE1LjQ3NDVDMTAuMTg5NyAxNS42NTgzIDEwLjQzODEgMTUuNzA4IDEwLjYyMTkgMTUuNTg1NEwxNS41MDA4IDEyLjMzMjhDMTUuNTQ0NyAxMi4zMDM1IDE1LjU4MjQgMTIuMjY1OCAxNS42MTE3IDEyLjIyMTlDMTUuNzM0MyAxMi4wMzgxIDE1LjY4NDYgMTEuNzg5NyAxNS41MDA4IDExLjY2NzJMMTAuNjIxOSA4LjQxNDU5WlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIE10KGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMiAxNi4wMDAxSDUuODg4ODlMMTEuMTgzNCAyMC4zMzE5QzExLjI3MjcgMjAuNDA1IDExLjM4NDYgMjAuNDQ0OSAxMS41IDIwLjQ0NDlDMTEuNzc2MSAyMC40NDQ5IDEyIDIwLjIyMTEgMTIgMTkuOTQ0OVY0LjA1NTE5QzEyIDMuOTM5NzcgMTEuOTYwMSAzLjgyNzkgMTEuODg3IDMuNzM4NTdDMTEuNzEyMSAzLjUyNDg1IDExLjM5NzEgMy40OTMzNSAxMS4xODM0IDMuNjY4MjFMNS44ODg4OSA4LjAwMDA3SDJDMS40NDc3MiA4LjAwMDA3IDEgOC40NDc3OCAxIDkuMDAwMDdWMTUuMDAwMUMxIDE1LjU1MjQgMS40NDc3MiAxNi4wMDAxIDIgMTYuMDAwMVpNMjMgMTJDMjMgMTUuMjkyIDIxLjU1MzkgMTguMjQ2MyAxOS4yNjIyIDIwLjI2MjJMMTcuODQ0NSAxOC44NDQ0QzE5Ljc3NTggMTcuMTkzNyAyMSAxNC43Mzk4IDIxIDEyQzIxIDkuMjYwMTYgMTkuNzc1OCA2LjgwNjI5IDE3Ljg0NDUgNS4xNTU1N0wxOS4yNjIyIDMuNzM3NzlDMjEuNTUzOSA1Ljc1MzY4IDIzIDguNzA3OTUgMjMgMTJaTTE4IDEyQzE4IDEwLjA4ODMgMTcuMTA2IDguMzg1NDggMTUuNzEzMyA3LjI4NjczTDE0LjI4NDIgOC43MTU4NEMxNS4zMjEzIDkuNDM4NTUgMTYgMTAuNjQgMTYgMTJDMTYgMTMuMzYgMTUuMzIxMyAxNC41NjE0IDE0LjI4NDIgMTUuMjg0MUwxNS43MTMzIDE2LjcxMzJDMTcuMTA2IDE1LjYxNDUgMTggMTMuOTExNiAxOCAxMlpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBwbyhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTExIDExVjVIMTNWMTFIMTlWMTNIMTNWMTlIMTFWMTNINVYxMUgxMVpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBrbyhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTkuOTk5NyAxNS4xNzA5TDE5LjE5MjEgNS45Nzg1MkwyMC42MDYzIDcuMzkyNzNMOS45OTk3IDE3Ljk5OTNMMy42MzU3NCAxMS42MzU0TDUuMDQ5OTYgMTAuMjIxMkw5Ljk5OTcgMTUuMTcwOVpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiB3byhlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTE3IDZIMjJWOEgyMFYyMUMyMCAyMS41NTIzIDE5LjU1MjMgMjIgMTkgMjJINUM0LjQ0NzcyIDIyIDQgMjEuNTUyMyA0IDIxVjhIMlY2SDdWM0M3IDIuNDQ3NzIgNy40NDc3MiAyIDggMkgxNkMxNi41NTIzIDIgMTcgMi40NDc3MiAxNyAzVjZaTTE4IDhINlYyMEgxOFY4Wk05IDRWNkgxNVY0SDlaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gdm8oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xNyA2SDIyVjhIMjBWMjFDMjAgMjEuNTUyMyAxOS41NTIzIDIyIDE5IDIySDVDNC40NDc3MiAyMiA0IDIxLjU1MjMgNCAyMVY4SDJWNkg3VjNDNyAyLjQ0NzcyIDcuNDQ3NzIgMiA4IDJIMTZDMTYuNTUyMyAyIDE3IDIuNDQ3NzIgMTcgM1Y2Wk05IDExVjE3SDExVjExSDlaTTEzIDExVjE3SDE1VjExSDEzWk05IDRWNkgxNVY0SDlaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gSG8oZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk00IDE5SDIwVjEySDIyVjIwQzIyIDIwLjU1MjMgMjEuNTUyMyAyMSAyMSAyMUgzQzIuNDQ3NzIgMjEgMiAyMC41NTIzIDIgMjBWMTJINFYxOVpNMTQgOUgxOUwxMiAxNkw1IDlIMTBWM0gxNFY5WlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIE1vKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTAgNlY4SDVWMTlIMTZWMTRIMThWMjBDMTggMjAuNTUyMyAxNy41NTIzIDIxIDE3IDIxSDRDMy40NDc3MiAyMSAzIDIwLjU1MjMgMyAyMFY3QzMgNi40NDc3MiAzLjQ0NzcyIDYgNCA2SDEwWk0yMSAzVjEyTDE3LjIwNiA4LjIwN0wxMS4yMDcxIDE0LjIwNzFMOS43OTI4OSAxMi43OTI5TDE1Ljc5MiA2Ljc5M0wxMiAzSDIxWlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIHhvKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNNSAxMEMzLjkgMTAgMyAxMC45IDMgMTJDMyAxMy4xIDMuOSAxNCA1IDE0QzYuMSAxNCA3IDEzLjEgNyAxMkM3IDEwLjkgNi4xIDEwIDUgMTBaTTE5IDEwQzE3LjkgMTAgMTcgMTAuOSAxNyAxMkMxNyAxMy4xIDE3LjkgMTQgMTkgMTRDMjAuMSAxNCAyMSAxMy4xIDIxIDEyQzIxIDEwLjkgMjAuMSAxMCAxOSAxMFpNMTIgMTBDMTAuOSAxMCAxMCAxMC45IDEwIDEyQzEwIDEzLjEgMTAuOSAxNCAxMiAxNEMxMy4xIDE0IDE0IDEzLjEgMTQgMTJDMTQgMTAuOSAxMy4xIDEwIDEyIDEwWlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIHlvKGUpIHtcbiAgcmV0dXJuIHAoeyBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTIgMjJDNi40NzcxNSAyMiAyIDE3LjUyMjggMiAxMkMyIDYuNDc3MTUgNi40NzcxNSAyIDEyIDJDMTcuNTIyOCAyIDIyIDYuNDc3MTUgMjIgMTJDMjIgMTcuNTIyOCAxNy41MjI4IDIyIDEyIDIyWk04IDEzQzggMTUuMjA5MSA5Ljc5MDg2IDE3IDEyIDE3QzE0LjIwOTEgMTcgMTYgMTUuMjA5MSAxNiAxM0g4Wk04IDExQzguODI4NDMgMTEgOS41IDEwLjMyODQgOS41IDkuNUM5LjUgOC42NzE1NyA4LjgyODQzIDggOCA4QzcuMTcxNTcgOCA2LjUgOC42NzE1NyA2LjUgOS41QzYuNSAxMC4zMjg0IDcuMTcxNTcgMTEgOCAxMVpNMTYgMTFDMTYuODI4NCAxMSAxNy41IDEwLjMyODQgMTcuNSA5LjVDMTcuNSA4LjY3MTU3IDE2LjgyODQgOCAxNiA4QzE1LjE3MTYgOCAxNC41IDguNjcxNTcgMTQuNSA5LjVDMTQuNSAxMC4zMjg0IDE1LjE3MTYgMTEgMTYgMTFaXCIgfSwgY2hpbGQ6IFtdIH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gV2UoZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xMiAyMkM2LjQ3NzE1IDIyIDIgMTcuNTIyOCAyIDEyQzIgNi40NzcxNSA2LjQ3NzE1IDIgMTIgMkMxNy41MjI4IDIgMjIgNi40NzcxNSAyMiAxMkMyMiAxNy41MjI4IDE3LjUyMjggMjIgMTIgMjJaTTEyIDIwQzE2LjQxODMgMjAgMjAgMTYuNDE4MyAyMCAxMkMyMCA3LjU4MTcyIDE2LjQxODMgNCAxMiA0QzcuNTgxNzIgNCA0IDcuNTgxNzIgNCAxMkM0IDE2LjQxODMgNy41ODE3MiAyMCAxMiAyMFpNOCAxM0gxNkMxNiAxNS4yMDkxIDE0LjIwOTEgMTcgMTIgMTdDOS43OTA4NiAxNyA4IDE1LjIwOTEgOCAxM1pNOCAxMUM3LjE3MTU3IDExIDYuNSAxMC4zMjg0IDYuNSA5LjVDNi41IDguNjcxNTcgNy4xNzE1NyA4IDggOEM4LjgyODQzIDggOS41IDguNjcxNTcgOS41IDkuNUM5LjUgMTAuMzI4NCA4LjgyODQzIDExIDggMTFaTTE2IDExQzE1LjE3MTYgMTEgMTQuNSAxMC4zMjg0IDE0LjUgOS41QzE0LjUgOC42NzE1NyAxNS4xNzE2IDggMTYgOEMxNi44Mjg0IDggMTcuNSA4LjY3MTU3IDE3LjUgOS41QzE3LjUgMTAuMzI4NCAxNi44Mjg0IDExIDE2IDExWlwiIH0sIGNoaWxkOiBbXSB9XSB9KShlKTtcbn1cbmxldCB0ZTtcbmFzeW5jIGZ1bmN0aW9uIEJvKCkge1xuICByZXR1cm4gdGUgfHwgKHRlID0gKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBbZSwgdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBpbXBvcnQoXCJlbW9qaS1tYXJ0XCIpLFxuICAgICAgLy8gdXNlIGEgZHluYW1pYyBpbXBvcnQgdG8gZW5jb3VyYWdlIGJ1bmRsZS1zcGxpdHRpbmdcbiAgICAgIC8vIGFuZCBhIHNtYWxsZXIgaW5pdGlhbCBjbGllbnQgYnVuZGxlIHNpemVcbiAgICAgIGltcG9ydChcIkBlbW9qaS1tYXJ0L2RhdGFcIilcbiAgICBdKSwgbiA9IFwiZGVmYXVsdFwiIGluIGUgPyBlLmRlZmF1bHQgOiBlLCBvID0gXCJkZWZhdWx0XCIgaW4gdCA/IHQuZGVmYXVsdCA6IHQ7XG4gICAgcmV0dXJuIGF3YWl0IG4uaW5pdCh7IGRhdGE6IG8gfSksIHsgZW1vamlNYXJ0OiBuLCBlbW9qaURhdGE6IG8gfTtcbiAgfSkoKSwgdGUpO1xufVxuZnVuY3Rpb24gVm8oZSkge1xuICBjb25zdCB0ID0gXyhudWxsKSwgbiA9IF8obnVsbCk7XG4gIHJldHVybiBuLmN1cnJlbnQgJiYgbi5jdXJyZW50LnVwZGF0ZShlKSwgeSgoKSA9PiAoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGVtb2ppTWFydDogbyB9ID0gYXdhaXQgQm8oKTtcbiAgICBuLmN1cnJlbnQgPSBuZXcgby5QaWNrZXIoeyAuLi5lLCByZWY6IHQgfSk7XG4gIH0pKCksICgpID0+IHtcbiAgICBuLmN1cnJlbnQgPSBudWxsO1xuICB9KSwgW10pLCBOLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHQgfSk7XG59XG5jb25zdCAkZSA9IChlKSA9PiB7XG4gIGNvbnN0IFt0LCBuXSA9IGsoITEpLCBvID0gQygpLCByID0gRCgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHYoby5HZW5lcmljLlBvcG92ZXIuUm9vdCwgeyBvcGVuZWQ6IHQsIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGkoby5HZW5lcmljLlBvcG92ZXIuVHJpZ2dlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBvbkNsaWNrOiAobCkgPT4ge1xuICAgICAgICAgIGwucHJldmVudERlZmF1bHQoKSwgbC5zdG9wUHJvcGFnYXRpb24oKSwgbighdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZS5jaGlsZHJlblxuICAgICAgfVxuICAgICkgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGkoby5HZW5lcmljLlBvcG92ZXIuQ29udGVudCwgeyB2YXJpYW50OiBcInBhbmVsLXBvcG92ZXJcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgVm8sXG4gICAgICB7XG4gICAgICAgIHBlckxpbmU6IDcsXG4gICAgICAgIG9uQ2xpY2tPdXRzaWRlOiAoKSA9PiBuKCExKSxcbiAgICAgICAgb25FbW9qaVNlbGVjdDogKGwpID0+IHtcbiAgICAgICAgICBlLm9uRW1vamlTZWxlY3QobCksIG4oITEpO1xuICAgICAgICB9LFxuICAgICAgICB0aGVtZTogciA9PSBudWxsID8gdm9pZCAwIDogci5jb2xvclNjaGVtZVByZWZlcmVuY2VcbiAgICAgIH1cbiAgICApIH0pXG4gIF0gfSk7XG59O1xuZnVuY3Rpb24gU28oZSwgdCkge1xuICByZXR1cm4gSWUoZSwgW3RdKS5nZXQodCk7XG59XG5mdW5jdGlvbiBJZShlLCB0KSB7XG4gIGNvbnN0IG4gPSBlLmNvbW1lbnRzO1xuICBpZiAoIW4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudHMgcGx1Z2luIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgbyA9IG4udXNlclN0b3JlLCByID0gZygoKSA9PiB7XG4gICAgY29uc3QgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBkIG9mIHQpIHtcbiAgICAgIGNvbnN0IGEgPSBvLmdldFVzZXIoZCk7XG4gICAgICBhICYmIHMuc2V0KGQsIGEpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfSwgW28sIHRdKSwgbCA9IHgoKCkgPT4gKHtcbiAgICBjdXJyZW50OiByKClcbiAgfSksIFtyXSksIGMgPSBnKFxuICAgIChzKSA9PiB7XG4gICAgICBjb25zdCBkID0gby5zdWJzY3JpYmUoKGEpID0+IHtcbiAgICAgICAgbC5jdXJyZW50ID0gcigpLCBzKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvLmxvYWRVc2Vycyh0KSwgZDtcbiAgICB9LFxuICAgIFtvLCByLCB0LCBsXVxuICApO1xuICByZXR1cm4geWUoYywgKCkgPT4gbC5jdXJyZW50KTtcbn1cbmNvbnN0IFRvID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgbyA9IGIoKTtcbiAgaWYgKCFvLmNvbW1lbnRzKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiUmVhY3Rpb25CYWRnZSBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgQmxvY2tOb3RlIGVkaXRvciB3aXRoIGNvbW1lbnRzIGVuYWJsZWRcIlxuICAgICk7XG4gIGNvbnN0IHIgPSBlLmNvbW1lbnQucmVhY3Rpb25zLmZpbmQoXG4gICAgKGQpID0+IGQuZW1vamkgPT09IGUuZW1vamlcbiAgKTtcbiAgaWYgKCFyKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVHJ5aW5nIHRvIHJlbmRlciByZWFjdGlvbiBiYWRnZSBmb3Igbm9uLWV4aXN0aW5nIHJlYWN0aW9uXCJcbiAgICApO1xuICBjb25zdCBbbCwgY10gPSBrKFtdKSwgcyA9IEllKG8sIGwpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5HZW5lcmljLkJhZGdlLlJvb3QsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBJKFwiYm4tYmFkZ2VcIiwgXCJibi1jb21tZW50LXJlYWN0aW9uXCIpLFxuICAgICAgdGV4dDogci51c2VySWRzLmxlbmd0aC50b1N0cmluZygpLFxuICAgICAgaWNvbjogci5lbW9qaSxcbiAgICAgIGlzU2VsZWN0ZWQ6IG8uY29tbWVudHMudGhyZWFkU3RvcmUuYXV0aC5jYW5EZWxldGVSZWFjdGlvbihcbiAgICAgICAgZS5jb21tZW50LFxuICAgICAgICByLmVtb2ppXG4gICAgICApLFxuICAgICAgb25DbGljazogKCkgPT4gZS5vblJlYWN0aW9uU2VsZWN0KHIuZW1vamkpLFxuICAgICAgb25Nb3VzZUVudGVyOiAoKSA9PiBjKHIudXNlcklkcyksXG4gICAgICBtYWluVG9vbHRpcDogbi5jb21tZW50cy5yZWFjdGlvbnMucmVhY3RlZF9ieSxcbiAgICAgIHNlY29uZGFyeVRvb2x0aXA6IGAke0FycmF5LmZyb20ocy52YWx1ZXMoKSkubWFwKChkKSA9PiBkLnVzZXJuYW1lKS5qb2luKGBcbmApfWBcbiAgICB9LFxuICAgIHIuZW1vamlcbiAgKTtcbn0sIExvID0gKHtcbiAgY29tbWVudDogZSxcbiAgdGhyZWFkOiB0LFxuICBzaG93UmVzb2x2ZUJ1dHRvbjogblxufSkgPT4ge1xuICBjb25zdCBvID0gTSgpLCByID0gZGUoXG4gICAge1xuICAgICAgaW5pdGlhbENvbnRlbnQ6IGUuYm9keSxcbiAgICAgIHRyYWlsaW5nQmxvY2s6ICExLFxuICAgICAgZGljdGlvbmFyeToge1xuICAgICAgICAuLi5vLFxuICAgICAgICBwbGFjZWhvbGRlcnM6IHtcbiAgICAgICAgICBlbXB0eURvY3VtZW50OiBvLnBsYWNlaG9sZGVycy5lZGl0X2NvbW1lbnRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNjaGVtYTogRWUsXG4gICAgICBzaWRlTWVudURldGVjdGlvbjogXCJlZGl0b3JcIlxuICAgIH0sXG4gICAgW2UuYm9keV1cbiAgKSwgbCA9IEMoKSwgW2MsIHNdID0gayghMSksIGQgPSBiKCk7XG4gIGlmICghZC5jb21tZW50cylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50cyBwbHVnaW4gbm90IGZvdW5kXCIpO1xuICBjb25zdCBhID0gZC5jb21tZW50cy50aHJlYWRTdG9yZSwgdSA9IGcoKCkgPT4ge1xuICAgIHMoITApO1xuICB9LCBbXSksIG0gPSBnKCgpID0+IHtcbiAgICByLnJlcGxhY2VCbG9ja3Moci5kb2N1bWVudCwgZS5ib2R5KSwgcyghMSk7XG4gIH0sIFtyLCBlLmJvZHldKSwgaCA9IGcoXG4gICAgYXN5bmMgKEUpID0+IHtcbiAgICAgIGF3YWl0IGEudXBkYXRlQ29tbWVudCh7XG4gICAgICAgIGNvbW1lbnRJZDogZS5pZCxcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIGJvZHk6IHIuZG9jdW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgdGhyZWFkSWQ6IHQuaWRcbiAgICAgIH0pLCBzKCExKTtcbiAgICB9LFxuICAgIFtlLCB0LmlkLCByLCBhXVxuICApLCBmID0gZyhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYS5kZWxldGVDb21tZW50KHtcbiAgICAgIGNvbW1lbnRJZDogZS5pZCxcbiAgICAgIHRocmVhZElkOiB0LmlkXG4gICAgfSk7XG4gIH0sIFtlLCB0LmlkLCBhXSksIHcgPSBnKFxuICAgIGFzeW5jIChFKSA9PiB7XG4gICAgICBhLmF1dGguY2FuQWRkUmVhY3Rpb24oZSwgRSkgPyBhd2FpdCBhLmFkZFJlYWN0aW9uKHtcbiAgICAgICAgdGhyZWFkSWQ6IHQuaWQsXG4gICAgICAgIGNvbW1lbnRJZDogZS5pZCxcbiAgICAgICAgZW1vamk6IEVcbiAgICAgIH0pIDogYS5hdXRoLmNhbkRlbGV0ZVJlYWN0aW9uKGUsIEUpICYmIGF3YWl0IGEuZGVsZXRlUmVhY3Rpb24oe1xuICAgICAgICB0aHJlYWRJZDogdC5pZCxcbiAgICAgICAgY29tbWVudElkOiBlLmlkLFxuICAgICAgICBlbW9qaTogRVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbYSwgZSwgdC5pZF1cbiAgKSwgSCA9IGcoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGEucmVzb2x2ZVRocmVhZCh7XG4gICAgICB0aHJlYWRJZDogdC5pZFxuICAgIH0pO1xuICB9LCBbdC5pZCwgYV0pLCBCID0gZyhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYS51bnJlc29sdmVUaHJlYWQoe1xuICAgICAgdGhyZWFkSWQ6IHQuaWRcbiAgICB9KTtcbiAgfSwgW3QuaWQsIGFdKSwgViA9IFNvKGQsIGUudXNlcklkKTtcbiAgaWYgKCFlLmJvZHkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBTO1xuICBjb25zdCBPID0gYS5hdXRoLmNhbkFkZFJlYWN0aW9uKGUpLCB6ID0gYS5hdXRoLmNhbkRlbGV0ZUNvbW1lbnQoZSksIGogPSBhLmF1dGguY2FuVXBkYXRlQ29tbWVudChlKSwgWiA9IG4gJiYgKHQucmVzb2x2ZWQgPyBhLmF1dGguY2FuVW5yZXNvbHZlVGhyZWFkKHQpIDogYS5hdXRoLmNhblJlc29sdmVUaHJlYWQodCkpO1xuICBjIHx8IChTID0gLyogQF9fUFVSRV9fICovIHYoXG4gICAgbC5HZW5lcmljLlRvb2xiYXIuUm9vdCxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IEkoXCJibi1hY3Rpb24tdG9vbGJhclwiLCBcImJuLWNvbW1lbnQtYWN0aW9uc1wiKSxcbiAgICAgIHZhcmlhbnQ6IFwiYWN0aW9uLXRvb2xiYXJcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIE8gJiYgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgJGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgb25FbW9qaVNlbGVjdDogKEUpID0+IHcoRS5uYXRpdmUpLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgICBsLkdlbmVyaWMuVG9vbGJhci5CdXR0b24sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYWluVG9vbHRpcDogby5jb21tZW50cy5hY3Rpb25zLmFkZF9yZWFjdGlvbixcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBcImNvbXBhY3RcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoV2UsIHsgc2l6ZTogMTYgfSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhZGQtcmVhY3Rpb25cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgWiAmJiAodC5yZXNvbHZlZCA/IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIGwuR2VuZXJpYy5Ub29sYmFyLkJ1dHRvbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYWluVG9vbHRpcDogXCJSZS1vcGVuXCIsXG4gICAgICAgICAgICB2YXJpYW50OiBcImNvbXBhY3RcIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IEIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoS24sIHsgc2l6ZTogMTYgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVvcGVuXCJcbiAgICAgICAgKSA6IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIGwuR2VuZXJpYy5Ub29sYmFyLkJ1dHRvbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYWluVG9vbHRpcDogby5jb21tZW50cy5hY3Rpb25zLnJlc29sdmUsXG4gICAgICAgICAgICB2YXJpYW50OiBcImNvbXBhY3RcIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IEgsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoa28sIHsgc2l6ZTogMTYgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVzb2x2ZVwiXG4gICAgICAgICkpLFxuICAgICAgICAoeiB8fCBqKSAmJiAvKiBAX19QVVJFX18gKi8gdihsLkdlbmVyaWMuTWVudS5Sb290LCB7IHBvc2l0aW9uOiBcImJvdHRvbS1zdGFydFwiLCBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKGwuR2VuZXJpYy5NZW51LlRyaWdnZXIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgbC5HZW5lcmljLlRvb2xiYXIuQnV0dG9uLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYWluVG9vbHRpcDogby5jb21tZW50cy5hY3Rpb25zLm1vcmVfYWN0aW9ucyxcbiAgICAgICAgICAgICAgdmFyaWFudDogXCJjb21wYWN0XCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaSh4bywgeyBzaXplOiAxNiB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibW9yZS1hY3Rpb25zXCJcbiAgICAgICAgICApIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyB2KGwuR2VuZXJpYy5NZW51LkRyb3Bkb3duLCB7IGNsYXNzTmFtZTogXCJibi1tZW51LWRyb3Bkb3duXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBqICYmIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgICBsLkdlbmVyaWMuTWVudS5JdGVtLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkoWG4sIHt9KSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiB1LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvLmNvbW1lbnRzLmFjdGlvbnMuZWRpdF9jb21tZW50XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiZWRpdC1jb21tZW50XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB6ICYmIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgICBsLkdlbmVyaWMuTWVudS5JdGVtLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkodm8sIHt9KSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvLmNvbW1lbnRzLmFjdGlvbnMuZGVsZXRlX2NvbW1lbnRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJkZWxldGUtY29tbWVudFwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgXSB9KVxuICAgICAgICBdIH0pXG4gICAgICBdXG4gICAgfVxuICApKTtcbiAgY29uc3QgJCA9IGUuY3JlYXRlZEF0LnRvTG9jYWxlRGF0ZVN0cmluZyh2b2lkIDAsIHtcbiAgICBtb250aDogXCJzaG9ydFwiLFxuICAgIGRheTogXCJudW1lcmljXCJcbiAgfSk7XG4gIGlmICghZS5ib2R5KVxuICAgIHRocm93IG5ldyBFcnJvcihcInNvZnQgZGVsZXRlcyBhcmUgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICBsLkNvbW1lbnRzLkNvbW1lbnQsXG4gICAge1xuICAgICAgYXV0aG9ySW5mbzogViA/PyBcImxvYWRpbmdcIixcbiAgICAgIHRpbWVTdHJpbmc6ICQsXG4gICAgICBlZGl0ZWQ6IGUudXBkYXRlZEF0LmdldFRpbWUoKSAhPT0gZS5jcmVhdGVkQXQuZ2V0VGltZSgpLFxuICAgICAgc2hvd0FjdGlvbnM6IFwiaG92ZXJcIixcbiAgICAgIGFjdGlvbnM6IFMsXG4gICAgICBjbGFzc05hbWU6IFwiYm4tdGhyZWFkLWNvbW1lbnRcIixcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgTGUsXG4gICAgICAgIHtcbiAgICAgICAgICBhdXRvRm9jdXM6IGMsXG4gICAgICAgICAgZWRpdG9yOiByLFxuICAgICAgICAgIGVkaXRhYmxlOiBjLFxuICAgICAgICAgIGFjdGlvbnM6IGUucmVhY3Rpb25zLmxlbmd0aCA+IDAgfHwgYyA/ICh7IGlzRW1wdHk6IEUgfSkgPT4gLyogQF9fUFVSRV9fICovIHYoVCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgICAgZS5yZWFjdGlvbnMubGVuZ3RoID4gMCAmJiAhYyAmJiAvKiBAX19QVVJFX18gKi8gdihcbiAgICAgICAgICAgICAgbC5HZW5lcmljLkJhZGdlLkdyb3VwLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBJKFxuICAgICAgICAgICAgICAgICAgXCJibi1iYWRnZS1ncm91cFwiLFxuICAgICAgICAgICAgICAgICAgXCJibi1jb21tZW50LXJlYWN0aW9uc1wiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgZS5yZWFjdGlvbnMubWFwKChGKSA9PiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgICAgICAgICAgVG8sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb21tZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICAgIGVtb2ppOiBGLmVtb2ppLFxuICAgICAgICAgICAgICAgICAgICAgIG9uUmVhY3Rpb25TZWxlY3Q6IHdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgRi5lbW9qaVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgICAgICAgICAgJGUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBvbkVtb2ppU2VsZWN0OiAoRikgPT4gdyhGLm5hdGl2ZSksXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgICAgICAgICAgICAgbC5HZW5lcmljLkJhZGdlLlJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogSShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJuLWJhZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJibi1jb21tZW50LWFkZC1yZWFjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShXZSwgeyBzaXplOiAxNiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpblRvb2x0aXA6IG8uY29tbWVudHMuYWN0aW9ucy5hZGRfcmVhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjICYmIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgICAgICAgICAgICBsLkdlbmVyaWMuVG9vbGJhci5Sb290LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyaWFudDogXCJhY3Rpb24tdG9vbGJhclwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogSShcbiAgICAgICAgICAgICAgICAgIFwiYm4tYWN0aW9uLXRvb2xiYXJcIixcbiAgICAgICAgICAgICAgICAgIFwiYm4tY29tbWVudC1hY3Rpb25zXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgICAgICAgICAgbC5HZW5lcmljLlRvb2xiYXIuQnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgbWFpblRvb2x0aXA6IFwiU2F2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ6IFwiY29tcGFjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogRSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJTYXZlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgICAgICAgICBsLkdlbmVyaWMuVG9vbGJhci5CdXR0b24sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbWFpblRvb2x0aXA6IFwiQ2FuY2VsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFyaWFudDogXCJjb21wYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljazogbSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDYW5jZWxcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgXSB9KSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICApO1xufSwgRW8gPSAoe1xuICB0aHJlYWQ6IGUsXG4gIG1heENvbW1lbnRzQmVmb3JlQ29sbGFwc2U6IHRcbn0pID0+IHtcbiAgY29uc3QgbiA9IEMoKSwgbyA9IE0oKSwgciA9IGIoKSwgbCA9IEllKHIsIGUucmVzb2x2ZWRCeSA/IFtlLnJlc29sdmVkQnldIDogW10pLCBjID0gZS5jb21tZW50cy5tYXAoKHMsIGQpID0+IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIExvLFxuICAgIHtcbiAgICAgIHRocmVhZDogZSxcbiAgICAgIGNvbW1lbnQ6IHMsXG4gICAgICBzaG93UmVzb2x2ZUJ1dHRvbjogZCA9PT0gMFxuICAgIH0sXG4gICAgcy5pZFxuICApKTtcbiAgaWYgKGUucmVzb2x2ZWQgJiYgZS5yZXNvbHZlZFVwZGF0ZWRBdCAmJiBlLnJlc29sdmVkQnkpIHtcbiAgICBpZiAoIWwuZ2V0KGUucmVzb2x2ZWRCeSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVc2VyICR7ZS5yZXNvbHZlZEJ5fSByZXNvbHZlZCB0aHJlYWQgJHtlLmlkfSwgYnV0IHRoZWlyIGRhdGEgY291bGQgbm90IGJlIGZvdW5kLmBcbiAgICAgICk7XG4gICAgY29uc3QgZCA9IGUuY29tbWVudHMuZmluZExhc3RJbmRleChcbiAgICAgIChhKSA9PiBlLnJlc29sdmVkVXBkYXRlZEF0LmdldFRpbWUoKSA+IGEuY3JlYXRlZEF0LmdldFRpbWUoKVxuICAgICkgKyAxO1xuICAgIGMuc3BsaWNlKFxuICAgICAgZCxcbiAgICAgIDAsXG4gICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgbi5Db21tZW50cy5Db21tZW50LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImJuLXRocmVhZC1jb21tZW50XCIsXG4gICAgICAgICAgYXV0aG9ySW5mbzogZS5yZXNvbHZlZEJ5ICYmIGwuZ2V0KGUucmVzb2x2ZWRCeSkgfHwgXCJsb2FkaW5nXCIsXG4gICAgICAgICAgdGltZVN0cmluZzogZS5yZXNvbHZlZFVwZGF0ZWRBdC50b0xvY2FsZURhdGVTdHJpbmcodm9pZCAwLCB7XG4gICAgICAgICAgICBtb250aDogXCJzaG9ydFwiLFxuICAgICAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGVkaXRlZDogITEsXG4gICAgICAgICAgc2hvd0FjdGlvbnM6ICExLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJibi1yZXNvbHZlZC10ZXh0XCIsIGNoaWxkcmVuOiBvLmNvbW1lbnRzLnNpZGViYXIubWFya2VkX2FzX3Jlc29sdmVkIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwicmVzb2x2ZWQtY29tbWVudFwiXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdCAmJiBjLmxlbmd0aCA+IHQgJiYgYy5zcGxpY2UoXG4gICAgMSxcbiAgICBjLmxlbmd0aCAtIDIsXG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICBuLkNvbW1lbnRzLkV4cGFuZFNlY3Rpb25zUHJvbXB0LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tdGhyZWFkLWV4cGFuZC1wcm9tcHRcIixcbiAgICAgICAgY2hpbGRyZW46IG8uY29tbWVudHMuc2lkZWJhci5tb3JlX3JlcGxpZXMoZS5jb21tZW50cy5sZW5ndGggLSAyKVxuICAgICAgfSxcbiAgICAgIFwiZXhwYW5kLXByb21wdFwiXG4gICAgKVxuICApLCBjO1xufSwgeHQgPSAoe1xuICB0aHJlYWQ6IGUsXG4gIHNlbGVjdGVkOiB0LFxuICByZWZlcmVuY2VUZXh0OiBuLFxuICBtYXhDb21tZW50c0JlZm9yZUNvbGxhcHNlOiBvLFxuICBvbkZvY3VzOiByLFxuICBvbkJsdXI6IGwsXG4gIHRhYkluZGV4OiBjXG59KSA9PiB7XG4gIGNvbnN0IHMgPSBDKCksIGQgPSBNKCksIHUgPSBiKCkuY29tbWVudHM7XG4gIGlmICghdSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50cyBwbHVnaW4gbm90IGZvdW5kXCIpO1xuICBjb25zdCBtID0gZGUoe1xuICAgIHRyYWlsaW5nQmxvY2s6ICExLFxuICAgIGRpY3Rpb25hcnk6IHtcbiAgICAgIC4uLmQsXG4gICAgICBwbGFjZWhvbGRlcnM6IHtcbiAgICAgICAgZW1wdHlEb2N1bWVudDogZC5wbGFjZWhvbGRlcnMuY29tbWVudF9yZXBseVxuICAgICAgfVxuICAgIH0sXG4gICAgc2NoZW1hOiBFZSxcbiAgICBzaWRlTWVudURldGVjdGlvbjogXCJlZGl0b3JcIlxuICB9KSwgaCA9IGcoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHUudGhyZWFkU3RvcmUuYWRkQ29tbWVudCh7XG4gICAgICBjb21tZW50OiB7XG4gICAgICAgIGJvZHk6IG0uZG9jdW1lbnRcbiAgICAgIH0sXG4gICAgICB0aHJlYWRJZDogZS5pZFxuICAgIH0pLCBtLnJlbW92ZUJsb2NrcyhtLmRvY3VtZW50KTtcbiAgfSwgW3UsIG0sIGUuaWRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgIHMuQ29tbWVudHMuQ2FyZCxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwiYm4tdGhyZWFkXCIsXG4gICAgICBoZWFkZXJUZXh0OiBuLFxuICAgICAgb25Gb2N1czogcixcbiAgICAgIG9uQmx1cjogbCxcbiAgICAgIHNlbGVjdGVkOiB0LFxuICAgICAgdGFiSW5kZXg6IGMsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gaShzLkNvbW1lbnRzLkNhcmRTZWN0aW9uLCB7IGNsYXNzTmFtZTogXCJibi10aHJlYWQtY29tbWVudHNcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIEVvLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocmVhZDogZSxcbiAgICAgICAgICAgIG1heENvbW1lbnRzQmVmb3JlQ29sbGFwc2U6IHQgPyB2b2lkIDAgOiBvIHx8IDVcbiAgICAgICAgICB9XG4gICAgICAgICkgfSksXG4gICAgICAgIHQgJiYgLyogQF9fUFVSRV9fICovIGkocy5Db21tZW50cy5DYXJkU2VjdGlvbiwgeyBjbGFzc05hbWU6IFwiYm4tdGhyZWFkLWNvbXBvc2VyXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICBMZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhdXRvRm9jdXM6ICExLFxuICAgICAgICAgICAgZWRpdGFibGU6ICEwLFxuICAgICAgICAgICAgZWRpdG9yOiBtLFxuICAgICAgICAgICAgYWN0aW9uczogKHsgaXNFbXB0eTogZiB9KSA9PiBmID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgICBzLkdlbmVyaWMuVG9vbGJhci5Sb290LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyaWFudDogXCJhY3Rpb24tdG9vbGJhclwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogSShcbiAgICAgICAgICAgICAgICAgIFwiYm4tYWN0aW9uLXRvb2xiYXJcIixcbiAgICAgICAgICAgICAgICAgIFwiYm4tY29tbWVudC1hY3Rpb25zXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgICAgICAgIHMuR2VuZXJpYy5Ub29sYmFyLkJ1dHRvbixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpblRvb2x0aXA6IFwiU2F2ZVwiLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYW50OiBcImNvbXBhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogZixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogaCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiU2F2ZVwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICApIH0pXG4gICAgICBdXG4gICAgfVxuICApO1xufTtcbmZ1bmN0aW9uIHl0KGUpIHtcbiAgY29uc3QgdCA9IGUuY29tbWVudHM7XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50cyBwbHVnaW4gbm90IGZvdW5kXCIpO1xuICBjb25zdCBuID0gdC50aHJlYWRTdG9yZSwgbyA9IF8oKTtcbiAgby5jdXJyZW50IHx8IChvLmN1cnJlbnQgPSBuLmdldFRocmVhZHMoKSk7XG4gIGNvbnN0IHIgPSBnKFxuICAgIChsKSA9PiBuLnN1YnNjcmliZSgoYykgPT4ge1xuICAgICAgby5jdXJyZW50ID0gYywgbCgpO1xuICAgIH0pLFxuICAgIFtuXVxuICApO1xuICByZXR1cm4geWUociwgKCkgPT4gby5jdXJyZW50KTtcbn1cbmNvbnN0IFJvID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IGIoKTtcbiAgaWYgKCF0LmNvbW1lbnRzKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiRmxvYXRpbmdDb21wb3NlckNvbnRyb2xsZXIgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIEJsb2NrTm90ZSBlZGl0b3IgaGFzIGVuYWJsZWQgY29tbWVudHNcIlxuICAgICk7XG4gIGNvbnN0IG4gPSBQKFxuICAgIHQuY29tbWVudHMub25VcGRhdGUuYmluZCh0LmNvbW1lbnRzKVxuICApLCB7IGlzTW91bnRlZDogbywgcmVmOiByLCBzdHlsZTogbCwgZ2V0RmxvYXRpbmdQcm9wczogYywgc2V0UmVmZXJlbmNlOiBzIH0gPSBHKCEhKG4gIT0gbnVsbCAmJiBuLnNlbGVjdGVkVGhyZWFkSWQpLCBudWxsLCA1ZTMsIHtcbiAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgbWlkZGxld2FyZTogW0EoMTApLCBsZSgpLCBXKCldLFxuICAgIG9uT3BlbkNoYW5nZTogKG0pID0+IHtcbiAgICAgIHZhciBoO1xuICAgICAgbSB8fCAoKGggPSB0LmNvbW1lbnRzKSA9PSBudWxsIHx8IGguc2VsZWN0VGhyZWFkKHZvaWQgMCksIHQuZm9jdXMoKSk7XG4gICAgfSxcbiAgICAuLi5lLmZsb2F0aW5nT3B0aW9uc1xuICB9KSwgZCA9IGcoKCkgPT4ge1xuICAgIHZhciBoO1xuICAgIGlmICghKG4gIT0gbnVsbCAmJiBuLnNlbGVjdGVkVGhyZWFkSWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG0gPSAoaCA9IHQuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGgucXVlcnlTZWxlY3RvcihcbiAgICAgIGBbZGF0YS1ibi10aHJlYWQtaWQ9XCIke24gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc2VsZWN0ZWRUaHJlYWRJZH1cIl1gXG4gICAgKTtcbiAgICBtICYmIHMobSk7XG4gIH0sIFtzLCB0LCBuID09IG51bGwgPyB2b2lkIDAgOiBuLnNlbGVjdGVkVGhyZWFkSWRdKTtcbiAgeSgoKSA9PiB7XG4gICAgaWYgKG4gIT0gbnVsbCAmJiBuLnNlbGVjdGVkVGhyZWFkSWQpXG4gICAgICByZXR1cm4gdC5vbkNoYW5nZSgoKSA9PiB7XG4gICAgICAgIGQoKTtcbiAgICAgIH0pO1xuICB9LCBbdCwgZCwgbiA9PSBudWxsID8gdm9pZCAwIDogbi5zZWxlY3RlZFRocmVhZElkXSksIEd0KGQsIFtkXSk7XG4gIGNvbnN0IGEgPSB5dCh0KTtcbiAgaWYgKCFvIHx8ICFuIHx8ICFuLnNlbGVjdGVkVGhyZWFkSWQpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHUgPSBlLmZsb2F0aW5nVGhyZWFkIHx8IHh0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyByZWY6IHIsIHN0eWxlOiBsLCAuLi5jKCksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICB1LFxuICAgIHtcbiAgICAgIHRocmVhZDogYS5nZXQobi5zZWxlY3RlZFRocmVhZElkKSxcbiAgICAgIHNlbGVjdGVkOiAhMFxuICAgIH1cbiAgKSB9KTtcbn0sIF9vID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgeyBibG9jazogbyB9ID0gZSwgciA9IGIoKSwgW2wsIGNdID0gayhcIlwiKSwgcyA9IGcoXG4gICAgKHUpID0+IHtcbiAgICAgIGModS5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICB9LFxuICAgIFtdXG4gICksIGQgPSBnKFxuICAgICh1KSA9PiB7XG4gICAgICB1LmtleSA9PT0gXCJFbnRlclwiICYmICh1LnByZXZlbnREZWZhdWx0KCksIHIudXBkYXRlQmxvY2sobywge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIG5hbWU6IEZlKGwpLFxuICAgICAgICAgIHVybDogbFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBbciwgbywgbF1cbiAgKSwgYSA9IGcoKCkgPT4ge1xuICAgIHIudXBkYXRlQmxvY2sobywge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbmFtZTogRmUobCksXG4gICAgICAgIHVybDogbFxuICAgICAgfVxuICAgIH0pO1xuICB9LCBbciwgbywgbF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHYodC5GaWxlUGFuZWwuVGFiUGFuZWwsIHsgY2xhc3NOYW1lOiBcImJuLXRhYi1wYW5lbFwiLCBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgdC5GaWxlUGFuZWwuVGV4dElucHV0LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tdGV4dC1pbnB1dFwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogbi5maWxlX3BhbmVsLmVtYmVkLnVybF9wbGFjZWhvbGRlcixcbiAgICAgICAgdmFsdWU6IGwsXG4gICAgICAgIG9uQ2hhbmdlOiBzLFxuICAgICAgICBvbktleURvd246IGQsXG4gICAgICAgIFwiZGF0YS10ZXN0XCI6IFwiZW1iZWQtaW5wdXRcIlxuICAgICAgfVxuICAgICksXG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICB0LkZpbGVQYW5lbC5CdXR0b24sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1idXR0b25cIixcbiAgICAgICAgb25DbGljazogYSxcbiAgICAgICAgXCJkYXRhLXRlc3RcIjogXCJlbWJlZC1pbnB1dC1idXR0b25cIixcbiAgICAgICAgY2hpbGRyZW46IG4uZmlsZV9wYW5lbC5lbWJlZC5lbWJlZF9idXR0b25bby50eXBlXSB8fCBuLmZpbGVfcGFuZWwuZW1iZWQuZW1iZWRfYnV0dG9uLmZpbGVcbiAgICAgIH1cbiAgICApXG4gIF0gfSk7XG59LCBJbyA9IChlKSA9PiB7XG4gIHZhciBtO1xuICBjb25zdCB0ID0gQygpLCBuID0gTSgpLCB7IGJsb2NrOiBvLCBzZXRMb2FkaW5nOiByIH0gPSBlLCBsID0gYigpLCBbYywgc10gPSBrKCExKTtcbiAgeSgoKSA9PiB7XG4gICAgYyAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHMoITEpO1xuICAgIH0sIDNlMyk7XG4gIH0sIFtjXSk7XG4gIGNvbnN0IGQgPSBnKFxuICAgIChoKSA9PiB7XG4gICAgICBpZiAoaCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gZih3KSB7XG4gICAgICAgIGlmIChyKCEwKSwgbC51cGxvYWRGaWxlICE9PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBIID0gYXdhaXQgbC51cGxvYWRGaWxlKHcpO1xuICAgICAgICAgICAgdHlwZW9mIEggPT0gXCJzdHJpbmdcIiAmJiAoSCA9IHtcbiAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB3Lm5hbWUsXG4gICAgICAgICAgICAgICAgdXJsOiBIXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBsLnVwZGF0ZUJsb2NrKG8sIEgpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcyghMCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHIoITEpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGYoaCk7XG4gICAgfSxcbiAgICBbbywgbCwgcl1cbiAgKSwgYSA9IGwuc2NoZW1hLmJsb2NrU2NoZW1hW28udHlwZV0sIHUgPSBhLmlzRmlsZUJsb2NrICYmICgobSA9IGEuZmlsZUJsb2NrQWNjZXB0KSAhPSBudWxsICYmIG0ubGVuZ3RoKSA/IGEuZmlsZUJsb2NrQWNjZXB0LmpvaW4oXCIsXCIpIDogXCIqLypcIjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KHQuRmlsZVBhbmVsLlRhYlBhbmVsLCB7IGNsYXNzTmFtZTogXCJibi10YWItcGFuZWxcIiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuRmlsZVBhbmVsLkZpbGVJbnB1dCxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImJuLWZpbGUtaW5wdXRcIixcbiAgICAgICAgXCJkYXRhLXRlc3RcIjogXCJ1cGxvYWQtaW5wdXRcIixcbiAgICAgICAgYWNjZXB0OiB1LFxuICAgICAgICBwbGFjZWhvbGRlcjogbi5maWxlX3BhbmVsLnVwbG9hZC5maWxlX3BsYWNlaG9sZGVyW28udHlwZV0gfHwgbi5maWxlX3BhbmVsLnVwbG9hZC5maWxlX3BsYWNlaG9sZGVyLmZpbGUsXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICBvbkNoYW5nZTogZFxuICAgICAgfVxuICAgICksXG4gICAgYyAmJiAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJibi1lcnJvci10ZXh0XCIsIGNoaWxkcmVuOiBuLmZpbGVfcGFuZWwudXBsb2FkLnVwbG9hZF9lcnJvciB9KVxuICBdIH0pO1xufSwgQnQgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gQygpLCBuID0gTSgpLCBvID0gYigpLCBbciwgbF0gPSBrKCExKSwgYyA9IGUudGFicyA/PyBbXG4gICAgLi4uby51cGxvYWRGaWxlICE9PSB2b2lkIDAgPyBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG4uZmlsZV9wYW5lbC51cGxvYWQudGl0bGUsXG4gICAgICAgIHRhYlBhbmVsOiAvKiBAX19QVVJFX18gKi8gaShJbywgeyBibG9jazogZS5ibG9jaywgc2V0TG9hZGluZzogbCB9KVxuICAgICAgfVxuICAgIF0gOiBbXSxcbiAgICB7XG4gICAgICBuYW1lOiBuLmZpbGVfcGFuZWwuZW1iZWQudGl0bGUsXG4gICAgICB0YWJQYW5lbDogLyogQF9fUFVSRV9fICovIGkoX28sIHsgYmxvY2s6IGUuYmxvY2sgfSlcbiAgICB9XG4gIF0sIFtzLCBkXSA9IGsoXG4gICAgZS5kZWZhdWx0T3BlblRhYiB8fCBjWzBdLm5hbWVcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuRmlsZVBhbmVsLlJvb3QsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLXBhbmVsXCIsXG4gICAgICBkZWZhdWx0T3BlblRhYjogcyxcbiAgICAgIG9wZW5UYWI6IHMsXG4gICAgICBzZXRPcGVuVGFiOiBkLFxuICAgICAgdGFiczogYyxcbiAgICAgIGxvYWRpbmc6IHJcbiAgICB9XG4gICk7XG59LCBObyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBiKCk7XG4gIGlmICghdC5maWxlUGFuZWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJGaWxlVG9vbGJhckNvbnRyb2xsZXIgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIEJsb2NrTm90ZSBlZGl0b3Igc2NoZW1hIGNvbnRhaW5zIGZpbGUgYmxvY2tcIlxuICAgICk7XG4gIGNvbnN0IG4gPSBQKFxuICAgIHQuZmlsZVBhbmVsLm9uVXBkYXRlLmJpbmQodC5maWxlUGFuZWwpXG4gICksIHsgaXNNb3VudGVkOiBvLCByZWY6IHIsIHN0eWxlOiBsLCBnZXRGbG9hdGluZ1Byb3BzOiBjIH0gPSBHKFxuICAgIChuID09IG51bGwgPyB2b2lkIDAgOiBuLnNob3cpIHx8ICExLFxuICAgIChuID09IG51bGwgPyB2b2lkIDAgOiBuLnJlZmVyZW5jZVBvcykgfHwgbnVsbCxcbiAgICA1ZTMsXG4gICAge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICAgICAgbWlkZGxld2FyZTogW0EoMTApLCBXKCldLFxuICAgICAgb25PcGVuQ2hhbmdlOiAobSkgPT4ge1xuICAgICAgICBtIHx8ICh0LmZpbGVQYW5lbC5jbG9zZU1lbnUoKSwgdC5mb2N1cygpKTtcbiAgICAgIH0sXG4gICAgICAuLi5lLmZsb2F0aW5nT3B0aW9uc1xuICAgIH1cbiAgKTtcbiAgaWYgKCFvIHx8ICFuKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB7IHNob3c6IHMsIHJlZmVyZW5jZVBvczogZCwgLi4uYSB9ID0gbiwgdSA9IGUuZmlsZVBhbmVsIHx8IEJ0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyByZWY6IHIsIHN0eWxlOiBsLCAuLi5jKCksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaSh1LCB7IC4uLmEgfSkgfSk7XG59O1xuZnVuY3Rpb24gVShlLCB0KSB7XG4gIHVlKGUsIHQpLCBzZShlLCB0KTtcbn1cbmZ1bmN0aW9uIFBvKGUpIHtcbiAgcmV0dXJuICh0KSA9PiB7XG4gICAgZS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBuKHQpIDogbiAhPSBudWxsICYmIChuLmN1cnJlbnQgPSB0KTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFIoZSkge1xuICBjb25zdCB0ID0gRCgpO1xuICBpZiAoZSB8fCAoZSA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZWRpdG9yKSwgIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCInZWRpdG9yJyBpcyByZXF1aXJlZCwgZWl0aGVyIGZyb20gQmxvY2tOb3RlQ29udGV4dCBvciBhcyBhIGZ1bmN0aW9uIGFyZ3VtZW50XCJcbiAgICApO1xuICBjb25zdCBuID0gZSwgW28sIHJdID0gaygoKSA9PiB7XG4gICAgdmFyIGw7XG4gICAgcmV0dXJuICgobCA9IG4uZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBsLmJsb2NrcykgfHwgW24uZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2tdO1xuICB9KTtcbiAgcmV0dXJuIFUoXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIGw7XG4gICAgICByZXR1cm4gcihcbiAgICAgICAgKChsID0gbi5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuYmxvY2tzKSB8fCBbbi5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9ja11cbiAgICAgICk7XG4gICAgfSxcbiAgICBuXG4gICksIG87XG59XG5jb25zdCBPbyA9IHtcbiAgYm9sZDogbm8sXG4gIGl0YWxpYzogbG8sXG4gIHVuZGVybGluZTogaG8sXG4gIHN0cmlrZTogdW8sXG4gIGNvZGU6IFluXG59O1xuZnVuY3Rpb24gRG8oZSwgdCkge1xuICByZXR1cm4gZSBpbiB0LnNjaGVtYS5zdHlsZVNjaGVtYSAmJiB0LnNjaGVtYS5zdHlsZVNjaGVtYVtlXS50eXBlID09PSBlICYmIHQuc2NoZW1hLnN0eWxlU2NoZW1hW2VdLnByb3BTY2hlbWEgPT09IFwiYm9vbGVhblwiO1xufVxuY29uc3QgbmUgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gTSgpLCBuID0gQygpLCBvID0gYigpLCByID0gRG8oXG4gICAgZS5iYXNpY1RleHRTdHlsZSxcbiAgICBvXG4gICksIGwgPSBSKG8pLCBbYywgc10gPSBrKFxuICAgIGUuYmFzaWNUZXh0U3R5bGUgaW4gby5nZXRBY3RpdmVTdHlsZXMoKVxuICApO1xuICBVKCgpID0+IHtcbiAgICByICYmIHMoZS5iYXNpY1RleHRTdHlsZSBpbiBvLmdldEFjdGl2ZVN0eWxlcygpKTtcbiAgfSwgbyk7XG4gIGNvbnN0IGQgPSAobSkgPT4ge1xuICAgIGlmIChvLmZvY3VzKCksICEhcikge1xuICAgICAgaWYgKG8uc2NoZW1hLnN0eWxlU2NoZW1hW21dLnByb3BTY2hlbWEgIT09IFwiYm9vbGVhblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gb25seSB0b2dnbGUgYm9vbGVhbiBzdHlsZXNcIik7XG4gICAgICBvLnRvZ2dsZVN0eWxlcyh7IFttXTogITAgfSk7XG4gICAgfVxuICB9O1xuICBpZiAoIXgoKCkgPT4gciA/ICEhbC5maW5kKChtKSA9PiBtLmNvbnRlbnQgIT09IHZvaWQgMCkgOiAhMSwgW3IsIGxdKSB8fCAhby5pc0VkaXRhYmxlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB1ID0gT29bZS5iYXNpY1RleHRTdHlsZV07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICBuLkZvcm1hdHRpbmdUb29sYmFyLkJ1dHRvbixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICBcImRhdGEtdGVzdFwiOiBlLmJhc2ljVGV4dFN0eWxlLFxuICAgICAgb25DbGljazogKCkgPT4gZChlLmJhc2ljVGV4dFN0eWxlKSxcbiAgICAgIGlzU2VsZWN0ZWQ6IGMsXG4gICAgICBsYWJlbDogdC5mb3JtYXR0aW5nX3Rvb2xiYXJbZS5iYXNpY1RleHRTdHlsZV0udG9vbHRpcCxcbiAgICAgIG1haW5Ub29sdGlwOiB0LmZvcm1hdHRpbmdfdG9vbGJhcltlLmJhc2ljVGV4dFN0eWxlXS50b29sdGlwLFxuICAgICAgc2Vjb25kYXJ5VG9vbHRpcDogY2UoXG4gICAgICAgIHQuZm9ybWF0dGluZ190b29sYmFyW2UuYmFzaWNUZXh0U3R5bGVdLnNlY29uZGFyeV90b29sdGlwLFxuICAgICAgICB0LmdlbmVyaWMuY3RybF9zaG9ydGN1dFxuICAgICAgKSxcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKHUsIHt9KVxuICAgIH1cbiAgKTtcbn0sIHdlID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IGUudGV4dENvbG9yIHx8IFwiZGVmYXVsdFwiLCBuID0gZS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJkZWZhdWx0XCIsIG8gPSBlLnNpemUgfHwgMTYsIHIgPSB4KFxuICAgICgpID0+ICh7XG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgIGZvbnRTaXplOiAobyAqIDAuNzUpLnRvU3RyaW5nKCkgKyBcInB4XCIsXG4gICAgICBoZWlnaHQ6IG8udG9TdHJpbmcoKSArIFwicHhcIixcbiAgICAgIGxpbmVIZWlnaHQ6IG8udG9TdHJpbmcoKSArIFwicHhcIixcbiAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgIHdpZHRoOiBvLnRvU3RyaW5nKCkgKyBcInB4XCJcbiAgICB9KSxcbiAgICBbb11cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWNvbG9yLWljb25cIixcbiAgICAgIFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCI6IG4sXG4gICAgICBcImRhdGEtdGV4dC1jb2xvclwiOiB0LFxuICAgICAgc3R5bGU6IHIsXG4gICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICB9XG4gICk7XG59LCBxZSA9IFtcbiAgXCJkZWZhdWx0XCIsXG4gIFwiZ3JheVwiLFxuICBcImJyb3duXCIsXG4gIFwicmVkXCIsXG4gIFwib3JhbmdlXCIsXG4gIFwieWVsbG93XCIsXG4gIFwiZ3JlZW5cIixcbiAgXCJibHVlXCIsXG4gIFwicHVycGxlXCIsXG4gIFwicGlua1wiXG5dLCBtZSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBNKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gdihULCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGkoKCkgPT4gZS50ZXh0ID8gLyogQF9fUFVSRV9fICovIHYoVCwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGkodC5HZW5lcmljLk1lbnUuTGFiZWwsIHsgY2hpbGRyZW46IG4uY29sb3JfcGlja2VyLnRleHRfdGl0bGUgfSksXG4gICAgICBxZS5tYXAoKGwpID0+IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICB0LkdlbmVyaWMuTWVudS5JdGVtLFxuICAgICAgICB7XG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgZS5vbkNsaWNrICYmIGUub25DbGljaygpLCBlLnRleHQuc2V0Q29sb3IobCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRhdGEtdGVzdFwiOiBcInRleHQtY29sb3ItXCIgKyBsLFxuICAgICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKHdlLCB7IHRleHRDb2xvcjogbCwgc2l6ZTogZS5pY29uU2l6ZSB9KSxcbiAgICAgICAgICBjaGVja2VkOiBlLnRleHQuY29sb3IgPT09IGwsXG4gICAgICAgICAgY2hpbGRyZW46IG4uY29sb3JfcGlja2VyLmNvbG9yc1tsXVxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtY29sb3ItXCIgKyBsXG4gICAgICApKVxuICAgIF0gfSkgOiBudWxsLCB7fSksXG4gICAgLyogQF9fUFVSRV9fICovIGkoKCkgPT4gZS5iYWNrZ3JvdW5kID8gLyogQF9fUFVSRV9fICovIHYoVCwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGkodC5HZW5lcmljLk1lbnUuTGFiZWwsIHsgY2hpbGRyZW46IG4uY29sb3JfcGlja2VyLmJhY2tncm91bmRfdGl0bGUgfSksXG4gICAgICBxZS5tYXAoKGwpID0+IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICB0LkdlbmVyaWMuTWVudS5JdGVtLFxuICAgICAgICB7XG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgZS5vbkNsaWNrICYmIGUub25DbGljaygpLCBlLmJhY2tncm91bmQuc2V0Q29sb3IobCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRhdGEtdGVzdFwiOiBcImJhY2tncm91bmQtY29sb3ItXCIgKyBsLFxuICAgICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKHdlLCB7IGJhY2tncm91bmRDb2xvcjogbCwgc2l6ZTogZS5pY29uU2l6ZSB9KSxcbiAgICAgICAgICBjaGVja2VkOiBlLmJhY2tncm91bmQuY29sb3IgPT09IGwsXG4gICAgICAgICAgY2hpbGRyZW46IG4uY29sb3JfcGlja2VyLmNvbG9yc1tsXVxuICAgICAgICB9LFxuICAgICAgICBcImJhY2tncm91bmQtY29sb3ItXCIgKyBsXG4gICAgICApKVxuICAgIF0gfSkgOiBudWxsLCB7fSlcbiAgXSB9KTtcbn07XG5mdW5jdGlvbiBLZShlLCB0KSB7XG4gIHJldHVybiBgJHtlfUNvbG9yYCBpbiB0LnNjaGVtYS5zdHlsZVNjaGVtYSAmJiB0LnNjaGVtYS5zdHlsZVNjaGVtYVtgJHtlfUNvbG9yYF0udHlwZSA9PT0gYCR7ZX1Db2xvcmAgJiYgdC5zY2hlbWEuc3R5bGVTY2hlbWFbYCR7ZX1Db2xvcmBdLnByb3BTY2hlbWEgPT09IFwic3RyaW5nXCI7XG59XG5jb25zdCBabyA9ICgpID0+IHtcbiAgY29uc3QgZSA9IEMoKSwgdCA9IE0oKSwgbiA9IGIoKSwgbyA9IEtlKFwidGV4dFwiLCBuKSwgciA9IEtlKFwiYmFja2dyb3VuZFwiLCBuKSwgbCA9IFIobiksIFtjLCBzXSA9IGsoXG4gICAgbyAmJiBuLmdldEFjdGl2ZVN0eWxlcygpLnRleHRDb2xvciB8fCBcImRlZmF1bHRcIlxuICApLCBbZCwgYV0gPSBrKFxuICAgIHIgJiYgbi5nZXRBY3RpdmVTdHlsZXMoKS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJkZWZhdWx0XCJcbiAgKTtcbiAgVSgoKSA9PiB7XG4gICAgbyAmJiBzKG4uZ2V0QWN0aXZlU3R5bGVzKCkudGV4dENvbG9yIHx8IFwiZGVmYXVsdFwiKSwgciAmJiBhKFxuICAgICAgbi5nZXRBY3RpdmVTdHlsZXMoKS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9LCBuKTtcbiAgY29uc3QgdSA9IGcoXG4gICAgKGYpID0+IHtcbiAgICAgIGlmICghbylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUcmllZCB0byBzZXQgdGV4dCBjb2xvciwgYnV0IHN0eWxlIGRvZXMgbm90IGV4aXN0IGluIGVkaXRvciBzY2hlbWEuXCJcbiAgICAgICAgKTtcbiAgICAgIGYgPT09IFwiZGVmYXVsdFwiID8gbi5yZW1vdmVTdHlsZXMoeyB0ZXh0Q29sb3I6IGYgfSkgOiBuLmFkZFN0eWxlcyh7IHRleHRDb2xvcjogZiB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4uZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW24sIG9dXG4gICksIG0gPSBnKFxuICAgIChmKSA9PiB7XG4gICAgICBpZiAoIXIpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVHJpZWQgdG8gc2V0IGJhY2tncm91bmQgY29sb3IsIGJ1dCBzdHlsZSBkb2VzIG5vdCBleGlzdCBpbiBlZGl0b3Igc2NoZW1hLlwiXG4gICAgICAgICk7XG4gICAgICBmID09PSBcImRlZmF1bHRcIiA/IG4ucmVtb3ZlU3R5bGVzKHsgYmFja2dyb3VuZENvbG9yOiBmIH0pIDogbi5hZGRTdHlsZXMoeyBiYWNrZ3JvdW5kQ29sb3I6IGYgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBuLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtyLCBuXVxuICApO1xuICByZXR1cm4gIXgoKCkgPT4ge1xuICAgIGlmICghbyAmJiAhcilcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgbClcbiAgICAgIGlmIChmLmNvbnRlbnQgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfSwgW3IsIGwsIG9dKSB8fCAhbi5pc0VkaXRhYmxlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyB2KGUuR2VuZXJpYy5NZW51LlJvb3QsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaShlLkdlbmVyaWMuTWVudS5UcmlnZ2VyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIGUuRm9ybWF0dGluZ1Rvb2xiYXIuQnV0dG9uLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICAgIFwiZGF0YS10ZXN0XCI6IFwiY29sb3JzXCIsXG4gICAgICAgIGxhYmVsOiB0LmZvcm1hdHRpbmdfdG9vbGJhci5jb2xvcnMudG9vbHRpcCxcbiAgICAgICAgbWFpblRvb2x0aXA6IHQuZm9ybWF0dGluZ190b29sYmFyLmNvbG9ycy50b29sdGlwLFxuICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICB3ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IGMsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGQsXG4gICAgICAgICAgICBzaXplOiAyMFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICkgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICBlLkdlbmVyaWMuTWVudS5Ecm9wZG93bixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImJuLW1lbnUtZHJvcGRvd24gYm4tY29sb3ItcGlja2VyLWRyb3Bkb3duXCIsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICBtZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0OiBvID8ge1xuICAgICAgICAgICAgICBjb2xvcjogYyxcbiAgICAgICAgICAgICAgc2V0Q29sb3I6IHVcbiAgICAgICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiByID8ge1xuICAgICAgICAgICAgICBjb2xvcjogZCxcbiAgICAgICAgICAgICAgc2V0Q29sb3I6IG1cbiAgICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApXG4gIF0gfSk7XG59LCBYZSA9IChlKSA9PiB7XG4gIGZvciAoY29uc3QgdCBvZiBRdClcbiAgICBpZiAoZS5zdGFydHNXaXRoKHQpKVxuICAgICAgcmV0dXJuIGU7XG4gIHJldHVybiBgJHtlbn06Ly8ke2V9YDtcbn0sIFZ0ID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgeyB1cmw6IG8sIHRleHQ6IHIsIGVkaXRMaW5rOiBsLCBzaG93VGV4dEZpZWxkOiBjIH0gPSBlLCBbcywgZF0gPSBrKG8pLCBbYSwgdV0gPSBrKHIpO1xuICB5KCgpID0+IHtcbiAgICBkKG8pLCB1KHIpO1xuICB9LCBbciwgb10pO1xuICBjb25zdCBtID0gZyhcbiAgICAoSCkgPT4ge1xuICAgICAgSC5rZXkgPT09IFwiRW50ZXJcIiAmJiAoSC5wcmV2ZW50RGVmYXVsdCgpLCBsKFhlKHMpLCBhKSk7XG4gICAgfSxcbiAgICBbbCwgcywgYV1cbiAgKSwgaCA9IGcoXG4gICAgKEgpID0+IGQoSC5jdXJyZW50VGFyZ2V0LnZhbHVlKSxcbiAgICBbXVxuICApLCBmID0gZyhcbiAgICAoSCkgPT4gdShILmN1cnJlbnRUYXJnZXQudmFsdWUpLFxuICAgIFtdXG4gICksIHcgPSBnKFxuICAgICgpID0+IGwoWGUocyksIGEpLFxuICAgIFtsLCBzLCBhXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHYodC5HZW5lcmljLkZvcm0uUm9vdCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgdC5HZW5lcmljLkZvcm0uVGV4dElucHV0LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tdGV4dC1pbnB1dFwiLFxuICAgICAgICBuYW1lOiBcInVybFwiLFxuICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShDdCwge30pLFxuICAgICAgICBhdXRvRm9jdXM6ICEwLFxuICAgICAgICBwbGFjZWhvbGRlcjogbi5saW5rX3Rvb2xiYXIuZm9ybS51cmxfcGxhY2Vob2xkZXIsXG4gICAgICAgIHZhbHVlOiBzLFxuICAgICAgICBvbktleURvd246IG0sXG4gICAgICAgIG9uQ2hhbmdlOiBoLFxuICAgICAgICBvblN1Ym1pdDogd1xuICAgICAgfVxuICAgICksXG4gICAgYyAhPT0gITEgJiYgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICB0LkdlbmVyaWMuRm9ybS5UZXh0SW5wdXQsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJibi10ZXh0LWlucHV0XCIsXG4gICAgICAgIG5hbWU6IFwidGl0bGVcIixcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkoX2UsIHt9KSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IG4ubGlua190b29sYmFyLmZvcm0udGl0bGVfcGxhY2Vob2xkZXIsXG4gICAgICAgIHZhbHVlOiBhLFxuICAgICAgICBvbktleURvd246IG0sXG4gICAgICAgIG9uQ2hhbmdlOiBmLFxuICAgICAgICBvblN1Ym1pdDogd1xuICAgICAgfVxuICAgIClcbiAgXSB9KTtcbn07XG5mdW5jdGlvbiBGbyhlKSB7XG4gIHJldHVybiBcImxpbmtcIiBpbiBlLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hICYmIGUuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEubGluayA9PT0gXCJsaW5rXCI7XG59XG5jb25zdCBBbyA9ICgpID0+IHtcbiAgdmFyIGY7XG4gIGNvbnN0IGUgPSBiKCksIHQgPSBDKCksIG4gPSBNKCksIG8gPSBGbyhlKSwgciA9IFIoZSksIFtsLCBjXSA9IGsoITEpLCBbcywgZF0gPSBrKGUuZ2V0U2VsZWN0ZWRMaW5rVXJsKCkgfHwgXCJcIiksIFthLCB1XSA9IGsoZS5nZXRTZWxlY3RlZFRleHQoKSk7XG4gIFUoKCkgPT4ge1xuICAgIGMoITEpLCB1KGUuZ2V0U2VsZWN0ZWRUZXh0KCkgfHwgXCJcIiksIGQoZS5nZXRTZWxlY3RlZExpbmtVcmwoKSB8fCBcIlwiKTtcbiAgfSwgZSksIHkoKCkgPT4ge1xuICAgIHZhciBIO1xuICAgIGNvbnN0IHcgPSAoQikgPT4ge1xuICAgICAgKEIuY3RybEtleSB8fCBCLm1ldGFLZXkpICYmIEIua2V5ID09PSBcImtcIiAmJiAoYyghMCksIEIucHJldmVudERlZmF1bHQoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gKEggPSBlLnByb3NlbWlycm9yVmlldykgPT0gbnVsbCB8fCBILmRvbS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB3KSwgKCkgPT4ge1xuICAgICAgdmFyIEI7XG4gICAgICAoQiA9IGUucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsIHx8IEIuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHcpO1xuICAgIH07XG4gIH0sIFsoZiA9IGUucHJvc2VtaXJyb3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogZi5kb21dKTtcbiAgY29uc3QgbSA9IGcoXG4gICAgKHcpID0+IHtcbiAgICAgIGUuY3JlYXRlTGluayh3KSwgZS5mb2N1cygpO1xuICAgIH0sXG4gICAgW2VdXG4gICk7XG4gIHJldHVybiAheCgoKSA9PiB7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAoY29uc3QgdyBvZiByKVxuICAgICAgaWYgKHcuY29udGVudCA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICF0bihlLnByb3NlbWlycm9yU3RhdGUuc2VsZWN0aW9uKTtcbiAgfSwgW28sIHIsIGUucHJvc2VtaXJyb3JTdGF0ZS5zZWxlY3Rpb25dKSB8fCAhKFwibGlua1wiIGluIGUuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEpIHx8ICFlLmlzRWRpdGFibGUgPyBudWxsIDogLyogQF9fUFVSRV9fICovIHYodC5HZW5lcmljLlBvcG92ZXIuUm9vdCwgeyBvcGVuZWQ6IGwsIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGkodC5HZW5lcmljLlBvcG92ZXIuVHJpZ2dlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICB0LkZvcm1hdHRpbmdUb29sYmFyLkJ1dHRvbixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImJuLWJ1dHRvblwiLFxuICAgICAgICBcImRhdGEtdGVzdFwiOiBcImNyZWF0ZUxpbmtcIixcbiAgICAgICAgbGFiZWw6IG4uZm9ybWF0dGluZ190b29sYmFyLmxpbmsudG9vbHRpcCxcbiAgICAgICAgbWFpblRvb2x0aXA6IG4uZm9ybWF0dGluZ190b29sYmFyLmxpbmsudG9vbHRpcCxcbiAgICAgICAgc2Vjb25kYXJ5VG9vbHRpcDogY2UoXG4gICAgICAgICAgbi5mb3JtYXR0aW5nX3Rvb2xiYXIubGluay5zZWNvbmRhcnlfdG9vbHRpcCxcbiAgICAgICAgICBuLmdlbmVyaWMuY3RybF9zaG9ydGN1dFxuICAgICAgICApLFxuICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShDdCwge30pLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBjKCEwKVxuICAgICAgfVxuICAgICkgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICB0LkdlbmVyaWMuUG9wb3Zlci5Db250ZW50LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tcG9wb3Zlci1jb250ZW50IGJuLWZvcm0tcG9wb3ZlclwiLFxuICAgICAgICB2YXJpYW50OiBcImZvcm0tcG9wb3ZlclwiLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgVnQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXJsOiBzLFxuICAgICAgICAgICAgdGV4dDogYSxcbiAgICAgICAgICAgIGVkaXRMaW5rOiBtLFxuICAgICAgICAgICAgc2hvd1RleHRGaWVsZDogITFcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApXG4gIF0gfSk7XG59LCBHbyA9ICgpID0+IHtcbiAgY29uc3QgZSA9IE0oKSwgdCA9IEMoKSwgbiA9IGIoKSwgW28sIHJdID0gaygpLCBsID0gUihuKSwgYyA9IHgoKCkgPT4ge1xuICAgIGlmIChsLmxlbmd0aCAhPT0gMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gbFswXTtcbiAgICBpZiAoSihhLCBuKSlcbiAgICAgIHJldHVybiByKGEucHJvcHMuY2FwdGlvbiksIGE7XG4gIH0sIFtuLCBsXSksIHMgPSBnKFxuICAgIChhKSA9PiB7XG4gICAgICBjICYmIGEua2V5ID09PSBcIkVudGVyXCIgJiYgKGEucHJldmVudERlZmF1bHQoKSwgbi51cGRhdGVCbG9jayhjLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2FwdGlvbjogb1xuICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgW28sIG4sIGNdXG4gICksIGQgPSBnKFxuICAgIChhKSA9PiByKGEuY3VycmVudFRhcmdldC52YWx1ZSksXG4gICAgW11cbiAgKTtcbiAgcmV0dXJuICFjIHx8IFEoYywgbikgfHwgIW4uaXNFZGl0YWJsZSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gdih0LkdlbmVyaWMuUG9wb3Zlci5Sb290LCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGkodC5HZW5lcmljLlBvcG92ZXIuVHJpZ2dlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICB0LkZvcm1hdHRpbmdUb29sYmFyLkJ1dHRvbixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImJuLWJ1dHRvblwiLFxuICAgICAgICBsYWJlbDogZS5mb3JtYXR0aW5nX3Rvb2xiYXIuZmlsZV9jYXB0aW9uLnRvb2x0aXAsXG4gICAgICAgIG1haW5Ub29sdGlwOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2NhcHRpb24udG9vbHRpcCxcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkoamUsIHt9KSxcbiAgICAgICAgaXNTZWxlY3RlZDogYy5wcm9wcy5jYXB0aW9uICE9PSBcIlwiXG4gICAgICB9XG4gICAgKSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuR2VuZXJpYy5Qb3BvdmVyLkNvbnRlbnQsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1wb3BvdmVyLWNvbnRlbnQgYm4tZm9ybS1wb3BvdmVyXCIsXG4gICAgICAgIHZhcmlhbnQ6IFwiZm9ybS1wb3BvdmVyXCIsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuRm9ybS5Sb290LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICB0LkdlbmVyaWMuRm9ybS5UZXh0SW5wdXQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJmaWxlLWNhcHRpb25cIixcbiAgICAgICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKGplLCB7fSksXG4gICAgICAgICAgICB2YWx1ZTogbyB8fCBcIlwiLFxuICAgICAgICAgICAgYXV0b0ZvY3VzOiAhMCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2NhcHRpb24uaW5wdXRfcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbktleURvd246IHMsXG4gICAgICAgICAgICBvbkNoYW5nZTogZFxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KVxuICAgICAgfVxuICAgIClcbiAgXSB9KTtcbn0sIFVvID0gKCkgPT4ge1xuICBjb25zdCBlID0gTSgpLCB0ID0gQygpLCBuID0gYigpLCBvID0gUihuKSwgciA9IHgoKCkgPT4ge1xuICAgIGlmIChvLmxlbmd0aCAhPT0gMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjID0gb1swXTtcbiAgICBpZiAoSihjLCBuKSlcbiAgICAgIHJldHVybiBjO1xuICB9LCBbbiwgb10pLCBsID0gZygoKSA9PiB7XG4gICAgbi5mb2N1cygpLCBuLnJlbW92ZUJsb2Nrcyhbcl0pO1xuICB9LCBbbiwgcl0pO1xuICByZXR1cm4gIXIgfHwgUShyLCBuKSB8fCAhbi5pc0VkaXRhYmxlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuRm9ybWF0dGluZ1Rvb2xiYXIuQnV0dG9uLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1idXR0b25cIixcbiAgICAgIGxhYmVsOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2RlbGV0ZS50b29sdGlwW3IudHlwZV0gfHwgZS5mb3JtYXR0aW5nX3Rvb2xiYXIuZmlsZV9kZWxldGUudG9vbHRpcC5maWxlLFxuICAgICAgbWFpblRvb2x0aXA6IGUuZm9ybWF0dGluZ190b29sYmFyLmZpbGVfZGVsZXRlLnRvb2x0aXBbci50eXBlXSB8fCBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2RlbGV0ZS50b29sdGlwLmZpbGUsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaSh3bywge30pLFxuICAgICAgb25DbGljazogbFxuICAgIH1cbiAgKTtcbn0sIHpvID0gKCkgPT4ge1xuICBjb25zdCBlID0gTSgpLCB0ID0gQygpLCBuID0gYigpLCBbbywgcl0gPSBrKCksIGwgPSBSKG4pLCBjID0geCgoKSA9PiB7XG4gICAgaWYgKGwubGVuZ3RoICE9PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBsWzBdO1xuICAgIGlmIChKKGEsIG4pKVxuICAgICAgcmV0dXJuIHIoYS5wcm9wcy5uYW1lKSwgYTtcbiAgfSwgW24sIGxdKSwgcyA9IGcoXG4gICAgKGEpID0+IHtcbiAgICAgIGMgJiYgYS5rZXkgPT09IFwiRW50ZXJcIiAmJiAoYS5wcmV2ZW50RGVmYXVsdCgpLCBuLnVwZGF0ZUJsb2NrKGMsIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBuYW1lOiBvXG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBbbywgbiwgY11cbiAgKSwgZCA9IGcoXG4gICAgKGEpID0+IHIoYS5jdXJyZW50VGFyZ2V0LnZhbHVlKSxcbiAgICBbXVxuICApO1xuICByZXR1cm4gIWMgfHwgUShjLCBuKSB8fCAhbi5pc0VkaXRhYmxlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyB2KHQuR2VuZXJpYy5Qb3BvdmVyLlJvb3QsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuUG9wb3Zlci5UcmlnZ2VyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuRm9ybWF0dGluZ1Rvb2xiYXIuQnV0dG9uLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICAgIGxhYmVsOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX3JlbmFtZS50b29sdGlwW2MudHlwZV0gfHwgZS5mb3JtYXR0aW5nX3Rvb2xiYXIuZmlsZV9yZW5hbWUudG9vbHRpcC5maWxlLFxuICAgICAgICBtYWluVG9vbHRpcDogZS5mb3JtYXR0aW5nX3Rvb2xiYXIuZmlsZV9yZW5hbWUudG9vbHRpcFtjLnR5cGVdIHx8IGUuZm9ybWF0dGluZ190b29sYmFyLmZpbGVfcmVuYW1lLnRvb2x0aXAuZmlsZSxcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkoemUsIHt9KVxuICAgICAgfVxuICAgICkgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICB0LkdlbmVyaWMuUG9wb3Zlci5Db250ZW50LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tcG9wb3Zlci1jb250ZW50IGJuLWZvcm0tcG9wb3ZlclwiLFxuICAgICAgICB2YXJpYW50OiBcImZvcm0tcG9wb3ZlclwiLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkodC5HZW5lcmljLkZvcm0uUm9vdCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgdC5HZW5lcmljLkZvcm0uVGV4dElucHV0LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiZmlsZS1uYW1lXCIsXG4gICAgICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaSh6ZSwge30pLFxuICAgICAgICAgICAgdmFsdWU6IG8gfHwgXCJcIixcbiAgICAgICAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogZS5mb3JtYXR0aW5nX3Rvb2xiYXIuZmlsZV9yZW5hbWUuaW5wdXRfcGxhY2Vob2xkZXJbYy50eXBlXSB8fCBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX3JlbmFtZS5pbnB1dF9wbGFjZWhvbGRlci5maWxlLFxuICAgICAgICAgICAgb25LZXlEb3duOiBzLFxuICAgICAgICAgICAgb25DaGFuZ2U6IGRcbiAgICAgICAgICB9XG4gICAgICAgICkgfSlcbiAgICAgIH1cbiAgICApXG4gIF0gfSk7XG59LCBqbyA9ICgpID0+IHtcbiAgY29uc3QgZSA9IE0oKSwgdCA9IEMoKSwgbiA9IGIoKSwgbyA9IFIobiksIFtyLCBsXSA9IGsoITEpO1xuICB5KCgpID0+IHtcbiAgICBsKCExKTtcbiAgfSwgW29dKTtcbiAgY29uc3QgYyA9IG8ubGVuZ3RoID09PSAxID8gb1swXSA6IHZvaWQgMDtcbiAgcmV0dXJuIGMgPT09IHZvaWQgMCB8fCAhSihjLCBuKSB8fCAhbi5pc0VkaXRhYmxlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyB2KHQuR2VuZXJpYy5Qb3BvdmVyLlJvb3QsIHsgb3BlbmVkOiByLCBwb3NpdGlvbjogXCJib3R0b21cIiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuUG9wb3Zlci5UcmlnZ2VyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuRm9ybWF0dGluZ1Rvb2xiYXIuQnV0dG9uLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IGwoIXIpLFxuICAgICAgICBpc1NlbGVjdGVkOiByLFxuICAgICAgICBtYWluVG9vbHRpcDogZS5mb3JtYXR0aW5nX3Rvb2xiYXIuZmlsZV9yZXBsYWNlLnRvb2x0aXBbYy50eXBlXSB8fCBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX3JlcGxhY2UudG9vbHRpcC5maWxlLFxuICAgICAgICBsYWJlbDogZS5mb3JtYXR0aW5nX3Rvb2xiYXIuZmlsZV9yZXBsYWNlLnRvb2x0aXBbYy50eXBlXSB8fCBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX3JlcGxhY2UudG9vbHRpcC5maWxlLFxuICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShibywge30pXG4gICAgICB9XG4gICAgKSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuR2VuZXJpYy5Qb3BvdmVyLkNvbnRlbnQsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1wb3BvdmVyLWNvbnRlbnQgYm4tcGFuZWwtcG9wb3ZlclwiLFxuICAgICAgICB2YXJpYW50OiBcInBhbmVsLXBvcG92ZXJcIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKEJ0LCB7IGJsb2NrOiBjIH0pXG4gICAgICB9XG4gICAgKVxuICBdIH0pO1xufSwgV28gPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBNKCksIHQgPSBDKCksIG4gPSBiKCksIG8gPSBSKG4pLCBbciwgbF0gPSBrKFxuICAgICgpID0+IG4uY2FuTmVzdEJsb2NrKClcbiAgKTtcbiAgVSgoKSA9PiB7XG4gICAgbChuLmNhbk5lc3RCbG9jaygpKTtcbiAgfSwgbik7XG4gIGNvbnN0IGMgPSBnKCgpID0+IHtcbiAgICBuLmZvY3VzKCksIG4ubmVzdEJsb2NrKCk7XG4gIH0sIFtuXSk7XG4gIHJldHVybiAheCgoKSA9PiAhby5maW5kKFxuICAgIChkKSA9PiBuLnNjaGVtYS5ibG9ja1NjaGVtYVtkLnR5cGVdLmNvbnRlbnQgIT09IFwiaW5saW5lXCJcbiAgKSwgW24uc2NoZW1hLmJsb2NrU2NoZW1hLCBvXSkgfHwgIW4uaXNFZGl0YWJsZSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICB0LkZvcm1hdHRpbmdUb29sYmFyLkJ1dHRvbixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICBcImRhdGEtdGVzdFwiOiBcIm5lc3RCbG9ja1wiLFxuICAgICAgb25DbGljazogYyxcbiAgICAgIGlzRGlzYWJsZWQ6ICFyLFxuICAgICAgbGFiZWw6IGUuZm9ybWF0dGluZ190b29sYmFyLm5lc3QudG9vbHRpcCxcbiAgICAgIG1haW5Ub29sdGlwOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5uZXN0LnRvb2x0aXAsXG4gICAgICBzZWNvbmRhcnlUb29sdGlwOiBjZShcbiAgICAgICAgZS5mb3JtYXR0aW5nX3Rvb2xiYXIubmVzdC5zZWNvbmRhcnlfdG9vbHRpcCxcbiAgICAgICAgZS5nZW5lcmljLmN0cmxfc2hvcnRjdXRcbiAgICAgICksXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShpbywge30pXG4gICAgfVxuICApO1xufSwgJG8gPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBNKCksIHQgPSBDKCksIG4gPSBiKCksIG8gPSBSKG4pLCBbciwgbF0gPSBrKFxuICAgICgpID0+IG4uY2FuVW5uZXN0QmxvY2soKVxuICApO1xuICBVKCgpID0+IHtcbiAgICBsKG4uY2FuVW5uZXN0QmxvY2soKSk7XG4gIH0sIG4pO1xuICBjb25zdCBjID0gZygoKSA9PiB7XG4gICAgbi5mb2N1cygpLCBuLnVubmVzdEJsb2NrKCk7XG4gIH0sIFtuXSk7XG4gIHJldHVybiAheCgoKSA9PiAhby5maW5kKFxuICAgIChkKSA9PiBuLnNjaGVtYS5ibG9ja1NjaGVtYVtkLnR5cGVdLmNvbnRlbnQgIT09IFwiaW5saW5lXCJcbiAgKSwgW24uc2NoZW1hLmJsb2NrU2NoZW1hLCBvXSkgfHwgIW4uaXNFZGl0YWJsZSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICB0LkZvcm1hdHRpbmdUb29sYmFyLkJ1dHRvbixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICBcImRhdGEtdGVzdFwiOiBcInVubmVzdEJsb2NrXCIsXG4gICAgICBvbkNsaWNrOiBjLFxuICAgICAgaXNEaXNhYmxlZDogIXIsXG4gICAgICBsYWJlbDogZS5mb3JtYXR0aW5nX3Rvb2xiYXIudW5uZXN0LnRvb2x0aXAsXG4gICAgICBtYWluVG9vbHRpcDogZS5mb3JtYXR0aW5nX3Rvb2xiYXIudW5uZXN0LnRvb2x0aXAsXG4gICAgICBzZWNvbmRhcnlUb29sdGlwOiBjZShcbiAgICAgICAgZS5mb3JtYXR0aW5nX3Rvb2xiYXIudW5uZXN0LnNlY29uZGFyeV90b29sdGlwLFxuICAgICAgICBlLmdlbmVyaWMuY3RybF9zaG9ydGN1dFxuICAgICAgKSxcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKHJvLCB7fSlcbiAgICB9XG4gICk7XG59LCBxbyA9IChlKSA9PiBbXG4gIHtcbiAgICBuYW1lOiBlLnNsYXNoX21lbnUucGFyYWdyYXBoLnRpdGxlLFxuICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgaWNvbjogX2UsXG4gICAgaXNTZWxlY3RlZDogKHQpID0+IHQudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIlxuICB9LFxuICB7XG4gICAgbmFtZTogZS5zbGFzaF9tZW51LmhlYWRpbmcudGl0bGUsXG4gICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgcHJvcHM6IHsgbGV2ZWw6IDEgfSxcbiAgICBpY29uOiBmdCxcbiAgICBpc1NlbGVjdGVkOiAodCkgPT4gdC50eXBlID09PSBcImhlYWRpbmdcIiAmJiBcImxldmVsXCIgaW4gdC5wcm9wcyAmJiB0LnByb3BzLmxldmVsID09PSAxXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlLnNsYXNoX21lbnUuaGVhZGluZ18yLnRpdGxlLFxuICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgIHByb3BzOiB7IGxldmVsOiAyIH0sXG4gICAgaWNvbjogZ3QsXG4gICAgaXNTZWxlY3RlZDogKHQpID0+IHQudHlwZSA9PT0gXCJoZWFkaW5nXCIgJiYgXCJsZXZlbFwiIGluIHQucHJvcHMgJiYgdC5wcm9wcy5sZXZlbCA9PT0gMlxuICB9LFxuICB7XG4gICAgbmFtZTogZS5zbGFzaF9tZW51LmhlYWRpbmdfMy50aXRsZSxcbiAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICBwcm9wczogeyBsZXZlbDogMyB9LFxuICAgIGljb246IGJ0LFxuICAgIGlzU2VsZWN0ZWQ6ICh0KSA9PiB0LnR5cGUgPT09IFwiaGVhZGluZ1wiICYmIFwibGV2ZWxcIiBpbiB0LnByb3BzICYmIHQucHJvcHMubGV2ZWwgPT09IDNcbiAgfSxcbiAge1xuICAgIG5hbWU6IGUuc2xhc2hfbWVudS5xdW90ZS50aXRsZSxcbiAgICB0eXBlOiBcInF1b3RlXCIsXG4gICAgaWNvbjogdnQsXG4gICAgaXNTZWxlY3RlZDogKHQpID0+IHQudHlwZSA9PT0gXCJxdW90ZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlLnNsYXNoX21lbnUuYnVsbGV0X2xpc3QudGl0bGUsXG4gICAgdHlwZTogXCJidWxsZXRMaXN0SXRlbVwiLFxuICAgIGljb246IHd0LFxuICAgIGlzU2VsZWN0ZWQ6ICh0KSA9PiB0LnR5cGUgPT09IFwiYnVsbGV0TGlzdEl0ZW1cIlxuICB9LFxuICB7XG4gICAgbmFtZTogZS5zbGFzaF9tZW51Lm51bWJlcmVkX2xpc3QudGl0bGUsXG4gICAgdHlwZTogXCJudW1iZXJlZExpc3RJdGVtXCIsXG4gICAgaWNvbjoga3QsXG4gICAgaXNTZWxlY3RlZDogKHQpID0+IHQudHlwZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGUuc2xhc2hfbWVudS5jaGVja19saXN0LnRpdGxlLFxuICAgIHR5cGU6IFwiY2hlY2tMaXN0SXRlbVwiLFxuICAgIGljb246IHB0LFxuICAgIGlzU2VsZWN0ZWQ6ICh0KSA9PiB0LnR5cGUgPT09IFwiY2hlY2tMaXN0SXRlbVwiXG4gIH1cbl0sIEtvID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgbyA9IGIoKSwgciA9IFIobyksIFtsLCBjXSA9IGsoby5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jayksIHMgPSB4KCgpID0+IChlLml0ZW1zIHx8IHFvKG4pKS5maWx0ZXIoXG4gICAgKHUpID0+IHUudHlwZSBpbiBvLnNjaGVtYS5ibG9ja1NjaGVtYVxuICApLCBbbywgbiwgZS5pdGVtc10pLCBkID0geChcbiAgICAoKSA9PiBzLmZpbmQoKHUpID0+IHUudHlwZSA9PT0gbC50eXBlKSAhPT0gdm9pZCAwLFxuICAgIFtsLnR5cGUsIHNdXG4gICksIGEgPSB4KCgpID0+IHtcbiAgICBjb25zdCB1ID0gKG0pID0+IHtcbiAgICAgIG8uZm9jdXMoKTtcbiAgICAgIGZvciAoY29uc3QgaCBvZiByKVxuICAgICAgICBvLnVwZGF0ZUJsb2NrKGgsIHtcbiAgICAgICAgICB0eXBlOiBtLnR5cGUsXG4gICAgICAgICAgcHJvcHM6IG0ucHJvcHNcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gcy5tYXAoKG0pID0+IHtcbiAgICAgIGNvbnN0IGggPSBtLmljb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBtLm5hbWUsXG4gICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKGgsIHsgc2l6ZTogMTYgfSksXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHUobSksXG4gICAgICAgIGlzU2VsZWN0ZWQ6IG0uaXNTZWxlY3RlZChsKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW2wsIHMsIG8sIHJdKTtcbiAgcmV0dXJuIFUoKCkgPT4ge1xuICAgIGMoby5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jayk7XG4gIH0sIG8pLCAhZCB8fCAhby5pc0VkaXRhYmxlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuRm9ybWF0dGluZ1Rvb2xiYXIuU2VsZWN0LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1zZWxlY3RcIixcbiAgICAgIGl0ZW1zOiBhXG4gICAgfVxuICApO1xufSwgWG8gPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBNKCksIHQgPSBDKCksIG4gPSBiKCksIG8gPSBnKCgpID0+IHtcbiAgICB2YXIgcjtcbiAgICAociA9IG4uY29tbWVudHMpID09IG51bGwgfHwgci5zdGFydFBlbmRpbmdDb21tZW50KCksIG4uZm9ybWF0dGluZ1Rvb2xiYXIuY2xvc2VNZW51KCk7XG4gIH0sIFtuXSk7XG4gIHJldHVybiBuLmNvbW1lbnRzID8gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5Gb3JtYXR0aW5nVG9vbGJhci5CdXR0b24sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWJ1dHRvblwiLFxuICAgICAgbGFiZWw6IGUuZm9ybWF0dGluZ190b29sYmFyLmNvbW1lbnQudG9vbHRpcCxcbiAgICAgIG1haW5Ub29sdGlwOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5jb21tZW50LnRvb2x0aXAsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShodCwge30pLFxuICAgICAgb25DbGljazogb1xuICAgIH1cbiAgKSA6IG51bGw7XG59LCBZbyA9ICgpID0+IHtcbiAgY29uc3QgZSA9IE0oKSwgdCA9IEMoKSwgbiA9IGIoKSwgbyA9IGcoKCkgPT4ge1xuICAgIG4uX3RpcHRhcEVkaXRvci5jaGFpbigpLmZvY3VzKCkuYWRkUGVuZGluZ0NvbW1lbnQoKS5ydW4oKTtcbiAgfSwgW25dKTtcbiAgcmV0dXJuIChcbiAgICAvLyBXZSBtYW51YWxseSBjaGVjayBpZiBhIGNvbW1lbnQgZXh0ZW5zaW9uIChsaWtlIGxpdmVibG9ja3MpIGlzIGluc3RhbGxlZFxuICAgIC8vIEJ5IGFkZGluZyBkZWZhdWx0IHN1cHBvcnQgZm9yIHRoaXMsIHRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBjdXN0b21pemUgdGhlIGZvcm1hdHRpbmcgdG9vbGJhclxuICAgICFuLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuYWRkUGVuZGluZ0NvbW1lbnQgfHwgIW4uaXNFZGl0YWJsZSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuRm9ybWF0dGluZ1Rvb2xiYXIuQnV0dG9uLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICAgIGxhYmVsOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5jb21tZW50LnRvb2x0aXAsXG4gICAgICAgIG1haW5Ub29sdGlwOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5jb21tZW50LnRvb2x0aXAsXG4gICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKGh0LCB7fSksXG4gICAgICAgIG9uQ2xpY2s6IG9cbiAgICAgIH1cbiAgICApXG4gICk7XG59O1xuZnVuY3Rpb24gdmUoZSwgdCkge1xuICB0cnkge1xuICAgIGNvbnN0IG4gPSBuZXcgVVJMKGUsIHQpO1xuICAgIGlmIChuLnByb3RvY29sICE9PSBcImphdmFzY3JpcHQ6XCIpXG4gICAgICByZXR1cm4gbi5ocmVmO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gXCIjXCI7XG59XG5jb25zdCBKbyA9ICgpID0+IHtcbiAgY29uc3QgZSA9IE0oKSwgdCA9IEMoKSwgbiA9IGIoKSwgbyA9IFIobiksIHIgPSB4KCgpID0+IHtcbiAgICBpZiAoby5sZW5ndGggIT09IDEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYyA9IG9bMF07XG4gICAgaWYgKEooYywgbikpXG4gICAgICByZXR1cm4gYztcbiAgfSwgW24sIG9dKSwgbCA9IGcoKCkgPT4ge1xuICAgIHIgJiYgci5wcm9wcy51cmwgJiYgKG4uZm9jdXMoKSwgbi5yZXNvbHZlRmlsZVVybCA/IG4ucmVzb2x2ZUZpbGVVcmwoci5wcm9wcy51cmwpLnRoZW4oXG4gICAgICAoYykgPT4gd2luZG93Lm9wZW4odmUoYywgd2luZG93LmxvY2F0aW9uLmhyZWYpKVxuICAgICkgOiB3aW5kb3cub3Blbih2ZShyLnByb3BzLnVybCwgd2luZG93LmxvY2F0aW9uLmhyZWYpKSk7XG4gIH0sIFtuLCByXSk7XG4gIHJldHVybiAhciB8fCBRKHIsIG4pID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuRm9ybWF0dGluZ1Rvb2xiYXIuQnV0dG9uLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1idXR0b25cIixcbiAgICAgIGxhYmVsOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2Rvd25sb2FkLnRvb2x0aXBbci50eXBlXSB8fCBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2Rvd25sb2FkLnRvb2x0aXAuZmlsZSxcbiAgICAgIG1haW5Ub29sdGlwOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2Rvd25sb2FkLnRvb2x0aXBbci50eXBlXSB8fCBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX2Rvd25sb2FkLnRvb2x0aXAuZmlsZSxcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKEhvLCB7fSksXG4gICAgICBvbkNsaWNrOiBsXG4gICAgfVxuICApO1xufSwgUW8gPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBNKCksIHQgPSBDKCksIG4gPSBiKCksIG8gPSBSKG4pLCByID0geCgoKSA9PiB7XG4gICAgaWYgKG8ubGVuZ3RoICE9PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGMgPSBvWzBdO1xuICAgIGlmIChubihjLCBuKSlcbiAgICAgIHJldHVybiBjO1xuICB9LCBbbiwgb10pLCBsID0gZygoKSA9PiB7XG4gICAgciAmJiBuLnVwZGF0ZUJsb2NrKHIsIHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNob3dQcmV2aWV3OiAhci5wcm9wcy5zaG93UHJldmlld1xuICAgICAgICAvLyBUT0RPXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtuLCByXSk7XG4gIHJldHVybiAhciB8fCBRKHIsIG4pIHx8ICFuLmlzRWRpdGFibGUgPyBudWxsIDogLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5Gb3JtYXR0aW5nVG9vbGJhci5CdXR0b24sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWJ1dHRvblwiLFxuICAgICAgbGFiZWw6IFwiVG9nZ2xlIHByZXZpZXdcIixcbiAgICAgIG1haW5Ub29sdGlwOiBlLmZvcm1hdHRpbmdfdG9vbGJhci5maWxlX3ByZXZpZXdfdG9nZ2xlLnRvb2x0aXAsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gaShnbywge30pLFxuICAgICAgaXNTZWxlY3RlZDogci5wcm9wcy5zaG93UHJldmlldyxcbiAgICAgIG9uQ2xpY2s6IGxcbiAgICB9XG4gICk7XG59LCBlciA9ICgpID0+IHtcbiAgY29uc3QgZSA9IE0oKSwgdCA9IEMoKSwgbiA9IGIoKSwgbyA9IFIobiksIHIgPSB4KCgpID0+IHtcbiAgICB2YXIgcztcbiAgICBpZiAoby5sZW5ndGggIT09IDEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYyA9IG9bMF07XG4gICAgaWYgKGMudHlwZSA9PT0gXCJ0YWJsZVwiKVxuICAgICAgcmV0dXJuIChzID0gbi50YWJsZUhhbmRsZXMpID09IG51bGwgPyB2b2lkIDAgOiBzLmdldE1lcmdlRGlyZWN0aW9uKGMpO1xuICB9LCBbbiwgb10pLCBsID0gZygoKSA9PiB7XG4gICAgdmFyIGM7XG4gICAgKGMgPSBuLnRhYmxlSGFuZGxlcykgPT0gbnVsbCB8fCBjLm1lcmdlQ2VsbHMoKTtcbiAgfSwgW25dKTtcbiAgcmV0dXJuICFuLmlzRWRpdGFibGUgfHwgciA9PT0gdm9pZCAwIHx8ICFuLnNldHRpbmdzLnRhYmxlcy5zcGxpdENlbGxzID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuRm9ybWF0dGluZ1Rvb2xiYXIuQnV0dG9uLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1idXR0b25cIixcbiAgICAgIGxhYmVsOiBlLmZvcm1hdHRpbmdfdG9vbGJhci50YWJsZV9jZWxsX21lcmdlLnRvb2x0aXAsXG4gICAgICBtYWluVG9vbHRpcDogZS5mb3JtYXR0aW5nX3Rvb2xiYXIudGFibGVfY2VsbF9tZXJnZS50b29sdGlwLFxuICAgICAgaWNvbjogciA9PT0gXCJob3Jpem9udGFsXCIgPyAvKiBAX19QVVJFX18gKi8gaShhbywge30pIDogLyogQF9fUFVSRV9fICovIGkoc28sIHt9KSxcbiAgICAgIG9uQ2xpY2s6IGxcbiAgICB9XG4gICk7XG59LCB0ciA9IHtcbiAgbGVmdDogZW8sXG4gIGNlbnRlcjogSm4sXG4gIHJpZ2h0OiB0byxcbiAganVzdGlmeTogUW5cbn0sIGJlID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgbyA9IGIoKSwgciA9IFIobyksIGwgPSB4KCgpID0+IHtcbiAgICB2YXIgdTtcbiAgICBjb25zdCBhID0gclswXTtcbiAgICBpZiAoa2UoXCJ0ZXh0QWxpZ25tZW50XCIsIGEsIG8pKVxuICAgICAgcmV0dXJuIGEucHJvcHMudGV4dEFsaWdubWVudDtcbiAgICBpZiAoYS50eXBlID09PSBcInRhYmxlXCIpIHtcbiAgICAgIGNvbnN0IG0gPSAodSA9IG8udGFibGVIYW5kbGVzKSA9PSBudWxsID8gdm9pZCAwIDogdS5nZXRDZWxsU2VsZWN0aW9uKCk7XG4gICAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGggPSBtLmNlbGxzLm1hcChcbiAgICAgICAgKHsgcm93OiB3LCBjb2w6IEggfSkgPT4gSyhcbiAgICAgICAgICBhLmNvbnRlbnQucm93c1t3XS5jZWxsc1tIXVxuICAgICAgICApLnByb3BzLnRleHRBbGlnbm1lbnRcbiAgICAgICksIGYgPSBoWzBdO1xuICAgICAgaWYgKGguZXZlcnkoKHcpID0+IHcgPT09IGYpKVxuICAgICAgICByZXR1cm4gZjtcbiAgICB9XG4gIH0sIFtvLCByXSksIGMgPSBnKFxuICAgIChhKSA9PiB7XG4gICAgICB2YXIgdTtcbiAgICAgIG8uZm9jdXMoKTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiByKVxuICAgICAgICBpZiAocShcInRleHRBbGlnbm1lbnRcIiwgbS50eXBlLCBvKSlcbiAgICAgICAgICBvLnVwZGF0ZUJsb2NrKG0sIHtcbiAgICAgICAgICAgIHByb3BzOiB7IHRleHRBbGlnbm1lbnQ6IGEgfVxuICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChtLnR5cGUgPT09IFwidGFibGVcIikge1xuICAgICAgICAgIGNvbnN0IGggPSAodSA9IG8udGFibGVIYW5kbGVzKSA9PSBudWxsID8gdm9pZCAwIDogdS5nZXRDZWxsU2VsZWN0aW9uKCk7XG4gICAgICAgICAgaWYgKCFoKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgZiA9IG0uY29udGVudC5yb3dzLm1hcChcbiAgICAgICAgICAgICh3KSA9PiAoe1xuICAgICAgICAgICAgICAuLi53LFxuICAgICAgICAgICAgICBjZWxsczogdy5jZWxscy5tYXAoKEgpID0+IEsoSCkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaC5jZWxscy5mb3JFYWNoKCh7IHJvdzogdywgY29sOiBIIH0pID0+IHtcbiAgICAgICAgICAgIGZbd10uY2VsbHNbSF0ucHJvcHMudGV4dEFsaWdubWVudCA9IGE7XG4gICAgICAgICAgfSksIG8udXBkYXRlQmxvY2sobSwge1xuICAgICAgICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAuLi5tLmNvbnRlbnQsXG4gICAgICAgICAgICAgIHR5cGU6IFwidGFibGVDb250ZW50XCIsXG4gICAgICAgICAgICAgIHJvd3M6IGZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgby5zZXRUZXh0Q3Vyc29yUG9zaXRpb24obSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFtvLCByXVxuICApO1xuICBpZiAoIXgoKCkgPT4gISFyLmZpbmQoXG4gICAgKGEpID0+IFwidGV4dEFsaWdubWVudFwiIGluIGEucHJvcHMgfHwgYS50eXBlID09PSBcInRhYmxlXCIgJiYgYS5jaGlsZHJlblxuICApLCBbcl0pIHx8ICFvLmlzRWRpdGFibGUpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGQgPSB0cltlLnRleHRBbGlnbm1lbnRdO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5Gb3JtYXR0aW5nVG9vbGJhci5CdXR0b24sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWJ1dHRvblwiLFxuICAgICAgXCJkYXRhLXRlc3RcIjogYGFsaWduVGV4dCR7ZS50ZXh0QWxpZ25tZW50LnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBlLnRleHRBbGlnbm1lbnQuc2xpY2UoMSl9YCxcbiAgICAgIG9uQ2xpY2s6ICgpID0+IGMoZS50ZXh0QWxpZ25tZW50KSxcbiAgICAgIGlzU2VsZWN0ZWQ6IGwgPT09IGUudGV4dEFsaWdubWVudCxcbiAgICAgIGxhYmVsOiBuLmZvcm1hdHRpbmdfdG9vbGJhcltgYWxpZ25fJHtlLnRleHRBbGlnbm1lbnR9YF0udG9vbHRpcCxcbiAgICAgIG1haW5Ub29sdGlwOiBuLmZvcm1hdHRpbmdfdG9vbGJhcltgYWxpZ25fJHtlLnRleHRBbGlnbm1lbnR9YF0udG9vbHRpcCxcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKGQsIHt9KVxuICAgIH1cbiAgKTtcbn0sIG5yID0gKGUpID0+IFtcbiAgLyogQF9fUFVSRV9fICovIGkoS28sIHsgaXRlbXM6IGUgfSwgXCJibG9ja1R5cGVTZWxlY3RcIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBpKGVyLCB7fSwgXCJ0YWJsZUNlbGxNZXJnZUJ1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIGkoR28sIHt9LCBcImZpbGVDYXB0aW9uQnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gaShqbywge30sIFwicmVwbGFjZUZpbGVCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBpKHpvLCB7fSwgXCJmaWxlUmVuYW1lQnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gaShVbywge30sIFwiZmlsZURlbGV0ZUJ1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIGkoSm8sIHt9LCBcImZpbGVEb3dubG9hZEJ1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIGkoUW8sIHt9LCBcImZpbGVQcmV2aWV3QnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gaShuZSwgeyBiYXNpY1RleHRTdHlsZTogXCJib2xkXCIgfSwgXCJib2xkU3R5bGVCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBpKG5lLCB7IGJhc2ljVGV4dFN0eWxlOiBcIml0YWxpY1wiIH0sIFwiaXRhbGljU3R5bGVCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIG5lLFxuICAgIHtcbiAgICAgIGJhc2ljVGV4dFN0eWxlOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcInVuZGVybGluZVN0eWxlQnV0dG9uXCJcbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGkobmUsIHsgYmFzaWNUZXh0U3R5bGU6IFwic3RyaWtlXCIgfSwgXCJzdHJpa2VTdHlsZUJ1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIGkoYmUsIHsgdGV4dEFsaWdubWVudDogXCJsZWZ0XCIgfSwgXCJ0ZXh0QWxpZ25MZWZ0QnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gaShiZSwgeyB0ZXh0QWxpZ25tZW50OiBcImNlbnRlclwiIH0sIFwidGV4dEFsaWduQ2VudGVyQnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gaShiZSwgeyB0ZXh0QWxpZ25tZW50OiBcInJpZ2h0XCIgfSwgXCJ0ZXh0QWxpZ25SaWdodEJ1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIGkoWm8sIHt9LCBcImNvbG9yU3R5bGVCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBpKFdvLCB7fSwgXCJuZXN0QmxvY2tCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBpKCRvLCB7fSwgXCJ1bm5lc3RCbG9ja0J1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIGkoQW8sIHt9LCBcImNyZWF0ZUxpbmtCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBpKFhvLCB7fSwgXCJhZGRDb21tZW50QnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gaShZbywge30sIFwiYWRkVGlwdGFwQ29tbWVudEJ1dHRvblwiKVxuXSwgU3QgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gQygpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5Gb3JtYXR0aW5nVG9vbGJhci5Sb290LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi10b29sYmFyIGJuLWZvcm1hdHRpbmctdG9vbGJhclwiLFxuICAgICAgY2hpbGRyZW46IGUuY2hpbGRyZW4gfHwgbnIoZS5ibG9ja1R5cGVTZWxlY3RJdGVtcylcbiAgICB9XG4gICk7XG59LCBZZSA9IChlKSA9PiB7XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByZXR1cm4gXCJ0b3Atc3RhcnRcIjtcbiAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICByZXR1cm4gXCJ0b3BcIjtcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHJldHVybiBcInRvcC1lbmRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwidG9wLXN0YXJ0XCI7XG4gIH1cbn0sIG9yID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IF8obnVsbCksIG4gPSBiKCksIFtvLCByXSA9IGsoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgaCA9IG4uZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2s7XG4gICAgICByZXR1cm4gXCJ0ZXh0QWxpZ25tZW50XCIgaW4gaC5wcm9wcyA/IFllKFxuICAgICAgICBoLnByb3BzLnRleHRBbGlnbm1lbnRcbiAgICAgICkgOiBcInRvcC1zdGFydFwiO1xuICAgIH1cbiAgKTtcbiAgVSgoKSA9PiB7XG4gICAgY29uc3QgaCA9IG4uZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2s7XG4gICAgXCJ0ZXh0QWxpZ25tZW50XCIgaW4gaC5wcm9wcyA/IHIoXG4gICAgICBZZShcbiAgICAgICAgaC5wcm9wcy50ZXh0QWxpZ25tZW50XG4gICAgICApXG4gICAgKSA6IHIoXCJ0b3Atc3RhcnRcIik7XG4gIH0sIG4pO1xuICBjb25zdCBsID0gUChcbiAgICBuLmZvcm1hdHRpbmdUb29sYmFyLm9uVXBkYXRlLmJpbmQobi5mb3JtYXR0aW5nVG9vbGJhcilcbiAgKSwgeyBpc01vdW50ZWQ6IGMsIHJlZjogcywgc3R5bGU6IGQsIGdldEZsb2F0aW5nUHJvcHM6IGEgfSA9IEcoXG4gICAgKGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwuc2hvdykgfHwgITEsXG4gICAgKGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwucmVmZXJlbmNlUG9zKSB8fCBudWxsLFxuICAgIDNlMyxcbiAgICB7XG4gICAgICBwbGFjZW1lbnQ6IG8sXG4gICAgICBtaWRkbGV3YXJlOiBbQSgxMCksIGxlKCksIFcoKV0sXG4gICAgICBvbk9wZW5DaGFuZ2U6IChoLCBmKSA9PiB7XG4gICAgICAgIGggfHwgKG4uZm9ybWF0dGluZ1Rvb2xiYXIuY2xvc2VNZW51KCksIG4uZm9jdXMoKSk7XG4gICAgICB9LFxuICAgICAgLi4uZS5mbG9hdGluZ09wdGlvbnNcbiAgICB9XG4gICksIHUgPSB4KCgpID0+IFBvKFt0LCBzXSksIFt0LCBzXSk7XG4gIGlmICghYyB8fCAhbClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKCFsLnNob3cgJiYgdC5jdXJyZW50KVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogdSxcbiAgICAgICAgc3R5bGU6IGQsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogdC5jdXJyZW50LmlubmVySFRNTCB9XG4gICAgICB9XG4gICAgKTtcbiAgY29uc3QgbSA9IGUuZm9ybWF0dGluZ1Rvb2xiYXIgfHwgU3Q7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IHJlZjogdSwgc3R5bGU6IGQsIC4uLmEoKSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKG0sIHt9KSB9KTtcbn0sIHJyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuTGlua1Rvb2xiYXIuQnV0dG9uLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1idXR0b25cIixcbiAgICAgIGxhYmVsOiBuLmxpbmtfdG9vbGJhci5kZWxldGUudG9vbHRpcCxcbiAgICAgIG1haW5Ub29sdGlwOiBuLmxpbmtfdG9vbGJhci5kZWxldGUudG9vbHRpcCxcbiAgICAgIGlzU2VsZWN0ZWQ6ICExLFxuICAgICAgb25DbGljazogZS5kZWxldGVMaW5rLFxuICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkoY28sIHt9KVxuICAgIH1cbiAgKTtcbn0sIGlyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KHQuR2VuZXJpYy5Qb3BvdmVyLlJvb3QsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuUG9wb3Zlci5UcmlnZ2VyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuTGlua1Rvb2xiYXIuQnV0dG9uLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IFwiYm4tYnV0dG9uXCIsXG4gICAgICAgIG1haW5Ub29sdGlwOiBuLmxpbmtfdG9vbGJhci5lZGl0LnRvb2x0aXAsXG4gICAgICAgIGlzU2VsZWN0ZWQ6ICExLFxuICAgICAgICBjaGlsZHJlbjogbi5saW5rX3Rvb2xiYXIuZWRpdC50ZXh0XG4gICAgICB9XG4gICAgKSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuR2VuZXJpYy5Qb3BvdmVyLkNvbnRlbnQsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1wb3BvdmVyLWNvbnRlbnQgYm4tZm9ybS1wb3BvdmVyXCIsXG4gICAgICAgIHZhcmlhbnQ6IFwiZm9ybS1wb3BvdmVyXCIsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShWdCwgeyAuLi5lIH0pXG4gICAgICB9XG4gICAgKVxuICBdIH0pO1xufSwgbHIgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gQygpLCBuID0gTSgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5MaW5rVG9vbGJhci5CdXR0b24sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWJ1dHRvblwiLFxuICAgICAgbWFpblRvb2x0aXA6IG4ubGlua190b29sYmFyLm9wZW4udG9vbHRpcCxcbiAgICAgIGxhYmVsOiBuLmxpbmtfdG9vbGJhci5vcGVuLnRvb2x0aXAsXG4gICAgICBpc1NlbGVjdGVkOiAhMSxcbiAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgd2luZG93Lm9wZW4odmUoZS51cmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSwgXCJfYmxhbmtcIik7XG4gICAgICB9LFxuICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkoTW8sIHt9KVxuICAgIH1cbiAgKTtcbn0sIGNyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKTtcbiAgcmV0dXJuIGUuY2hpbGRyZW4gPyAvKiBAX19QVVJFX18gKi8gaSh0LkxpbmtUb29sYmFyLlJvb3QsIHsgY2xhc3NOYW1lOiBcImJuLXRvb2xiYXIgYm4tbGluay10b29sYmFyXCIsIGNoaWxkcmVuOiBlLmNoaWxkcmVuIH0pIDogLyogQF9fUFVSRV9fICovIHYoXG4gICAgdC5MaW5rVG9vbGJhci5Sb290LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi10b29sYmFyIGJuLWxpbmstdG9vbGJhclwiLFxuICAgICAgb25Nb3VzZUVudGVyOiBlLnN0b3BIaWRlVGltZXIsXG4gICAgICBvbk1vdXNlTGVhdmU6IGUuc3RhcnRIaWRlVGltZXIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICBpcixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB1cmw6IGUudXJsLFxuICAgICAgICAgICAgdGV4dDogZS50ZXh0LFxuICAgICAgICAgICAgZWRpdExpbms6IGUuZWRpdExpbmtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKGxyLCB7IHVybDogZS51cmwgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKHJyLCB7IGRlbGV0ZUxpbms6IGUuZGVsZXRlTGluayB9KVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn0sIGFyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IGIoKSwgbiA9IHtcbiAgICBkZWxldGVMaW5rOiB0LmxpbmtUb29sYmFyLmRlbGV0ZUxpbmssXG4gICAgZWRpdExpbms6IHQubGlua1Rvb2xiYXIuZWRpdExpbmssXG4gICAgc3RhcnRIaWRlVGltZXI6IHQubGlua1Rvb2xiYXIuc3RhcnRIaWRlVGltZXIsXG4gICAgc3RvcEhpZGVUaW1lcjogdC5saW5rVG9vbGJhci5zdG9wSGlkZVRpbWVyXG4gIH0sIG8gPSBQKFxuICAgIHQubGlua1Rvb2xiYXIub25VcGRhdGUuYmluZCh0LmxpbmtUb29sYmFyKVxuICApLCB7IGlzTW91bnRlZDogciwgcmVmOiBsLCBzdHlsZTogYywgZ2V0RmxvYXRpbmdQcm9wczogcyB9ID0gRyhcbiAgICAobyA9PSBudWxsID8gdm9pZCAwIDogby5zaG93KSB8fCAhMSxcbiAgICAobyA9PSBudWxsID8gdm9pZCAwIDogby5yZWZlcmVuY2VQb3MpIHx8IG51bGwsXG4gICAgNGUzLFxuICAgIHtcbiAgICAgIHBsYWNlbWVudDogXCJ0b3Atc3RhcnRcIixcbiAgICAgIG1pZGRsZXdhcmU6IFtBKDEwKSwgVygpXSxcbiAgICAgIG9uT3BlbkNoYW5nZTogKGgpID0+IHtcbiAgICAgICAgaCB8fCAodC5saW5rVG9vbGJhci5jbG9zZU1lbnUoKSwgdC5mb2N1cygpKTtcbiAgICAgIH0sXG4gICAgICAuLi5lLmZsb2F0aW5nT3B0aW9uc1xuICAgIH1cbiAgKTtcbiAgaWYgKCFyIHx8ICFvKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB7IHNob3c6IGQsIHJlZmVyZW5jZVBvczogYSwgLi4udSB9ID0gbywgbSA9IGUubGlua1Rvb2xiYXIgfHwgY3I7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IHJlZjogbCwgc3R5bGU6IGMsIC4uLnMoKSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKG0sIHsgLi4udSwgLi4ubiB9KSB9KTtcbn07XG5mdW5jdGlvbiBzcihlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAxMDI0IDEwMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk00ODIgMTUyaDYwcTggMCA4IDh2NzA0cTAgOC04IDhoLTYwcS04IDAtOC04VjE2MHEwLTggOC04WlwiIH0sIGNoaWxkOiBbXSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTkyIDQ3NGg2NzJxOCAwIDggOHY2MHEwIDgtOCA4SDE2MHEtOCAwLTgtOHYtNjBxMC04IDgtOFpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5jb25zdCBkciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBNKCksIG8gPSBiKCksIHIgPSBnKCgpID0+IHtcbiAgICBjb25zdCBsID0gZS5ibG9jay5jb250ZW50O1xuICAgIGlmIChsICE9PSB2b2lkIDAgJiYgQXJyYXkuaXNBcnJheShsKSAmJiBsLmxlbmd0aCA9PT0gMClcbiAgICAgIG8uc2V0VGV4dEN1cnNvclBvc2l0aW9uKGUuYmxvY2spLCBvLm9wZW5TdWdnZXN0aW9uTWVudShcIi9cIik7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBzID0gby5pbnNlcnRCbG9ja3MoXG4gICAgICAgIFt7IHR5cGU6IFwicGFyYWdyYXBoXCIgfV0sXG4gICAgICAgIGUuYmxvY2ssXG4gICAgICAgIFwiYWZ0ZXJcIlxuICAgICAgKVswXTtcbiAgICAgIG8uc2V0VGV4dEN1cnNvclBvc2l0aW9uKHMpLCBvLm9wZW5TdWdnZXN0aW9uTWVudShcIi9cIik7XG4gICAgfVxuICB9LCBbbywgZS5ibG9ja10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5TaWRlTWVudS5CdXR0b24sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWJ1dHRvblwiLFxuICAgICAgbGFiZWw6IG4uc2lkZV9tZW51LmFkZF9ibG9ja19sYWJlbCxcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKHNyLCB7IHNpemU6IDI0LCBvbkNsaWNrOiByLCBcImRhdGEtdGVzdFwiOiBcImRyYWdIYW5kbGVBZGRcIiB9KVxuICAgIH1cbiAgKTtcbn07XG5mdW5jdGlvbiBUdChlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGw6IFwibm9uZVwiLCBkOiBcIk0wIDBoMjR2MjRIMFYwelwiIH0sIGNoaWxkOiBbXSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTEgMThjMCAxLjEtLjkgMi0yIDJzLTItLjktMi0yIC45LTIgMi0yIDIgLjkgMiAyem0tMi04Yy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMiAyLS45IDItMi0uOS0yLTItMnptMC02Yy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMiAyLS45IDItMi0uOS0yLTItMnptNiA0YzEuMSAwIDItLjkgMi0ycy0uOS0yLTItMi0yIC45LTIgMiAuOSAyIDIgMnptMCAyYy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMiAyLS45IDItMi0uOS0yLTItMnptMCA2Yy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMiAyLS45IDItMi0uOS0yLTItMnpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiB1cihlKSB7XG4gIHJldHVybiBwKHsgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGw6IFwibm9uZVwiLCBkOiBcIk0wIDBoMjR2MjRIMHpcIiB9LCBjaGlsZDogW10gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwibTcgMTAgNSA1IDUtNXpcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5jb25zdCBtciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBiKCk7XG4gIHJldHVybiAhcShcInRleHRDb2xvclwiLCBlLmJsb2NrLnR5cGUsIG4pICYmICFxKFwiYmFja2dyb3VuZENvbG9yXCIsIGUuYmxvY2sudHlwZSwgbikgPyBudWxsIDogLyogQF9fUFVSRV9fICovIHYodC5HZW5lcmljLk1lbnUuUm9vdCwgeyBwb3NpdGlvbjogXCJyaWdodFwiLCBzdWI6ICEwLCBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBpKHQuR2VuZXJpYy5NZW51LlRyaWdnZXIsIHsgc3ViOiAhMCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgdC5HZW5lcmljLk1lbnUuSXRlbSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImJuLW1lbnUtaXRlbVwiLFxuICAgICAgICBzdWJUcmlnZ2VyOiAhMCxcbiAgICAgICAgY2hpbGRyZW46IGUuY2hpbGRyZW5cbiAgICAgIH1cbiAgICApIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgdC5HZW5lcmljLk1lbnUuRHJvcGRvd24sXG4gICAgICB7XG4gICAgICAgIHN1YjogITAsXG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1tZW51LWRyb3Bkb3duIGJuLWNvbG9yLXBpY2tlci1kcm9wZG93blwiLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgbWUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWNvblNpemU6IDE4LFxuICAgICAgICAgICAgdGV4dDogcShcbiAgICAgICAgICAgICAgXCJ0ZXh0Q29sb3JcIixcbiAgICAgICAgICAgICAgZS5ibG9jay50eXBlLFxuICAgICAgICAgICAgICBuXG4gICAgICAgICAgICApICYmIGtlKFwidGV4dENvbG9yXCIsIGUuYmxvY2ssIG4pID8ge1xuICAgICAgICAgICAgICBjb2xvcjogZS5ibG9jay5wcm9wcy50ZXh0Q29sb3IsXG4gICAgICAgICAgICAgIHNldENvbG9yOiAobykgPT4gbi51cGRhdGVCbG9jayhlLmJsb2NrLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogZS5ibG9jay50eXBlLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7IHRleHRDb2xvcjogbyB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogcShcbiAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICAgICAgZS5ibG9jay50eXBlLFxuICAgICAgICAgICAgICBuXG4gICAgICAgICAgICApICYmIGtlKFwiYmFja2dyb3VuZENvbG9yXCIsIGUuYmxvY2ssIG4pID8ge1xuICAgICAgICAgICAgICBjb2xvcjogZS5ibG9jay5wcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgIHNldENvbG9yOiAobykgPT4gbi51cGRhdGVCbG9jayhlLmJsb2NrLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHsgYmFja2dyb3VuZENvbG9yOiBvIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApXG4gIF0gfSk7XG59LCBociA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBiKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICB0LkdlbmVyaWMuTWVudS5JdGVtLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1tZW51LWl0ZW1cIixcbiAgICAgIG9uQ2xpY2s6ICgpID0+IG4ucmVtb3ZlQmxvY2tzKFtlLmJsb2NrXSksXG4gICAgICBjaGlsZHJlbjogZS5jaGlsZHJlblxuICAgIH1cbiAgKTtcbn0sIGZyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IGIoKTtcbiAgaWYgKGUuYmxvY2sudHlwZSAhPT0gXCJ0YWJsZVwiIHx8ICFuLnNldHRpbmdzLnRhYmxlcy5oZWFkZXJzKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBvID0gISFlLmJsb2NrLmNvbnRlbnQuaGVhZGVyUm93cztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuR2VuZXJpYy5NZW51Lkl0ZW0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLW1lbnUtaXRlbVwiLFxuICAgICAgY2hlY2tlZDogbyxcbiAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgY29uc3QgciA9IG4uZ2V0QmxvY2soZS5ibG9jay5pZCk7XG4gICAgICAgIHIgJiYgbi51cGRhdGVCbG9jayhyLCB7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAuLi5yLmNvbnRlbnQsXG4gICAgICAgICAgICBoZWFkZXJSb3dzOiBvID8gdm9pZCAwIDogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IGUuY2hpbGRyZW5cbiAgICB9XG4gICk7XG59LCBnciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBiKCk7XG4gIGlmIChlLmJsb2NrLnR5cGUgIT09IFwidGFibGVcIiB8fCAhbi5zZXR0aW5ncy50YWJsZXMuaGVhZGVycylcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbyA9ICEhZS5ibG9jay5jb250ZW50LmhlYWRlckNvbHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICB0LkdlbmVyaWMuTWVudS5JdGVtLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1tZW51LWl0ZW1cIixcbiAgICAgIGNoZWNrZWQ6IG8sXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIG4udXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgICAgIHR5cGU6IFwidGFibGVcIixcbiAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAuLi5lLmJsb2NrLmNvbnRlbnQsXG4gICAgICAgICAgICB0eXBlOiBcInRhYmxlQ29udGVudFwiLFxuICAgICAgICAgICAgaGVhZGVyQ29sczogbyA/IHZvaWQgMCA6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBlLmNoaWxkcmVuXG4gICAgfVxuICApO1xufSwgYnIgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gQygpLCBuID0gTSgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5HZW5lcmljLk1lbnUuRHJvcGRvd24sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLW1lbnUtZHJvcGRvd24gYm4tZHJhZy1oYW5kbGUtbWVudVwiLFxuICAgICAgY2hpbGRyZW46IGUuY2hpbGRyZW4gfHwgLyogQF9fUFVSRV9fICovIHYoVCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gaShociwgeyAuLi5lLCBjaGlsZHJlbjogbi5kcmFnX2hhbmRsZS5kZWxldGVfbWVudWl0ZW0gfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKG1yLCB7IC4uLmUsIGNoaWxkcmVuOiBuLmRyYWdfaGFuZGxlLmNvbG9yc19tZW51aXRlbSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkoZnIsIHsgLi4uZSwgY2hpbGRyZW46IG4uZHJhZ19oYW5kbGUuaGVhZGVyX3Jvd19tZW51aXRlbSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkoZ3IsIHsgLi4uZSwgY2hpbGRyZW46IG4uZHJhZ19oYW5kbGUuaGVhZGVyX2NvbHVtbl9tZW51aXRlbSB9KVxuICAgICAgXSB9KVxuICAgIH1cbiAgKTtcbn0sIENyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgbyA9IGUuZHJhZ0hhbmRsZU1lbnUgfHwgYnI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gdihcbiAgICB0LkdlbmVyaWMuTWVudS5Sb290LFxuICAgIHtcbiAgICAgIG9uT3BlbkNoYW5nZTogKHIpID0+IHtcbiAgICAgICAgciA/IGUuZnJlZXplTWVudSgpIDogZS51bmZyZWV6ZU1lbnUoKTtcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuTWVudS5UcmlnZ2VyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICB0LlNpZGVNZW51LkJ1dHRvbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogbi5zaWRlX21lbnUuZHJhZ19oYW5kbGVfbGFiZWwsXG4gICAgICAgICAgICBkcmFnZ2FibGU6ICEwLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IChyKSA9PiBlLmJsb2NrRHJhZ1N0YXJ0KHIsIGUuYmxvY2spLFxuICAgICAgICAgICAgb25EcmFnRW5kOiBlLmJsb2NrRHJhZ0VuZCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJibi1idXR0b25cIixcbiAgICAgICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKFR0LCB7IHNpemU6IDI0LCBcImRhdGEtdGVzdFwiOiBcImRyYWdIYW5kbGVcIiB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkobywgeyBibG9jazogZS5ibG9jaywgY2hpbGRyZW46IGUuY2hpbGRyZW4gfSlcbiAgICAgIF1cbiAgICB9XG4gICk7XG59LCBwciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSB4KCgpID0+IHtcbiAgICBjb25zdCBvID0ge1xuICAgICAgXCJkYXRhLWJsb2NrLXR5cGVcIjogZS5ibG9jay50eXBlXG4gICAgfTtcbiAgICByZXR1cm4gZS5ibG9jay50eXBlID09PSBcImhlYWRpbmdcIiAmJiAob1tcImRhdGEtbGV2ZWxcIl0gPSBlLmJsb2NrLnByb3BzLmxldmVsLnRvU3RyaW5nKCkpLCBlLmVkaXRvci5zY2hlbWEuYmxvY2tTY2hlbWFbZS5ibG9jay50eXBlXS5pc0ZpbGVCbG9jayAmJiAoZS5ibG9jay5wcm9wcy51cmwgPyBvW1wiZGF0YS11cmxcIl0gPSBcInRydWVcIiA6IG9bXCJkYXRhLXVybFwiXSA9IFwiZmFsc2VcIiksIG87XG4gIH0sIFtlLmJsb2NrLCBlLmVkaXRvci5zY2hlbWEuYmxvY2tTY2hlbWFdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKHQuU2lkZU1lbnUuUm9vdCwgeyBjbGFzc05hbWU6IFwiYm4tc2lkZS1tZW51XCIsIC4uLm4sIGNoaWxkcmVuOiBlLmNoaWxkcmVuIHx8IC8qIEBfX1BVUkVfXyAqLyB2KFQsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaShkciwgeyAuLi5lIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBpKENyLCB7IC4uLmUgfSlcbiAgXSB9KSB9KTtcbn0sIGtyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IGIoKSwgbiA9IHtcbiAgICBibG9ja0RyYWdTdGFydDogdC5zaWRlTWVudS5ibG9ja0RyYWdTdGFydCxcbiAgICBibG9ja0RyYWdFbmQ6IHQuc2lkZU1lbnUuYmxvY2tEcmFnRW5kLFxuICAgIGZyZWV6ZU1lbnU6IHQuc2lkZU1lbnUuZnJlZXplTWVudSxcbiAgICB1bmZyZWV6ZU1lbnU6IHQuc2lkZU1lbnUudW5mcmVlemVNZW51XG4gIH0sIG8gPSBQKFxuICAgIHQuc2lkZU1lbnUub25VcGRhdGUuYmluZCh0LnNpZGVNZW51KVxuICApLCB7IGlzTW91bnRlZDogciwgcmVmOiBsLCBzdHlsZTogYywgZ2V0RmxvYXRpbmdQcm9wczogcyB9ID0gRyhcbiAgICAobyA9PSBudWxsID8gdm9pZCAwIDogby5zaG93KSB8fCAhMSxcbiAgICAobyA9PSBudWxsID8gdm9pZCAwIDogby5yZWZlcmVuY2VQb3MpIHx8IG51bGwsXG4gICAgMWUzLFxuICAgIHtcbiAgICAgIHBsYWNlbWVudDogXCJsZWZ0LXN0YXJ0XCIsXG4gICAgICAuLi5lLmZsb2F0aW5nT3B0aW9uc1xuICAgIH1cbiAgKTtcbiAgaWYgKCFyIHx8ICFvKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB7IHNob3c6IGQsIHJlZmVyZW5jZVBvczogYSwgLi4udSB9ID0gbywgbSA9IGUuc2lkZU1lbnUgfHwgcHI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IHJlZjogbCwgc3R5bGU6IGMsIC4uLnMoKSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKG0sIHsgLi4udSwgLi4ubiwgZWRpdG9yOiB0IH0pIH0pO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHdyKGUsIHQpIHtcbiAgcmV0dXJuIChhd2FpdCBvbihlLCB0KSkubWFwKFxuICAgICh7IGlkOiBuLCBvbkl0ZW1DbGljazogbyB9KSA9PiAoe1xuICAgICAgaWQ6IG4sXG4gICAgICBvbkl0ZW1DbGljazogbyxcbiAgICAgIGljb246IG5cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gdnIoZSkge1xuICBjb25zdCB0ID0gQygpLCBuID0gTSgpLCB7IGl0ZW1zOiBvLCBsb2FkaW5nU3RhdGU6IHIsIHNlbGVjdGVkSW5kZXg6IGwsIG9uSXRlbUNsaWNrOiBjLCBjb2x1bW5zOiBzIH0gPSBlLCBkID0gciA9PT0gXCJsb2FkaW5nLWluaXRpYWxcIiB8fCByID09PSBcImxvYWRpbmdcIiA/IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuR3JpZFN1Z2dlc3Rpb25NZW51LkxvYWRlcixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwiYm4tZ3JpZC1zdWdnZXN0aW9uLW1lbnUtbG9hZGVyXCIsXG4gICAgICBjb2x1bW5zOiBzLFxuICAgICAgY2hpbGRyZW46IG4uc3VnZ2VzdGlvbl9tZW51LmxvYWRpbmdcbiAgICB9XG4gICkgOiBudWxsLCBhID0geCgoKSA9PiB7XG4gICAgY29uc3QgdSA9IFtdO1xuICAgIGZvciAobGV0IG0gPSAwOyBtIDwgby5sZW5ndGg7IG0rKykge1xuICAgICAgY29uc3QgaCA9IG9bbV07XG4gICAgICB1LnB1c2goXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIHQuR3JpZFN1Z2dlc3Rpb25NZW51Lkl0ZW0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJuLWdyaWQtc3VnZ2VzdGlvbi1tZW51LWl0ZW1cIixcbiAgICAgICAgICAgIGl0ZW06IGgsXG4gICAgICAgICAgICBpZDogYGJuLWdyaWQtc3VnZ2VzdGlvbi1tZW51LWl0ZW0tJHttfWAsXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiBtID09PSBsLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4gYyA9PSBudWxsID8gdm9pZCAwIDogYyhoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaC5pZFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbiAgfSwgW3QsIG8sIGMsIGxdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgIHQuR3JpZFN1Z2dlc3Rpb25NZW51LlJvb3QsXG4gICAge1xuICAgICAgaWQ6IFwiYm4tZ3JpZC1zdWdnZXN0aW9uLW1lbnVcIixcbiAgICAgIGNvbHVtbnM6IHMsXG4gICAgICBjbGFzc05hbWU6IFwiYm4tZ3JpZC1zdWdnZXN0aW9uLW1lbnVcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIGQsXG4gICAgICAgIGEsXG4gICAgICAgIGEubGVuZ3RoID09PSAwICYmIGUubG9hZGluZ1N0YXRlID09PSBcImxvYWRlZFwiICYmIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIHQuR3JpZFN1Z2dlc3Rpb25NZW51LkVtcHR5SXRlbSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiYm4tZ3JpZC1zdWdnZXN0aW9uLW1lbnUtZW1wdHktaXRlbVwiLFxuICAgICAgICAgICAgY29sdW1uczogcyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuLnN1Z2dlc3Rpb25fbWVudS5ub19pdGVtc190aXRsZVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEx0KGUsIHQsIG4sIG8gPSAzKSB7XG4gIGNvbnN0IHIgPSBfKDApO1xuICB5KCgpID0+IHtcbiAgICB0ICE9PSB2b2lkIDAgJiYgKGUubGVuZ3RoID4gMCA/IHIuY3VycmVudCA9IHQubGVuZ3RoIDogdC5sZW5ndGggLSByLmN1cnJlbnQgPiBvICYmIG4oKSk7XG4gIH0sIFtuLCBvLCBlLmxlbmd0aCwgdF0pO1xufVxuZnVuY3Rpb24gRXQoZSwgdCkge1xuICBjb25zdCBbbiwgb10gPSBrKFtdKSwgW3IsIGxdID0gayghMSksIGMgPSBfKCksIHMgPSBfKCk7XG4gIHJldHVybiB5KCgpID0+IHtcbiAgICBjb25zdCBkID0gZTtcbiAgICBjLmN1cnJlbnQgPSBlLCBsKCEwKSwgdChlKS50aGVuKChhKSA9PiB7XG4gICAgICBjLmN1cnJlbnQgPT09IGQgJiYgKG8oYSksIGwoITEpLCBzLmN1cnJlbnQgPSBkKTtcbiAgICB9KTtcbiAgfSwgW2UsIHRdKSwge1xuICAgIGl0ZW1zOiBuIHx8IFtdLFxuICAgIC8vIFRoZSBxdWVyeSB0aGF0IHdhcyB1c2VkIHRvIHJldHJpZXZlIHRoZSBsYXN0IHNldCBvZiBpdGVtcyBtYXkgbm90IGJlIHRoZVxuICAgIC8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgcXVlcnkgYXMgdGhlIGl0ZW1zIGZyb20gdGhlIGN1cnJlbnQgcXVlcnkgbWF5IG5vdFxuICAgIC8vIGhhdmUgYmVlbiByZXRyaWV2ZWQgeWV0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIHRoZSByZXR1cm5zIG9mIHRoaXNcbiAgICAvLyBob29rIGluIG90aGVyIGhvb2tzLlxuICAgIHVzZWRRdWVyeTogcy5jdXJyZW50LFxuICAgIGxvYWRpbmdTdGF0ZTogcy5jdXJyZW50ID09PSB2b2lkIDAgPyBcImxvYWRpbmctaW5pdGlhbFwiIDogciA/IFwibG9hZGluZ1wiIDogXCJsb2FkZWRcIlxuICB9O1xufVxuZnVuY3Rpb24gSHIoZSwgdCwgbiwgbywgcikge1xuICBjb25zdCBbbCwgY10gPSBrKDApLCBzID0gbyAhPT0gdm9pZCAwICYmIG8gPiAxO1xuICByZXR1cm4geSgoKSA9PiB7XG4gICAgdmFyIGE7XG4gICAgY29uc3QgZCA9ICh1KSA9PiAodS5rZXkgPT09IFwiQXJyb3dMZWZ0XCIgJiYgKHUucHJldmVudERlZmF1bHQoKSwgbi5sZW5ndGggJiYgYygobCAtIDEgKyBuLmxlbmd0aCkgJSBuLmxlbmd0aCkpLCB1LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgJiYgKHUucHJldmVudERlZmF1bHQoKSwgbi5sZW5ndGggJiYgYygobCArIDEgKyBuLmxlbmd0aCkgJSBuLmxlbmd0aCkpLCB1LmtleSA9PT0gXCJBcnJvd1VwXCIgPyAodS5wcmV2ZW50RGVmYXVsdCgpLCBuLmxlbmd0aCAmJiBjKFxuICAgICAgKGwgLSBvICsgbi5sZW5ndGgpICUgbi5sZW5ndGhcbiAgICApLCAhMCkgOiB1LmtleSA9PT0gXCJBcnJvd0Rvd25cIiA/ICh1LnByZXZlbnREZWZhdWx0KCksIG4ubGVuZ3RoICYmIGMoKGwgKyBvKSAlIG4ubGVuZ3RoKSwgITApIDogdS5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdS5pc0NvbXBvc2luZyA/ICh1LnByZXZlbnREZWZhdWx0KCksIG4ubGVuZ3RoICYmIChyID09IG51bGwgfHwgcihuW2xdKSksICEwKSA6ICExKTtcbiAgICByZXR1cm4gKGEgPSBlLmRvbUVsZW1lbnQpID09IG51bGwgfHwgYS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBkLFxuICAgICAgITBcbiAgICApLCAoKSA9PiB7XG4gICAgICB2YXIgdTtcbiAgICAgICh1ID0gZS5kb21FbGVtZW50KSA9PSBudWxsIHx8IHUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJrZXlkb3duXCIsXG4gICAgICAgIGQsXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIH07XG4gIH0sIFtlLmRvbUVsZW1lbnQsIG4sIGwsIHIsIG8sIHNdKSwgeSgoKSA9PiB7XG4gICAgYygwKTtcbiAgfSwgW3RdKSwge1xuICAgIHNlbGVjdGVkSW5kZXg6IG4ubGVuZ3RoID09PSAwID8gdm9pZCAwIDogbFxuICB9O1xufVxuZnVuY3Rpb24gTXIoZSkge1xuICBjb25zdCBuID0gRCgpLnNldENvbnRlbnRFZGl0YWJsZVByb3BzLCBvID0gYigpLCB7XG4gICAgZ2V0SXRlbXM6IHIsXG4gICAgZ3JpZFN1Z2dlc3Rpb25NZW51Q29tcG9uZW50OiBsLFxuICAgIHF1ZXJ5OiBjLFxuICAgIGNsZWFyUXVlcnk6IHMsXG4gICAgY2xvc2VNZW51OiBkLFxuICAgIG9uSXRlbUNsaWNrOiBhLFxuICAgIGNvbHVtbnM6IHVcbiAgfSA9IGUsIG0gPSBnKFxuICAgIChWKSA9PiB7XG4gICAgICBkKCksIHMoKSwgYSA9PSBudWxsIHx8IGEoVik7XG4gICAgfSxcbiAgICBbYSwgZCwgc11cbiAgKSwgeyBpdGVtczogaCwgdXNlZFF1ZXJ5OiBmLCBsb2FkaW5nU3RhdGU6IHcgfSA9IEV0KFxuICAgIGMsXG4gICAgclxuICApO1xuICBMdChoLCBmLCBkKTtcbiAgY29uc3QgeyBzZWxlY3RlZEluZGV4OiBIIH0gPSBIcihcbiAgICBvLFxuICAgIGMsXG4gICAgaCxcbiAgICB1LFxuICAgIG1cbiAgKTtcbiAgcmV0dXJuIHkoKCkgPT4gKG4oKFYpID0+ICh7XG4gICAgLi4uVixcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogITAsXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IFwiYm4tc3VnZ2VzdGlvbi1tZW51XCJcbiAgfSkpLCAoKSA9PiB7XG4gICAgbigoVikgPT4gKHtcbiAgICAgIC4uLlYsXG4gICAgICBcImFyaWEtZXhwYW5kZWRcIjogITEsXG4gICAgICBcImFyaWEtY29udHJvbHNcIjogdm9pZCAwXG4gICAgfSkpO1xuICB9KSwgW25dKSwgeSgoKSA9PiAobigoVikgPT4gKHtcbiAgICAuLi5WLFxuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IEggPyBcImJuLXN1Z2dlc3Rpb24tbWVudS1pdGVtLVwiICsgSCA6IHZvaWQgMFxuICB9KSksICgpID0+IHtcbiAgICBuKChWKSA9PiAoe1xuICAgICAgLi4uVixcbiAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IHZvaWQgMFxuICAgIH0pKTtcbiAgfSksIFtuLCBIXSksIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIGwsXG4gICAge1xuICAgICAgaXRlbXM6IGgsXG4gICAgICBvbkl0ZW1DbGljazogbSxcbiAgICAgIGxvYWRpbmdTdGF0ZTogdyxcbiAgICAgIHNlbGVjdGVkSW5kZXg6IEgsXG4gICAgICBjb2x1bW5zOiB1XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24geHIoZSkge1xuICBjb25zdCB0ID0gYigpLCB7XG4gICAgdHJpZ2dlckNoYXJhY3RlcjogbixcbiAgICBncmlkU3VnZ2VzdGlvbk1lbnVDb21wb25lbnQ6IG8sXG4gICAgY29sdW1uczogcixcbiAgICBtaW5RdWVyeUxlbmd0aDogbCxcbiAgICBvbkl0ZW1DbGljazogYyxcbiAgICBnZXRJdGVtczogcyxcbiAgICBmbG9hdGluZ09wdGlvbnM6IGRcbiAgfSA9IGUsIGEgPSB4KCgpID0+IGMgfHwgKChTKSA9PiB7XG4gICAgUy5vbkl0ZW1DbGljayh0KTtcbiAgfSksIFt0LCBjXSksIHUgPSB4KCgpID0+IHMgfHwgKGFzeW5jIChTKSA9PiBhd2FpdCB3cihcbiAgICB0LFxuICAgIFNcbiAgKSksIFt0LCBzXSksIG0gPSB7XG4gICAgY2xvc2VNZW51OiB0LnN1Z2dlc3Rpb25NZW51cy5jbG9zZU1lbnUsXG4gICAgY2xlYXJRdWVyeTogdC5zdWdnZXN0aW9uTWVudXMuY2xlYXJRdWVyeVxuICB9LCBoID0gZyhcbiAgICAoUykgPT4gdC5zdWdnZXN0aW9uTWVudXMub25VcGRhdGUobiwgUyksXG4gICAgW3Quc3VnZ2VzdGlvbk1lbnVzLCBuXVxuICApLCBmID0gUChoKSwgeyBpc01vdW50ZWQ6IHcsIHJlZjogSCwgc3R5bGU6IEIsIGdldEZsb2F0aW5nUHJvcHM6IFYgfSA9IEcoXG4gICAgKGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuc2hvdykgfHwgITEsXG4gICAgKGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYucmVmZXJlbmNlUG9zKSB8fCBudWxsLFxuICAgIDJlMyxcbiAgICB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCIsXG4gICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgIEEoMTApLFxuICAgICAgICAvLyBGbGlwcyB0aGUgbWVudSBwbGFjZW1lbnQgdG8gbWF4aW1pemUgdGhlIHNwYWNlIGF2YWlsYWJsZSwgYW5kIHByZXZlbnRzXG4gICAgICAgIC8vIHRoZSBtZW51IGZyb20gYmVpbmcgY3V0IG9mZiBieSB0aGUgY29uZmluZXMgb2YgdGhlIHNjcmVlbi5cbiAgICAgICAgVygpLFxuICAgICAgICBTZSh7XG4gICAgICAgICAgYXBwbHkoeyBhdmFpbGFibGVIZWlnaHQ6IFMsIGVsZW1lbnRzOiBPIH0pIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oTy5mbG9hdGluZy5zdHlsZSwge1xuICAgICAgICAgICAgICBtYXhIZWlnaHQ6IGAke1MgLSAxMH1weGBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIF0sXG4gICAgICBvbk9wZW5DaGFuZ2UoUykge1xuICAgICAgICBTIHx8IHQuc3VnZ2VzdGlvbk1lbnVzLmNsb3NlTWVudSgpO1xuICAgICAgfSxcbiAgICAgIC4uLmRcbiAgICB9XG4gICk7XG4gIHJldHVybiAhdyB8fCAhZiB8fCAhKGYgIT0gbnVsbCAmJiBmLmlnbm9yZVF1ZXJ5TGVuZ3RoKSAmJiBsICYmIChmLnF1ZXJ5LnN0YXJ0c1dpdGgoXCIgXCIpIHx8IGYucXVlcnkubGVuZ3RoIDwgbCkgPyBudWxsIDogLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyByZWY6IEgsIHN0eWxlOiBCLCAuLi5WKCksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICBNcixcbiAgICB7XG4gICAgICBxdWVyeTogZi5xdWVyeSxcbiAgICAgIGNsb3NlTWVudTogbS5jbG9zZU1lbnUsXG4gICAgICBjbGVhclF1ZXJ5OiBtLmNsZWFyUXVlcnksXG4gICAgICBnZXRJdGVtczogdSxcbiAgICAgIGNvbHVtbnM6IHIsXG4gICAgICBncmlkU3VnZ2VzdGlvbk1lbnVDb21wb25lbnQ6IG8gfHwgdnIsXG4gICAgICBvbkl0ZW1DbGljazogYVxuICAgIH1cbiAgKSB9KTtcbn1cbmZ1bmN0aW9uIHlyKGUpIHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgeyBpdGVtczogbywgbG9hZGluZ1N0YXRlOiByLCBzZWxlY3RlZEluZGV4OiBsLCBvbkl0ZW1DbGljazogYyB9ID0gZSwgcyA9IHIgPT09IFwibG9hZGluZy1pbml0aWFsXCIgfHwgciA9PT0gXCJsb2FkaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gaSh0LlN1Z2dlc3Rpb25NZW51LkxvYWRlciwgeyBjbGFzc05hbWU6IFwiYm4tc3VnZ2VzdGlvbi1tZW51LWxvYWRlclwiLCBjaGlsZHJlbjogbi5zdWdnZXN0aW9uX21lbnUubG9hZGluZyB9KSA6IG51bGwsIGQgPSB4KCgpID0+IHtcbiAgICBsZXQgYTtcbiAgICBjb25zdCB1ID0gW107XG4gICAgZm9yIChsZXQgbSA9IDA7IG0gPCBvLmxlbmd0aDsgbSsrKSB7XG4gICAgICBjb25zdCBoID0gb1ttXTtcbiAgICAgIGguZ3JvdXAgIT09IGEgJiYgKGEgPSBoLmdyb3VwLCB1LnB1c2goXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIHQuU3VnZ2VzdGlvbk1lbnUuTGFiZWwsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJuLXN1Z2dlc3Rpb24tbWVudS1sYWJlbFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFcbiAgICAgICAgKVxuICAgICAgKSksIHUucHVzaChcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgdC5TdWdnZXN0aW9uTWVudS5JdGVtLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJibi1zdWdnZXN0aW9uLW1lbnUtaXRlbVwiLFxuICAgICAgICAgICAgaXRlbTogaCxcbiAgICAgICAgICAgIGlkOiBgYm4tc3VnZ2VzdGlvbi1tZW51LWl0ZW0tJHttfWAsXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiBtID09PSBsLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4gYyA9PSBudWxsID8gdm9pZCAwIDogYyhoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaC50aXRsZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbiAgfSwgW3QsIG8sIGMsIGxdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgIHQuU3VnZ2VzdGlvbk1lbnUuUm9vdCxcbiAgICB7XG4gICAgICBpZDogXCJibi1zdWdnZXN0aW9uLW1lbnVcIixcbiAgICAgIGNsYXNzTmFtZTogXCJibi1zdWdnZXN0aW9uLW1lbnVcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIGQsXG4gICAgICAgIGQubGVuZ3RoID09PSAwICYmIChlLmxvYWRpbmdTdGF0ZSA9PT0gXCJsb2FkaW5nXCIgfHwgZS5sb2FkaW5nU3RhdGUgPT09IFwibG9hZGVkXCIpICYmIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIHQuU3VnZ2VzdGlvbk1lbnUuRW1wdHlJdGVtLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJibi1zdWdnZXN0aW9uLW1lbnUtaXRlbVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IG4uc3VnZ2VzdGlvbl9tZW51Lm5vX2l0ZW1zX3RpdGxlXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBzXG4gICAgICBdXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gQnIoZSwgdCwgbiwgbykge1xuICBjb25zdCBbciwgbF0gPSBrKDApO1xuICByZXR1cm4geSgoKSA9PiB7XG4gICAgdmFyIHM7XG4gICAgY29uc3QgYyA9IChkKSA9PiBkLmtleSA9PT0gXCJBcnJvd1VwXCIgPyAoZC5wcmV2ZW50RGVmYXVsdCgpLCBuLmxlbmd0aCAmJiBsKChyIC0gMSArIG4ubGVuZ3RoKSAlIG4ubGVuZ3RoKSwgITApIDogZC5rZXkgPT09IFwiQXJyb3dEb3duXCIgPyAoZC5wcmV2ZW50RGVmYXVsdCgpLCBuLmxlbmd0aCAmJiBsKChyICsgMSkgJSBuLmxlbmd0aCksICEwKSA6IGQua2V5ID09PSBcIkVudGVyXCIgJiYgIWQuaXNDb21wb3NpbmcgPyAoZC5wcmV2ZW50RGVmYXVsdCgpLCBkLnN0b3BQcm9wYWdhdGlvbigpLCBuLmxlbmd0aCAmJiAobyA9PSBudWxsIHx8IG8obltyXSkpLCAhMCkgOiAhMTtcbiAgICByZXR1cm4gKHMgPSBlLmRvbUVsZW1lbnQpID09IG51bGwgfHwgcy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBjLFxuICAgICAgITBcbiAgICApLCAoKSA9PiB7XG4gICAgICB2YXIgZDtcbiAgICAgIChkID0gZS5kb21FbGVtZW50KSA9PSBudWxsIHx8IGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJrZXlkb3duXCIsXG4gICAgICAgIGMsXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIH07XG4gIH0sIFtlLmRvbUVsZW1lbnQsIG4sIHIsIG9dKSwgeSgoKSA9PiB7XG4gICAgbCgwKTtcbiAgfSwgW3RdKSwge1xuICAgIHNlbGVjdGVkSW5kZXg6IG4ubGVuZ3RoID09PSAwID8gdm9pZCAwIDogclxuICB9O1xufVxuZnVuY3Rpb24gVnIoZSkge1xuICBjb25zdCBuID0gRCgpLnNldENvbnRlbnRFZGl0YWJsZVByb3BzLCBvID0gYigpLCB7XG4gICAgZ2V0SXRlbXM6IHIsXG4gICAgc3VnZ2VzdGlvbk1lbnVDb21wb25lbnQ6IGwsXG4gICAgcXVlcnk6IGMsXG4gICAgY2xlYXJRdWVyeTogcyxcbiAgICBjbG9zZU1lbnU6IGQsXG4gICAgb25JdGVtQ2xpY2s6IGFcbiAgfSA9IGUsIHUgPSBnKFxuICAgIChCKSA9PiB7XG4gICAgICBkKCksIHMoKSwgYSA9PSBudWxsIHx8IGEoQik7XG4gICAgfSxcbiAgICBbYSwgZCwgc11cbiAgKSwgeyBpdGVtczogbSwgdXNlZFF1ZXJ5OiBoLCBsb2FkaW5nU3RhdGU6IGYgfSA9IEV0KFxuICAgIGMsXG4gICAgclxuICApO1xuICBMdChtLCBoLCBkKTtcbiAgY29uc3QgeyBzZWxlY3RlZEluZGV4OiB3IH0gPSBCcihcbiAgICBvLFxuICAgIGMsXG4gICAgbSxcbiAgICB1XG4gICk7XG4gIHJldHVybiB5KCgpID0+IChuKChCKSA9PiAoe1xuICAgIC4uLkIsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6ICEwLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiBcImJuLXN1Z2dlc3Rpb24tbWVudVwiXG4gIH0pKSwgKCkgPT4ge1xuICAgIG4oKEIpID0+ICh7XG4gICAgICAuLi5CLFxuICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6ICExLFxuICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IHZvaWQgMFxuICAgIH0pKTtcbiAgfSksIFtuXSksIHkoKCkgPT4gKG4oKEIpID0+ICh7XG4gICAgLi4uQixcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiB3ID8gXCJibi1zdWdnZXN0aW9uLW1lbnUtaXRlbS1cIiArIHcgOiB2b2lkIDBcbiAgfSkpLCAoKSA9PiB7XG4gICAgbigoQikgPT4gKHtcbiAgICAgIC4uLkIsXG4gICAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiB2b2lkIDBcbiAgICB9KSk7XG4gIH0pLCBbbiwgd10pLCAvKiBAX19QVVJFX18gKi8gaShcbiAgICBsLFxuICAgIHtcbiAgICAgIGl0ZW1zOiBtLFxuICAgICAgb25JdGVtQ2xpY2s6IHUsXG4gICAgICBsb2FkaW5nU3RhdGU6IGYsXG4gICAgICBzZWxlY3RlZEluZGV4OiB3XG4gICAgfVxuICApO1xufVxuY29uc3QgU3IgPSB7XG4gIGhlYWRpbmc6IGZ0LFxuICBoZWFkaW5nXzI6IGd0LFxuICBoZWFkaW5nXzM6IGJ0LFxuICBxdW90ZTogdnQsXG4gIG51bWJlcmVkX2xpc3Q6IGt0LFxuICBidWxsZXRfbGlzdDogd3QsXG4gIGNoZWNrX2xpc3Q6IHB0LFxuICBwYXJhZ3JhcGg6IF9lLFxuICB0YWJsZTogbW8sXG4gIGltYWdlOiBIdCxcbiAgdmlkZW86IGZvLFxuICBhdWRpbzogTXQsXG4gIGZpbGU6IFJlLFxuICBlbW9qaTogeW8sXG4gIGNvZGVfYmxvY2s6IG9vXG59O1xuZnVuY3Rpb24gVHIoZSkge1xuICByZXR1cm4gcm4oZSkubWFwKCh0KSA9PiB7XG4gICAgY29uc3QgbiA9IFNyW3Qua2V5XTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udCxcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBpKG4sIHsgc2l6ZTogMTggfSlcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIExyKGUpIHtcbiAgY29uc3QgdCA9IGIoKSwge1xuICAgIHRyaWdnZXJDaGFyYWN0ZXI6IG4sXG4gICAgc3VnZ2VzdGlvbk1lbnVDb21wb25lbnQ6IG8sXG4gICAgbWluUXVlcnlMZW5ndGg6IHIsXG4gICAgb25JdGVtQ2xpY2s6IGwsXG4gICAgZ2V0SXRlbXM6IGMsXG4gICAgZmxvYXRpbmdPcHRpb25zOiBzXG4gIH0gPSBlLCBkID0geCgoKSA9PiBsIHx8ICgoVikgPT4ge1xuICAgIFYub25JdGVtQ2xpY2sodCk7XG4gIH0pLCBbdCwgbF0pLCBhID0geCgoKSA9PiBjIHx8IChhc3luYyAoVikgPT4gbG4oXG4gICAgVHIodCksXG4gICAgVlxuICApKSwgW3QsIGNdKSwgdSA9IHtcbiAgICBjbG9zZU1lbnU6IHQuc3VnZ2VzdGlvbk1lbnVzLmNsb3NlTWVudSxcbiAgICBjbGVhclF1ZXJ5OiB0LnN1Z2dlc3Rpb25NZW51cy5jbGVhclF1ZXJ5XG4gIH0sIG0gPSBnKFxuICAgIChWKSA9PiB0LnN1Z2dlc3Rpb25NZW51cy5vblVwZGF0ZShuLCBWKSxcbiAgICBbdC5zdWdnZXN0aW9uTWVudXMsIG5dXG4gICksIGggPSBQKG0pLCB7IGlzTW91bnRlZDogZiwgcmVmOiB3LCBzdHlsZTogSCwgZ2V0RmxvYXRpbmdQcm9wczogQiB9ID0gRyhcbiAgICAoaCA9PSBudWxsID8gdm9pZCAwIDogaC5zaG93KSB8fCAhMSxcbiAgICAoaCA9PSBudWxsID8gdm9pZCAwIDogaC5yZWZlcmVuY2VQb3MpIHx8IG51bGwsXG4gICAgMmUzLFxuICAgIHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIixcbiAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgQSgxMCksXG4gICAgICAgIC8vIEZsaXBzIHRoZSBtZW51IHBsYWNlbWVudCB0byBtYXhpbWl6ZSB0aGUgc3BhY2UgYXZhaWxhYmxlLCBhbmQgcHJldmVudHNcbiAgICAgICAgLy8gdGhlIG1lbnUgZnJvbSBiZWluZyBjdXQgb2ZmIGJ5IHRoZSBjb25maW5lcyBvZiB0aGUgc2NyZWVuLlxuICAgICAgICBXKHtcbiAgICAgICAgICBtYWluQXhpczogITAsXG4gICAgICAgICAgY3Jvc3NBeGlzOiAhMVxuICAgICAgICB9KSxcbiAgICAgICAgbGUoKSxcbiAgICAgICAgU2Uoe1xuICAgICAgICAgIGFwcGx5KHsgYXZhaWxhYmxlSGVpZ2h0OiBWLCBlbGVtZW50czogUyB9KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKFMuZmxvYXRpbmcuc3R5bGUsIHtcbiAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBgJHtWIC0gMTB9cHhgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdLFxuICAgICAgb25PcGVuQ2hhbmdlKFYpIHtcbiAgICAgICAgViB8fCB0LnN1Z2dlc3Rpb25NZW51cy5jbG9zZU1lbnUoKTtcbiAgICAgIH0sXG4gICAgICAuLi5zXG4gICAgfVxuICApO1xuICByZXR1cm4gIWYgfHwgIWggfHwgIShoICE9IG51bGwgJiYgaC5pZ25vcmVRdWVyeUxlbmd0aCkgJiYgciAmJiAoaC5xdWVyeS5zdGFydHNXaXRoKFwiIFwiKSB8fCBoLnF1ZXJ5Lmxlbmd0aCA8IHIpID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBpKFwiZGl2XCIsIHsgcmVmOiB3LCBzdHlsZTogSCwgLi4uQigpLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgVnIsXG4gICAge1xuICAgICAgcXVlcnk6IGgucXVlcnksXG4gICAgICBjbG9zZU1lbnU6IHUuY2xvc2VNZW51LFxuICAgICAgY2xlYXJRdWVyeTogdS5jbGVhclF1ZXJ5LFxuICAgICAgZ2V0SXRlbXM6IGEsXG4gICAgICBzdWdnZXN0aW9uTWVudUNvbXBvbmVudDogbyB8fCB5cixcbiAgICAgIG9uSXRlbUNsaWNrOiBkXG4gICAgfVxuICApIH0pO1xufVxuY29uc3QgRXIgPSAoZSwgdCA9IDAuMykgPT4ge1xuICBjb25zdCBuID0gTWF0aC5mbG9vcihlKSArIHQsIG8gPSBNYXRoLmNlaWwoZSkgLSB0O1xuICByZXR1cm4gZSA+PSBuICYmIGUgPD0gbyA/IE1hdGgucm91bmQoZSkgOiBlIDwgbiA/IE1hdGguZmxvb3IoZSkgOiBNYXRoLmNlaWwoZSk7XG59LCBSciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBfKCExKSwgW28sIHJdID0gaygpLCBsID0gZyhcbiAgICAocykgPT4ge1xuICAgICAgZS5vbk1vdXNlRG93bigpLCByKHtcbiAgICAgICAgb3JpZ2luYWxDb250ZW50OiBlLmJsb2NrLmNvbnRlbnQsXG4gICAgICAgIG9yaWdpbmFsQ3JvcHBlZENvbnRlbnQ6IHtcbiAgICAgICAgICByb3dzOiBlLmVkaXRvci50YWJsZUhhbmRsZXMuY3JvcEVtcHR5Um93c09yQ29sdW1ucyhcbiAgICAgICAgICAgIGUuYmxvY2ssXG4gICAgICAgICAgICBlLm9yaWVudGF0aW9uID09PSBcImFkZE9yUmVtb3ZlQ29sdW1uc1wiID8gXCJjb2x1bW5zXCIgOiBcInJvd3NcIlxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRQb3M6IGUub3JpZW50YXRpb24gPT09IFwiYWRkT3JSZW1vdmVDb2x1bW5zXCIgPyBzLmNsaWVudFggOiBzLmNsaWVudFlcbiAgICAgIH0pLCBuLmN1cnJlbnQgPSAhMSwgcy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgW2VdXG4gICksIGMgPSBnKCgpID0+IHtcbiAgICBuLmN1cnJlbnQgfHwgZS5lZGl0b3IudXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgY29udGVudDoge1xuICAgICAgICAuLi5lLmJsb2NrLmNvbnRlbnQsXG4gICAgICAgIHJvd3M6IGUub3JpZW50YXRpb24gPT09IFwiYWRkT3JSZW1vdmVDb2x1bW5zXCIgPyBlLmVkaXRvci50YWJsZUhhbmRsZXMuYWRkUm93c09yQ29sdW1ucyhcbiAgICAgICAgICBlLmJsb2NrLFxuICAgICAgICAgIFwiY29sdW1uc1wiLFxuICAgICAgICAgIDFcbiAgICAgICAgKSA6IGUuZWRpdG9yLnRhYmxlSGFuZGxlcy5hZGRSb3dzT3JDb2x1bW5zKFxuICAgICAgICAgIGUuYmxvY2ssXG4gICAgICAgICAgXCJyb3dzXCIsXG4gICAgICAgICAgMVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtlLmJsb2NrLCBlLm9yaWVudGF0aW9uLCBlLmVkaXRvcl0pO1xuICByZXR1cm4geSgoKSA9PiB7XG4gICAgY29uc3QgcyA9IChkKSA9PiB7XG4gICAgICB2YXIgdywgSDtcbiAgICAgIGlmICghbylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZWRpdGluZ1N0YXRlIGlzIHVuZGVmaW5lZFwiKTtcbiAgICAgIG4uY3VycmVudCA9ICEwO1xuICAgICAgY29uc3QgYSA9IChlLm9yaWVudGF0aW9uID09PSBcImFkZE9yUmVtb3ZlQ29sdW1uc1wiID8gZC5jbGllbnRYIDogZC5jbGllbnRZKSAtIG8uc3RhcnRQb3MsIHUgPSBlLm9yaWVudGF0aW9uID09PSBcImFkZE9yUmVtb3ZlQ29sdW1uc1wiID8gKCh3ID0gby5vcmlnaW5hbENyb3BwZWRDb250ZW50LnJvd3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiB3LmNlbGxzLmxlbmd0aCkgPz8gMCA6IG8ub3JpZ2luYWxDcm9wcGVkQ29udGVudC5yb3dzLmxlbmd0aCwgbSA9IGUub3JpZW50YXRpb24gPT09IFwiYWRkT3JSZW1vdmVDb2x1bW5zXCIgPyAoKEggPSBvLm9yaWdpbmFsQ29udGVudC5yb3dzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogSC5jZWxscy5sZW5ndGgpID8/IDAgOiBvLm9yaWdpbmFsQ29udGVudC5yb3dzLmxlbmd0aCwgaCA9IGUub3JpZW50YXRpb24gPT09IFwiYWRkT3JSZW1vdmVDb2x1bW5zXCIgPyBlLmJsb2NrLmNvbnRlbnQucm93c1swXS5jZWxscy5sZW5ndGggOiBlLmJsb2NrLmNvbnRlbnQucm93cy5sZW5ndGgsIGYgPSBtICsgRXIoXG4gICAgICAgIGEgLyAoZS5vcmllbnRhdGlvbiA9PT0gXCJhZGRPclJlbW92ZUNvbHVtbnNcIiA/IGNuIDogYW4pLFxuICAgICAgICAwLjNcbiAgICAgICk7XG4gICAgICBmID49IHUgJiYgZiA+IDAgJiYgZiAhPT0gaCAmJiAoZS5lZGl0b3IudXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAuLi5lLmJsb2NrLmNvbnRlbnQsXG4gICAgICAgICAgcm93czogZS5vcmllbnRhdGlvbiA9PT0gXCJhZGRPclJlbW92ZUNvbHVtbnNcIiA/IGUuZWRpdG9yLnRhYmxlSGFuZGxlcy5hZGRSb3dzT3JDb2x1bW5zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IG8ub3JpZ2luYWxDcm9wcGVkQ29udGVudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29sdW1uc1wiLFxuICAgICAgICAgICAgZiAtIHVcbiAgICAgICAgICApIDogZS5lZGl0b3IudGFibGVIYW5kbGVzLmFkZFJvd3NPckNvbHVtbnMoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGFibGVcIixcbiAgICAgICAgICAgICAgY29udGVudDogby5vcmlnaW5hbENyb3BwZWRDb250ZW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyb3dzXCIsXG4gICAgICAgICAgICBmIC0gdVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSksIGUuYmxvY2suY29udGVudCAmJiBlLmVkaXRvci5zZXRUZXh0Q3Vyc29yUG9zaXRpb24oZS5ibG9jaykpO1xuICAgIH07XG4gICAgcmV0dXJuIG8gJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgcyksICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHMpO1xuICAgIH07XG4gIH0sIFtvLCBlLmJsb2NrLCBlLmVkaXRvciwgZS5vcmllbnRhdGlvbl0pLCB5KCgpID0+IHtcbiAgICBjb25zdCBzID0gZS5vbk1vdXNlVXAsIGQgPSAoKSA9PiB7XG4gICAgICByKHZvaWQgMCksIHMoKTtcbiAgICB9O1xuICAgIHJldHVybiBvICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBkKSwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGQpO1xuICAgIH07XG4gIH0sIFtvLCBlLm9uTW91c2VVcF0pLCAvKiBAX19QVVJFX18gKi8gaShcbiAgICB0LlRhYmxlSGFuZGxlLkV4dGVuZEJ1dHRvbixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IEkoXG4gICAgICAgIFwiYm4tZXh0ZW5kLWJ1dHRvblwiLFxuICAgICAgICBlLm9yaWVudGF0aW9uID09PSBcImFkZE9yUmVtb3ZlQ29sdW1uc1wiID8gXCJibi1leHRlbmQtYnV0dG9uLWFkZC1yZW1vdmUtY29sdW1uc1wiIDogXCJibi1leHRlbmQtYnV0dG9uLWFkZC1yZW1vdmUtcm93c1wiLFxuICAgICAgICBvICE9PSBudWxsID8gXCJibi1leHRlbmQtYnV0dG9uLWVkaXRpbmdcIiA6IFwiXCJcbiAgICAgICksXG4gICAgICBvbkNsaWNrOiBjLFxuICAgICAgb25Nb3VzZURvd246IGwsXG4gICAgICBjaGlsZHJlbjogZS5jaGlsZHJlbiB8fCAvKiBAX19QVVJFX18gKi8gaShwbywgeyBzaXplOiAxOCwgXCJkYXRhLXRlc3RcIjogXCJleHRlbmRCdXR0b25cIiB9KVxuICAgIH1cbiAgKTtcbn0sIEplID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgciA9IGIoKS50YWJsZUhhbmRsZXM7XG4gIHJldHVybiByID8gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5HZW5lcmljLk1lbnUuSXRlbSxcbiAgICB7XG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIHIuYWRkUm93T3JDb2x1bW4oXG4gICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICBlLm9yaWVudGF0aW9uID09PSBcInJvd1wiID8geyBvcmllbnRhdGlvbjogXCJyb3dcIiwgc2lkZTogZS5zaWRlIH0gOiB7IG9yaWVudGF0aW9uOiBcImNvbHVtblwiLCBzaWRlOiBlLnNpZGUgfVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBuLnRhYmxlX2hhbmRsZVtgYWRkXyR7ZS5zaWRlfV9tZW51aXRlbWBdXG4gICAgfVxuICApIDogbnVsbDtcbn0sIF9yID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKSwgbiA9IE0oKSwgciA9IGIoKS50YWJsZUhhbmRsZXM7XG4gIHJldHVybiByID8gLyogQF9fUFVSRV9fICovIGkoXG4gICAgdC5HZW5lcmljLk1lbnUuSXRlbSxcbiAgICB7XG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIHIucmVtb3ZlUm93T3JDb2x1bW4oZS5pbmRleCwgZS5vcmllbnRhdGlvbik7XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IGUub3JpZW50YXRpb24gPT09IFwicm93XCIgPyBuLnRhYmxlX2hhbmRsZS5kZWxldGVfcm93X21lbnVpdGVtIDogbi50YWJsZV9oYW5kbGUuZGVsZXRlX2NvbHVtbl9tZW51aXRlbVxuICAgIH1cbiAgKSA6IG51bGw7XG59LCBJciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBNKCksIG8gPSBiKCksIHIgPSBvLnRhYmxlSGFuZGxlcywgbCA9IHgoKCkgPT4gIXIgfHwgIWUuYmxvY2sgPyBbXSA6IGUub3JpZW50YXRpb24gPT09IFwicm93XCIgPyByLmdldENlbGxzQXRSb3dIYW5kbGUoZS5ibG9jaywgZS5pbmRleCkgOiByLmdldENlbGxzQXRDb2x1bW5IYW5kbGUoZS5ibG9jaywgZS5pbmRleCksIFtlLmJsb2NrLCBlLmluZGV4LCBlLm9yaWVudGF0aW9uLCByXSksIGMgPSAoZCwgYSkgPT4ge1xuICAgIGNvbnN0IHUgPSBlLmJsb2NrLmNvbnRlbnQucm93cy5tYXAoKG0pID0+ICh7XG4gICAgICAuLi5tLFxuICAgICAgY2VsbHM6IG0uY2VsbHMubWFwKChoKSA9PiBLKGgpKVxuICAgIH0pKTtcbiAgICBsLmZvckVhY2goKHsgcm93OiBtLCBjb2w6IGggfSkgPT4ge1xuICAgICAgYSA9PT0gXCJ0ZXh0XCIgPyB1W21dLmNlbGxzW2hdLnByb3BzLnRleHRDb2xvciA9IGQgOiB1W21dLmNlbGxzW2hdLnByb3BzLmJhY2tncm91bmRDb2xvciA9IGQ7XG4gICAgfSksIG8udXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgY29udGVudDoge1xuICAgICAgICAuLi5lLmJsb2NrLmNvbnRlbnQsXG4gICAgICAgIHJvd3M6IHVcbiAgICAgIH1cbiAgICB9KSwgby5zZXRUZXh0Q3Vyc29yUG9zaXRpb24oZS5ibG9jayk7XG4gIH07XG4gIGlmICghbCB8fCAhbFswXSB8fCAhciB8fCBvLnNldHRpbmdzLnRhYmxlcy5jZWxsVGV4dENvbG9yID09PSAhMSAmJiBvLnNldHRpbmdzLnRhYmxlcy5jZWxsQmFja2dyb3VuZENvbG9yID09PSAhMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgcyA9IEsobFswXS5jZWxsKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KHQuR2VuZXJpYy5NZW51LlJvb3QsIHsgcG9zaXRpb246IFwicmlnaHRcIiwgc3ViOiAhMCwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuTWVudS5UcmlnZ2VyLCB7IHN1YjogITAsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuR2VuZXJpYy5NZW51Lkl0ZW0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1tZW51LWl0ZW1cIixcbiAgICAgICAgc3ViVHJpZ2dlcjogITAsXG4gICAgICAgIGNoaWxkcmVuOiBlLmNoaWxkcmVuIHx8IG4uZHJhZ19oYW5kbGUuY29sb3JzX21lbnVpdGVtXG4gICAgICB9XG4gICAgKSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuR2VuZXJpYy5NZW51LkRyb3Bkb3duLFxuICAgICAge1xuICAgICAgICBzdWI6ICEwLFxuICAgICAgICBjbGFzc05hbWU6IFwiYm4tbWVudS1kcm9wZG93biBibi1jb2xvci1waWNrZXItZHJvcGRvd25cIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIG1lLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGljb25TaXplOiAxOCxcbiAgICAgICAgICAgIHRleHQ6IG8uc2V0dGluZ3MudGFibGVzLmNlbGxUZXh0Q29sb3IgPyB7XG4gICAgICAgICAgICAgIC8vIEFsbCBjZWxscyBoYXZlIHRoZSBzYW1lIHRleHQgY29sb3JcbiAgICAgICAgICAgICAgY29sb3I6IGwuZXZlcnkoXG4gICAgICAgICAgICAgICAgKHsgY2VsbDogZCB9KSA9PiBYKGQpICYmIGQucHJvcHMudGV4dENvbG9yID09PSBzLnByb3BzLnRleHRDb2xvclxuICAgICAgICAgICAgICApID8gcy5wcm9wcy50ZXh0Q29sb3IgOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgc2V0Q29sb3I6IChkKSA9PiB7XG4gICAgICAgICAgICAgICAgYyhkLCBcInRleHRcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBvLnNldHRpbmdzLnRhYmxlcy5jZWxsQmFja2dyb3VuZENvbG9yID8ge1xuICAgICAgICAgICAgICBjb2xvcjogbC5ldmVyeShcbiAgICAgICAgICAgICAgICAoeyBjZWxsOiBkIH0pID0+IFgoZCkgJiYgZC5wcm9wcy5iYWNrZ3JvdW5kQ29sb3IgPT09IHMucHJvcHMuYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICkgPyBzLnByb3BzLmJhY2tncm91bmRDb2xvciA6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICBzZXRDb2xvcjogKGQpID0+IGMoZCwgXCJiYWNrZ3JvdW5kXCIpXG4gICAgICAgICAgICB9IDogdm9pZCAwXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKVxuICBdIH0pO1xufSwgTnIgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gQygpLCBuID0gTSgpLCBvID0gYigpO1xuICBpZiAoIW8udGFibGVIYW5kbGVzIHx8IGUuaW5kZXggIT09IDAgfHwgZS5vcmllbnRhdGlvbiAhPT0gXCJyb3dcIiB8fCAhby5zZXR0aW5ncy50YWJsZXMuaGVhZGVycylcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbCA9ICEhZS5ibG9jay5jb250ZW50LmhlYWRlclJvd3M7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICB0LkdlbmVyaWMuTWVudS5JdGVtLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1tZW51LWl0ZW1cIixcbiAgICAgIGNoZWNrZWQ6IGwsXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBvLmdldEJsb2NrKGUuYmxvY2suaWQpO1xuICAgICAgICBjICYmIG8udXBkYXRlQmxvY2soYywge1xuICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgLi4uYy5jb250ZW50LFxuICAgICAgICAgICAgaGVhZGVyUm93czogbCA/IHZvaWQgMCA6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBuLmRyYWdfaGFuZGxlLmhlYWRlcl9yb3dfbWVudWl0ZW1cbiAgICB9XG4gICk7XG59LCBQciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBNKCksIG8gPSBiKCk7XG4gIGlmICghby50YWJsZUhhbmRsZXMgfHwgZS5pbmRleCAhPT0gMCB8fCBlLm9yaWVudGF0aW9uICE9PSBcImNvbHVtblwiIHx8ICFvLnNldHRpbmdzLnRhYmxlcy5oZWFkZXJzKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBsID0gISFlLmJsb2NrLmNvbnRlbnQuaGVhZGVyQ29scztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuR2VuZXJpYy5NZW51Lkl0ZW0sXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLW1lbnUtaXRlbVwiLFxuICAgICAgY2hlY2tlZDogbCxcbiAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IG8uZ2V0QmxvY2soZS5ibG9jay5pZCk7XG4gICAgICAgIGMgJiYgby51cGRhdGVCbG9jayhjLCB7XG4gICAgICAgICAgLi4uYyxcbiAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAuLi5jLmNvbnRlbnQsXG4gICAgICAgICAgICBoZWFkZXJDb2xzOiBsID8gdm9pZCAwIDogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IG4uZHJhZ19oYW5kbGUuaGVhZGVyX2NvbHVtbl9tZW51aXRlbVxuICAgIH1cbiAgKTtcbn0sIE9yID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKHQuR2VuZXJpYy5NZW51LkRyb3Bkb3duLCB7IGNsYXNzTmFtZTogXCJibi10YWJsZS1oYW5kbGUtbWVudVwiLCBjaGlsZHJlbjogZS5jaGlsZHJlbiB8fCAvKiBAX19QVVJFX18gKi8gdihULCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICBfcixcbiAgICAgIHtcbiAgICAgICAgb3JpZW50YXRpb246IGUub3JpZW50YXRpb24sXG4gICAgICAgIGJsb2NrOiBlLmJsb2NrLFxuICAgICAgICBpbmRleDogZS5pbmRleFxuICAgICAgfVxuICAgICksXG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICBKZSxcbiAgICAgIHtcbiAgICAgICAgb3JpZW50YXRpb246IGUub3JpZW50YXRpb24sXG4gICAgICAgIGJsb2NrOiBlLmJsb2NrLFxuICAgICAgICBpbmRleDogZS5pbmRleCxcbiAgICAgICAgc2lkZTogZS5vcmllbnRhdGlvbiA9PT0gXCJyb3dcIiA/IFwiYWJvdmVcIiA6IFwibGVmdFwiXG4gICAgICB9XG4gICAgKSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIEplLFxuICAgICAge1xuICAgICAgICBvcmllbnRhdGlvbjogZS5vcmllbnRhdGlvbixcbiAgICAgICAgYmxvY2s6IGUuYmxvY2ssXG4gICAgICAgIGluZGV4OiBlLmluZGV4LFxuICAgICAgICBzaWRlOiBlLm9yaWVudGF0aW9uID09PSBcInJvd1wiID8gXCJiZWxvd1wiIDogXCJyaWdodFwiXG4gICAgICB9XG4gICAgKSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIE5yLFxuICAgICAge1xuICAgICAgICBvcmllbnRhdGlvbjogZS5vcmllbnRhdGlvbixcbiAgICAgICAgYmxvY2s6IGUuYmxvY2ssXG4gICAgICAgIGluZGV4OiBlLmluZGV4XG4gICAgICB9XG4gICAgKSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIFByLFxuICAgICAge1xuICAgICAgICBvcmllbnRhdGlvbjogZS5vcmllbnRhdGlvbixcbiAgICAgICAgYmxvY2s6IGUuYmxvY2ssXG4gICAgICAgIGluZGV4OiBlLmluZGV4XG4gICAgICB9XG4gICAgKSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIElyLFxuICAgICAge1xuICAgICAgICBvcmllbnRhdGlvbjogZS5vcmllbnRhdGlvbixcbiAgICAgICAgYmxvY2s6IGUuYmxvY2ssXG4gICAgICAgIGluZGV4OiBlLmluZGV4XG4gICAgICB9XG4gICAgKVxuICBdIH0pIH0pO1xufSwgRHIgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gQygpLCBbbiwgb10gPSBrKCExKSwgciA9IGUudGFibGVIYW5kbGVNZW51IHx8IE9yLCBsID0geCgoKSA9PiB7XG4gICAgY29uc3QgYyA9IGUuZWRpdG9yLnRhYmxlSGFuZGxlcztcbiAgICByZXR1cm4gIWMgfHwgIWUuYmxvY2sgPyAhMSA6IGUub3JpZW50YXRpb24gPT09IFwiY29sdW1uXCIgPyBjLmdldENlbGxzQXRDb2x1bW5IYW5kbGUoZS5ibG9jaywgZS5pbmRleCkuZXZlcnkoKHsgY2VsbDogcyB9KSA9PiBudChzKSA9PT0gMSkgOiBjLmdldENlbGxzQXRSb3dIYW5kbGUoZS5ibG9jaywgZS5pbmRleCkuZXZlcnkoKHsgY2VsbDogcyB9KSA9PiBvdChzKSA9PT0gMSk7XG4gIH0sIFtlLmJsb2NrLCBlLmVkaXRvci50YWJsZUhhbmRsZXMsIGUuaW5kZXgsIGUub3JpZW50YXRpb25dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgIHQuR2VuZXJpYy5NZW51LlJvb3QsXG4gICAge1xuICAgICAgb25PcGVuQ2hhbmdlOiAoYykgPT4ge1xuICAgICAgICBjID8gKGUuZnJlZXplSGFuZGxlcygpLCBlLmhpZGVPdGhlclNpZGUoKSkgOiAoZS51bmZyZWV6ZUhhbmRsZXMoKSwgZS5zaG93T3RoZXJTaWRlKCksIGUuZWRpdG9yLmZvY3VzKCkpO1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuTWVudS5UcmlnZ2VyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICB0LlRhYmxlSGFuZGxlLlJvb3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBJKFxuICAgICAgICAgICAgICBcImJuLXRhYmxlLWhhbmRsZVwiLFxuICAgICAgICAgICAgICBuID8gXCJibi10YWJsZS1oYW5kbGUtZHJhZ2dpbmdcIiA6IFwiXCIsXG4gICAgICAgICAgICAgIGwgPyBcIlwiIDogXCJibi10YWJsZS1oYW5kbGUtbm90LWRyYWdnYWJsZVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBsLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IChjKSA9PiB7XG4gICAgICAgICAgICAgIG8oITApLCBlLmRyYWdTdGFydChjKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdFbmQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgZS5kcmFnRW5kKCksIG8oITEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiBlLm9yaWVudGF0aW9uID09PSBcImNvbHVtblwiID8geyB0cmFuc2Zvcm06IFwicm90YXRlKDAuMjV0dXJuKVwiIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICBjaGlsZHJlbjogZS5jaGlsZHJlbiB8fCAvKiBAX19QVVJFX18gKi8gaShUdCwgeyBzaXplOiAyNCwgXCJkYXRhLXRlc3RcIjogXCJ0YWJsZUhhbmRsZVwiIH0pXG4gICAgICAgICAgfVxuICAgICAgICApIH0pLFxuICAgICAgICBhZShcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBlLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICBibG9jazogZS5ibG9jayxcbiAgICAgICAgICAgICAgaW5kZXg6IGUuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIGUubWVudUNvbnRhaW5lclxuICAgICAgICApXG4gICAgICBdXG4gICAgfVxuICApO1xufTtcbmZ1bmN0aW9uIFFlKGUsIHQsIG4pIHtcbiAgY29uc3QgeyByZWZzOiBvLCB1cGRhdGU6IHIsIGNvbnRleHQ6IGwsIGZsb2F0aW5nU3R5bGVzOiBjIH0gPSBCZSh7XG4gICAgb3BlbjogdCxcbiAgICBwbGFjZW1lbnQ6IGUgPT09IFwiYWRkT3JSZW1vdmVDb2x1bW5zXCIgPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiLFxuICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgIFNlKHtcbiAgICAgICAgYXBwbHkoeyByZWN0czogYSwgZWxlbWVudHM6IHUgfSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB1LmZsb2F0aW5nLnN0eWxlLFxuICAgICAgICAgICAgZSA9PT0gXCJhZGRPclJlbW92ZUNvbHVtbnNcIiA/IHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiBgJHthLnJlZmVyZW5jZS5oZWlnaHR9cHhgXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICB3aWR0aDogYCR7YS5yZWZlcmVuY2Uud2lkdGh9cHhgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdXG4gIH0pLCB7IGlzTW91bnRlZDogcywgc3R5bGVzOiBkIH0gPSBWZShsKTtcbiAgcmV0dXJuIHkoKCkgPT4ge1xuICAgIHIoKTtcbiAgfSwgW24sIHJdKSwgeSgoKSA9PiB7XG4gICAgbiAhPT0gbnVsbCAmJiBvLnNldFJlZmVyZW5jZSh7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IG5cbiAgICB9KTtcbiAgfSwgW2UsIG4sIG9dKSwgeChcbiAgICAoKSA9PiAoe1xuICAgICAgaXNNb3VudGVkOiBzLFxuICAgICAgcmVmOiBvLnNldEZsb2F0aW5nLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIC4uLmQsXG4gICAgICAgIC4uLmNcbiAgICAgIH1cbiAgICB9KSxcbiAgICBbYywgcywgby5zZXRGbG9hdGluZywgZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIFpyKGUsIHQsIG4pIHtcbiAgY29uc3QgbyA9IFFlKFxuICAgIFwiYWRkT3JSZW1vdmVSb3dzXCIsXG4gICAgdCxcbiAgICBuXG4gICksIHIgPSBRZShcbiAgICBcImFkZE9yUmVtb3ZlQ29sdW1uc1wiLFxuICAgIGUsXG4gICAgblxuICApO1xuICByZXR1cm4geChcbiAgICAoKSA9PiAoe1xuICAgICAgYWRkT3JSZW1vdmVSb3dzQnV0dG9uOiBvLFxuICAgICAgYWRkT3JSZW1vdmVDb2x1bW5zQnV0dG9uOiByXG4gICAgfSksXG4gICAgW3IsIG9dXG4gICk7XG59XG5mdW5jdGlvbiBGcihlLCB0LCBuKSB7XG4gIHJldHVybiBuICYmIG4uZHJhZ2dlZENlbGxPcmllbnRhdGlvbiA9PT0gXCJyb3dcIiA/IG5ldyBET01SZWN0KFxuICAgIHQueCxcbiAgICBuLm1vdXNlUG9zLFxuICAgIHQud2lkdGgsXG4gICAgMFxuICApIDogbmV3IERPTVJlY3QoXG4gICAgdC54LFxuICAgIGUueSxcbiAgICB0LndpZHRoLFxuICAgIGUuaGVpZ2h0XG4gICk7XG59XG5mdW5jdGlvbiBBcihlLCB0LCBuKSB7XG4gIHJldHVybiBuICYmIG4uZHJhZ2dlZENlbGxPcmllbnRhdGlvbiA9PT0gXCJjb2xcIiA/IG5ldyBET01SZWN0KFxuICAgIG4ubW91c2VQb3MsXG4gICAgdC55LFxuICAgIDAsXG4gICAgdC5oZWlnaHRcbiAgKSA6IG5ldyBET01SZWN0KFxuICAgIGUueCxcbiAgICB0LnksXG4gICAgZS53aWR0aCxcbiAgICB0LmhlaWdodFxuICApO1xufVxuZnVuY3Rpb24gR3IoZSkge1xuICByZXR1cm4gbmV3IERPTVJlY3QoXG4gICAgZS54LFxuICAgIGUueSxcbiAgICBlLndpZHRoLFxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIENlKGUsIHQsIG4sIG8sIHIpIHtcbiAgY29uc3QgeyByZWZzOiBsLCB1cGRhdGU6IGMsIGNvbnRleHQ6IHMsIGZsb2F0aW5nU3R5bGVzOiBkIH0gPSBCZSh7XG4gICAgb3BlbjogdCxcbiAgICBwbGFjZW1lbnQ6IGUgPT09IFwicm93XCIgPyBcImxlZnRcIiA6IGUgPT09IFwiY29sXCIgPyBcInRvcFwiIDogXCJib3R0b20tZW5kXCIsXG4gICAgbWlkZGxld2FyZTogW1xuICAgICAgQShcbiAgICAgICAgZSA9PT0gXCJyb3dcIiA/IC0xMCA6IGUgPT09IFwiY29sXCIgPyAtMTIgOiB7IG1haW5BeGlzOiAxLCBjcm9zc0F4aXM6IC0xIH1cbiAgICAgIClcbiAgICBdXG4gIH0pLCB7IGlzTW91bnRlZDogYSwgc3R5bGVzOiB1IH0gPSBWZShzKTtcbiAgcmV0dXJuIHkoKCkgPT4ge1xuICAgIGMoKTtcbiAgfSwgW24sIG8sIGNdKSwgeSgoKSA9PiB7XG4gICAgbiA9PT0gbnVsbCB8fCBvID09PSBudWxsIHx8IC8vIElnbm9yZSBjZWxsIGhhbmRsZSB3aGVuIGRyYWdnaW5nXG4gICAgciAmJiBlID09PSBcImNlbGxcIiB8fCBsLnNldFJlZmVyZW5jZSh7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IChlID09PSBcInJvd1wiID8gRnIgOiBlID09PSBcImNvbFwiID8gQXIgOiBHcikobiwgbywgcilcbiAgICB9KTtcbiAgfSwgW3IsIGUsIG4sIG8sIGxdKSwgeChcbiAgICAoKSA9PiAoe1xuICAgICAgaXNNb3VudGVkOiBhLFxuICAgICAgcmVmOiBsLnNldEZsb2F0aW5nLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIC4uLnUsXG4gICAgICAgIC4uLmRcbiAgICAgIH1cbiAgICB9KSxcbiAgICBbZCwgYSwgbC5zZXRGbG9hdGluZywgdV1cbiAgKTtcbn1cbmZ1bmN0aW9uIFVyKGUsIHQsIG4sIG8pIHtcbiAgY29uc3QgciA9IENlKFxuICAgIFwicm93XCIsXG4gICAgZSxcbiAgICB0LFxuICAgIG4sXG4gICAgb1xuICApLCBsID0gQ2UoXG4gICAgXCJjb2xcIixcbiAgICBlLFxuICAgIHQsXG4gICAgbixcbiAgICBvXG4gICksIGMgPSBDZShcbiAgICBcImNlbGxcIixcbiAgICBlLFxuICAgIHQsXG4gICAgbixcbiAgICBvXG4gICk7XG4gIHJldHVybiB4KFxuICAgICgpID0+ICh7XG4gICAgICByb3dIYW5kbGU6IHIsXG4gICAgICBjb2xIYW5kbGU6IGwsXG4gICAgICBjZWxsSGFuZGxlOiBjXG4gICAgfSksXG4gICAgW2wsIHIsIGNdXG4gICk7XG59XG5jb25zdCB6ciA9IChlKSA9PiB7XG4gIHZhciBjLCBzO1xuICBjb25zdCB0ID0gQygpLCBuID0gTSgpLCBvID0gYigpLCByID0gKGQsIGEpID0+IHtcbiAgICBjb25zdCB1ID0gZS5ibG9jay5jb250ZW50LnJvd3MubWFwKChtKSA9PiAoe1xuICAgICAgLi4ubSxcbiAgICAgIGNlbGxzOiBtLmNlbGxzLm1hcCgoaCkgPT4gSyhoKSlcbiAgICB9KSk7XG4gICAgYSA9PT0gXCJ0ZXh0XCIgPyB1W2Uucm93SW5kZXhdLmNlbGxzW2UuY29sSW5kZXhdLnByb3BzLnRleHRDb2xvciA9IGQgOiB1W2Uucm93SW5kZXhdLmNlbGxzW2UuY29sSW5kZXhdLnByb3BzLmJhY2tncm91bmRDb2xvciA9IGQsIG8udXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgY29udGVudDoge1xuICAgICAgICAuLi5lLmJsb2NrLmNvbnRlbnQsXG4gICAgICAgIHJvd3M6IHVcbiAgICAgIH1cbiAgICB9KSwgby5zZXRUZXh0Q3Vyc29yUG9zaXRpb24oZS5ibG9jayk7XG4gIH0sIGwgPSAocyA9IChjID0gZS5ibG9jay5jb250ZW50LnJvd3NbZS5yb3dJbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBjLmNlbGxzKSA9PSBudWxsID8gdm9pZCAwIDogc1tlLmNvbEluZGV4XTtcbiAgcmV0dXJuICFsIHx8IG8uc2V0dGluZ3MudGFibGVzLmNlbGxUZXh0Q29sb3IgPT09ICExICYmIG8uc2V0dGluZ3MudGFibGVzLmNlbGxCYWNrZ3JvdW5kQ29sb3IgPT09ICExID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyB2KHQuR2VuZXJpYy5NZW51LlJvb3QsIHsgcG9zaXRpb246IFwicmlnaHRcIiwgc3ViOiAhMCwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuTWVudS5UcmlnZ2VyLCB7IHN1YjogITAsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuR2VuZXJpYy5NZW51Lkl0ZW0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJibi1tZW51LWl0ZW1cIixcbiAgICAgICAgc3ViVHJpZ2dlcjogITAsXG4gICAgICAgIGNoaWxkcmVuOiBlLmNoaWxkcmVuIHx8IG4uZHJhZ19oYW5kbGUuY29sb3JzX21lbnVpdGVtXG4gICAgICB9XG4gICAgKSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHQuR2VuZXJpYy5NZW51LkRyb3Bkb3duLFxuICAgICAge1xuICAgICAgICBzdWI6ICEwLFxuICAgICAgICBjbGFzc05hbWU6IFwiYm4tbWVudS1kcm9wZG93biBibi1jb2xvci1waWNrZXItZHJvcGRvd25cIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgIG1lLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGljb25TaXplOiAxOCxcbiAgICAgICAgICAgIHRleHQ6IG8uc2V0dGluZ3MudGFibGVzLmNlbGxUZXh0Q29sb3IgPyB7XG4gICAgICAgICAgICAgIGNvbG9yOiBYKGwpID8gbC5wcm9wcy50ZXh0Q29sb3IgOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgc2V0Q29sb3I6IChkKSA9PiByKGQsIFwidGV4dFwiKVxuICAgICAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IG8uc2V0dGluZ3MudGFibGVzLmNlbGxCYWNrZ3JvdW5kQ29sb3IgPyB7XG4gICAgICAgICAgICAgIGNvbG9yOiBYKGwpID8gbC5wcm9wcy5iYWNrZ3JvdW5kQ29sb3IgOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgc2V0Q29sb3I6IChkKSA9PiByKGQsIFwiYmFja2dyb3VuZFwiKVxuICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIClcbiAgXSB9KTtcbn0sIGpyID0gKGUpID0+IHtcbiAgdmFyIGwsIGM7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBNKCksIG8gPSBiKCksIHIgPSAoYyA9IChsID0gZS5ibG9jay5jb250ZW50LnJvd3NbZS5yb3dJbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBsLmNlbGxzKSA9PSBudWxsID8gdm9pZCAwIDogY1tlLmNvbEluZGV4XTtcbiAgcmV0dXJuICFyIHx8ICFYKHIpIHx8IG90KHIpID09PSAxICYmIG50KHIpID09PSAxIHx8ICFvLnNldHRpbmdzLnRhYmxlcy5zcGxpdENlbGxzID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuR2VuZXJpYy5NZW51Lkl0ZW0sXG4gICAge1xuICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICB2YXIgcztcbiAgICAgICAgKHMgPSBvLnRhYmxlSGFuZGxlcykgPT0gbnVsbCB8fCBzLnNwbGl0Q2VsbCh7XG4gICAgICAgICAgcm93OiBlLnJvd0luZGV4LFxuICAgICAgICAgIGNvbDogZS5jb2xJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogbi50YWJsZV9oYW5kbGUuc3BsaXRfY2VsbF9tZW51aXRlbVxuICAgIH1cbiAgKTtcbn0sIFdyID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIHQuR2VuZXJpYy5NZW51LkRyb3Bkb3duLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1tZW51LWRyb3Bkb3duIGJuLWRyYWctaGFuZGxlLW1lbnVcIixcbiAgICAgIGNoaWxkcmVuOiBlLmNoaWxkcmVuIHx8IC8qIEBfX1BVUkVfXyAqLyB2KFQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAganIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2s6IGUuYmxvY2ssXG4gICAgICAgICAgICByb3dJbmRleDogZS5yb3dJbmRleCxcbiAgICAgICAgICAgIGNvbEluZGV4OiBlLmNvbEluZGV4XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICB6cixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBibG9jazogZS5ibG9jayxcbiAgICAgICAgICAgIHJvd0luZGV4OiBlLnJvd0luZGV4LFxuICAgICAgICAgICAgY29sSW5kZXg6IGUuY29sSW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIF0gfSlcbiAgICB9XG4gICk7XG59LCAkciA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBDKCksIG4gPSBlLnRhYmxlQ2VsbE1lbnUgfHwgV3I7XG4gIHJldHVybiAhZS5lZGl0b3Iuc2V0dGluZ3MudGFibGVzLnNwbGl0Q2VsbHMgJiYgIWUuZWRpdG9yLnNldHRpbmdzLnRhYmxlcy5jZWxsQmFja2dyb3VuZENvbG9yICYmICFlLmVkaXRvci5zZXR0aW5ncy50YWJsZXMuY2VsbFRleHRDb2xvciA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gdihcbiAgICB0LkdlbmVyaWMuTWVudS5Sb290LFxuICAgIHtcbiAgICAgIG9uT3BlbkNoYW5nZTogKG8pID0+IHtcbiAgICAgICAgbyA/IGUuZnJlZXplSGFuZGxlcygpIDogKGUudW5mcmVlemVIYW5kbGVzKCksIGUuZWRpdG9yLmZvY3VzKCkpO1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuTWVudS5UcmlnZ2VyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaSh0LkdlbmVyaWMuTWVudS5CdXR0b24sIHsgY2xhc3NOYW1lOiBcImJuLXRhYmxlLWNlbGwtaGFuZGxlXCIsIGNoaWxkcmVuOiBlLmNoaWxkcmVuIHx8IC8qIEBfX1BVUkVfXyAqLyBpKHVyLCB7IHNpemU6IDEyLCBcImRhdGEtdGVzdFwiOiBcInRhYmxlQ2VsbEhhbmRsZVwiIH0pIH0pIH0pLFxuICAgICAgICBhZShcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJsb2NrOiBlLmJsb2NrLFxuICAgICAgICAgICAgICByb3dJbmRleDogZS5yb3dJbmRleCxcbiAgICAgICAgICAgICAgY29sSW5kZXg6IGUuY29sSW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIGUubWVudUNvbnRhaW5lclxuICAgICAgICApXG4gICAgICBdXG4gICAgfVxuICApO1xufSwgcXIgPSAoZSkgPT4ge1xuICB2YXIgJCwgRTtcbiAgY29uc3QgdCA9IGIoKSwgW24sIG9dID0gayhudWxsKTtcbiAgaWYgKCF0LnRhYmxlSGFuZGxlcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRhYmxlSGFuZGxlc0NvbnRyb2xsZXIgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIEJsb2NrTm90ZSBlZGl0b3Igc2NoZW1hIGNvbnRhaW5zIHRhYmxlIGJsb2NrXCJcbiAgICApO1xuICBjb25zdCByID0ge1xuICAgIHJvd0RyYWdTdGFydDogdC50YWJsZUhhbmRsZXMucm93RHJhZ1N0YXJ0LFxuICAgIGNvbERyYWdTdGFydDogdC50YWJsZUhhbmRsZXMuY29sRHJhZ1N0YXJ0LFxuICAgIGRyYWdFbmQ6IHQudGFibGVIYW5kbGVzLmRyYWdFbmQsXG4gICAgZnJlZXplSGFuZGxlczogdC50YWJsZUhhbmRsZXMuZnJlZXplSGFuZGxlcyxcbiAgICB1bmZyZWV6ZUhhbmRsZXM6IHQudGFibGVIYW5kbGVzLnVuZnJlZXplSGFuZGxlc1xuICB9LCB7IGZyZWV6ZUhhbmRsZXM6IGwsIHVuZnJlZXplSGFuZGxlczogYyB9ID0gciwgcyA9IGcoKCkgPT4ge1xuICAgIGwoKSwgTyghMCksIFYoITApO1xuICB9LCBbbF0pLCBkID0gZygoKSA9PiB7XG4gICAgYygpLCBPKCExKSwgVighMSk7XG4gIH0sIFtjXSksIGEgPSBQKFxuICAgIHQudGFibGVIYW5kbGVzLm9uVXBkYXRlLmJpbmQodC50YWJsZUhhbmRsZXMpXG4gICksIHUgPSB4KCgpID0+IHtcbiAgICB2YXIgRiwgZWU7XG4gICAgcmV0dXJuIGEgIT0gbnVsbCAmJiBhLmRyYWdnaW5nU3RhdGUgPyB7XG4gICAgICBkcmFnZ2VkQ2VsbE9yaWVudGF0aW9uOiAoRiA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZHJhZ2dpbmdTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEYuZHJhZ2dlZENlbGxPcmllbnRhdGlvbixcbiAgICAgIG1vdXNlUG9zOiAoZWUgPSBhID09IG51bGwgPyB2b2lkIDAgOiBhLmRyYWdnaW5nU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBlZS5tb3VzZVBvc1xuICAgIH0gOiB2b2lkIDA7XG4gIH0sIFtcbiAgICBhID09IG51bGwgPyB2b2lkIDAgOiBhLmRyYWdnaW5nU3RhdGUsXG4gICAgKCQgPSBhID09IG51bGwgPyB2b2lkIDAgOiBhLmRyYWdnaW5nU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiAkLmRyYWdnZWRDZWxsT3JpZW50YXRpb24sXG4gICAgKEUgPSBhID09IG51bGwgPyB2b2lkIDAgOiBhLmRyYWdnaW5nU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBFLm1vdXNlUG9zXG4gIF0pLCB7IHJvd0hhbmRsZTogbSwgY29sSGFuZGxlOiBoLCBjZWxsSGFuZGxlOiBmIH0gPSBVcihcbiAgICAoYSA9PSBudWxsID8gdm9pZCAwIDogYS5zaG93KSB8fCAhMSxcbiAgICAoYSA9PSBudWxsID8gdm9pZCAwIDogYS5yZWZlcmVuY2VQb3NDZWxsKSB8fCBudWxsLFxuICAgIChhID09IG51bGwgPyB2b2lkIDAgOiBhLnJlZmVyZW5jZVBvc1RhYmxlKSB8fCBudWxsLFxuICAgIHVcbiAgKSwgeyBhZGRPclJlbW92ZUNvbHVtbnNCdXR0b246IHcsIGFkZE9yUmVtb3ZlUm93c0J1dHRvbjogSCB9ID0gWnIoXG4gICAgKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuc2hvd0FkZE9yUmVtb3ZlQ29sdW1uc0J1dHRvbikgfHwgITEsXG4gICAgKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuc2hvd0FkZE9yUmVtb3ZlUm93c0J1dHRvbikgfHwgITEsXG4gICAgKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEucmVmZXJlbmNlUG9zVGFibGUpIHx8IG51bGxcbiAgKSwgW0IsIFZdID0gayghMSksIFtTLCBPXSA9IGsoITEpO1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHogPSBlLnRhYmxlSGFuZGxlIHx8IERyLCBqID0gZS5leHRlbmRCdXR0b24gfHwgUnIsIFogPSBlLnRhYmxlQ2VsbEhhbmRsZSB8fCAkcjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFQsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IHJlZjogbyB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gdigkdCwgeyByb290OiBhLndpZGdldENvbnRhaW5lciwgY2hpbGRyZW46IFtcbiAgICAgICFCICYmIG4gJiYgbS5pc01vdW50ZWQgJiYgYS5yb3dJbmRleCAhPT0gdm9pZCAwICYmIC8qIEBfX1BVUkVfXyAqLyBpKFwiZGl2XCIsIHsgcmVmOiBtLnJlZiwgc3R5bGU6IG0uc3R5bGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgeixcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvcjogdCxcbiAgICAgICAgICBvcmllbnRhdGlvbjogXCJyb3dcIixcbiAgICAgICAgICBzaG93T3RoZXJTaWRlOiAoKSA9PiBPKCExKSxcbiAgICAgICAgICBoaWRlT3RoZXJTaWRlOiAoKSA9PiBPKCEwKSxcbiAgICAgICAgICBpbmRleDogYS5yb3dJbmRleCxcbiAgICAgICAgICBibG9jazogYS5ibG9jayxcbiAgICAgICAgICBkcmFnU3RhcnQ6IHIucm93RHJhZ1N0YXJ0LFxuICAgICAgICAgIGRyYWdFbmQ6IHIuZHJhZ0VuZCxcbiAgICAgICAgICBmcmVlemVIYW5kbGVzOiByLmZyZWV6ZUhhbmRsZXMsXG4gICAgICAgICAgdW5mcmVlemVIYW5kbGVzOiByLnVuZnJlZXplSGFuZGxlcyxcbiAgICAgICAgICBtZW51Q29udGFpbmVyOiBuXG4gICAgICAgIH1cbiAgICAgICkgfSksXG4gICAgICAhUyAmJiBuICYmIGguaXNNb3VudGVkICYmIGEuY29sSW5kZXggIT09IHZvaWQgMCAmJiAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IHJlZjogaC5yZWYsIHN0eWxlOiBoLnN0eWxlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgIHosXG4gICAgICAgIHtcbiAgICAgICAgICBlZGl0b3I6IHQsXG4gICAgICAgICAgb3JpZW50YXRpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgc2hvd090aGVyU2lkZTogKCkgPT4gVighMSksXG4gICAgICAgICAgaGlkZU90aGVyU2lkZTogKCkgPT4gVighMCksXG4gICAgICAgICAgaW5kZXg6IGEuY29sSW5kZXgsXG4gICAgICAgICAgYmxvY2s6IGEuYmxvY2ssXG4gICAgICAgICAgZHJhZ1N0YXJ0OiByLmNvbERyYWdTdGFydCxcbiAgICAgICAgICBkcmFnRW5kOiByLmRyYWdFbmQsXG4gICAgICAgICAgZnJlZXplSGFuZGxlczogci5mcmVlemVIYW5kbGVzLFxuICAgICAgICAgIHVuZnJlZXplSGFuZGxlczogci51bmZyZWV6ZUhhbmRsZXMsXG4gICAgICAgICAgbWVudUNvbnRhaW5lcjogblxuICAgICAgICB9XG4gICAgICApIH0pLFxuICAgICAgbiAmJiBmLmlzTW91bnRlZCAmJiBhLmNvbEluZGV4ICE9PSB2b2lkIDAgJiYgYS5yb3dJbmRleCAhPT0gdm9pZCAwICYmIC8qIEBfX1BVUkVfXyAqLyBpKFwiZGl2XCIsIHsgcmVmOiBmLnJlZiwgc3R5bGU6IGYuc3R5bGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgWixcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvcjogdCxcbiAgICAgICAgICBibG9jazogYS5ibG9jayxcbiAgICAgICAgICByb3dJbmRleDogYS5yb3dJbmRleCxcbiAgICAgICAgICBjb2xJbmRleDogYS5jb2xJbmRleCxcbiAgICAgICAgICBtZW51Q29udGFpbmVyOiBuLFxuICAgICAgICAgIGZyZWV6ZUhhbmRsZXM6IHIuZnJlZXplSGFuZGxlcyxcbiAgICAgICAgICB1bmZyZWV6ZUhhbmRsZXM6IHIudW5mcmVlemVIYW5kbGVzXG4gICAgICAgIH1cbiAgICAgICkgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogSC5yZWYsXG4gICAgICAgICAgc3R5bGU6IEguc3R5bGUsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0LFxuICAgICAgICAgICAgICBvcmllbnRhdGlvbjogXCJhZGRPclJlbW92ZVJvd3NcIixcbiAgICAgICAgICAgICAgYmxvY2s6IGEuYmxvY2ssXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duOiBzLFxuICAgICAgICAgICAgICBvbk1vdXNlVXA6IGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogdy5yZWYsXG4gICAgICAgICAgc3R5bGU6IHcuc3R5bGUsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0LFxuICAgICAgICAgICAgICBvcmllbnRhdGlvbjogXCJhZGRPclJlbW92ZUNvbHVtbnNcIixcbiAgICAgICAgICAgICAgYmxvY2s6IGEuYmxvY2ssXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duOiBzLFxuICAgICAgICAgICAgICBvbk1vdXNlVXA6IGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdIH0pXG4gIF0gfSk7XG59O1xuZnVuY3Rpb24gS3IoZSkge1xuICBjb25zdCB0ID0gYigpO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJCbG9ja05vdGVEZWZhdWx0VUkgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJsb2NrTm90ZUNvbnRleHQuUHJvdmlkZXJcIlxuICAgICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gdihULCB7IGNoaWxkcmVuOiBbXG4gICAgZS5mb3JtYXR0aW5nVG9vbGJhciAhPT0gITEgJiYgLyogQF9fUFVSRV9fICovIGkob3IsIHt9KSxcbiAgICBlLmxpbmtUb29sYmFyICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gaShhciwge30pLFxuICAgIGUuc2xhc2hNZW51ICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gaShMciwgeyB0cmlnZ2VyQ2hhcmFjdGVyOiBcIi9cIiB9KSxcbiAgICBlLmVtb2ppUGlja2VyICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIHhyLFxuICAgICAge1xuICAgICAgICB0cmlnZ2VyQ2hhcmFjdGVyOiBcIjpcIixcbiAgICAgICAgY29sdW1uczogMTAsXG4gICAgICAgIG1pblF1ZXJ5TGVuZ3RoOiAyXG4gICAgICB9XG4gICAgKSxcbiAgICBlLnNpZGVNZW51ICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gaShrciwge30pLFxuICAgIHQuZmlsZVBhbmVsICYmIGUuZmlsZVBhbmVsICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gaShObywge30pLFxuICAgIHQudGFibGVIYW5kbGVzICYmIGUudGFibGVIYW5kbGVzICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gaShxciwge30pLFxuICAgIHQuY29tbWVudHMgJiYgZS5jb21tZW50cyAhPT0gITEgJiYgLyogQF9fUFVSRV9fICovIHYoVCwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGkoQW4sIHt9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKFJvLCB7fSlcbiAgICBdIH0pXG4gIF0gfSk7XG59XG5jb25zdCBYciA9ICgpID0+IHtcbiAgY29uc3QgZSA9IHgoXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIGM7XG4gICAgICByZXR1cm4gKGMgPSB3aW5kb3cubWF0Y2hNZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMuY2FsbCh3aW5kb3csIFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKTtcbiAgICB9LFxuICAgIFtdXG4gICksIHQgPSB4KFxuICAgICgpID0+IHtcbiAgICAgIHZhciBjO1xuICAgICAgcmV0dXJuIChjID0gd2luZG93Lm1hdGNoTWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBjLmNhbGwod2luZG93LCBcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpXCIpO1xuICAgIH0sXG4gICAgW11cbiAgKSwgbiA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubWF0Y2hlcywgbyA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubWF0Y2hlcywgW3IsIGxdID0gayhuID8gXCJkYXJrXCIgOiBvID8gXCJsaWdodFwiIDogXCJuby1wcmVmZXJlbmNlXCIpO1xuICByZXR1cm4geSgoKSA9PiB7XG4gICAgbChuID8gXCJkYXJrXCIgOiBvID8gXCJsaWdodFwiIDogXCJuby1wcmVmZXJlbmNlXCIpO1xuICB9LCBbbiwgb10pLCB5KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIChlID09IG51bGwgPyB2b2lkIDAgOiBlLmFkZEV2ZW50TGlzdGVuZXIpID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgYyA9ICh7IG1hdGNoZXM6IGQgfSkgPT4gZCAmJiBsKFwiZGFya1wiKSwgcyA9ICh7IG1hdGNoZXM6IGQgfSkgPT4gZCAmJiBsKFwibGlnaHRcIik7XG4gICAgICByZXR1cm4gZSA9PSBudWxsIHx8IGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjKSwgdCA9PSBudWxsIHx8IHQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBzKSwgKCkgPT4ge1xuICAgICAgICBlID09IG51bGwgfHwgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGMpLCB0ID09IG51bGwgfHwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYyA9ICgpID0+IGwoXG4gICAgICAgIGUubWF0Y2hlcyA/IFwiZGFya1wiIDogdC5tYXRjaGVzID8gXCJsaWdodFwiIDogXCJuby1wcmVmZXJlbmNlXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZSA9PSBudWxsIHx8IGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjKSwgdCA9PSBudWxsIHx8IHQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjKSwgKCkgPT4ge1xuICAgICAgICBlID09IG51bGwgfHwgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGMpLCB0ID09IG51bGwgfHwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlLCB0XSksIHR5cGVvZiB3aW5kb3cubWF0Y2hNZWRpYSAhPSBcImZ1bmN0aW9uXCIsIHI7XG59LCBSdCA9IE1lKHZvaWQgMCk7XG5mdW5jdGlvbiBZcigpIHtcbiAgcmV0dXJuIHhlKFJ0KTtcbn1cbmZ1bmN0aW9uIEpyKCkge1xuICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHQgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKG4pIHtcbiAgICAgIHJldHVybiBlLmFkZChuKSwgKCkgPT4ge1xuICAgICAgICBlLmRlbGV0ZShuKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTbmFwc2hvdCgpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgTm9kZVZpZXcgUmVuZGVyZXIgdG8gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBzZXRSZW5kZXJlcihuLCBvKSB7XG4gICAgICB0ID0ge1xuICAgICAgICAuLi50LFxuICAgICAgICBbbl06IGFlKG8ucmVhY3RFbGVtZW50LCBvLmVsZW1lbnQsIG4pXG4gICAgICB9LCBlLmZvckVhY2goKHIpID0+IHIoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgTm9kZVZpZXcgUmVuZGVyZXIgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIHJlbW92ZVJlbmRlcmVyKG4pIHtcbiAgICAgIGNvbnN0IG8gPSB7IC4uLnQgfTtcbiAgICAgIGRlbGV0ZSBvW25dLCB0ID0gbywgZS5mb3JFYWNoKChyKSA9PiByKCkpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFFyID0gKHtcbiAgY29udGVudENvbXBvbmVudDogZVxufSkgPT4ge1xuICBjb25zdCB0ID0geWUoXG4gICAgZS5zdWJzY3JpYmUsXG4gICAgZS5nZXRTbmFwc2hvdCxcbiAgICBlLmdldFNlcnZlclNuYXBzaG90XG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShULCB7IGNoaWxkcmVuOiBPYmplY3QudmFsdWVzKHQpIH0pO1xufSwgZWkgPSBVdCgoZSwgdCkgPT4ge1xuICBjb25zdCBbbiwgb10gPSBrKCk7XG4gIHJldHVybiB6dChcbiAgICB0LFxuICAgICgpID0+IChyLCBsKSA9PiB7XG4gICAgICBsdCgoKSA9PiB7XG4gICAgICAgIG8oeyBub2RlOiByLCBjb250YWluZXI6IGwgfSk7XG4gICAgICB9KSwgbyh2b2lkIDApO1xuICAgIH0sXG4gICAgW11cbiAgKSwgLyogQF9fUFVSRV9fICovIGkoVCwgeyBjaGlsZHJlbjogbiAmJiBhZShuLm5vZGUsIG4uY29udGFpbmVyKSB9KTtcbn0pLCBldCA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiB0aShlLCB0KSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3I6IG4sXG4gICAgY2xhc3NOYW1lOiBvLFxuICAgIHRoZW1lOiByLFxuICAgIGNoaWxkcmVuOiBsLFxuICAgIGVkaXRhYmxlOiBjLFxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiBzLFxuICAgIG9uQ2hhbmdlOiBkLFxuICAgIGZvcm1hdHRpbmdUb29sYmFyOiBhLFxuICAgIGxpbmtUb29sYmFyOiB1LFxuICAgIHNsYXNoTWVudTogbSxcbiAgICBlbW9qaVBpY2tlcjogaCxcbiAgICBzaWRlTWVudTogZixcbiAgICBmaWxlUGFuZWw6IHcsXG4gICAgdGFibGVIYW5kbGVzOiBILFxuICAgIGNvbW1lbnRzOiBCLFxuICAgIGF1dG9Gb2N1czogVixcbiAgICByZW5kZXJFZGl0b3I6IFMgPSAhbi5oZWFkbGVzcyxcbiAgICAuLi5PXG4gIH0gPSBlLCBbeiwgal0gPSBrKCksIFogPSBEKCksICQgPSBYcigpLCBFID0gKFogPT0gbnVsbCA/IHZvaWQgMCA6IFouY29sb3JTY2hlbWVQcmVmZXJlbmNlKSB8fCAkLCBGID0gciB8fCAoRSA9PT0gXCJkYXJrXCIgPyBcImRhcmtcIiA6IFwibGlnaHRcIik7XG4gIHVlKGQgfHwgZXQsIG4pLCBzZShzIHx8IGV0LCBuKSwgeSgoKSA9PiB7XG4gICAgbi5pc0VkaXRhYmxlID0gYyAhPT0gITE7XG4gIH0sIFtjLCBuXSk7XG4gIGNvbnN0IGVlID0gZyhcbiAgICAoRHQpID0+IHtcbiAgICAgIG4uZWxlbWVudFJlbmRlcmVyID0gRHQ7XG4gICAgfSxcbiAgICBbbl1cbiAgKSwgTnQgPSB4KCgpID0+ICh7XG4gICAgLi4uWixcbiAgICBlZGl0b3I6IG4sXG4gICAgc2V0Q29udGVudEVkaXRhYmxlUHJvcHM6IGpcbiAgfSksIFtaLCBuXSksIFB0ID0ge1xuICAgIGZvcm1hdHRpbmdUb29sYmFyOiBhLFxuICAgIGxpbmtUb29sYmFyOiB1LFxuICAgIHNsYXNoTWVudTogbSxcbiAgICBlbW9qaVBpY2tlcjogaCxcbiAgICBzaWRlTWVudTogZixcbiAgICBmaWxlUGFuZWw6IHcsXG4gICAgdGFibGVIYW5kbGVzOiBILFxuICAgIGNvbW1lbnRzOiBCXG4gIH0sIE90ID0ge1xuICAgIGF1dG9Gb2N1czogVixcbiAgICBjb250ZW50RWRpdGFibGVQcm9wczogelxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoZHQuUHJvdmlkZXIsIHsgdmFsdWU6IE50LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHYoXG4gICAgUnQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgZWRpdG9yUHJvcHM6IE90LFxuICAgICAgICBkZWZhdWx0VUlQcm9wczogUHRcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gaShlaSwgeyByZWY6IGVlIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICBuaSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IG8sXG4gICAgICAgICAgICByZW5kZXJFZGl0b3I6IFMsXG4gICAgICAgICAgICBlZGl0b3JDb2xvclNjaGVtZTogRixcbiAgICAgICAgICAgIHJlZjogdCxcbiAgICAgICAgICAgIC4uLk8sXG4gICAgICAgICAgICBjaGlsZHJlbjogbFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXVxuICAgIH1cbiAgKSB9KTtcbn1cbmNvbnN0IG5pID0gTi5mb3J3YXJkUmVmKCh7IGNsYXNzTmFtZTogZSwgcmVuZGVyRWRpdG9yOiB0LCBlZGl0b3JDb2xvclNjaGVtZTogbiwgY2hpbGRyZW46IG8sIC4uLnIgfSwgbCkgPT4gLyogQF9fUFVSRV9fICovIGkoXG4gIFwiZGl2XCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEkoXCJibi1jb250YWluZXJcIiwgbiwgZSksXG4gICAgXCJkYXRhLWNvbG9yLXNjaGVtZVwiOiBuLFxuICAgIC4uLnIsXG4gICAgcmVmOiBsLFxuICAgIGNoaWxkcmVuOiB0ID8gLyogQF9fUFVSRV9fICovIGkob2ksIHsgY2hpbGRyZW46IG8gfSkgOiBvXG4gIH1cbikpLCBGaSA9IE4uZm9yd2FyZFJlZih0aSksIG9pID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IFlyKCksIG4gPSBiKCksIG8gPSB4KCgpID0+IEpyKCksIFtdKSwgciA9IGcoXG4gICAgKGwpID0+IHtcbiAgICAgIG4ubW91bnQobCwgbyk7XG4gICAgfSxcbiAgICBbbiwgb11cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFQsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gaShRciwgeyBjb250ZW50Q29tcG9uZW50OiBvIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBpKHJpLCB7IC4uLnQuZWRpdG9yUHJvcHMsIC4uLmUsIG1vdW50OiByIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBpKEtyLCB7IC4uLnQuZGVmYXVsdFVJUHJvcHMgfSksXG4gICAgZS5jaGlsZHJlblxuICBdIH0pO1xufSwgcmkgPSAoZSkgPT4ge1xuICBjb25zdCB7IGF1dG9Gb2N1czogdCwgbW91bnQ6IG4sIGNvbnRlbnRFZGl0YWJsZVByb3BzOiBvIH0gPSBlO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxuICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgICAgXCJkYXRhLWJuLWF1dG9mb2N1c1wiOiB0LFxuICAgICAgcmVmOiBuLFxuICAgICAgLi4ub1xuICAgIH1cbiAgKTtcbn07XG5mdW5jdGlvbiBpZShlLCB0KSB7XG4gIGxldCBuO1xuICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbGV0IHI7XG4gIGlmICh0ICE9IG51bGwgJiYgdC5lbGVtZW50UmVuZGVyZXIpXG4gICAgdC5lbGVtZW50UmVuZGVyZXIoXG4gICAgICBlKChkKSA9PiBuID0gZCB8fCB2b2lkIDApLFxuICAgICAgb1xuICAgICk7XG4gIGVsc2Uge1xuICAgIGlmICghKHQgIT0gbnVsbCAmJiB0LmhlYWRsZXNzKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJlbGVtZW50UmVuZGVyZXIgbm90IGF2YWlsYWJsZSwgZXhwZWN0ZWQgaGVhZGxlc3MgZWRpdG9yXCJcbiAgICAgICk7XG4gICAgciA9IE5uKG8pLCBsdCgoKSA9PiB7XG4gICAgICByLnJlbmRlcihlKChkKSA9PiBuID0gZCB8fCB2b2lkIDApKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIW8uY2hpbGRFbGVtZW50Q291bnQpXG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlJlYWN0SW5saW5lQ29udGVudFNwZWM6IHJlbmRlckhUTUwoKSBmYWlsZWRcIiksIHtcbiAgICAgIGRvbTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcbiAgICB9O1xuICBuID09IG51bGwgfHwgbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRtcC1maW5kXCIsIFwidHJ1ZVwiKTtcbiAgY29uc3QgbCA9IG8uY2xvbmVOb2RlKCEwKSwgYyA9IGwuZmlyc3RFbGVtZW50Q2hpbGQsIHMgPSBsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgXCJbZGF0YS10bXAtZmluZF1cIlxuICApO1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10bXAtZmluZFwiKSwgciA9PSBudWxsIHx8IHIudW5tb3VudCgpLCB7XG4gICAgZG9tOiBjLFxuICAgIGNvbnRlbnRET006IHMgfHwgdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBwZShlKSB7XG4gIHZhciB0O1xuICByZXR1cm4gKFxuICAgIC8vIENyZWF0ZXMgYGJsb2NrQ29udGVudGAgZWxlbWVudFxuICAgIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgc3QsXG4gICAgICB7XG4gICAgICAgIG9uRHJhZ092ZXI6IChuKSA9PiBuLnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhlLmRvbUF0dHJpYnV0ZXMgfHwge30pLmZpbHRlcihcbiAgICAgICAgICAgIChbbl0pID0+IG4gIT09IFwiY2xhc3NcIlxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgY2xhc3NOYW1lOiBJKFxuICAgICAgICAgIFwiYm4tYmxvY2stY29udGVudFwiLFxuICAgICAgICAgICgodCA9IGUuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY2xhc3MpIHx8IFwiXCJcbiAgICAgICAgKSxcbiAgICAgICAgXCJkYXRhLWNvbnRlbnQtdHlwZVwiOiBlLmJsb2NrVHlwZSxcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGUuYmxvY2tQcm9wcykuZmlsdGVyKChbbiwgb10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBlLnByb3BTY2hlbWFbbl07XG4gICAgICAgICAgICByZXR1cm4gIWZuLmluY2x1ZGVzKG4pICYmIG8gIT09IHIuZGVmYXVsdDtcbiAgICAgICAgICB9KS5tYXAoKFtuLCBvXSkgPT4gW2l0KG4pLCBvXSlcbiAgICAgICAgKSxcbiAgICAgICAgXCJkYXRhLWZpbGUtYmxvY2tcIjogZS5pc0ZpbGVCbG9jayA9PT0gITAgfHwgdm9pZCAwLFxuICAgICAgICBjaGlsZHJlbjogZS5jaGlsZHJlblxuICAgICAgfVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGhlKGUsIHQpIHtcbiAgY29uc3QgbiA9IFRlKHtcbiAgICBuYW1lOiBlLnR5cGUsXG4gICAgY29udGVudDogZS5jb250ZW50ID09PSBcImlubGluZVwiID8gXCJpbmxpbmUqXCIgOiBcIlwiLFxuICAgIGdyb3VwOiBcImJsb2NrQ29udGVudFwiLFxuICAgIHNlbGVjdGFibGU6IGUuaXNTZWxlY3RhYmxlID8/ICEwLFxuICAgIGlzb2xhdGluZzogITAsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBydChlLnByb3BTY2hlbWEpO1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgcmV0dXJuIG1uKGUsIHQucGFyc2UpO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBvIH0pIHtcbiAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHVuKFxuICAgICAgICB7XG4gICAgICAgICAgZG9tOiByLFxuICAgICAgICAgIGNvbnRlbnRET006IGUuY29udGVudCA9PT0gXCJpbmxpbmVcIiA/IHIgOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgZS50eXBlLFxuICAgICAgICB7fSxcbiAgICAgICAgZS5wcm9wU2NoZW1hLFxuICAgICAgICBlLmlzRmlsZUJsb2NrLFxuICAgICAgICBvXG4gICAgICApO1xuICAgIH0sXG4gICAgYWRkTm9kZVZpZXcoKSB7XG4gICAgICByZXR1cm4gKG8pID0+IHtcbiAgICAgICAgY29uc3QgciA9IGN0KFxuICAgICAgICAgIChsKSA9PiB7XG4gICAgICAgICAgICB2YXIgbTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLm9wdGlvbnMuZWRpdG9yLCBzID0gc24oXG4gICAgICAgICAgICAgIGwuZ2V0UG9zLFxuICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgZS50eXBlXG4gICAgICAgICAgICApLCBkID0gKChtID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBtLmJsb2NrQ29udGVudCkgfHwge30sIGEgPSBhdCgpLm5vZGVWaWV3Q29udGVudFJlZjtcbiAgICAgICAgICAgIGlmICghYSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZVZpZXdDb250ZW50UmVmIGlzIG5vdCBzZXRcIik7XG4gICAgICAgICAgICBjb25zdCB1ID0gdC5yZW5kZXI7XG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgICAgIHBlLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmxvY2tUeXBlOiBzLnR5cGUsXG4gICAgICAgICAgICAgICAgYmxvY2tQcm9wczogcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBwcm9wU2NoZW1hOiBlLnByb3BTY2hlbWEsXG4gICAgICAgICAgICAgICAgaXNGaWxlQmxvY2s6IGUuaXNGaWxlQmxvY2ssXG4gICAgICAgICAgICAgICAgZG9tQXR0cmlidXRlczogZCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgICAgICAgICB1LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBibG9jazogcyxcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBjLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50UmVmOiBhXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJuLXJlYWN0LW5vZGUtdmlldy1yZW5kZXJlclwiXG4gICAgICAgICAgfVxuICAgICAgICApKG8pO1xuICAgICAgICByZXR1cm4gZS5pc1NlbGVjdGFibGUgPT09ICExICYmIGRuKHIsIHRoaXMuZWRpdG9yKSwgcjtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhuKGUsIHtcbiAgICBub2RlOiBuLFxuICAgIHRvSW50ZXJuYWxIVE1MOiAobywgcikgPT4ge1xuICAgICAgdmFyIGQsIGE7XG4gICAgICBjb25zdCBsID0gKChkID0gbi5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBkLmJsb2NrQ29udGVudCkgfHwge30sIGMgPSB0LnJlbmRlciwgcyA9IGllKFxuICAgICAgICAodSkgPT4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgcGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tUeXBlOiBvLnR5cGUsXG4gICAgICAgICAgICBibG9ja1Byb3BzOiBvLnByb3BzLFxuICAgICAgICAgICAgcHJvcFNjaGVtYTogZS5wcm9wU2NoZW1hLFxuICAgICAgICAgICAgZG9tQXR0cmlidXRlczogbCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgICAgYyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJsb2NrOiBvLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogcixcbiAgICAgICAgICAgICAgICBjb250ZW50UmVmOiB1XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHJcbiAgICAgICk7XG4gICAgICByZXR1cm4gKGEgPSBzLmNvbnRlbnRET00pID09IG51bGwgfHwgYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRhYmxlXCIsIFwiXCIpLCBzO1xuICAgIH0sXG4gICAgdG9FeHRlcm5hbEhUTUw6IChvLCByKSA9PiB7XG4gICAgICB2YXIgZCwgYTtcbiAgICAgIGNvbnN0IGwgPSAoKGQgPSBuLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGQuYmxvY2tDb250ZW50KSB8fCB7fSwgYyA9IHQudG9FeHRlcm5hbEhUTUwgfHwgdC5yZW5kZXIsIHMgPSBpZSgodSkgPT4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgIHBlLFxuICAgICAgICB7XG4gICAgICAgICAgYmxvY2tUeXBlOiBvLnR5cGUsXG4gICAgICAgICAgYmxvY2tQcm9wczogby5wcm9wcyxcbiAgICAgICAgICBwcm9wU2NoZW1hOiBlLnByb3BTY2hlbWEsXG4gICAgICAgICAgZG9tQXR0cmlidXRlczogbCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBibG9jazogbyxcbiAgICAgICAgICAgICAgZWRpdG9yOiByLFxuICAgICAgICAgICAgICBjb250ZW50UmVmOiB1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApLCByKTtcbiAgICAgIHJldHVybiAoYSA9IHMuY29udGVudERPTSkgPT0gbnVsbCB8fCBhLnNldEF0dHJpYnV0ZShcImRhdGEtZWRpdGFibGVcIiwgXCJcIiksIHM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIE5lKGUpIHtcbiAgY29uc3QgdCA9IGIoKSwgW24sIG9dID0gayhcImxvYWRpbmdcIiksIFtyLCBsXSA9IGsoKTtcbiAgaWYgKHkoKCkgPT4ge1xuICAgIGxldCBjID0gITA7XG4gICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcyA9IFwiXCI7XG4gICAgICBvKFwibG9hZGluZ1wiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHMgPSB0LnJlc29sdmVGaWxlVXJsID8gYXdhaXQgdC5yZXNvbHZlRmlsZVVybChlKSA6IGU7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgbyhcImVycm9yXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjICYmIChvKFwibG9hZGVkXCIpLCBsKHMpKTtcbiAgICB9KSgpLCAoKSA9PiB7XG4gICAgICBjID0gITE7XG4gICAgfTtcbiAgfSwgW3QsIGVdKSwgbiAhPT0gXCJsb2FkZWRcIilcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGluZ1N0YXRlOiBuXG4gICAgfTtcbiAgaWYgKCFyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZpbmlzaGVkIGZldGNoaW5nIGZpbGUgYnV0IGRpZCBub3QgZ2V0IGRvd25sb2FkIFVSTC5cIik7XG4gIHJldHVybiB7XG4gICAgbG9hZGluZ1N0YXRlOiBuLFxuICAgIGRvd25sb2FkVXJsOiByXG4gIH07XG59XG5jb25zdCBQZSA9IChlKSA9PiAvKiBAX19QVVJFX18gKi8gdihcImZpZ3VyZVwiLCB7IGNoaWxkcmVuOiBbXG4gIGUuY2hpbGRyZW4sXG4gIC8qIEBfX1BVUkVfXyAqLyBpKFwiZmlnY2FwdGlvblwiLCB7IGNoaWxkcmVuOiBlLmNhcHRpb24gfSlcbl0gfSk7XG5mdW5jdGlvbiBpaShlKSB7XG4gIGNvbnN0IHQgPSBiKCk7XG4gIHkoKCkgPT4gdC5vblVwbG9hZEVuZChlKSwgW2UsIHRdKTtcbn1cbmZ1bmN0aW9uIGxpKGUpIHtcbiAgY29uc3QgdCA9IGIoKTtcbiAgeSgoKSA9PiB0Lm9uVXBsb2FkU3RhcnQoZSksIFtlLCB0XSk7XG59XG5mdW5jdGlvbiBfdChlKSB7XG4gIGNvbnN0IFt0LCBuXSA9IGsoITEpO1xuICByZXR1cm4gbGkoKG8pID0+IHtcbiAgICBvID09PSBlICYmIG4oITApO1xuICB9KSwgaWkoKG8pID0+IHtcbiAgICBvID09PSBlICYmIG4oITEpO1xuICB9KSwgdDtcbn1cbmNvbnN0IGNpID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IE0oKSwgbiA9IGcoXG4gICAgKHIpID0+IHtcbiAgICAgIHIucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIFtdXG4gICksIG8gPSBnKCgpID0+IHtcbiAgICBlLmVkaXRvci5kaXNwYXRjaChcbiAgICAgIGUuZWRpdG9yLl90aXB0YXBFZGl0b3Iuc3RhdGUudHIuc2V0TWV0YShcbiAgICAgICAgZS5lZGl0b3IuZmlsZVBhbmVsLnBsdWdpbixcbiAgICAgICAge1xuICAgICAgICAgIGJsb2NrOiBlLmJsb2NrXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9LCBbZS5ibG9jaywgZS5lZGl0b3JdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB2KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWFkZC1maWxlLWJ1dHRvblwiLFxuICAgICAgb25Nb3VzZURvd246IG4sXG4gICAgICBvbkNsaWNrOiBvLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYm4tYWRkLWZpbGUtYnV0dG9uLWljb25cIiwgY2hpbGRyZW46IGUuYnV0dG9uSWNvbiB8fCAvKiBAX19QVVJFX18gKi8gaShSZSwgeyBzaXplOiAyNCB9KSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYm4tYWRkLWZpbGUtYnV0dG9uLXRleHRcIiwgY2hpbGRyZW46IGUuYnV0dG9uVGV4dCB8fCB0LmZpbGVfYmxvY2tzLmZpbGUuYWRkX2J1dHRvbl90ZXh0IH0pXG4gICAgICBdXG4gICAgfVxuICApO1xufSwgYWkgPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIHYoXG4gIFwiZGl2XCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IFwiYm4tZmlsZS1uYW1lLXdpdGgtaWNvblwiLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogITEsXG4gICAgZHJhZ2dhYmxlOiAhMSxcbiAgICBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYm4tZmlsZS1pY29uXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShSZSwgeyBzaXplOiAyNCB9KSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKFwicFwiLCB7IGNsYXNzTmFtZTogXCJibi1maWxlLW5hbWVcIiwgY2hpbGRyZW46IGUuYmxvY2sucHJvcHMubmFtZSB9KVxuICAgIF1cbiAgfVxuKSwgT2UgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gX3QoZS5ibG9jay5pZCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1maWxlLWJsb2NrLWNvbnRlbnQtd3JhcHBlclwiLFxuICAgICAgb25Nb3VzZUVudGVyOiBlLm9uTW91c2VFbnRlcixcbiAgICAgIG9uTW91c2VMZWF2ZTogZS5vbk1vdXNlTGVhdmUsXG4gICAgICBzdHlsZTogZS5zdHlsZSxcbiAgICAgIGNoaWxkcmVuOiB0ID8gKFxuICAgICAgICAvLyBTaG93IGxvYWRlciB3aGlsZSBhIGZpbGUgaXMgYmVpbmcgdXBsb2FkZWQuXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImJuLWZpbGUtbG9hZGluZy1wcmV2aWV3XCIsIGNoaWxkcmVuOiBcIkxvYWRpbmcuLi5cIiB9KVxuICAgICAgKSA6IGUuYmxvY2sucHJvcHMudXJsID09PSBcIlwiID8gKFxuICAgICAgICAvLyBTaG93IHRoZSBhZGQgZmlsZSBidXR0b24gaWYgdGhlIGZpbGUgaGFzIG5vdCBiZWVuIHVwbG9hZGVkIHlldC5cbiAgICAgICAgLyogQF9fUFVSRV9fICovIGkoY2ksIHsgLi4uZSB9KVxuICAgICAgKSA6IChcbiAgICAgICAgLy8gU2hvdyB0aGUgZmlsZSBwcmV2aWV3LCBvciB0aGUgZmlsZSBuYW1lIGFuZCBpY29uLlxuICAgICAgICAvKiBAX19QVVJFX18gKi8gdihULCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgZS5ibG9jay5wcm9wcy5zaG93UHJldmlldyA9PT0gITEgfHwgIWUuY2hpbGRyZW4gPyAoXG4gICAgICAgICAgICAvLyBTaG93IGZpbGUgbmFtZSBhbmQgaWNvbi5cbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKGFpLCB7IC4uLmUgfSlcbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgLy8gU2hvdyBwcmV2aWV3LlxuICAgICAgICAgICAgZS5jaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgZS5ibG9jay5wcm9wcy5jYXB0aW9uICYmIC8vIFNob3cgdGhlIGNhcHRpb24gaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBpKFwicFwiLCB7IGNsYXNzTmFtZTogXCJibi1maWxlLWNhcHRpb25cIiwgY2hpbGRyZW46IGUuYmxvY2sucHJvcHMuY2FwdGlvbiB9KVxuICAgICAgICBdIH0pXG4gICAgICApXG4gICAgfVxuICApO1xufSwgZmUgPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIHYoXCJkaXZcIiwgeyBjaGlsZHJlbjogW1xuICBlLmNoaWxkcmVuLFxuICAvKiBAX19QVVJFX18gKi8gaShcInBcIiwgeyBjaGlsZHJlbjogZS5jYXB0aW9uIH0pXG5dIH0pLCBzaSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBOZShlLmJsb2NrLnByb3BzLnVybCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICBcImF1ZGlvXCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWF1ZGlvXCIsXG4gICAgICBzcmM6IHQubG9hZGluZ1N0YXRlID09PSBcImxvYWRpbmdcIiA/IGUuYmxvY2sucHJvcHMudXJsIDogdC5kb3dubG9hZFVybCxcbiAgICAgIGNvbnRyb2xzOiAhMCxcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogITEsXG4gICAgICBkcmFnZ2FibGU6ICExXG4gICAgfVxuICApO1xufSwgZGkgPSAoZSkgPT4ge1xuICBpZiAoIWUuYmxvY2sucHJvcHMudXJsKVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcInBcIiwgeyBjaGlsZHJlbjogXCJBZGQgYXVkaW9cIiB9KTtcbiAgY29uc3QgdCA9IGUuYmxvY2sucHJvcHMuc2hvd1ByZXZpZXcgPyAvKiBAX19QVVJFX18gKi8gaShcImF1ZGlvXCIsIHsgc3JjOiBlLmJsb2NrLnByb3BzLnVybCB9KSA6IC8qIEBfX1BVUkVfXyAqLyBpKFwiYVwiLCB7IGhyZWY6IGUuYmxvY2sucHJvcHMudXJsLCBjaGlsZHJlbjogZS5ibG9jay5wcm9wcy5uYW1lIHx8IGUuYmxvY2sucHJvcHMudXJsIH0pO1xuICByZXR1cm4gZS5ibG9jay5wcm9wcy5jYXB0aW9uID8gZS5ibG9jay5wcm9wcy5zaG93UHJldmlldyA/IC8qIEBfX1BVUkVfXyAqLyBpKFBlLCB7IGNhcHRpb246IGUuYmxvY2sucHJvcHMuY2FwdGlvbiwgY2hpbGRyZW46IHQgfSkgOiAvKiBAX19QVVJFX18gKi8gaShmZSwgeyBjYXB0aW9uOiBlLmJsb2NrLnByb3BzLmNhcHRpb24sIGNoaWxkcmVuOiB0IH0pIDogdDtcbn0sIHVpID0gKGUpID0+IC8qIEBfX1BVUkVfXyAqLyBpKFxuICBPZSxcbiAge1xuICAgIC4uLmUsXG4gICAgYnV0dG9uVGV4dDogZS5lZGl0b3IuZGljdGlvbmFyeS5maWxlX2Jsb2Nrcy5hdWRpby5hZGRfYnV0dG9uX3RleHQsXG4gICAgYnV0dG9uSWNvbjogLyogQF9fUFVSRV9fICovIGkoTXQsIHsgc2l6ZTogMjQgfSksXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBpKHNpLCB7IC4uLmUgfSlcbiAgfVxuKSwgQWkgPSBoZShibiwge1xuICByZW5kZXI6IHVpLFxuICBwYXJzZTogZ24sXG4gIHRvRXh0ZXJuYWxIVE1MOiBkaVxufSksIG1pID0gKGUpID0+IHtcbiAgaWYgKCFlLmJsb2NrLnByb3BzLnVybClcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXCJwXCIsIHsgY2hpbGRyZW46IFwiQWRkIGZpbGVcIiB9KTtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBpKFwiYVwiLCB7IGhyZWY6IGUuYmxvY2sucHJvcHMudXJsLCBjaGlsZHJlbjogZS5ibG9jay5wcm9wcy5uYW1lIHx8IGUuYmxvY2sucHJvcHMudXJsIH0pO1xuICByZXR1cm4gZS5ibG9jay5wcm9wcy5jYXB0aW9uID8gLyogQF9fUFVSRV9fICovIGkoZmUsIHsgY2FwdGlvbjogZS5ibG9jay5wcm9wcy5jYXB0aW9uLCBjaGlsZHJlbjogdCB9KSA6IHQ7XG59LCBoaSA9IChlKSA9PiAvKiBAX19QVVJFX18gKi8gaShPZSwgeyAuLi5lIH0pLCBHaSA9IGhlKHBuLCB7XG4gIHJlbmRlcjogaGksXG4gIHBhcnNlOiBDbixcbiAgdG9FeHRlcm5hbEhUTUw6IG1pXG59KSwgSXQgPSAoZSkgPT4ge1xuICBjb25zdCBbdCwgbl0gPSBrKHZvaWQgMCksIFtvLCByXSA9IGsoZS5ibG9jay5wcm9wcy5wcmV2aWV3V2lkdGgpLCBbbCwgY10gPSBrKCExKSwgcyA9IF8obnVsbCk7XG4gIHkoKCkgPT4ge1xuICAgIGNvbnN0IGYgPSAoSCkgPT4ge1xuICAgICAgbGV0IEI7XG4gICAgICBlLmJsb2NrLnByb3BzLnRleHRBbGlnbm1lbnQgPT09IFwiY2VudGVyXCIgPyB0LmhhbmRsZVVzZWQgPT09IFwibGVmdFwiID8gQiA9IHQuaW5pdGlhbFdpZHRoICsgKHQuaW5pdGlhbENsaWVudFggLSBILmNsaWVudFgpICogMiA6IEIgPSB0LmluaXRpYWxXaWR0aCArIChILmNsaWVudFggLSB0LmluaXRpYWxDbGllbnRYKSAqIDIgOiB0LmhhbmRsZVVzZWQgPT09IFwibGVmdFwiID8gQiA9IHQuaW5pdGlhbFdpZHRoICsgdC5pbml0aWFsQ2xpZW50WCAtIEguY2xpZW50WCA6IEIgPSB0LmluaXRpYWxXaWR0aCArIEguY2xpZW50WCAtIHQuaW5pdGlhbENsaWVudFg7XG4gICAgICBjb25zdCBWID0gNjQ7XG4gICAgICBCIDwgViA/IHIoVikgOiByKEIpO1xuICAgIH0sIHcgPSAoKSA9PiB7XG4gICAgICBuKHZvaWQgMCksIGUuZWRpdG9yLnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBwcmV2aWV3V2lkdGg6IG9cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdCAmJiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZiksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB3KSksICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGYpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdyk7XG4gICAgfTtcbiAgfSwgW2UsIHQsIG9dKTtcbiAgY29uc3QgZCA9IGcoKCkgPT4ge1xuICAgIGUuZWRpdG9yLmlzRWRpdGFibGUgJiYgYyghMCk7XG4gIH0sIFtlLmVkaXRvci5pc0VkaXRhYmxlXSksIGEgPSBnKCgpID0+IHtcbiAgICBjKCExKTtcbiAgfSwgW10pLCB1ID0gZyhcbiAgICAoZikgPT4ge1xuICAgICAgZi5wcmV2ZW50RGVmYXVsdCgpLCBuKHtcbiAgICAgICAgaGFuZGxlVXNlZDogXCJsZWZ0XCIsXG4gICAgICAgIGluaXRpYWxXaWR0aDogcy5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICBpbml0aWFsQ2xpZW50WDogZi5jbGllbnRYXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtdXG4gICksIG0gPSBnKFxuICAgIChmKSA9PiB7XG4gICAgICBmLnByZXZlbnREZWZhdWx0KCksIG4oe1xuICAgICAgICBoYW5kbGVVc2VkOiBcInJpZ2h0XCIsXG4gICAgICAgIGluaXRpYWxXaWR0aDogcy5jdXJyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICBpbml0aWFsQ2xpZW50WDogZi5jbGllbnRYXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtdXG4gICksIGggPSBfdChlLmJsb2NrLmlkKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgIE9lLFxuICAgIHtcbiAgICAgIC4uLmUsXG4gICAgICBvbk1vdXNlRW50ZXI6IGQsXG4gICAgICBvbk1vdXNlTGVhdmU6IGEsXG4gICAgICBzdHlsZTogZS5ibG9jay5wcm9wcy51cmwgJiYgIWggJiYgZS5ibG9jay5wcm9wcy5zaG93UHJldmlldyA/IHsgd2lkdGg6IGAke299cHhgIH0gOiB2b2lkIDAsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHYoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYm4tdmlzdWFsLW1lZGlhLXdyYXBwZXJcIiwgcmVmOiBzLCBjaGlsZHJlbjogW1xuICAgICAgICBlLmNoaWxkcmVuLFxuICAgICAgICAobCB8fCB0KSAmJiAvKiBAX19QVVJFX18gKi8gdihULCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiYm4tcmVzaXplLWhhbmRsZVwiLFxuICAgICAgICAgICAgICBzdHlsZTogeyBsZWZ0OiBcIjRweFwiIH0sXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duOiB1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJibi1yZXNpemUtaGFuZGxlXCIsXG4gICAgICAgICAgICAgIHN0eWxlOiB7IHJpZ2h0OiBcIjRweFwiIH0sXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duOiBtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICBdIH0pXG4gICAgICBdIH0pXG4gICAgfVxuICApO1xufSwgZmkgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gTmUoZS5ibG9jay5wcm9wcy51cmwpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgXCJpbWdcIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IFwiYm4tdmlzdWFsLW1lZGlhXCIsXG4gICAgICBzcmM6IHQubG9hZGluZ1N0YXRlID09PSBcImxvYWRpbmdcIiA/IGUuYmxvY2sucHJvcHMudXJsIDogdC5kb3dubG9hZFVybCxcbiAgICAgIGFsdDogZS5ibG9jay5wcm9wcy5jYXB0aW9uIHx8IFwiQmxvY2tOb3RlIGltYWdlXCIsXG4gICAgICBjb250ZW50RWRpdGFibGU6ICExLFxuICAgICAgZHJhZ2dhYmxlOiAhMVxuICAgIH1cbiAgKTtcbn0sIGdpID0gKGUpID0+IHtcbiAgaWYgKCFlLmJsb2NrLnByb3BzLnVybClcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXCJwXCIsIHsgY2hpbGRyZW46IFwiQWRkIGltYWdlXCIgfSk7XG4gIGNvbnN0IHQgPSBlLmJsb2NrLnByb3BzLnNob3dQcmV2aWV3ID8gLyogQF9fUFVSRV9fICovIGkoXG4gICAgXCJpbWdcIixcbiAgICB7XG4gICAgICBzcmM6IGUuYmxvY2sucHJvcHMudXJsLFxuICAgICAgYWx0OiBlLmJsb2NrLnByb3BzLm5hbWUgfHwgZS5ibG9jay5wcm9wcy5jYXB0aW9uIHx8IFwiQmxvY2tOb3RlIGltYWdlXCIsXG4gICAgICB3aWR0aDogZS5ibG9jay5wcm9wcy5wcmV2aWV3V2lkdGhcbiAgICB9XG4gICkgOiAvKiBAX19QVVJFX18gKi8gaShcImFcIiwgeyBocmVmOiBlLmJsb2NrLnByb3BzLnVybCwgY2hpbGRyZW46IGUuYmxvY2sucHJvcHMubmFtZSB8fCBlLmJsb2NrLnByb3BzLnVybCB9KTtcbiAgcmV0dXJuIGUuYmxvY2sucHJvcHMuY2FwdGlvbiA/IGUuYmxvY2sucHJvcHMuc2hvd1ByZXZpZXcgPyAvKiBAX19QVVJFX18gKi8gaShQZSwgeyBjYXB0aW9uOiBlLmJsb2NrLnByb3BzLmNhcHRpb24sIGNoaWxkcmVuOiB0IH0pIDogLyogQF9fUFVSRV9fICovIGkoZmUsIHsgY2FwdGlvbjogZS5ibG9jay5wcm9wcy5jYXB0aW9uLCBjaGlsZHJlbjogdCB9KSA6IHQ7XG59LCBiaSA9IChlKSA9PiAvKiBAX19QVVJFX18gKi8gaShcbiAgSXQsXG4gIHtcbiAgICAuLi5lLFxuICAgIGJ1dHRvblRleHQ6IGUuZWRpdG9yLmRpY3Rpb25hcnkuZmlsZV9ibG9ja3MuaW1hZ2UuYWRkX2J1dHRvbl90ZXh0LFxuICAgIGJ1dHRvbkljb246IC8qIEBfX1BVUkVfXyAqLyBpKEh0LCB7IHNpemU6IDI0IH0pLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShmaSwgeyAuLi5lIH0pXG4gIH1cbiksIFVpID0gaGUod24sIHtcbiAgcmVuZGVyOiBiaSxcbiAgcGFyc2U6IGtuLFxuICB0b0V4dGVybmFsSFRNTDogZ2lcbn0pO1xuZnVuY3Rpb24gQ2koZSkge1xuICByZXR1cm4gcCh7IGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTQgM3Y0YTEgMSAwIDAgMCAxIDFoNFwiIH0sIGNoaWxkOiBbXSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTkgMTh2MWEyIDIgMCAwIDEgLTIgMmgtMTBhMiAyIDAgMCAxIC0yIC0ydi0xXCIgfSwgY2hpbGQ6IFtdIH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDE0aDNtNC41IDBoM200LjUgMGgzXCIgfSwgY2hpbGQ6IFtdIH0sIHsgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk01IDEwdi01YTIgMiAwIDAgMSAyIC0yaDdsNSA1djJcIiB9LCBjaGlsZDogW10gfV0gfSkoZSk7XG59XG5jb25zdCBwaSA9IHtcbiAgcGFnZV9icmVhazogQ2lcbn07XG5mdW5jdGlvbiB6aShlKSB7XG4gIHJldHVybiB2bihlKS5tYXAoKHQpID0+IHtcbiAgICBjb25zdCBuID0gcGlbdC5rZXldO1xuICAgIHJldHVybiB7XG4gICAgICAuLi50LFxuICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGkobiwgeyBzaXplOiAxOCB9KVxuICAgIH07XG4gIH0pO1xufVxuY29uc3Qga2kgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gTmUoZS5ibG9jay5wcm9wcy51cmwpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgXCJ2aWRlb1wiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi12aXN1YWwtbWVkaWFcIixcbiAgICAgIHNyYzogdC5sb2FkaW5nU3RhdGUgPT09IFwibG9hZGluZ1wiID8gZS5ibG9jay5wcm9wcy51cmwgOiB0LmRvd25sb2FkVXJsLFxuICAgICAgY29udHJvbHM6ICEwLFxuICAgICAgY29udGVudEVkaXRhYmxlOiAhMSxcbiAgICAgIGRyYWdnYWJsZTogITFcbiAgICB9XG4gICk7XG59LCB3aSA9IChlKSA9PiB7XG4gIGlmICghZS5ibG9jay5wcm9wcy51cmwpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFwicFwiLCB7IGNoaWxkcmVuOiBcIkFkZCB2aWRlb1wiIH0pO1xuICBjb25zdCB0ID0gZS5ibG9jay5wcm9wcy5zaG93UHJldmlldyA/IC8qIEBfX1BVUkVfXyAqLyBpKFwidmlkZW9cIiwgeyBzcmM6IGUuYmxvY2sucHJvcHMudXJsIH0pIDogLyogQF9fUFVSRV9fICovIGkoXCJhXCIsIHsgaHJlZjogZS5ibG9jay5wcm9wcy51cmwsIGNoaWxkcmVuOiBlLmJsb2NrLnByb3BzLm5hbWUgfHwgZS5ibG9jay5wcm9wcy51cmwgfSk7XG4gIHJldHVybiBlLmJsb2NrLnByb3BzLmNhcHRpb24gPyBlLmJsb2NrLnByb3BzLnNob3dQcmV2aWV3ID8gLyogQF9fUFVSRV9fICovIGkoUGUsIHsgY2FwdGlvbjogZS5ibG9jay5wcm9wcy5jYXB0aW9uLCBjaGlsZHJlbjogdCB9KSA6IC8qIEBfX1BVUkVfXyAqLyBpKGZlLCB7IGNhcHRpb246IGUuYmxvY2sucHJvcHMuY2FwdGlvbiwgY2hpbGRyZW46IHQgfSkgOiB0O1xufSwgdmkgPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIGkoXG4gIEl0LFxuICB7XG4gICAgLi4uZSxcbiAgICBidXR0b25UZXh0OiBlLmVkaXRvci5kaWN0aW9uYXJ5LmZpbGVfYmxvY2tzLnZpZGVvLmFkZF9idXR0b25fdGV4dCxcbiAgICBidXR0b25JY29uOiAvKiBAX19QVVJFX18gKi8gaShDbywgeyBzaXplOiAyNCB9KSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGkoa2ksIHsgLi4uZSB9KVxuICB9XG4pLCBqaSA9IGhlKE1uLCB7XG4gIHJlbmRlcjogdmksXG4gIHBhcnNlOiBIbixcbiAgdG9FeHRlcm5hbEhUTUw6IHdpXG59KSwgV2kgPSAoZSkgPT4ge1xuICBjb25zdCBbdCwgbl0gPSBrKFwibm9uZVwiKSwgbyA9IF8obnVsbCksIHIgPSBiKCksIGwgPSBQKFxuICAgIHIuZm9ybWF0dGluZ1Rvb2xiYXIub25VcGRhdGUuYmluZChyLmZvcm1hdHRpbmdUb29sYmFyKVxuICApLCBjID0geCgoKSA9PiAoe1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgYm90dG9tOiAwLFxuICAgIHpJbmRleDogM2UzLFxuICAgIHRyYW5zZm9ybTogdFxuICB9KSwgW3RdKTtcbiAgaWYgKHkoKCkgPT4ge1xuICAgIGNvbnN0IGQgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG4gICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgIGNvbnN0IHUgPSBkb2N1bWVudC5ib2R5LCBtID0gZC5vZmZzZXRMZWZ0LCBoID0gZC5oZWlnaHQgLSB1LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArIGQub2Zmc2V0VG9wO1xuICAgICAgbihcbiAgICAgICAgYHRyYW5zbGF0ZSgke219cHgsICR7aH1weCkgc2NhbGUoJHsxIC8gZC5zY2FsZX0pYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGEpLCB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBhKSwgYSgpLCAoKSA9PiB7XG4gICAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBhKSwgd2luZG93LnZpc3VhbFZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgYSk7XG4gICAgfTtcbiAgfSwgW10pLCAhbClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKCFsLnNob3cgJiYgby5jdXJyZW50KVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogbyxcbiAgICAgICAgc3R5bGU6IGMsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogby5jdXJyZW50LmlubmVySFRNTCB9XG4gICAgICB9XG4gICAgKTtcbiAgY29uc3QgcyA9IGUuZm9ybWF0dGluZ1Rvb2xiYXIgfHwgU3Q7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaShcImRpdlwiLCB7IHJlZjogbywgc3R5bGU6IGMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShzLCB7fSkgfSk7XG59LCBIaSA9IE4ubWVtbyhcbiAgKHtcbiAgICB0aHJlYWQ6IGUsXG4gICAgc2VsZWN0ZWRUaHJlYWRJZDogdCxcbiAgICBlZGl0b3I6IG4sXG4gICAgbWF4Q29tbWVudHNCZWZvcmVDb2xsYXBzZTogbyxcbiAgICByZWZlcmVuY2VUZXh0OiByXG4gIH0pID0+IHtcbiAgICBjb25zdCBsID0gZyhcbiAgICAgIChzKSA9PiB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICBzLnRhcmdldC5jbG9zZXN0KFwiLmJuLWFjdGlvbi10b29sYmFyXCIpIHx8IChkID0gbi5jb21tZW50cykgPT0gbnVsbCB8fCBkLnNlbGVjdFRocmVhZChlLmlkKTtcbiAgICAgIH0sXG4gICAgICBbbi5jb21tZW50cywgZS5pZF1cbiAgICApLCBjID0gZyhcbiAgICAgIChzKSA9PiB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICBpZiAoIXMucmVsYXRlZFRhcmdldCB8fCBzLnJlbGF0ZWRUYXJnZXQuY2xvc2VzdChcIi5ibi1hY3Rpb24tdG9vbGJhclwiKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGQgPSBzLnRhcmdldCBpbnN0YW5jZW9mIE5vZGUgPyBzLnRhcmdldCA6IG51bGwsIGEgPSBzLnJlbGF0ZWRUYXJnZXQgaW5zdGFuY2VvZiBOb2RlID8gcy5yZWxhdGVkVGFyZ2V0LmNsb3Nlc3QoXCIuYm4tdGhyZWFkXCIpIDogbnVsbDtcbiAgICAgICAgKCFkIHx8ICFhIHx8ICFhLmNvbnRhaW5zKGQpKSAmJiAoKHUgPSBuLmNvbW1lbnRzKSA9PSBudWxsIHx8IHUuc2VsZWN0VGhyZWFkKHZvaWQgMCkpO1xuICAgICAgfSxcbiAgICAgIFtuLmNvbW1lbnRzXVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgeHQsXG4gICAgICB7XG4gICAgICAgIHRocmVhZDogZSxcbiAgICAgICAgc2VsZWN0ZWQ6IGUuaWQgPT09IHQsXG4gICAgICAgIHJlZmVyZW5jZVRleHQ6IHIsXG4gICAgICAgIG1heENvbW1lbnRzQmVmb3JlQ29sbGFwc2U6IG8sXG4gICAgICAgIG9uRm9jdXM6IGwsXG4gICAgICAgIG9uQmx1cjogYyxcbiAgICAgICAgdGFiSW5kZXg6IDBcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuZnVuY3Rpb24gTWkoZSwgdCwgbikge1xuICBpZiAodCA9PT0gXCJyZWNlbnQtYWN0aXZpdHlcIilcbiAgICByZXR1cm4gZS5zb3J0KFxuICAgICAgKG8sIHIpID0+IHIuY29tbWVudHNbci5jb21tZW50cy5sZW5ndGggLSAxXS5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gby5jb21tZW50c1tvLmNvbW1lbnRzLmxlbmd0aCAtIDFdLmNyZWF0ZWRBdC5nZXRUaW1lKClcbiAgICApO1xuICBpZiAodCA9PT0gXCJvbGRlc3RcIilcbiAgICByZXR1cm4gZS5zb3J0KFxuICAgICAgKG8sIHIpID0+IG8uY3JlYXRlZEF0LmdldFRpbWUoKSAtIHIuY3JlYXRlZEF0LmdldFRpbWUoKVxuICAgICk7XG4gIGlmICh0ID09PSBcInBvc2l0aW9uXCIpXG4gICAgcmV0dXJuIGUuc29ydCgobywgcikgPT4ge1xuICAgICAgdmFyIHMsIGQ7XG4gICAgICBjb25zdCBsID0gKChzID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5nZXQoby5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBzLmZyb20pIHx8IE51bWJlci5NQVhfVkFMVUUsIGMgPSAoKGQgPSBuID09IG51bGwgPyB2b2lkIDAgOiBuLmdldChyLmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZnJvbSkgfHwgTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHJldHVybiBsIC0gYztcbiAgICB9KTtcbiAgdGhyb3cgbmV3IHhuKHQpO1xufVxuZnVuY3Rpb24gdHQoZSwgdCkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIFwiT3JpZ2luYWwgY29udGVudCBkZWxldGVkXCI7XG4gIGlmIChlLnByb3NlbWlycm9yU3RhdGUuZG9jLm5vZGVTaXplIDwgdC50bylcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3QgbiA9IGUucHJvc2VtaXJyb3JTdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgdC5mcm9tLFxuICAgIHQudG9cbiAgKTtcbiAgcmV0dXJuIG4ubGVuZ3RoID4gMTUgPyBgJHtuLnNsaWNlKDAsIDE1KX3igKZgIDogbjtcbn1cbmZ1bmN0aW9uICRpKGUpIHtcbiAgY29uc3QgdCA9IGIoKTtcbiAgaWYgKCF0LmNvbW1lbnRzKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1lbnRzIHBsdWdpbiBub3QgZm91bmRcIik7XG4gIGNvbnN0IG4gPSBQKFxuICAgIHQuY29tbWVudHMub25VcGRhdGUuYmluZCh0LmNvbW1lbnRzKVxuICApLCBvID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5zZWxlY3RlZFRocmVhZElkLCByID0geXQodCksIGwgPSB4KCgpID0+IHtcbiAgICBjb25zdCBjID0gQXJyYXkuZnJvbShyLnZhbHVlcygpKSwgcyA9IE1pKFxuICAgICAgYyxcbiAgICAgIGUuc29ydCB8fCBcInBvc2l0aW9uXCIsXG4gICAgICBuID09IG51bGwgPyB2b2lkIDAgOiBuLnRocmVhZFBvc2l0aW9uc1xuICAgICksIGQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgcylcbiAgICAgIGEucmVzb2x2ZWQgPyAoZS5maWx0ZXIgPT09IFwicmVzb2x2ZWRcIiB8fCBlLmZpbHRlciA9PT0gXCJhbGxcIikgJiYgZC5wdXNoKHtcbiAgICAgICAgdGhyZWFkOiBhLFxuICAgICAgICByZWZlcmVuY2VUZXh0OiB0dChcbiAgICAgICAgICB0LFxuICAgICAgICAgIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4udGhyZWFkUG9zaXRpb25zLmdldChhLmlkKVxuICAgICAgICApXG4gICAgICB9KSA6IChlLmZpbHRlciA9PT0gXCJvcGVuXCIgfHwgZS5maWx0ZXIgPT09IFwiYWxsXCIpICYmIGQucHVzaCh7XG4gICAgICAgIHRocmVhZDogYSxcbiAgICAgICAgcmVmZXJlbmNlVGV4dDogdHQoXG4gICAgICAgICAgdCxcbiAgICAgICAgICBuID09IG51bGwgPyB2b2lkIDAgOiBuLnRocmVhZFBvc2l0aW9ucy5nZXQoYS5pZClcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGQ7XG4gIH0sIFtyLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLnRocmVhZFBvc2l0aW9ucywgZS5maWx0ZXIsIGUuc29ydCwgdF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYm4tdGhyZWFkcy1zaWRlYmFyXCIsIGNoaWxkcmVuOiBsLm1hcCgoYykgPT4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgSGksXG4gICAge1xuICAgICAgdGhyZWFkOiBjLnRocmVhZCxcbiAgICAgIHNlbGVjdGVkVGhyZWFkSWQ6IG8sXG4gICAgICBlZGl0b3I6IHQsXG4gICAgICByZWZlcmVuY2VUZXh0OiBjLnJlZmVyZW5jZVRleHQsXG4gICAgICBtYXhDb21tZW50c0JlZm9yZUNvbGxhcHNlOiBlLm1heENvbW1lbnRzQmVmb3JlQ29sbGFwc2VcbiAgICB9LFxuICAgIGMudGhyZWFkLmlkXG4gICkpIH0pO1xufVxuZnVuY3Rpb24gcWkoZSkge1xuICBjb25zdCB0ID0gRCgpO1xuICBpZiAoZSB8fCAoZSA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZWRpdG9yKSwgIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCInZWRpdG9yJyBpcyByZXF1aXJlZCwgZWl0aGVyIGZyb20gQmxvY2tOb3RlQ29udGV4dCBvciBhcyBhIGZ1bmN0aW9uIGFyZ3VtZW50XCJcbiAgICApO1xuICBjb25zdCBuID0gZSwgW28sIHJdID0gaygoKSA9PiBuLmdldEFjdGl2ZVN0eWxlcygpKTtcbiAgcmV0dXJuIHVlKCgpID0+IHtcbiAgICByKG4uZ2V0QWN0aXZlU3R5bGVzKCkpO1xuICB9LCBuKSwgc2UoKCkgPT4ge1xuICAgIHIobi5nZXRBY3RpdmVTdHlsZXMoKSk7XG4gIH0sIG4pLCBvO1xufVxuZnVuY3Rpb24geGkoKSB7XG4gIGNvbnN0IFssIGVdID0gaygwKTtcbiAgcmV0dXJuICgpID0+IGUoKHQpID0+IHQgKyAxKTtcbn1cbmNvbnN0IEtpID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IHhpKCk7XG4gIHkoKCkgPT4ge1xuICAgIGNvbnN0IG4gPSAoKSA9PiB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBlLm9uKFwidHJhbnNhY3Rpb25cIiwgbiksICgpID0+IHtcbiAgICAgIGUub2ZmKFwidHJhbnNhY3Rpb25cIiwgbik7XG4gICAgfTtcbiAgfSwgW2VdKTtcbn07XG5mdW5jdGlvbiB5aShlKSB7XG4gIHJldHVybiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlLnJlbGF0ZWRUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpIDogITE7XG59XG5mdW5jdGlvbiBYaSh7XG4gIG9uQmx1cjogZSxcbiAgb25Gb2N1czogdFxufSA9IHt9KSB7XG4gIGNvbnN0IG4gPSBfKG51bGwpLCBbbywgcl0gPSBrKCExKSwgbCA9IF8oITEpLCBjID0gKGEpID0+IHtcbiAgICByKGEpLCBsLmN1cnJlbnQgPSBhO1xuICB9LCBzID0gKGEpID0+IHtcbiAgICBsLmN1cnJlbnQgfHwgKGMoITApLCB0ID09IG51bGwgfHwgdChhKSk7XG4gIH0sIGQgPSAoYSkgPT4ge1xuICAgIGwuY3VycmVudCAmJiAheWkoYSkgJiYgKGMoITEpLCBlID09IG51bGwgfHwgZShhKSk7XG4gIH07XG4gIHJldHVybiB5KCgpID0+IHtcbiAgICBjb25zdCBhID0gbi5jdXJyZW50O1xuICAgIGlmIChhKVxuICAgICAgcmV0dXJuIGEuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgcyksIGEuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGQpLCAoKSA9PiB7XG4gICAgICAgIGEgPT0gbnVsbCB8fCBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHMpLCBhID09IG51bGwgfHwgYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZCk7XG4gICAgICB9O1xuICB9LCBbcywgZF0pLCB7IHJlZjogbiwgZm9jdXNlZDogbyB9O1xufVxuZnVuY3Rpb24gQmkoZSkge1xuICByZXR1cm4gKFxuICAgIC8vIENyZWF0ZXMgaW5saW5lIGNvbnRlbnQgc2VjdGlvbiBlbGVtZW50XG4gICAgLyogQF9fUFVSRV9fICovIGkoXG4gICAgICBzdCxcbiAgICAgIHtcbiAgICAgICAgYXM6IFwic3BhblwiLFxuICAgICAgICBjbGFzc05hbWU6IFwiYm4taW5saW5lLWNvbnRlbnQtc2VjdGlvblwiLFxuICAgICAgICBcImRhdGEtaW5saW5lLWNvbnRlbnQtdHlwZVwiOiBlLmlubGluZUNvbnRlbnRUeXBlLFxuICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZS5pbmxpbmVDb250ZW50UHJvcHMpLmZpbHRlcigoW3QsIG5dKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvID0gZS5wcm9wU2NoZW1hW3RdO1xuICAgICAgICAgICAgcmV0dXJuIG4gIT09IG8uZGVmYXVsdDtcbiAgICAgICAgICB9KS5tYXAoKFt0LCBuXSkgPT4gW2l0KHQpLCBuXSlcbiAgICAgICAgKSxcbiAgICAgICAgY2hpbGRyZW46IGUuY2hpbGRyZW5cbiAgICAgIH1cbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBZaShlLCB0KSB7XG4gIGNvbnN0IG4gPSBUZSh7XG4gICAgbmFtZTogZS50eXBlLFxuICAgIGlubGluZTogITAsXG4gICAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gICAgc2VsZWN0YWJsZTogZS5jb250ZW50ID09PSBcInN0eWxlZFwiLFxuICAgIGF0b206IGUuY29udGVudCA9PT0gXCJub25lXCIsXG4gICAgY29udGVudDogZS5jb250ZW50ID09PSBcInN0eWxlZFwiID8gXCJpbmxpbmUqXCIgOiBcIlwiLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gcnQoZS5wcm9wU2NoZW1hKTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgcmV0dXJuIFNuKGUpO1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgcmV0dXJuIFZuKGUpO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IG5vZGU6IG8gfSkge1xuICAgICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5lZGl0b3IsIGwgPSBBZShcbiAgICAgICAgbyxcbiAgICAgICAgci5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgci5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgICAgICksIGMgPSB0LnJlbmRlciwgcyA9IGllKFxuICAgICAgICAoZCkgPT4gLyogQF9fUFVSRV9fICovIGkoXG4gICAgICAgICAgYyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmVDb250ZW50OiBsLFxuICAgICAgICAgICAgdXBkYXRlSW5saW5lQ29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnRSZWY6IGRcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHJcbiAgICAgICk7XG4gICAgICByZXR1cm4gQm4oXG4gICAgICAgIHMsXG4gICAgICAgIGUudHlwZSxcbiAgICAgICAgby5hdHRycyxcbiAgICAgICAgZS5wcm9wU2NoZW1hXG4gICAgICApO1xuICAgIH0sXG4gICAgLy8gVE9ETzogbmVlZGVkP1xuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgY29uc3QgbyA9IHRoaXMub3B0aW9ucy5lZGl0b3I7XG4gICAgICByZXR1cm4gKHIpID0+IGN0KFxuICAgICAgICAobCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGMgPSBhdCgpLm5vZGVWaWV3Q29udGVudFJlZjtcbiAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlVmlld0NvbnRlbnRSZWYgaXMgbm90IHNldFwiKTtcbiAgICAgICAgICBjb25zdCBzID0gdC5yZW5kZXI7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpKFxuICAgICAgICAgICAgQmksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlubGluZUNvbnRlbnRQcm9wczogbC5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICBpbmxpbmVDb250ZW50VHlwZTogZS50eXBlLFxuICAgICAgICAgICAgICBwcm9wU2NoZW1hOiBlLnByb3BTY2hlbWEsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gaShcbiAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRSZWY6IGMsXG4gICAgICAgICAgICAgICAgICBpbmxpbmVDb250ZW50OiBBZShcbiAgICAgICAgICAgICAgICAgICAgbC5ub2RlLFxuICAgICAgICAgICAgICAgICAgICBvLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBvLnNjaGVtYS5zdHlsZVNjaGVtYVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUlubGluZUNvbnRlbnQ6IChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB5bihcbiAgICAgICAgICAgICAgICAgICAgICBbZF0sXG4gICAgICAgICAgICAgICAgICAgICAgby5fdGlwdGFwRWRpdG9yLnNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICBvLnNjaGVtYS5zdHlsZVNjaGVtYVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBvLmRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgIG8ucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnRyLnJlcGxhY2VXaXRoKFxuICAgICAgICAgICAgICAgICAgICAgICAgbC5nZXRQb3MoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGwuZ2V0UG9zKCkgKyBsLm5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYm4taWMtcmVhY3Qtbm9kZS12aWV3LXJlbmRlcmVyXCIsXG4gICAgICAgICAgYXM6IFwic3BhblwiXG4gICAgICAgICAgLy8gY29udGVudERPTUVsZW1lbnRUYWc6IFwic3BhblwiLCAocmVxdWlyZXMgdHQgdXBncmFkZSlcbiAgICAgICAgfVxuICAgICAgKShyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gVG4oZSwge1xuICAgIG5vZGU6IG5cbiAgfSk7XG59XG52YXIgWSwgSGU7XG5jbGFzcyBWaSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtYXJrOiB0LFxuICAgIHZpZXc6IG4sXG4gICAgaW5saW5lOiBvLFxuICAgIG9wdGlvbnM6IHIsXG4gICAgZWRpdG9yOiBsXG4gICAgLy8gQmxvY2tOb3RlIHNwZWNpZmljXG4gIH0pIHtcbiAgICBaZSh0aGlzLCBZKTtcbiAgICBMKHRoaXMsIFwiZG9tXCIpO1xuICAgIEwodGhpcywgXCJjb250ZW50RE9NXCIpO1xuICAgIEwodGhpcywgXCJtYXJrXCIpO1xuICAgIEwodGhpcywgXCJ2aWV3XCIpO1xuICAgIEwodGhpcywgXCJpbmxpbmVcIik7XG4gICAgTCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgTCh0aGlzLCBcImVkaXRvclwiKTtcbiAgICBMKHRoaXMsIFwic2hvdWxkSWdub3JlTXV0YXRpb25cIiwgKHQpID0+ICF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NID8gITAgOiB0LnR5cGUgPT09IFwic2VsZWN0aW9uXCIgPyAhMSA6IHRoaXMuY29udGVudERPTSA9PT0gdC50YXJnZXQgJiYgdC50eXBlID09PSBcImF0dHJpYnV0ZXNcIiA/ICEwIDogIXRoaXMuY29udGVudERPTS5jb250YWlucyh0LnRhcmdldCkpO1xuICAgIEwodGhpcywgXCJpZ25vcmVNdXRhdGlvblwiLCAodCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSByZXR1cm4gITA7XG4gICAgICBsZXQgbjtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb247XG4gICAgICByZXR1cm4gbyAmJiAobiA9IG8odCkpLCB0eXBlb2YgbiAhPSBcImJvb2xlYW5cIiAmJiAobiA9IHRoaXMuc2hvdWxkSWdub3JlTXV0YXRpb24odCkpLCBuO1xuICAgIH0pO1xuICAgIHRoaXMubWFyayA9IHQsIHRoaXMudmlldyA9IG4sIHRoaXMuaW5saW5lID0gbywgdGhpcy5vcHRpb25zID0gciwgdGhpcy5lZGl0b3IgPSBsLCB0aGlzLmRvbSA9IHRoaXMuY3JlYXRlRE9NKHIuYXMpLCB0aGlzLmNvbnRlbnRET00gPSByLmNvbnRlbnRBcyA/IHRoaXMuY3JlYXRlQ29udGVudERPTShyLmNvbnRlbnRBcykgOiB2b2lkIDAsIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImRhdGEtbWFyay12aWV3LXJvb3RcIiwgXCJ0cnVlXCIpLCB0aGlzLmNvbnRlbnRET00gJiYgKHRoaXMuY29udGVudERPTS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1hcmstdmlldy1jb250ZW50XCIsIFwidHJ1ZVwiKSwgdGhpcy5jb250ZW50RE9NLnN0eWxlLndoaXRlU3BhY2UgPSBcImluaGVyaXRcIik7XG4gIH1cbiAgY3JlYXRlRE9NKHQpIHtcbiAgICByZXR1cm4gZ2UodGhpcywgWSwgSGUpLmNhbGwodGhpcywgdCk7XG4gIH1cbiAgY3JlYXRlQ29udGVudERPTSh0KSB7XG4gICAgcmV0dXJuIGdlKHRoaXMsIFksIEhlKS5jYWxsKHRoaXMsIHQpO1xuICB9XG4gIGdldCBjb21wb25lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wb25lbnQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgdCwgbiwgbztcbiAgICAobiA9ICh0ID0gdGhpcy5vcHRpb25zKS5kZXN0cm95KSA9PSBudWxsIHx8IG4uY2FsbCh0KSwgdGhpcy5kb20ucmVtb3ZlKCksIChvID0gdGhpcy5jb250ZW50RE9NKSA9PSBudWxsIHx8IG8ucmVtb3ZlKCk7XG4gIH1cbn1cblkgPSBuZXcgV2Vha1NldCgpLCBIZSA9IGZ1bmN0aW9uKHQpIHtcbiAgY29uc3QgeyBpbmxpbmU6IG4sIG1hcms6IG8gfSA9IHRoaXM7XG4gIHJldHVybiB0ID09IG51bGwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG4gPyBcInNwYW5cIiA6IFwiZGl2XCIpIDogdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gdCA6IHQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHQobykgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpO1xufTtcbmNsYXNzIFNpIGV4dGVuZHMgVmkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8vIGltcGxlbWVudHMgUmVhY3RSZW5kZXJlcjxNYXJrVmlld0NvbnRleHQ+XG4gICAgLy8ga2V5OiBzdHJpbmcgPSBuYW5vaWQoKTtcbiAgICBMKHRoaXMsIFwiaWRcIiwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSkudG9TdHJpbmcoKSk7XG4gICAgTCh0aGlzLCBcImNvbnRleHRcIiwge1xuICAgICAgY29udGVudFJlZjogKG4pID0+IHtcbiAgICAgICAgbiAmJiB0aGlzLmNvbnRlbnRET00gJiYgbi5maXJzdENoaWxkICE9PSB0aGlzLmNvbnRlbnRET00gJiYgbi5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgfSxcbiAgICAgIHZpZXc6IHRoaXMudmlldyxcbiAgICAgIG1hcms6IHRoaXMubWFya1xuICAgIH0pO1xuICAgIEwodGhpcywgXCJ1cGRhdGVDb250ZXh0XCIsICgpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250ZXh0LCB7XG4gICAgICAgIG1hcms6IHRoaXMubWFya1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gcmVuZGVyID0gKCkgPT4ge1xuICAgIC8vICAgY29uc3QgVXNlckNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgIC8vICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChcbiAgICAvLyAgICAgPG1hcmtWaWV3Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dGhpcy5jb250ZXh0fT5cbiAgICAvLyAgICAgICA8VXNlckNvbXBvbmVudCAvPlxuICAgIC8vICAgICA8L21hcmtWaWV3Q29udGV4dC5Qcm92aWRlcj4sXG4gICAgLy8gICAgIHRoaXMuZG9tLFxuICAgIC8vICAgICB0aGlzLmtleVxuICAgIC8vICAgKTtcbiAgICAvLyB9O1xuICAgIEwodGhpcywgXCJyZW5kZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5jb250ZW50Q29tcG9uZW50LnNldFJlbmRlcmVyKFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICB0aGlzLnJlbmRlcmVyKClcbiAgICAgICk7XG4gICAgfSk7XG4gICAgTCh0aGlzLCBcImRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLmNvbnRlbnRDb21wb25lbnQucmVtb3ZlUmVuZGVyZXIodGhpcy5pZCk7XG4gICAgfSk7XG4gICAgTCh0aGlzLCBcInJlbmRlcmVyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbXBvbmVudCwgbyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubWFyay5hdHRycy5zdHJpbmdWYWx1ZSAmJiAoby52YWx1ZSA9IHRoaXMubWFyay5hdHRycy5zdHJpbmdWYWx1ZSksIHtcbiAgICAgICAgcmVhY3RFbGVtZW50OiAoXG4gICAgICAgICAgLy8gPG1hcmtWaWV3Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dGhpcy5jb250ZXh0fT5cbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gaShuLCB7IGNvbnRlbnRSZWY6IHRoaXMuY29udGV4dC5jb250ZW50UmVmLCAuLi5vIH0pXG4gICAgICAgICksXG4gICAgICAgIGVsZW1lbnQ6IHRoaXMuZG9tXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBKaShlLCB0KSB7XG4gIGNvbnN0IG4gPSBJbi5jcmVhdGUoe1xuICAgIG5hbWU6IGUudHlwZSxcbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgcmV0dXJuIFJuKGUucHJvcFNjaGVtYSk7XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICByZXR1cm4gRW4oZSk7XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbWFyazogbyB9KSB7XG4gICAgICBjb25zdCByID0ge307XG4gICAgICBlLnByb3BTY2hlbWEgPT09IFwic3RyaW5nXCIgJiYgKHIudmFsdWUgPSBvLmF0dHJzLnN0cmluZ1ZhbHVlKTtcbiAgICAgIGNvbnN0IGwgPSB0LnJlbmRlciwgYyA9IGllKFxuICAgICAgICAocykgPT4gLyogQF9fUFVSRV9fICovIGkobCwgeyAuLi5yLCBjb250ZW50UmVmOiBzIH0pLFxuICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdG9yXG4gICAgICApO1xuICAgICAgcmV0dXJuIExuKFxuICAgICAgICBjLFxuICAgICAgICBlLnR5cGUsXG4gICAgICAgIG8uYXR0cnMuc3RyaW5nVmFsdWUsXG4gICAgICAgIGUucHJvcFNjaGVtYVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbi5jb25maWcuYWRkTWFya1ZpZXcgPSAobykgPT4gKHIsIGwpID0+IHtcbiAgICBjb25zdCBjID0gbmV3IFNpKHtcbiAgICAgIGVkaXRvcjogbyxcbiAgICAgIGlubGluZTogITAsXG4gICAgICBtYXJrOiByLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb21wb25lbnQ6IHQucmVuZGVyLFxuICAgICAgICBjb250ZW50QXM6IFwic3BhblwiXG4gICAgICB9LFxuICAgICAgdmlldzogbFxuICAgIH0pO1xuICAgIHJldHVybiBjLnJlbmRlcigpLCBjO1xuICB9LCBfbihlLCB7XG4gICAgbWFyazogblxuICB9KTtcbn1cbmZ1bmN0aW9uIFFpKGUsIHQpIHtcbiAgY29uc3QgbiA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCByID0gbi50b3AgPCBvLnRvcCwgbCA9IG4uYm90dG9tID4gby5ib3R0b207XG4gIHJldHVybiByICYmIGwgPyBcImJvdGhcIiA6IHIgPyBcInRvcFwiIDogbCA/IFwiYm90dG9tXCIgOiBcIm5vbmVcIjtcbn1cbmV4cG9ydCB7XG4gIGRyIGFzIEFkZEJsb2NrQnV0dG9uLFxuICBKZSBhcyBBZGRCdXR0b24sXG4gIFhvIGFzIEFkZENvbW1lbnRCdXR0b24sXG4gIGNpIGFzIEFkZEZpbGVCdXR0b24sXG4gIFlvIGFzIEFkZFRpcHRhcENvbW1lbnRCdXR0b24sXG4gIHVpIGFzIEF1ZGlvQmxvY2ssXG4gIHNpIGFzIEF1ZGlvUHJldmlldyxcbiAgZGkgYXMgQXVkaW9Ub0V4dGVybmFsSFRNTCxcbiAgbmUgYXMgQmFzaWNUZXh0U3R5bGVCdXR0b24sXG4gIG1yIGFzIEJsb2NrQ29sb3JzSXRlbSxcbiAgcGUgYXMgQmxvY2tDb250ZW50V3JhcHBlcixcbiAgZHQgYXMgQmxvY2tOb3RlQ29udGV4dCxcbiAgS3IgYXMgQmxvY2tOb3RlRGVmYXVsdFVJLFxuICBvaSBhcyBCbG9ja05vdGVWaWV3RWRpdG9yLFxuICBGaSBhcyBCbG9ja05vdGVWaWV3UmF3LFxuICBLbyBhcyBCbG9ja1R5cGVTZWxlY3QsXG4gIHpyIGFzIENvbG9yUGlja2VyQnV0dG9uLFxuICBabyBhcyBDb2xvclN0eWxlQnV0dG9uLFxuICBMbyBhcyBDb21tZW50LFxuICBFbyBhcyBDb21tZW50cyxcbiAgT24gYXMgQ29tcG9uZW50c0NvbnRleHQsXG4gIEFvIGFzIENyZWF0ZUxpbmtCdXR0b24sXG4gIF9yIGFzIERlbGV0ZUJ1dHRvbixcbiAgcnIgYXMgRGVsZXRlTGlua0J1dHRvbixcbiAgQ3IgYXMgRHJhZ0hhbmRsZUJ1dHRvbixcbiAgYnIgYXMgRHJhZ0hhbmRsZU1lbnUsXG4gIGlyIGFzIEVkaXRMaW5rQnV0dG9uLFxuICBWdCBhcyBFZGl0TGlua01lbnVJdGVtcyxcbiAgX28gYXMgRW1iZWRUYWIsXG4gIFdpIGFzIEV4cGVyaW1lbnRhbE1vYmlsZUZvcm1hdHRpbmdUb29sYmFyQ29udHJvbGxlcixcbiAgUnIgYXMgRXh0ZW5kQnV0dG9uLFxuICBQZSBhcyBGaWd1cmVXaXRoQ2FwdGlvbixcbiAgaGkgYXMgRmlsZUJsb2NrLFxuICBPZSBhcyBGaWxlQmxvY2tXcmFwcGVyLFxuICBHbyBhcyBGaWxlQ2FwdGlvbkJ1dHRvbixcbiAgVW8gYXMgRmlsZURlbGV0ZUJ1dHRvbixcbiAgSm8gYXMgRmlsZURvd25sb2FkQnV0dG9uLFxuICBhaSBhcyBGaWxlTmFtZVdpdGhJY29uLFxuICBCdCBhcyBGaWxlUGFuZWwsXG4gIE5vIGFzIEZpbGVQYW5lbENvbnRyb2xsZXIsXG4gIFFvIGFzIEZpbGVQcmV2aWV3QnV0dG9uLFxuICB6byBhcyBGaWxlUmVuYW1lQnV0dG9uLFxuICBqbyBhcyBGaWxlUmVwbGFjZUJ1dHRvbixcbiAgbWkgYXMgRmlsZVRvRXh0ZXJuYWxIVE1MLFxuICBGbiBhcyBGbG9hdGluZ0NvbXBvc2VyLFxuICBBbiBhcyBGbG9hdGluZ0NvbXBvc2VyQ29udHJvbGxlcixcbiAgUm8gYXMgRmxvYXRpbmdUaHJlYWRDb250cm9sbGVyLFxuICBTdCBhcyBGb3JtYXR0aW5nVG9vbGJhcixcbiAgb3IgYXMgRm9ybWF0dGluZ1Rvb2xiYXJDb250cm9sbGVyLFxuICB4ciBhcyBHcmlkU3VnZ2VzdGlvbk1lbnVDb250cm9sbGVyLFxuICBNciBhcyBHcmlkU3VnZ2VzdGlvbk1lbnVXcmFwcGVyLFxuICBiaSBhcyBJbWFnZUJsb2NrLFxuICBmaSBhcyBJbWFnZVByZXZpZXcsXG4gIGdpIGFzIEltYWdlVG9FeHRlcm5hbEhUTUwsXG4gIEJpIGFzIElubGluZUNvbnRlbnRXcmFwcGVyLFxuICBjciBhcyBMaW5rVG9vbGJhcixcbiAgYXIgYXMgTGlua1Rvb2xiYXJDb250cm9sbGVyLFxuICBmZSBhcyBMaW5rV2l0aENhcHRpb24sXG4gIFdvIGFzIE5lc3RCbG9ja0J1dHRvbixcbiAgbHIgYXMgT3BlbkxpbmtCdXR0b24sXG4gIEFpIGFzIFJlYWN0QXVkaW9CbG9jayxcbiAgR2kgYXMgUmVhY3RGaWxlQmxvY2ssXG4gIFVpIGFzIFJlYWN0SW1hZ2VCbG9jayxcbiAgamkgYXMgUmVhY3RWaWRlb0Jsb2NrLFxuICBociBhcyBSZW1vdmVCbG9ja0l0ZW0sXG4gIEl0IGFzIFJlc2l6YWJsZUZpbGVCbG9ja1dyYXBwZXIsXG4gIHByIGFzIFNpZGVNZW51LFxuICBrciBhcyBTaWRlTWVudUNvbnRyb2xsZXIsXG4gIGpyIGFzIFNwbGl0QnV0dG9uLFxuICBMciBhcyBTdWdnZXN0aW9uTWVudUNvbnRyb2xsZXIsXG4gIFZyIGFzIFN1Z2dlc3Rpb25NZW51V3JhcHBlcixcbiAgJHIgYXMgVGFibGVDZWxsQnV0dG9uLFxuICBXciBhcyBUYWJsZUNlbGxNZW51LFxuICBlciBhcyBUYWJsZUNlbGxNZXJnZUJ1dHRvbixcbiAgZ3IgYXMgVGFibGVDb2x1bW5IZWFkZXJJdGVtLFxuICBEciBhcyBUYWJsZUhhbmRsZSxcbiAgT3IgYXMgVGFibGVIYW5kbGVNZW51LFxuICBxciBhcyBUYWJsZUhhbmRsZXNDb250cm9sbGVyLFxuICBmciBhcyBUYWJsZVJvd0hlYWRlckl0ZW0sXG4gIGJlIGFzIFRleHRBbGlnbkJ1dHRvbixcbiAgeHQgYXMgVGhyZWFkLFxuICAkaSBhcyBUaHJlYWRzU2lkZWJhcixcbiAgJG8gYXMgVW5uZXN0QmxvY2tCdXR0b24sXG4gIElvIGFzIFVwbG9hZFRhYixcbiAgdmkgYXMgVmlkZW9CbG9jayxcbiAga2kgYXMgVmlkZW9QcmV2aWV3LFxuICB3aSBhcyBWaWRlb1RvRXh0ZXJuYWxIVE1MLFxuICBxbyBhcyBibG9ja1R5cGVTZWxlY3RJdGVtcyxcbiAgaGUgYXMgY3JlYXRlUmVhY3RCbG9ja1NwZWMsXG4gIFlpIGFzIGNyZWF0ZVJlYWN0SW5saW5lQ29udGVudFNwZWMsXG4gIEppIGFzIGNyZWF0ZVJlYWN0U3R5bGVTcGVjLFxuICBRaSBhcyBlbGVtZW50T3ZlcmZsb3csXG4gIHdyIGFzIGdldERlZmF1bHRSZWFjdEVtb2ppUGlja2VySXRlbXMsXG4gIFRyIGFzIGdldERlZmF1bHRSZWFjdFNsYXNoTWVudUl0ZW1zLFxuICBuciBhcyBnZXRGb3JtYXR0aW5nVG9vbGJhckl0ZW1zLFxuICB6aSBhcyBnZXRQYWdlQnJlYWtSZWFjdFNsYXNoTWVudUl0ZW1zLFxuICB0dCBhcyBnZXRSZWZlcmVuY2VUZXh0LFxuICBQbyBhcyBtZXJnZVJlZnMsXG4gIHFpIGFzIHVzZUFjdGl2ZVN0eWxlcyxcbiAgT2kgYXMgdXNlQmxvY2tOb3RlLFxuICBEIGFzIHVzZUJsb2NrTm90ZUNvbnRleHQsXG4gIGIgYXMgdXNlQmxvY2tOb3RlRWRpdG9yLFxuICBMdCBhcyB1c2VDbG9zZVN1Z2dlc3Rpb25NZW51Tm9JdGVtcyxcbiAgQyBhcyB1c2VDb21wb25lbnRzQ29udGV4dCxcbiAgZGUgYXMgdXNlQ3JlYXRlQmxvY2tOb3RlLFxuICBNIGFzIHVzZURpY3Rpb25hcnksXG4gIHVlIGFzIHVzZUVkaXRvckNoYW5nZSxcbiAgVSBhcyB1c2VFZGl0b3JDb250ZW50T3JTZWxlY3Rpb25DaGFuZ2UsXG4gIEtpIGFzIHVzZUVkaXRvckZvcmNlVXBkYXRlLFxuICBzZSBhcyB1c2VFZGl0b3JTZWxlY3Rpb25DaGFuZ2UsXG4gIFpyIGFzIHVzZUV4dGVuZEJ1dHRvbnNQb3NpdGlvbmluZyxcbiAgWGkgYXMgdXNlRm9jdXNXaXRoaW4sXG4gIEhyIGFzIHVzZUdyaWRTdWdnZXN0aW9uTWVudUtleWJvYXJkTmF2aWdhdGlvbixcbiAgRXQgYXMgdXNlTG9hZFN1Z2dlc3Rpb25NZW51SXRlbXMsXG4gIFhyIGFzIHVzZVByZWZlcnNDb2xvclNjaGVtZSxcbiAgTmUgYXMgdXNlUmVzb2x2ZVVybCxcbiAgUiBhcyB1c2VTZWxlY3RlZEJsb2NrcyxcbiAgQnIgYXMgdXNlU3VnZ2VzdGlvbk1lbnVLZXlib2FyZE5hdmlnYXRpb24sXG4gIFVyIGFzIHVzZVRhYmxlSGFuZGxlc1Bvc2l0aW9uaW5nLFxuICB5dCBhcyB1c2VUaHJlYWRzLFxuICBTbyBhcyB1c2VVc2VyLFxuICBJZSBhcyB1c2VVc2Vyc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2Nrbm90ZS1yZWFjdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@blocknote/react/dist/blocknote-react.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingRootContext: () => (/* binding */ useFloatingRootContext),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(app-pages-browser)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/utils */ \"(app-pages-browser)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(app-pages-browser)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tabbable */ \"(app-pages-browser)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(app-pages-browser)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(app-pages-browser)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nfunction useMergeRefs(refs) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n  .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n};\n\nconst useInsertionEffect = SafeReact.useInsertionEffect;\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {\n    if (true) {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= list.length - 1 && isDisabled(list, index, disabledIndices));\n  return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    rtl,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(prevIndex / cols);\n    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          decrement: true,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(maxIndex / cols) === prevRow;\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nfunction buildCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach((_ref2, index) => {\n    let {\n      width,\n      height\n    } = _ref2;\n    if (width > cols) {\n      if (true) {\n        throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex++;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nfunction getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) return -1;\n  const firstCellIndex = cellMap.indexOf(index);\n  const sizeItem = sizes[index];\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + sizeItem.width - 1;\n    case 'bl':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + (sizeItem.height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nfunction getCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\nfunction isDisabled(list, index, disabledIndices) {\n  if (disabledIndices) {\n    return disabledIndices.includes(index);\n  }\n  const element = list[index];\n  return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n}\n\nvar index = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(props) {\n  const {\n    children,\n    elementsRef,\n    labelsRef\n  } = props;\n  const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new Map());\n  const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */\nfunction useListItem(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    label\n  } = props;\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n  const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\n\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  }\n  if (render) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\n\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that aren’t part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */\nconst Composite = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(props, forwardedRef) {\n  const {\n    render,\n    orientation = 'both',\n    loop = true,\n    rtl = false,\n    cols = 1,\n    disabledIndices,\n    activeIndex: externalActiveIndex,\n    onNavigate: externalSetActiveIndex,\n    itemSizes,\n    dense = false,\n    ...domProps\n  } = props;\n  const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    let nextIndex = activeIndex;\n    const minIndex = getMinIndex(elementsRef, disabledIndices);\n    const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n    const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;\n    const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;\n    if (isGrid) {\n      const sizes = itemSizes || Array.from({\n        length: elementsRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = buildCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(elementsRef.current, index, disabledIndices));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(elementsRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);\n      const maybeNextIndex = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        rtl,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getCellIndices([...(disabledIndices || elementsRef.current.map((_, index) => isDisabled(elementsRef.current, index) ? index : undefined)), undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getCellIndexOfCorner(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction we're\n        // moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === horizontalEndKey ? 'tr' : 'tl')\n      })];\n      if (maybeNextIndex != null) {\n        nextIndex = maybeNextIndex;\n      }\n    }\n    const toEndKeys = {\n      horizontal: [horizontalEndKey],\n      vertical: [ARROW_DOWN],\n      both: [horizontalEndKey, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [horizontalStartKey],\n      vertical: [ARROW_UP],\n      both: [horizontalStartKey, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n      var _elementsRef$current$;\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();\n    }\n  }\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      domProps.onKeyDown == null || domProps.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n    elementsRef: elementsRef\n  }, renderJsx(render, computedProps)));\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */\nconst CompositeItem = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(props, forwardedRef) {\n  const {\n    render,\n    ...domProps\n  } = props;\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      domProps.onFocus == null || domProps.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  };\n  return renderJsx(render, computedProps);\n});\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => // Ensure the id is unique with multiple independent versions of Floating UI\n// on <React 18\n\"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++;\nfunction useFloatingId() {\n  const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    serverHandoffComplete = true;\n  }, []);\n  return id;\n}\nconst useReactId = SafeReact.useId;\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */\nconst useId = useReactId || useFloatingId;\n\nlet devMessageSet;\nif (true) {\n  devMessageSet = /*#__PURE__*/new Set();\n}\nfunction warn() {\n  var _devMessageSet;\n  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n    messages[_key] = arguments[_key];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n    var _devMessageSet2;\n    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n    console.warn(message);\n  }\n}\nfunction error() {\n  var _devMessageSet3;\n  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    messages[_key2] = arguments[_key2];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n    var _devMessageSet4;\n    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n    console.error(message);\n  }\n}\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(props, ref) {\n  const {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow,\n        shift\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = props;\n  if (true) {\n    if (!ref) {\n      warn('The `ref` prop is required for `FloatingArrow`.');\n    }\n  }\n  const clipPathId = useId();\n  const [isRTL, setIsRTL] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n\n  // https://github.com/floating-ui/floating-ui/issues/2932\n  index(() => {\n    if (!floating) return;\n    const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(floating).direction === 'rtl';\n    if (isRTL) {\n      setIsRTL(true);\n    }\n  }, [floating]);\n  if (!floating) {\n    return null;\n  }\n  const [side, alignment] = placement.split('-');\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  let computedStaticOffset = staticOffset;\n  if (isVerticalSide && shift != null && shift.x || !isVerticalSide && shift != null && shift.y) {\n    computedStaticOffset = null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  const computedStrokeWidth = strokeWidth * 2;\n  const halfStrokeWidth = computedStrokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const isCustomShape = !!d;\n  const yOffsetProp = computedStaticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = computedStaticOffset && alignment === 'end' ? 'right' : 'left';\n  if (computedStaticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? computedStaticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? computedStaticOffset || arrow.y : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + computedStrokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + computedStrokeWidth / 2 + \"px)\",\n      transform: [rotation, transform].filter(t => !!t).join(' '),\n      ...restStyle\n    }\n  }), computedStrokeWidth > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: computedStrokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: computedStrokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + computedStrokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n\n/**\n * Returns the nearest floating tree context, if available.\n */\nconst useFloatingTree = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(props) {\n  const {\n    children,\n    id\n  } = props;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(props) {\n  const {\n    children\n  } = props;\n  const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [addNode, removeNode, events])\n  }, children);\n}\n\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\n\nfunction useLatestRef(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const openRef = useLatestRef(open);\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {});\n  const restTimeoutPendingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n        restTimeoutPendingRef.current = false;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    if (!handleCloseRef.current) return;\n    if (!open) return;\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n  const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = useEffectEvent(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  });\n  const clearPointerEvents = useEffectEvent(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  });\n  const isClickLikeOpenEvent = useEffectEvent(() => {\n    return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n  });\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, 'open')) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = window.setTimeout(() => {\n          if (!openRef.current) {\n            onOpenChange(true, event, 'hover');\n          }\n        }, openDelay);\n      } else if (!open) {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) return;\n      unbindMouseMoveRef.current();\n      const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating);\n      clearTimeout(restTimeoutRef.current);\n      restTimeoutPendingRef.current = false;\n      if (handleCloseRef.current && dataRef.current.floatingContext) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...dataRef.current.floatingContext,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            if (!isClickLikeOpenEvent()) {\n              closeWithDelay(event, true, 'safe-polygon');\n            }\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) return;\n      if (!dataRef.current.floatingContext) return;\n      handleCloseRef.current == null || handleCloseRef.current({\n        ...dataRef.current.floatingContext,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          if (!isClickLikeOpenEvent()) {\n            closeWithDelay(event);\n          }\n        }\n      })(event);\n    }\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.domReference)) {\n      var _elements$floating;\n      const ref = elements.domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      (_elements$floating = elements.floating) == null || _elements$floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        var _elements$floating2;\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [elements, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) return;\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      performedPointerEventsMutationRef.current = true;\n      const floatingEl = elements.floating;\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.domReference) && floatingEl) {\n        var _tree$nodesRef$curren;\n        const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).body;\n        body.setAttribute(safePolygonIdentifier, '');\n        const ref = elements.domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        body.style.pointerEvents = 'none';\n        ref.style.pointerEvents = 'auto';\n        floatingEl.style.pointerEvents = 'auto';\n        return () => {\n          body.style.pointerEvents = '';\n          ref.style.pointerEvents = '';\n          floatingEl.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      restTimeoutPendingRef.current = false;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      onPointerDown: setPointerRef,\n      onPointerEnter: setPointerRef,\n      onMouseMove(event) {\n        const {\n          nativeEvent\n        } = event;\n        function handleMouseMove() {\n          if (!blockMouseMoveRef.current && !openRef.current) {\n            onOpenChange(true, nativeEvent, 'hover');\n          }\n        }\n        if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current)) {\n          return;\n        }\n        if (open || restMs === 0) {\n          return;\n        }\n\n        // Ignore insignificant movements to account for tremors.\n        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {\n          return;\n        }\n        clearTimeout(restTimeoutRef.current);\n        if (pointerTypeRef.current === 'touch') {\n          handleMouseMove();\n        } else {\n          restTimeoutPendingRef.current = true;\n          restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);\n        }\n      }\n    };\n  }, [mouseOnly, onOpenChange, open, openRef, restMs]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onMouseEnter() {\n      clearTimeout(timeoutRef.current);\n    },\n    onMouseLeave(event) {\n      if (!isClickLikeOpenEvent()) {\n        closeWithDelay(event.nativeEvent, false);\n      }\n    }\n  }), [closeWithDelay, isClickLikeOpenEvent]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating\n  } : {}, [enabled, reference, floating]);\n}\n\nconst NOOP = () => {};\nconst FloatingDelayGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: NOOP,\n  setState: NOOP,\n  isInstantPhase: false\n});\n\n/**\n * @deprecated\n * Use the return value of `useDelayGroup()` instead.\n */\nconst useDelayGroupContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction FloatingDelayGroup(props) {\n  const {\n    children,\n    delay,\n    timeoutMs = 0\n  } = props;\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else if (!state.isInstantPhase) {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      if (state.isInstantPhase) {\n        setState({\n          isInstantPhase: false\n        });\n      }\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId, state.isInstantPhase]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setCurrentId])\n  }, children);\n}\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction useDelayGroup(context, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    floatingId\n  } = context;\n  const {\n    id: optionId,\n    enabled = true\n  } = options;\n  const id = optionId != null ? optionId : floatingId;\n  const groupContext = useDelayGroupContext();\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = groupContext;\n  index(() => {\n    if (!enabled) return;\n    if (!currentId) return;\n    setState({\n      delay: {\n        open: 1,\n        close: getDelay(initialDelay, 'close')\n      }\n    });\n    if (currentId !== id) {\n      onOpenChange(false);\n    }\n  }, [enabled, id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!enabled) return;\n    if (!currentId) return;\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      }\n      unset();\n    }\n  }, [enabled, open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (!enabled) return;\n    if (setCurrentId === NOOP || !open) return;\n    setCurrentId(id);\n  }, [enabled, open, setCurrentId, id]);\n  return groupContext;\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount$1 = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    [].forEach.call(parent.children, node => {\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(node) === 'script') return;\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  }\n  lockCount$1++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterValue = (counterMap.get(element) || 0) - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount$1--;\n    if (!lockCount$1) {\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  index(() => {\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n});\n\nconst PortalContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/createAttribute('portal');\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */\nfunction useFloatingPortalNode(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    id,\n    root\n  } = props;\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  index(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n      // Allow the subsequent layout effects to create a new node on updates.\n      // The portal node will still be cleaned up on unmount.\n      // https://github.com/floating-ui/floating-ui/issues/2454\n      queueMicrotask(() => {\n        portalNodeRef.current = null;\n      });\n    };\n  }, [portalNode]);\n  index(() => {\n    // Wait for the uniqueId to be generated before creating the portal node in\n    // React <18 (using `useFloatingId` instead of the native `useId`).\n    // https://github.com/floating-ui/floating-ui/issues/2778\n    if (!uniqueId) return;\n    if (portalNodeRef.current) return;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    if (!existingIdRoot) return;\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    existingIdRoot.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, uniqueId]);\n  index(() => {\n    // Wait for the root to exist before creating the portal node. The root must\n    // be stored in state, not a ref, for this to work reactively.\n    if (root === null) return;\n    if (!uniqueId) return;\n    if (portalNodeRef.current) return;\n    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n    if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(container)) container = container.current;\n    container = container || document.body;\n    let idWrapper = null;\n    if (id) {\n      idWrapper = document.createElement('div');\n      idWrapper.id = id;\n      container.appendChild(idWrapper);\n    }\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    container = idWrapper || container;\n    container.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, root, uniqueId, portalContext]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(props) {\n  const {\n    children,\n    id,\n    root,\n    preserveTabOrder = true\n  } = props;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;\n  const open = focusManagerState == null ? void 0 : focusManagerState.open;\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, modal]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!portalNode) return;\n    if (open) return;\n    enableFocusInside(portalNode);\n  }, [open, portalNode]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null || prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null || nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, 'focus-out'));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\n\nconst FOCUSABLE_ATTRIBUTE = 'data-floating-ui-focusable';\nfunction getFloatingFocusElement(floatingElement) {\n  if (!floatingElement) {\n    return null;\n  }\n  // Try to find the element that has `{...getFloatingProps()}` spread on it.\n  // This indicates the floating element is acting as a positioning wrapper, and\n  // so focus should be managed on the child element with the event handlers and\n  // aria props.\n  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(\"[\" + FOCUSABLE_ATTRIBUTE + \"]\") || floatingElement;\n}\n\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n  let tabbableEl = element;\n  if (!tabbableEl || (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(tabbableEl) === 'body') return;\n  if (!(0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(tabbableEl, getTabbableOptions())) {\n    const tabbableChild = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(tabbableEl, getTabbableOptions())[0];\n    if (tabbableChild) {\n      tabbableEl = tabbableChild;\n    }\n  }\n  previouslyFocusedElements.push(tabbableEl);\n  if (previouslyFocusedElements.length > LIST_LIMIT) {\n    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    restoreFocus = false,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    floatingId,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const tabbableIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const isInsidePortal = portalContext != null;\n  const floatingFocusElement = getFloatingFocusElement(floating);\n  const getTabbableContent = useEffectEvent(function (container) {\n    if (container === void 0) {\n      container = floatingFocusElement;\n    }\n    return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions()) : [];\n  });\n  const getTabbableElements = useEffectEvent(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floatingFocusElement && type === 'floating') {\n        return floatingFocusElement;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled) return;\n    if (!modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floatingFocusElement, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        }\n        const els = getTabbableElements();\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floatingFocusElement && event.shiftKey) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled) return;\n    if (!floating) return;\n    function handleFocusIn(event) {\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n      const tabbableContent = getTabbableContent();\n      const tabbableIndex = tabbableContent.indexOf(target);\n      if (tabbableIndex !== -1) {\n        tabbableIndexRef.current = tabbableIndex;\n      }\n    }\n    floating.addEventListener('focusin', handleFocusIn);\n    return () => {\n      floating.removeEventListener('focusin', handleFocusIn);\n    };\n  }, [disabled, floating, getTabbableContent]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled) return;\n    if (!closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Restore focus to the previous tabbable element index to prevent\n        // focus from being lost outside the floating tree.\n        if (restoreFocus && movedToUnrelatedNode && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement)) === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement).body) {\n          // Let `FloatingPortal` effect knows that focus is still inside the\n          // floating tree.\n          if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(floatingFocusElement)) {\n            floatingFocusElement.focus();\n          }\n          const prevTabbableIndex = tabbableIndexRef.current;\n          const tabbableContent = getTabbableContent();\n          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;\n          if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(nodeToFocus)) {\n            nodeToFocus.focus();\n          }\n        }\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event, 'focus-out');\n        }\n      });\n    }\n    if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, floatingFocusElement, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating) {\n      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(floatingFocusElement)) return;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floatingFocusElement);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;\n      const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floatingFocusElement, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floatingFocusElement\n        });\n      }\n    });\n  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floatingFocusElement) return;\n    let preventReturnFocusScroll = false;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n    const contextData = dataRef.current;\n    let openEvent = contextData.openEvent;\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        open,\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (open) {\n        openEvent = event;\n      }\n      if (reason === 'escape-key' && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      if (reason === 'hover' && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = true;\n      } else {\n        preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event));\n      }\n    }\n    events.on('openchange', onOpenChange);\n    const fallbackEl = doc.createElement('span');\n    fallbackEl.setAttribute('tabindex', '-1');\n    fallbackEl.setAttribute('aria-hidden', 'true');\n    Object.assign(fallbackEl.style, HIDDEN_STYLES);\n    if (isInsidePortal && domReference) {\n      domReference.insertAdjacentElement('afterend', fallbackEl);\n    }\n    function getReturnElement() {\n      if (typeof returnFocusRef.current === 'boolean') {\n        return getPreviouslyFocusedElement() || fallbackEl;\n      }\n      return returnFocusRef.current.current || fallbackEl;\n    }\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n      const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      });\n      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ['click', 'mousedown'].includes(openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      const returnElement = getReturnElement();\n      queueMicrotask(() => {\n        if (\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(returnElement) && (\n        // If the focus moved somewhere else after mount, avoid returning focus\n        // since it likely entered a different element which should be\n        // respected: https://github.com/floating-ui/floating-ui/issues/2607\n        returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n          returnElement.focus({\n            preventScroll: preventReturnFocusScroll\n          });\n        }\n        fallbackEl.remove();\n      });\n    };\n  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, refs, events, tree, nodeId, isInsidePortal, domReference]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    // The `returnFocus` cleanup behavior is inside a microtask; ensure we\n    // wait for it to complete before resetting the flag.\n    queueMicrotask(() => {\n      preventReturnFocusRef.current = false;\n    });\n  }, [disabled]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled) return;\n    if (!portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      refs\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n  index(() => {\n    if (disabled) return;\n    if (!floatingFocusElement) return;\n    if (typeof MutationObserver !== 'function') return;\n    if (ignoreInitialFocus) return;\n    const handleMutation = () => {\n      const tabIndex = floatingFocusElement.getAttribute('tabindex');\n      const tabbableContent = getTabbableContent();\n      const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating));\n      const tabbableIndex = tabbableContent.indexOf(activeEl);\n      if (tabbableIndex !== -1) {\n        tabbableIndexRef.current = tabbableIndex;\n      }\n      if (orderRef.current.includes('floating') || activeEl !== refs.domReference.current && tabbableContent.length === 0) {\n        if (tabIndex !== '0') {\n          floatingFocusElement.setAttribute('tabindex', '0');\n        }\n      } else if (tabIndex !== '-1') {\n        floatingFocusElement.setAttribute('tabindex', '-1');\n      }\n    };\n    handleMutation();\n    const observer = new MutationObserver(handleMutation);\n    observer.observe(floatingFocusElement, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [disabled, floating, floatingFocusElement, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null || nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null || prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nlet lockCount = 0;\nfunction enableScrollLock() {\n  const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getPlatform)());\n  const bodyStyle = document.body.style;\n  // RTL <body> scrollbar\n  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n  const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;\n  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;\n  bodyStyle.overflow = 'hidden';\n  if (scrollbarWidth) {\n    bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n  }\n\n  // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n  // technique has fewer side effects.\n  if (isIOS) {\n    var _window$visualViewpor, _window$visualViewpor2;\n    // iOS 12 does not support `visualViewport`.\n    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n    Object.assign(bodyStyle, {\n      position: 'fixed',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0'\n    });\n  }\n  return () => {\n    Object.assign(bodyStyle, {\n      overflow: '',\n      [paddingProp]: ''\n    });\n    if (isIOS) {\n      Object.assign(bodyStyle, {\n        position: '',\n        top: '',\n        left: '',\n        right: ''\n      });\n      window.scrollTo(scrollX, scrollY);\n    }\n  };\n}\nlet cleanup = () => {};\n\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(props, ref) {\n  const {\n    lockScroll = false,\n    ...rest\n  } = props;\n  index(() => {\n    if (!lockScroll) return;\n    lockCount++;\n    if (lockCount === 1) {\n      cleanup = enableScrollLock();\n    }\n    return () => {\n      lockCount--;\n      if (lockCount === 0) {\n        cleanup();\n      }\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true,\n    stickIfOpen = true\n  } = props;\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onPointerDown(event) {\n      pointerTypeRef.current = event.pointerType;\n    },\n    onMouseDown(event) {\n      const pointerType = pointerTypeRef.current;\n\n      // Ignore all buttons except for the \"main\" button.\n      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n      if (event.button !== 0) return;\n      if (eventOption === 'click') return;\n      if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n        onOpenChange(false, event.nativeEvent, 'click');\n      } else {\n        // Prevent stealing focus from the floating element\n        event.preventDefault();\n        onOpenChange(true, event.nativeEvent, 'click');\n      }\n    },\n    onClick(event) {\n      const pointerType = pointerTypeRef.current;\n      if (eventOption === 'mousedown' && pointerTypeRef.current) {\n        pointerTypeRef.current = undefined;\n        return;\n      }\n      if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === 'click' : true)) {\n        onOpenChange(false, event.nativeEvent, 'click');\n      } else {\n        onOpenChange(true, event.nativeEvent, 'click');\n      }\n    },\n    onKeyDown(event) {\n      pointerTypeRef.current = undefined;\n      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n        return;\n      }\n      if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n        // Prevent scrolling\n        event.preventDefault();\n        didKeyDownRef.current = true;\n      }\n      if (event.key === 'Enter') {\n        if (open && toggle) {\n          onOpenChange(false, event.nativeEvent, 'click');\n        } else {\n          onOpenChange(true, event.nativeEvent, 'click');\n        }\n      }\n    },\n    onKeyUp(event) {\n      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n        return;\n      }\n      if (event.key === ' ' && didKeyDownRef.current) {\n        didKeyDownRef.current = false;\n        if (open && toggle) {\n          onOpenChange(false, event.nativeEvent, 'click');\n        } else {\n          onOpenChange(true, event.nativeEvent, 'click');\n        }\n      }\n    }\n  }), [dataRef, domReference, eventOption, ignoreMouse, keyboardHandlers, onOpenChange, open, stickIfOpen, toggle]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference\n  } : {}, [enabled, reference]);\n}\n\nfunction createVirtualElement(domElement, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domElement || undefined,\n    getBoundingClientRect() {\n      var _data$dataRef$current;\n      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    dataRef,\n    elements: {\n      floating,\n      domReference\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType) ? floating : open;\n  const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(floating);\n    function handleMouseMove(event) {\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n      if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(domReference);\n  }, [openCheck, enabled, x, y, floating, dataRef, refs, domReference, setReference]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      onPointerDown: setPointerTypeRef,\n      onPointerEnter: setPointerTypeRef,\n      onMouseMove: handleReferenceEnterOrMove,\n      onMouseEnter: handleReferenceEnterOrMove\n    };\n  }, [handleReferenceEnterOrMove]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference\n  } : {}, [enabled, reference]);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    elements,\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const isComposingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    var _dataRef$current$floa;\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n\n    // Wait until IME is settled. Pressing `Escape` while composing should\n    // close the compose menu, but not the floating element.\n    if (isComposingRef.current) {\n      return;\n    }\n    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isReactEvent)(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    var _dataRef$current$floa2;\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) ? target : null;\n    while (targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(targetRootAncestor)) {\n      const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getParentNode)(targetRootAncestor);\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isRootElement)(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(target, elements.floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, elements.floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, elements.domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = useEffectEvent(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    let compositionTimeout = -1;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    function handleCompositionStart() {\n      window.clearTimeout(compositionTimeout);\n      isComposingRef.current = true;\n    }\n    function handleCompositionEnd() {\n      // Safari fires `compositionend` before `keydown`, so we need to wait\n      // until the next tick to set `isComposing` to `false`.\n      // https://bugs.webkit.org/show_bug.cgi?id=165004\n      compositionTimeout = window.setTimeout(() => {\n        isComposingRef.current = false;\n      },\n      // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.\n      // Only apply to WebKit for the test to remain 0ms.\n      (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isWebKit)() ? 5 : 0);\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating);\n    if (escapeKey) {\n      doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      doc.addEventListener('compositionstart', handleCompositionStart);\n      doc.addEventListener('compositionend', handleCompositionEnd);\n    }\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.domReference)) {\n        ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(elements.domReference);\n      }\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.floating)) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(elements.floating));\n      }\n      if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.reference) && elements.reference && elements.reference.contextElement) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(elements.reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      if (escapeKey) {\n        doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        doc.removeEventListener('compositionstart', handleCompositionStart);\n        doc.removeEventListener('compositionend', handleCompositionEnd);\n      }\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n      window.clearTimeout(compositionTimeout);\n    };\n  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    [bubbleHandlerKeys[referencePressEvent]]: event => {\n      if (referencePress) {\n        onOpenChange(false, event.nativeEvent, 'reference-press');\n      }\n    }\n  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    onMouseDown() {\n      endedOrStartedInsideRef.current = true;\n    },\n    onMouseUp() {\n      endedOrStartedInsideRef.current = true;\n    },\n    [captureHandlerKeys[outsidePressEvent]]: () => {\n      insideReactTreeRef.current = true;\n    }\n  }), [closeOnEscapeKeyDown, outsidePressEvent]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating\n  } : {}, [enabled, reference, floating]);\n}\n\nfunction useFloatingRootContext(options) {\n  const {\n    open = false,\n    onOpenChange: onOpenChangeProp,\n    elements: elementsProp\n  } = options;\n  const floatingId = useId();\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  const [events] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub());\n  const nested = useFloatingParentNodeId() != null;\n  if (true) {\n    const optionDomReference = elementsProp.reference;\n    if (optionDomReference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(optionDomReference)) {\n      error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');\n    }\n  }\n  const [positionReference, setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(elementsProp.reference);\n  const onOpenChange = useEffectEvent((open, event, reason) => {\n    dataRef.current.openEvent = open ? event : undefined;\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    onOpenChangeProp == null || onOpenChangeProp(open, event, reason);\n  });\n  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    setPositionReference\n  }), []);\n  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    reference: positionReference || elementsProp.reference || null,\n    floating: elementsProp.floating || null,\n    domReference: elementsProp.reference\n  }), [positionReference, elementsProp.reference, elementsProp.floating]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    dataRef,\n    open,\n    onOpenChange,\n    elements,\n    events,\n    floatingId,\n    refs\n  }), [open, onOpenChange, elements, events, floatingId, refs]);\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    nodeId\n  } = options;\n  const internalRootContext = useFloatingRootContext({\n    ...options,\n    elements: {\n      reference: null,\n      floating: null,\n      ...options.elements\n    }\n  });\n  const rootContext = options.rootContext || internalRootContext;\n  const computedElements = rootContext.elements;\n  const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const [positionReference, _setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;\n  const domReference = optionDomReference || _domReference;\n  const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const tree = useFloatingTree();\n  index(() => {\n    if (domReference) {\n      domReferenceRef.current = domReference;\n    }\n  }, [domReference]);\n  const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.useFloating)({\n    ...options,\n    elements: {\n      ...computedElements,\n      ...(positionReference && {\n        reference: positionReference\n      })\n    }\n  });\n  const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    const computedPositionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    // Store the positionReference in state if the DOM reference is specified externally via the\n    // `elements.reference` option. This ensures that it won't be overridden on future renders.\n    _setPositionReference(computedPositionReference);\n    position.refs.setReference(computedPositionReference);\n  }, [position.refs]);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position,\n    ...rootContext,\n    refs,\n    elements,\n    nodeId\n  }), [position, refs, elements, nodeId, rootContext]);\n  index(() => {\n    rootContext.dataRef.current.floatingContext = context;\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    dataRef,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(elements.domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(elements.domReference) && elements.domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    win.addEventListener('blur', onBlur);\n    win.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      win.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [elements.domReference, open, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onPointerDown(event) {\n      if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) return;\n      keyboardModalityRef.current = false;\n    },\n    onMouseLeave() {\n      blockFocusRef.current = false;\n    },\n    onFocus(event) {\n      if (blockFocusRef.current) return;\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event.nativeEvent);\n      if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target)) {\n        try {\n          // Mac Safari unreliably matches `:focus-visible` on the reference\n          // if focus was outside the page initially - use the fallback\n          // instead.\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)()) throw Error();\n          if (!target.matches(':focus-visible')) return;\n        } catch (e) {\n          // Old browsers will throw an error when using `:focus-visible`.\n          if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(target)) {\n            return;\n          }\n        }\n      }\n      onOpenChange(true, event.nativeEvent, 'focus');\n    },\n    onBlur(event) {\n      blockFocusRef.current = false;\n      const relatedTarget = event.relatedTarget;\n      const nativeEvent = event.nativeEvent;\n\n      // Hit the non-modal focus management portal guard. Focus will be\n      // moved into the floating element immediately after.\n      const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n      // Wait for the window blur listener to fire.\n      timeoutRef.current = window.setTimeout(() => {\n        var _dataRef$current$floa;\n        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(elements.domReference ? elements.domReference.ownerDocument : document);\n\n        // Focus left the page, keep it open.\n        if (!relatedTarget && activeEl === elements.domReference) return;\n\n        // When focusing the reference element (e.g. regular click), then\n        // clicking into the floating element, prevent it from hiding.\n        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n        // We can not rely on relatedTarget to point to the correct element\n        // as it will only point to the shadow host of the newly focused element\n        // and not the element that actually has received focus if it is located\n        // inside a shadow root.\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.domReference, activeEl) || movedToFocusGuard) {\n          return;\n        }\n        onOpenChange(false, nativeEvent, 'focus');\n      });\n    }\n  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference\n  } : {}, [enabled, reference]);\n}\n\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n      [ACTIVE_KEY]: _,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1,\n      [FOCUSABLE_ATTRIBUTE]: ''\n    }),\n    ...domUserProps,\n    ...propsList.map(value => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      if (typeof propsOrGetProps === 'function') {\n        return userProps ? propsOrGetProps(userProps) : null;\n      }\n      return propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n          return;\n        }\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  const referenceDeps = propsList.map(key => key == null ? void 0 : key.reference);\n  const floatingDeps = propsList.map(key => key == null ? void 0 : key.floating);\n  const itemDeps = propsList.map(key => key == null ? void 0 : key.item);\n  const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  referenceDeps);\n  const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  floatingDeps);\n  const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  itemDeps);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    elements\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef,\n    itemSizes,\n    dense = false\n  } = props;\n  if (true) {\n    if (allowEscape) {\n      if (!loop) {\n        warn('`useListNavigation` looping must be enabled to allow escaping.');\n      }\n      if (!virtual) {\n        warn('`useListNavigation` must be virtual to allow escaping.');\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either \"horizontal\" or \"both\".');\n    }\n  }\n  const floatingFocusElement = getFloatingFocusElement(elements.floating);\n  const floatingFocusElementRef = useLatestRef(floatingFocusElement);\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const typeableComboboxReference = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(elements.domReference);\n  const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n  const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n  const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!elements.floating);\n  const previousOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(open);\n  const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    function runFocus(item) {\n      if (virtual) {\n        setActiveId(item.id);\n        tree == null || tree.events.emit('virtualfocus', item);\n        if (virtualItemRef) {\n          virtualItemRef.current = item;\n        }\n      } else {\n        enqueueFocus(item, {\n          preventScroll: true,\n          // Mac Safari does not move the virtual cursor unless the focus call\n          // is sync. However, for the very first focus call, we need to wait\n          // for the position to be ready in order to prevent unwanted\n          // scrolling. This means the virtual cursor will not move to the first\n          // item when first opening the floating element, but will on\n          // subsequent calls. `preventScroll` is supported in modern Safari,\n          // so we can use that instead.\n          // iOS Safari must be async or the first item will not be focused.\n          sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n        });\n      }\n    }\n    const initialItem = listRef.current[indexRef.current];\n    if (initialItem) {\n      runFocus(initialItem);\n    }\n    requestAnimationFrame(() => {\n      const waitedItem = listRef.current[indexRef.current] || initialItem;\n      if (!waitedItem) return;\n      if (!initialItem) {\n        runFocus(waitedItem);\n      }\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) return;\n    if (open && elements.floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, elements.floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) return;\n    if (open && elements.floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndexRef.current != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    var _nodes$find;\n    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, elements.floating, tree, parentId, virtual]);\n  index(() => {\n    if (!enabled) return;\n    if (!tree) return;\n    if (!virtual) return;\n    if (parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!elements.floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  index(() => {\n    previousOpenRef.current = open;\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(floatingFocusElementRef.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, floatingFocusElementRef, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  const commonOnKeyDown = useEffectEvent(event => {\n    isPointerModalityRef.current = false;\n    forceSyncFocus.current = true;\n\n    // When composing a character, Chrome fires ArrowDown twice. Firefox/Safari\n    // don't appear to suffer from this. `event.isComposing` is avoided due to\n    // Safari not supporting it properly (although it's not needed in the first\n    // place for Safari, just avoiding any possible issues).\n    if (event.which === 229) {\n      return;\n    }\n\n    // If the floating element is animating out, ignore navigation. Otherwise,\n    // the `activeIndex` gets set to 0 despite not being open so the next time\n    // the user ArrowDowns, the first item won't be focused.\n    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {\n      return;\n    }\n    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n      (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      onOpenChange(false, event.nativeEvent, 'list-navigation');\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(elements.domReference)) {\n        if (virtual) {\n          tree == null || tree.events.emit('virtualfocus', elements.domReference);\n        } else {\n          elements.domReference.focus();\n        }\n      }\n      return;\n    }\n    const currentIndex = indexRef.current;\n    const minIndex = getMinIndex(listRef, disabledIndices);\n    const maxIndex = getMaxIndex(listRef, disabledIndices);\n    if (!typeableComboboxReference) {\n      if (event.key === 'Home') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n    }\n\n    // Grid navigation.\n    if (cols > 1) {\n      const sizes = itemSizes || Array.from({\n        length: listRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = buildCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(listRef.current, index, disabledIndices));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(listRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);\n      const index = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        rtl,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getCellIndices([...(disabledIndices || listRef.current.map((_, index) => isDisabled(listRef.current, index) ? index : undefined)), undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction\n        // we're moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? 'tr' : 'tl'),\n        stopEvent: true\n      })];\n      if (index != null) {\n        indexRef.current = index;\n        onNavigate(indexRef.current);\n      }\n      if (orientation === 'both') {\n        return;\n      }\n    }\n    if (isMainOrientationKey(event.key, orientation)) {\n      (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n\n      // Reset the index if no item is focused.\n      if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n        onNavigate(indexRef.current);\n        return;\n      }\n      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n        if (loop) {\n          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          });\n        } else {\n          indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          }));\n        }\n      } else {\n        if (loop) {\n          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          });\n        } else {\n          indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          }));\n        }\n      }\n      if (isIndexOutOfBounds(listRef, indexRef.current)) {\n        onNavigate(null);\n      } else {\n        onNavigate(indexRef.current);\n      }\n    }\n  });\n  const ariaActiveDescendantProp = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n  }, [virtual, open, hasActiveIndex, virtualId, activeId]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      'aria-orientation': orientation === 'both' ? undefined : orientation,\n      ...(!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(elements.domReference) && ariaActiveDescendantProp),\n      onKeyDown: commonOnKeyDown,\n      onPointerMove() {\n        isPointerModalityRef.current = true;\n      }\n    };\n  }, [ariaActiveDescendantProp, commonOnKeyDown, elements.domReference, orientation]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    return {\n      ...ariaActiveDescendantProp,\n      onKeyDown(event) {\n        isPointerModalityRef.current = false;\n        const isArrowKey = event.key.startsWith('Arrow');\n        const isHomeOrEndKey = ['Home', 'End'].includes(event.key);\n        const isMoveKey = isArrowKey || isHomeOrEndKey;\n        const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n        const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n        const isMainKey = isMainOrientationKey(event.key, orientation);\n        const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n        if (virtual && open) {\n          const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n          const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n          if (isMoveKey && deepestNode && virtualItemRef) {\n            const eventObject = new KeyboardEvent('keydown', {\n              key: event.key,\n              bubbles: true\n            });\n            if (isCrossOpenKey || isCrossCloseKey) {\n              var _deepestNode$context, _deepestNode$context2;\n              const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n              const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find(item => (item == null ? void 0 : item.id) === activeId) : null;\n              if (dispatchItem) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                dispatchItem.dispatchEvent(eventObject);\n                setVirtualId(undefined);\n              }\n            }\n            if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {\n              if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                var _deepestNode$context$;\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                return;\n              }\n            }\n          }\n          return commonOnKeyDown(event);\n        }\n\n        // If a floating element should not open on arrow key down, avoid\n        // setting `activeIndex` while it's closed.\n        if (!open && !openOnArrowKeyDown && isArrowKey) {\n          return;\n        }\n        if (isNavigationKey) {\n          keyRef.current = nested && isMainKey ? null : event.key;\n        }\n        if (nested) {\n          if (isCrossOpenKey) {\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            if (open) {\n              indexRef.current = getMinIndex(listRef, disabledIndicesRef.current);\n              onNavigate(indexRef.current);\n            } else {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            }\n          }\n          return;\n        }\n        if (isMainKey) {\n          if (selectedIndex != null) {\n            indexRef.current = selectedIndex;\n          }\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n          if (!open && openOnArrowKeyDown) {\n            onOpenChange(true, event.nativeEvent, 'list-navigation');\n          } else {\n            commonOnKeyDown(event);\n          }\n          if (open) {\n            onNavigate(indexRef.current);\n          }\n        }\n      },\n      onFocus() {\n        if (open && !virtual) {\n          onNavigate(null);\n        }\n      },\n      onPointerDown: checkVirtualPointer,\n      onMouseDown: checkVirtualMouse,\n      onClick: checkVirtualMouse\n    };\n  }, [activeId, ariaActiveDescendantProp, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating,\n    item\n  } : {}, [enabled, reference, floating, item]);\n}\n\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const referenceId = useId();\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n      };\n    }\n    return {\n      'aria-expanded': open ? 'true' : 'false',\n      'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n      'aria-controls': open ? floatingId : undefined,\n      ...(ariaRole === 'listbox' && {\n        role: 'combobox'\n      }),\n      ...(ariaRole === 'menu' && {\n        id: referenceId\n      }),\n      ...(ariaRole === 'menu' && isNested && {\n        role: 'menuitem'\n      }),\n      ...(role === 'select' && {\n        'aria-autocomplete': 'none'\n      }),\n      ...(role === 'combobox' && {\n        'aria-autocomplete': 'list'\n      })\n    };\n  }, [ariaRole, floatingId, isNested, open, referenceId, role]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const floatingProps = {\n      id: floatingId,\n      ...(ariaRole && {\n        role: ariaRole\n      })\n    };\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return floatingProps;\n    }\n    return {\n      ...floatingProps,\n      ...(ariaRole === 'menu' && {\n        'aria-labelledby': referenceId\n      })\n    };\n  }, [ariaRole, floatingId, referenceId, role]);\n  const item = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {\n    let {\n      active,\n      selected\n    } = _ref;\n    const commonProps = {\n      role: 'option',\n      ...(active && {\n        id: floatingId + \"-option\"\n      })\n    };\n\n    // For `menu`, we are unable to tell if the item is a `menuitemradio`\n    // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n    // avoid defaulting to `menuitem` as it may overwrite custom role props.\n    switch (role) {\n      case 'select':\n        return {\n          ...commonProps,\n          'aria-selected': active && selected\n        };\n      case 'combobox':\n        {\n          return {\n            ...commonProps,\n            ...(active && {\n              'aria-selected': true\n            })\n          };\n        }\n    }\n    return {};\n  }, [floatingId, role]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating,\n    item\n  } : {}, [enabled, reference, floating, item]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open && isMounted) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, isMounted, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n  if (!isMounted && status === 'close') {\n    setStatus('unmounted');\n  }\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    }\n    setStatus('close');\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');\n  const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  const setTypingChange = useEffectEvent(value => {\n    if (value) {\n      if (!dataRef.current.typing) {\n        dataRef.current.typing = value;\n        onTypingChange(value);\n      }\n    } else {\n      if (dataRef.current.typing) {\n        dataRef.current.typing = value;\n        onTypingChange(value);\n      }\n    }\n  });\n  const onKeyDown = useEffectEvent(event => {\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    const listContent = listRef.current;\n    if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n      if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n        setTypingChange(false);\n      } else if (event.key === ' ') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      }\n    }\n    if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n    // Character key.\n    event.key.length !== 1 ||\n    // Modifier key.\n    event.ctrlKey || event.metaKey || event.altKey) {\n      return;\n    }\n    if (open && event.key !== ' ') {\n      (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      setTypingChange(true);\n    }\n\n    // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n    // allow it in this case, too.\n    const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n      var _text$, _text$2;\n      return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n    });\n\n    // Allows the user to cycle through items that start with the same letter\n    // in rapid succession.\n    if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n      stringRef.current = '';\n      prevIndexRef.current = matchIndexRef.current;\n    }\n    stringRef.current += event.key;\n    clearTimeout(timeoutIdRef.current);\n    timeoutIdRef.current = setTimeout(() => {\n      stringRef.current = '';\n      prevIndexRef.current = matchIndexRef.current;\n      setTypingChange(false);\n    }, resetMs);\n    const prevIndex = prevIndexRef.current;\n    const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n    if (index !== -1) {\n      onMatch(index);\n      matchIndexRef.current = index;\n    } else if (event.key !== ' ') {\n      stringRef.current = '';\n      setTypingChange(false);\n    }\n  });\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown\n  }), [onKeyDown]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      onKeyDown,\n      onKeyUp(event) {\n        if (event.key === ' ') {\n          setTypingChange(false);\n        }\n      }\n    };\n  }, [onKeyDown, setTypingChange]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating\n  } : {}, [enabled, reference, floating]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside of it is\n * anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.evaluate)(props, state);\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n\n    // Valid combinations:\n    // 1. Floating element is the scrollRef and has a border (default)\n    // 2. Floating element is not the scrollRef, floating element has a border\n    // 3. Floating element is not the scrollRef, scrollRef has a border\n    // Floating > {...getFloatingProps()} wrapper > scrollRef > items is not\n    // allowed as VoiceOver doesn't work.\n    const clientTop = floating.clientTop || scrollEl.clientTop;\n    const floatingIsBordered = floating.clientTop !== 0;\n    const scrollElIsBordered = scrollEl.clientTop !== 0;\n    const floatingIsScrollEl = floating === scrollEl;\n    if (true) {\n      if (!state.placement.startsWith('bottom')) {\n        warn('`placement` side must be \"bottom\" when using the `inner`', 'middleware.');\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);\n    const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.max)(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;\n    const rounder = isScrollable ? v => v : _floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.round;\n    const maxHeight = rounder((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.max)(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.max)(0, overflow.bottom)));\n    scrollEl.style.maxHeight = maxHeight + \"px\";\n    scrollEl.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.min)(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;\n      react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(() => onFallbackChange(shouldFallback));\n    }\n    if (overflowRef) {\n      overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getUserAgent)())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown() {\n      controlledScrollingRef.current = true;\n    },\n    onWheel() {\n      controlledScrollingRef.current = false;\n    },\n    onPointerMove() {\n      controlledScrollingRef.current = false;\n    },\n    onScroll() {\n      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n      if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n        return;\n      }\n      if (prevScrollTopRef.current !== null) {\n        const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n          react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(() => onChange(d => d + scrollDiff));\n        }\n      }\n\n      // [Firefox] Wait for the height change to have been applied.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n      });\n    }\n  }), [elements.floating, onChange, overflowRef, scrollRef]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    floating\n  } : {}, [enabled, floating]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, target);\n      const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvZGlzdC9mbG9hdGluZy11aS5yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUM0QjtBQUMrTztBQUNwTztBQUNzRjtBQUM1RztBQUNWO0FBQzhFO0FBQzRFOztBQUVoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUsseUxBQUs7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlDQUFZO0FBQzFCLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsOENBQWlCO0FBQzFCLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLG1FQUFTO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtRUFBVztBQUNyQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUVB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QUNBLElBQUksSUFBSTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsOEJBQThCLDJDQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUJBQWlCLDBDQUFhO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUFjO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUVBQVMseUJBQXlCLGtFQUFRO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMmlCIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQGZsb2F0aW5nLXVpXFxyZWFjdFxcZGlzdFxcZmxvYXRpbmctdWkucmVhY3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdG9wRXZlbnQsIGdldERvY3VtZW50LCBpc01vdXNlTGlrZVBvaW50ZXJUeXBlLCBjb250YWlucywgYWN0aXZlRWxlbWVudCwgaXNTYWZhcmksIGlzVHlwZWFibGVDb21ib2JveCwgaXNWaXJ0dWFsQ2xpY2ssIGlzVmlydHVhbFBvaW50ZXJFdmVudCwgZ2V0VGFyZ2V0LCBnZXRQbGF0Zm9ybSwgaXNUeXBlYWJsZUVsZW1lbnQsIGlzUmVhY3RFdmVudCwgaXNSb290RWxlbWVudCwgaXNFdmVudFRhcmdldFdpdGhpbiwgaXNNYWMsIGdldFVzZXJBZ2VudCB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC91dGlscyc7XG5pbXBvcnQgeyBmbG9vciwgZXZhbHVhdGUsIG1heCwgbWluLCByb3VuZCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0VsZW1lbnQsIGdldE5vZGVOYW1lLCBpc0hUTUxFbGVtZW50LCBnZXRXaW5kb3csIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgZ2V0UGFyZW50Tm9kZSwgaXNXZWJLaXQgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmltcG9ydCB7IHRhYmJhYmxlLCBpc1RhYmJhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IGdldE92ZXJmbG93QW5jZXN0b3JzLCB1c2VGbG9hdGluZyBhcyB1c2VGbG9hdGluZyQxLCBvZmZzZXQsIGRldGVjdE92ZXJmbG93IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgcmVmcyBpbnRvIGEgc2luZ2xlIG1lbW9pemVkIGNhbGxiYWNrIHJlZiBvciBgbnVsbGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcmVhY3QtdXRpbHMjdXNlbWVyZ2VyZWZzXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlUmVmcyhyZWZzKSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVmcy5ldmVyeShyZWYgPT4gcmVmID09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgIHJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlZih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgcmVmcyk7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWkvbWF0ZXJpYWwtdWkvaXNzdWVzLzQxMTkwI2lzc3VlY29tbWVudC0yMDQwODczMzc5XG5jb25zdCBTYWZlUmVhY3QgPSB7XG4gIC4uLlJlYWN0XG59O1xuXG5jb25zdCB1c2VJbnNlcnRpb25FZmZlY3QgPSBTYWZlUmVhY3QudXNlSW5zZXJ0aW9uRWZmZWN0O1xuY29uc3QgdXNlU2FmZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdCB8fCAoZm4gPT4gZm4oKSk7XG5mdW5jdGlvbiB1c2VFZmZlY3RFdmVudChjYWxsYmFjaykge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgYW4gZXZlbnQgaGFuZGxlciB3aGlsZSByZW5kZXJpbmcuJyk7XG4gICAgfVxuICB9KTtcbiAgdXNlU2FmZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50KC4uLmFyZ3MpO1xuICB9LCBbXSk7XG59XG5cbmNvbnN0IEFSUk9XX1VQID0gJ0Fycm93VXAnO1xuY29uc3QgQVJST1dfRE9XTiA9ICdBcnJvd0Rvd24nO1xuY29uc3QgQVJST1dfTEVGVCA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFQgPSAnQXJyb3dSaWdodCc7XG5mdW5jdGlvbiBpc0RpZmZlcmVudFJvdyhpbmRleCwgY29scywgcHJldlJvdykge1xuICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCAvIGNvbHMpICE9PSBwcmV2Um93O1xufVxuZnVuY3Rpb24gaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICBzdGFydGluZ0luZGV4OiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoLFxuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc3RhcnRpbmdJbmRleCA9IC0xLFxuICAgIGRlY3JlbWVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBhbW91bnQgPSAxXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgbGlzdCA9IGxpc3RSZWYuY3VycmVudDtcbiAgbGV0IGluZGV4ID0gc3RhcnRpbmdJbmRleDtcbiAgZG8ge1xuICAgIGluZGV4ICs9IGRlY3JlbWVudCA/IC1hbW91bnQgOiBhbW91bnQ7XG4gIH0gd2hpbGUgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gbGlzdC5sZW5ndGggLSAxICYmIGlzRGlzYWJsZWQobGlzdCwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykpO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBnZXRHcmlkTmF2aWdhdGVkSW5kZXgoZWxlbWVudHNSZWYsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBldmVudCxcbiAgICBvcmllbnRhdGlvbixcbiAgICBsb29wLFxuICAgIHJ0bCxcbiAgICBjb2xzLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBtaW5JbmRleCxcbiAgICBtYXhJbmRleCxcbiAgICBwcmV2SW5kZXgsXG4gICAgc3RvcEV2ZW50OiBzdG9wID0gZmFsc2VcbiAgfSA9IF9yZWY7XG4gIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1VQKSB7XG4gICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIChwcmV2SW5kZXggLSBjb2xzIDwgbWluSW5kZXggfHwgbmV4dEluZGV4IDwgMCkpIHtcbiAgICAgICAgY29uc3QgY29sID0gcHJldkluZGV4ICUgY29scztcbiAgICAgICAgY29uc3QgbWF4Q29sID0gbWF4SW5kZXggJSBjb2xzO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXhJbmRleCAtIChtYXhDb2wgLSBjb2wpO1xuICAgICAgICBpZiAobWF4Q29sID09PSBjb2wpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhDb2wgPiBjb2wgPyBvZmZzZXQgOiBvZmZzZXQgLSBjb2xzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTikge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWluSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxvb3AgJiYgcHJldkluZGV4ICsgY29scyA+IG1heEluZGV4KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICUgY29scyAtIGNvbHMsXG4gICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbWFpbnMgb24gdGhlIHNhbWUgcm93L2NvbHVtbi5cbiAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICBjb25zdCBwcmV2Um93ID0gZmxvb3IocHJldkluZGV4IC8gY29scyk7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gKHJ0bCA/IEFSUk9XX0xFRlQgOiBBUlJPV19SSUdIVCkpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSBjb2xzIC0gMSkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSAocnRsID8gQVJST1dfUklHSFQgOiBBUlJPV19MRUZUKSkge1xuICAgICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKHByZXZJbmRleCAlIGNvbHMgIT09IDApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvb3AgJiYgaXNEaWZmZXJlbnRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdFJvdyA9IGZsb29yKG1heEluZGV4IC8gY29scykgPT09IHByZXZSb3c7XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbGFzdFJvdykge1xuICAgICAgICBuZXh0SW5kZXggPSBldmVudC5rZXkgPT09IChydGwgPyBBUlJPV19SSUdIVCA6IEFSUk9XX0xFRlQpID8gbWF4SW5kZXggOiBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRJbmRleDtcbn1cblxuLyoqIEZvciBlYWNoIGNlbGwgaW5kZXgsIGdldHMgdGhlIGl0ZW0gaW5kZXggdGhhdCBvY2N1cGllcyB0aGF0IGNlbGwgKi9cbmZ1bmN0aW9uIGJ1aWxkQ2VsbE1hcChzaXplcywgY29scywgZGVuc2UpIHtcbiAgY29uc3QgY2VsbE1hcCA9IFtdO1xuICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gIHNpemVzLmZvckVhY2goKF9yZWYyLCBpbmRleCkgPT4ge1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAod2lkdGggPiBjb2xzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltGbG9hdGluZyBVSV06IEludmFsaWQgZ3JpZCAtIGl0ZW0gd2lkdGggYXQgaW5kZXggXCIgKyBpbmRleCArIFwiIGlzIGdyZWF0ZXIgdGhhbiBncmlkIGNvbHVtbnNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpdGVtUGxhY2VkID0gZmFsc2U7XG4gICAgaWYgKGRlbnNlKSB7XG4gICAgICBzdGFydEluZGV4ID0gMDtcbiAgICB9XG4gICAgd2hpbGUgKCFpdGVtUGxhY2VkKSB7XG4gICAgICBjb25zdCB0YXJnZXRDZWxscyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICB0YXJnZXRDZWxscy5wdXNoKHN0YXJ0SW5kZXggKyBpICsgaiAqIGNvbHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRJbmRleCAlIGNvbHMgKyB3aWR0aCA8PSBjb2xzICYmIHRhcmdldENlbGxzLmV2ZXJ5KGNlbGwgPT4gY2VsbE1hcFtjZWxsXSA9PSBudWxsKSkge1xuICAgICAgICB0YXJnZXRDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgIGNlbGxNYXBbY2VsbF0gPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1QbGFjZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gY29udmVydCBpbnRvIGEgbm9uLXNwYXJzZSBhcnJheVxuICByZXR1cm4gWy4uLmNlbGxNYXBdO1xufVxuXG4vKiogR2V0cyBjZWxsIGluZGV4IG9mIGFuIGl0ZW0ncyBjb3JuZXIgb3IgLTEgd2hlbiBpbmRleCBpcyAtMS4gKi9cbmZ1bmN0aW9uIGdldENlbGxJbmRleE9mQ29ybmVyKGluZGV4LCBzaXplcywgY2VsbE1hcCwgY29scywgY29ybmVyKSB7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiAtMTtcbiAgY29uc3QgZmlyc3RDZWxsSW5kZXggPSBjZWxsTWFwLmluZGV4T2YoaW5kZXgpO1xuICBjb25zdCBzaXplSXRlbSA9IHNpemVzW2luZGV4XTtcbiAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICBjYXNlICd0bCc6XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgY2FzZSAndHInOlxuICAgICAgaWYgKCFzaXplSXRlbSkge1xuICAgICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXggKyBzaXplSXRlbS53aWR0aCAtIDE7XG4gICAgY2FzZSAnYmwnOlxuICAgICAgaWYgKCFzaXplSXRlbSkge1xuICAgICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXggKyAoc2l6ZUl0ZW0uaGVpZ2h0IC0gMSkgKiBjb2xzO1xuICAgIGNhc2UgJ2JyJzpcbiAgICAgIHJldHVybiBjZWxsTWFwLmxhc3RJbmRleE9mKGluZGV4KTtcbiAgfVxufVxuXG4vKiogR2V0cyBhbGwgY2VsbCBpbmRpY2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgc3BlY2lmaWVkIGluZGljZXMgKi9cbmZ1bmN0aW9uIGdldENlbGxJbmRpY2VzKGluZGljZXMsIGNlbGxNYXApIHtcbiAgcmV0dXJuIGNlbGxNYXAuZmxhdE1hcCgoaW5kZXgsIGNlbGxJbmRleCkgPT4gaW5kaWNlcy5pbmNsdWRlcyhpbmRleCkgPyBbY2VsbEluZGV4XSA6IFtdKTtcbn1cbmZ1bmN0aW9uIGlzRGlzYWJsZWQobGlzdCwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykge1xuICBpZiAoZGlzYWJsZWRJbmRpY2VzKSB7XG4gICAgcmV0dXJuIGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCk7XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IGxpc3RbaW5kZXhdO1xuICByZXR1cm4gZWxlbWVudCA9PSBudWxsIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJykgPT09ICd0cnVlJztcbn1cblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuZnVuY3Rpb24gc29ydEJ5RG9jdW1lbnRQb3NpdGlvbihhLCBiKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKTtcbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChtYXAxLCBtYXAyKSB7XG4gIGlmIChtYXAxLnNpemUgIT09IG1hcDIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbWFwMi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEZsb2F0aW5nTGlzdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgdW5yZWdpc3RlcjogKCkgPT4ge30sXG4gIG1hcDogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZWxlbWVudHNSZWY6IHtcbiAgICBjdXJyZW50OiBbXVxuICB9XG59KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBsaXN0IG9mIGl0ZW1zIHdpdGhpbiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3RcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdMaXN0KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbbWFwLCBzZXRNYXBdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBzZXRNYXAocHJldk1hcCA9PiBuZXcgTWFwKHByZXZNYXApLnNldChub2RlLCBudWxsKSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAocHJldk1hcCk7XG4gICAgICBtYXAuZGVsZXRlKG5vZGUpO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChtYXApO1xuICAgIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShuZXdNYXAua2V5cygpKS5zb3J0KHNvcnRCeURvY3VtZW50UG9zaXRpb24pO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBuZXdNYXAuc2V0KG5vZGUsIGluZGV4KTtcbiAgICB9KTtcbiAgICBpZiAoIWFyZU1hcHNFcXVhbChtYXAsIG5ld01hcCkpIHtcbiAgICAgIHNldE1hcChuZXdNYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICByZWdpc3RlcixcbiAgICAgIHVucmVnaXN0ZXIsXG4gICAgICBtYXAsXG4gICAgICBlbGVtZW50c1JlZixcbiAgICAgIGxhYmVsc1JlZlxuICAgIH0pLCBbcmVnaXN0ZXIsIHVucmVnaXN0ZXIsIG1hcCwgZWxlbWVudHNSZWYsIGxhYmVsc1JlZl0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cbi8qKlxuICogVXNlZCB0byByZWdpc3RlciBhIGxpc3QgaXRlbSBhbmQgaXRzIGluZGV4IChET00gcG9zaXRpb24pIGluIHRoZVxuICogYEZsb2F0aW5nTGlzdGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdMaXN0I3VzZWxpc3RpdGVtXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3RJdGVtKHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgbGFiZWxcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgcmVnaXN0ZXIsXG4gICAgdW5yZWdpc3RlcixcbiAgICBtYXAsXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTGlzdENvbnRleHQpO1xuICBjb25zdCBbaW5kZXgkMSwgc2V0SW5kZXhdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGNvbXBvbmVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgY29tcG9uZW50UmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIGlmIChpbmRleCQxICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50c1JlZi5jdXJyZW50W2luZGV4JDFdID0gbm9kZTtcbiAgICAgIGlmIChsYWJlbHNSZWYpIHtcbiAgICAgICAgdmFyIF9ub2RlJHRleHRDb250ZW50O1xuICAgICAgICBjb25zdCBpc0xhYmVsRGVmaW5lZCA9IGxhYmVsICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGxhYmVsc1JlZi5jdXJyZW50W2luZGV4JDFdID0gaXNMYWJlbERlZmluZWQgPyBsYWJlbCA6IChfbm9kZSR0ZXh0Q29udGVudCA9IG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudGV4dENvbnRlbnQpICE9IG51bGwgPyBfbm9kZSR0ZXh0Q29udGVudCA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCBbaW5kZXgkMSwgZWxlbWVudHNSZWYsIGxhYmVsc1JlZiwgbGFiZWxdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb25lbnRSZWYuY3VycmVudDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmVnaXN0ZXIobm9kZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtyZWdpc3RlciwgdW5yZWdpc3Rlcl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnRSZWYuY3VycmVudCA/IG1hcC5nZXQoY29tcG9uZW50UmVmLmN1cnJlbnQpIDogbnVsbDtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZixcbiAgICBpbmRleDogaW5kZXgkMSA9PSBudWxsID8gLTEgOiBpbmRleCQxXG4gIH0pLCBbaW5kZXgkMSwgcmVmXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpIHtcbiAgaWYgKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVuZGVyKGNvbXB1dGVkUHJvcHMpO1xuICB9XG4gIGlmIChyZW5kZXIpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBjb21wdXRlZFByb3BzKTtcbn1cbmNvbnN0IENvbXBvc2l0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGFjdGl2ZUluZGV4OiAwLFxuICBvbk5hdmlnYXRlOiAoKSA9PiB7fVxufSk7XG5jb25zdCBob3Jpem9udGFsS2V5cyA9IFtBUlJPV19MRUZULCBBUlJPV19SSUdIVF07XG5jb25zdCB2ZXJ0aWNhbEtleXMgPSBbQVJST1dfVVAsIEFSUk9XX0RPV05dO1xuY29uc3QgYWxsS2V5cyA9IFsuLi5ob3Jpem9udGFsS2V5cywgLi4udmVydGljYWxLZXlzXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2luZ2xlIHRhYiBzdG9wIHdob3NlIGl0ZW1zIGFyZSBuYXZpZ2F0ZWQgYnkgYXJyb3cga2V5cywgd2hpY2hcbiAqIHByb3ZpZGVzIGxpc3QgbmF2aWdhdGlvbiBvdXRzaWRlIG9mIGZsb2F0aW5nIGVsZW1lbnQgY29udGV4dHMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgdG8gZW5hYmxlIG5hdmlnYXRpb24gb2YgYSBsaXN0IG9mIGl0ZW1zIHRoYXQgYXJlbuKAmXQgcGFydCBvZiBhXG4gKiBmbG9hdGluZyBlbGVtZW50LiBBIG1lbnViYXIgaXMgYW4gZXhhbXBsZSBvZiBhIGNvbXBvc2l0ZSwgd2l0aCBlYWNoIHJlZmVyZW5jZVxuICogZWxlbWVudCBiZWluZyBhbiBpdGVtLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0NvbXBvc2l0ZVxuICovXG5jb25zdCBDb21wb3NpdGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGUocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgcmVuZGVyLFxuICAgIG9yaWVudGF0aW9uID0gJ2JvdGgnLFxuICAgIGxvb3AgPSB0cnVlLFxuICAgIHJ0bCA9IGZhbHNlLFxuICAgIGNvbHMgPSAxLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBhY3RpdmVJbmRleDogZXh0ZXJuYWxBY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiBleHRlcm5hbFNldEFjdGl2ZUluZGV4LFxuICAgIGl0ZW1TaXplcyxcbiAgICBkZW5zZSA9IGZhbHNlLFxuICAgIC4uLmRvbVByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW2ludGVybmFsQWN0aXZlSW5kZXgsIGludGVybmFsU2V0QWN0aXZlSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gZXh0ZXJuYWxBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxBY3RpdmVJbmRleCA6IGludGVybmFsQWN0aXZlSW5kZXg7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudChleHRlcm5hbFNldEFjdGl2ZUluZGV4ICE9IG51bGwgPyBleHRlcm5hbFNldEFjdGl2ZUluZGV4IDogaW50ZXJuYWxTZXRBY3RpdmVJbmRleCk7XG4gIGNvbnN0IGVsZW1lbnRzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudFByb3BzID0gcmVuZGVyICYmIHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicgPyByZW5kZXIucHJvcHMgOiB7fTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGVcbiAgfSksIFthY3RpdmVJbmRleCwgb25OYXZpZ2F0ZV0pO1xuICBjb25zdCBpc0dyaWQgPSBjb2xzID4gMTtcbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmICghYWxsS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSByZXR1cm47XG4gICAgbGV0IG5leHRJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IG1pbkluZGV4ID0gZ2V0TWluSW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBnZXRNYXhJbmRleChlbGVtZW50c1JlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICBjb25zdCBob3Jpem9udGFsRW5kS2V5ID0gcnRsID8gQVJST1dfTEVGVCA6IEFSUk9XX1JJR0hUO1xuICAgIGNvbnN0IGhvcml6b250YWxTdGFydEtleSA9IHJ0bCA/IEFSUk9XX1JJR0hUIDogQVJST1dfTEVGVDtcbiAgICBpZiAoaXNHcmlkKSB7XG4gICAgICBjb25zdCBzaXplcyA9IGl0ZW1TaXplcyB8fCBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBlbGVtZW50c1JlZi5jdXJyZW50Lmxlbmd0aFxuICAgICAgfSwgKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMVxuICAgICAgfSkpO1xuICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgIC8vIGFzIGlmIGV2ZXJ5IGl0ZW0gd2FzIDF4MSwgdGhlbiBjb252ZXJ0IGJhY2sgdG8gcmVhbCBpbmRpY2VzLlxuICAgICAgY29uc3QgY2VsbE1hcCA9IGJ1aWxkQ2VsbE1hcChzaXplcywgY29scywgZGVuc2UpO1xuICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhaXNEaXNhYmxlZChlbGVtZW50c1JlZi5jdXJyZW50LCBpbmRleCwgZGlzYWJsZWRJbmRpY2VzKSk7XG4gICAgICAvLyBsYXN0IGVuYWJsZWQgaW5kZXhcbiAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICFpc0Rpc2FibGVkKGVsZW1lbnRzUmVmLmN1cnJlbnQsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpID8gY2VsbEluZGV4IDogZm91bmRJbmRleCwgLTEpO1xuICAgICAgY29uc3QgbWF5YmVOZXh0SW5kZXggPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgIGN1cnJlbnQ6IGNlbGxNYXAubWFwKGl0ZW1JbmRleCA9PiBpdGVtSW5kZXggPyBlbGVtZW50c1JlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgfSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIHJ0bCxcbiAgICAgICAgY29scyxcbiAgICAgICAgLy8gdHJlYXQgdW5kZWZpbmVkIChlbXB0eSBncmlkIHNwYWNlcykgYXMgZGlzYWJsZWQgaW5kaWNlcyBzbyB3ZVxuICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICBkaXNhYmxlZEluZGljZXM6IGdldENlbGxJbmRpY2VzKFsuLi4oZGlzYWJsZWRJbmRpY2VzIHx8IGVsZW1lbnRzUmVmLmN1cnJlbnQubWFwKChfLCBpbmRleCkgPT4gaXNEaXNhYmxlZChlbGVtZW50c1JlZi5jdXJyZW50LCBpbmRleCkgPyBpbmRleCA6IHVuZGVmaW5lZCkpLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgbWluSW5kZXg6IG1pbkdyaWRJbmRleCxcbiAgICAgICAgbWF4SW5kZXg6IG1heEdyaWRJbmRleCxcbiAgICAgICAgcHJldkluZGV4OiBnZXRDZWxsSW5kZXhPZkNvcm5lcihhY3RpdmVJbmRleCA+IG1heEluZGV4ID8gbWluSW5kZXggOiBhY3RpdmVJbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsXG4gICAgICAgIC8vIHVzZSBhIGNvcm5lciBtYXRjaGluZyB0aGUgZWRnZSBjbG9zZXN0IHRvIHRoZSBkaXJlY3Rpb24gd2UncmVcbiAgICAgICAgLy8gbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgLy8gdG9wL2xlZnQgb3ZlciBib3R0b20vcmlnaHQuXG4gICAgICAgIGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTiA/ICdibCcgOiBldmVudC5rZXkgPT09IGhvcml6b250YWxFbmRLZXkgPyAndHInIDogJ3RsJylcbiAgICAgIH0pXTtcbiAgICAgIGlmIChtYXliZU5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1heWJlTmV4dEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0b0VuZEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbaG9yaXpvbnRhbEVuZEtleV0sXG4gICAgICB2ZXJ0aWNhbDogW0FSUk9XX0RPV05dLFxuICAgICAgYm90aDogW2hvcml6b250YWxFbmRLZXksIEFSUk9XX0RPV05dXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgY29uc3QgdG9TdGFydEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbaG9yaXpvbnRhbFN0YXJ0S2V5XSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfVVBdLFxuICAgICAgYm90aDogW2hvcml6b250YWxTdGFydEtleSwgQVJST1dfVVBdXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgY29uc3QgcHJldmVudGVkS2V5cyA9IGlzR3JpZCA/IGFsbEtleXMgOiB7XG4gICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsS2V5cyxcbiAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEtleXMsXG4gICAgICBib3RoOiBhbGxLZXlzXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgaWYgKG5leHRJbmRleCA9PT0gYWN0aXZlSW5kZXggJiYgWy4uLnRvRW5kS2V5cywgLi4udG9TdGFydEtleXNdLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgIGlmIChsb29wICYmIG5leHRJbmRleCA9PT0gbWF4SW5kZXggJiYgdG9FbmRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbWluSW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGxvb3AgJiYgbmV4dEluZGV4ID09PSBtaW5JbmRleCAmJiB0b1N0YXJ0S2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1heEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgZGVjcmVtZW50OiB0b1N0YXJ0S2V5cy5pbmNsdWRlcyhldmVudC5rZXkpLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5leHRJbmRleCAhPT0gYWN0aXZlSW5kZXggJiYgIWlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgdmFyIF9lbGVtZW50c1JlZiRjdXJyZW50JDtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKHByZXZlbnRlZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgb25OYXZpZ2F0ZShuZXh0SW5kZXgpO1xuICAgICAgKF9lbGVtZW50c1JlZiRjdXJyZW50JCA9IGVsZW1lbnRzUmVmLmN1cnJlbnRbbmV4dEluZGV4XSkgPT0gbnVsbCB8fCBfZWxlbWVudHNSZWYkY3VycmVudCQuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29tcHV0ZWRQcm9wcyA9IHtcbiAgICAuLi5kb21Qcm9wcyxcbiAgICAuLi5yZW5kZXJFbGVtZW50UHJvcHMsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbiA9PT0gJ2JvdGgnID8gdW5kZWZpbmVkIDogb3JpZW50YXRpb24sXG4gICAgb25LZXlEb3duKGUpIHtcbiAgICAgIGRvbVByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IGRvbVByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgIHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24gPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgaGFuZGxlS2V5RG93bihlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NpdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3QsIHtcbiAgICBlbGVtZW50c1JlZjogZWxlbWVudHNSZWZcbiAgfSwgcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykpKTtcbn0pO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZUl0ZW0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGVJdGVtKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgY29uc3Qge1xuICAgIHJlbmRlcixcbiAgICAuLi5kb21Qcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbXBvc2l0ZUNvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcmVmLFxuICAgIGluZGV4XG4gIH0gPSB1c2VMaXN0SXRlbSgpO1xuICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgZm9yd2FyZGVkUmVmLCByZW5kZXJFbGVtZW50UHJvcHMucmVmXSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLmRvbVByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICB0YWJJbmRleDogaXNBY3RpdmUgPyAwIDogLTEsXG4gICAgJ2RhdGEtYWN0aXZlJzogaXNBY3RpdmUgPyAnJyA6IHVuZGVmaW5lZCxcbiAgICBvbkZvY3VzKGUpIHtcbiAgICAgIGRvbVByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCBkb21Qcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xufSk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgY291bnQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiAvLyBFbnN1cmUgdGhlIGlkIGlzIHVuaXF1ZSB3aXRoIG11bHRpcGxlIGluZGVwZW5kZW50IHZlcnNpb25zIG9mIEZsb2F0aW5nIFVJXG4vLyBvbiA8UmVhY3QgMThcblwiZmxvYXRpbmctdWktXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA2KSArIGNvdW50Kys7XG5mdW5jdGlvbiB1c2VGbG9hdGluZ0lkKCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA/IGdlbklkKCkgOiB1bmRlZmluZWQpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIHNldElkKGdlbklkKCkpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSB0cnVlO1xuICB9LCBbXSk7XG4gIHJldHVybiBpZDtcbn1cbmNvbnN0IHVzZVJlYWN0SWQgPSBTYWZlUmVhY3QudXNlSWQ7XG5cbi8qKlxuICogVXNlcyBSZWFjdCAxOCdzIGJ1aWx0LWluIGB1c2VJZCgpYCB3aGVuIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayB0byBhXG4gKiBzbGlnaHRseSBsZXNzIHBlcmZvcm1hbnQgKHJlcXVpcmluZyBhIGRvdWJsZSByZW5kZXIpIGltcGxlbWVudGF0aW9uIGZvclxuICogZWFybGllciBSZWFjdCB2ZXJzaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdC11dGlscyN1c2VpZFxuICovXG5jb25zdCB1c2VJZCA9IHVzZVJlYWN0SWQgfHwgdXNlRmxvYXRpbmdJZDtcblxubGV0IGRldk1lc3NhZ2VTZXQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGRldk1lc3NhZ2VTZXQgPSAvKiNfX1BVUkVfXyovbmV3IFNldCgpO1xufVxuZnVuY3Rpb24gd2FybigpIHtcbiAgdmFyIF9kZXZNZXNzYWdlU2V0O1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWVzc2FnZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFwiRmxvYXRpbmcgVUk6IFwiICsgbWVzc2FnZXMuam9pbignICcpO1xuICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQgPSBkZXZNZXNzYWdlU2V0KSAhPSBudWxsICYmIF9kZXZNZXNzYWdlU2V0LmhhcyhtZXNzYWdlKSkpIHtcbiAgICB2YXIgX2Rldk1lc3NhZ2VTZXQyO1xuICAgIChfZGV2TWVzc2FnZVNldDIgPSBkZXZNZXNzYWdlU2V0KSA9PSBudWxsIHx8IF9kZXZNZXNzYWdlU2V0Mi5hZGQobWVzc2FnZSk7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgdmFyIF9kZXZNZXNzYWdlU2V0MztcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBtZXNzYWdlcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIG1lc3NhZ2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFwiRmxvYXRpbmcgVUk6IFwiICsgbWVzc2FnZXMuam9pbignICcpO1xuICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQzID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldDMuaGFzKG1lc3NhZ2UpKSkge1xuICAgIHZhciBfZGV2TWVzc2FnZVNldDQ7XG4gICAgKF9kZXZNZXNzYWdlU2V0NCA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQ0LmFkZChtZXNzYWdlKTtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHBvaW50aW5nIGFycm93IHRyaWFuZ2xlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nQXJyb3dcbiAqL1xuY29uc3QgRmxvYXRpbmdBcnJvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nQXJyb3cocHJvcHMsIHJlZikge1xuICBjb25zdCB7XG4gICAgY29udGV4dDoge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlRGF0YToge1xuICAgICAgICBhcnJvdyxcbiAgICAgICAgc2hpZnRcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpZHRoID0gMTQsXG4gICAgaGVpZ2h0ID0gNyxcbiAgICB0aXBSYWRpdXMgPSAwLFxuICAgIHN0cm9rZVdpZHRoID0gMCxcbiAgICBzdGF0aWNPZmZzZXQsXG4gICAgc3Ryb2tlLFxuICAgIGQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH0gPSB7fSxcbiAgICAuLi5yZXN0XG4gIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghcmVmKSB7XG4gICAgICB3YXJuKCdUaGUgYHJlZmAgcHJvcCBpcyByZXF1aXJlZCBmb3IgYEZsb2F0aW5nQXJyb3dgLicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjbGlwUGF0aElkID0gdXNlSWQoKTtcbiAgY29uc3QgW2lzUlRMLCBzZXRJc1JUTF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yOTMyXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWZsb2F0aW5nKSByZXR1cm47XG4gICAgY29uc3QgaXNSVEwgPSBnZXRDb21wdXRlZFN0eWxlKGZsb2F0aW5nKS5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgIGlmIChpc1JUTCkge1xuICAgICAgc2V0SXNSVEwodHJ1ZSk7XG4gICAgfVxuICB9LCBbZmxvYXRpbmddKTtcbiAgaWYgKCFmbG9hdGluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFtzaWRlLCBhbGlnbm1lbnRdID0gcGxhY2VtZW50LnNwbGl0KCctJyk7XG4gIGNvbnN0IGlzVmVydGljYWxTaWRlID0gc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbSc7XG4gIGxldCBjb21wdXRlZFN0YXRpY09mZnNldCA9IHN0YXRpY09mZnNldDtcbiAgaWYgKGlzVmVydGljYWxTaWRlICYmIHNoaWZ0ICE9IG51bGwgJiYgc2hpZnQueCB8fCAhaXNWZXJ0aWNhbFNpZGUgJiYgc2hpZnQgIT0gbnVsbCAmJiBzaGlmdC55KSB7XG4gICAgY29tcHV0ZWRTdGF0aWNPZmZzZXQgPSBudWxsO1xuICB9XG5cbiAgLy8gU3Ryb2tlcyBtdXN0IGJlIGRvdWJsZSB0aGUgYm9yZGVyIHdpZHRoLCB0aGlzIGVuc3VyZXMgdGhlIHN0cm9rZSdzIHdpZHRoXG4gIC8vIHdvcmtzIGFzIHlvdSdkIGV4cGVjdC5cbiAgY29uc3QgY29tcHV0ZWRTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoICogMjtcbiAgY29uc3QgaGFsZlN0cm9rZVdpZHRoID0gY29tcHV0ZWRTdHJva2VXaWR0aCAvIDI7XG4gIGNvbnN0IHN2Z1ggPSB3aWR0aCAvIDIgKiAodGlwUmFkaXVzIC8gLTggKyAxKTtcbiAgY29uc3Qgc3ZnWSA9IGhlaWdodCAvIDIgKiB0aXBSYWRpdXMgLyA0O1xuICBjb25zdCBpc0N1c3RvbVNoYXBlID0gISFkO1xuICBjb25zdCB5T2Zmc2V0UHJvcCA9IGNvbXB1dGVkU3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBsZXQgeE9mZnNldFByb3AgPSBjb21wdXRlZFN0YXRpY09mZnNldCAmJiBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgaWYgKGNvbXB1dGVkU3RhdGljT2Zmc2V0ICYmIGlzUlRMKSB7XG4gICAgeE9mZnNldFByb3AgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfVxuICBjb25zdCBhcnJvd1ggPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LngpICE9IG51bGwgPyBjb21wdXRlZFN0YXRpY09mZnNldCB8fCBhcnJvdy54IDogJyc7XG4gIGNvbnN0IGFycm93WSA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueSkgIT0gbnVsbCA/IGNvbXB1dGVkU3RhdGljT2Zmc2V0IHx8IGFycm93LnkgOiAnJztcbiAgY29uc3QgZFZhbHVlID0gZCB8fCAnTTAsMCcgKyAoXCIgSFwiICsgd2lkdGgpICsgKFwiIExcIiArICh3aWR0aCAtIHN2Z1gpICsgXCIsXCIgKyAoaGVpZ2h0IC0gc3ZnWSkpICsgKFwiIFFcIiArIHdpZHRoIC8gMiArIFwiLFwiICsgaGVpZ2h0ICsgXCIgXCIgKyBzdmdYICsgXCIsXCIgKyAoaGVpZ2h0IC0gc3ZnWSkpICsgJyBaJztcbiAgY29uc3Qgcm90YXRpb24gPSB7XG4gICAgdG9wOiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgxODBkZWcpJyA6ICcnLFxuICAgIGxlZnQ6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDkwZGVnKScgOiAncm90YXRlKC05MGRlZyknLFxuICAgIGJvdHRvbTogaXNDdXN0b21TaGFwZSA/ICcnIDogJ3JvdGF0ZSgxODBkZWcpJyxcbiAgICByaWdodDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoLTkwZGVnKScgOiAncm90YXRlKDkwZGVnKSdcbiAgfVtzaWRlXTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgIHJlZjogcmVmLFxuICAgIHdpZHRoOiBpc0N1c3RvbVNoYXBlID8gd2lkdGggOiB3aWR0aCArIGNvbXB1dGVkU3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aCxcbiAgICB2aWV3Qm94OiBcIjAgMCBcIiArIHdpZHRoICsgXCIgXCIgKyAoaGVpZ2h0ID4gd2lkdGggPyBoZWlnaHQgOiB3aWR0aCksXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgW3hPZmZzZXRQcm9wXTogYXJyb3dYLFxuICAgICAgW3lPZmZzZXRQcm9wXTogYXJyb3dZLFxuICAgICAgW3NpZGVdOiBpc1ZlcnRpY2FsU2lkZSB8fCBpc0N1c3RvbVNoYXBlID8gJzEwMCUnIDogXCJjYWxjKDEwMCUgLSBcIiArIGNvbXB1dGVkU3Ryb2tlV2lkdGggLyAyICsgXCJweClcIixcbiAgICAgIHRyYW5zZm9ybTogW3JvdGF0aW9uLCB0cmFuc2Zvcm1dLmZpbHRlcih0ID0+ICEhdCkuam9pbignICcpLFxuICAgICAgLi4ucmVzdFN0eWxlXG4gICAgfVxuICB9KSwgY29tcHV0ZWRTdHJva2VXaWR0aCA+IDAgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBjbGlwUGF0aDogXCJ1cmwoI1wiICsgY2xpcFBhdGhJZCArIFwiKVwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgLy8gQWNjb3VudCBmb3IgdGhlIHN0cm9rZSBvbiB0aGUgZmlsbCBwYXRoIHJlbmRlcmVkIGJlbG93LlxuICAgICxcbiAgICBzdHJva2VXaWR0aDogY29tcHV0ZWRTdHJva2VXaWR0aCArIChkID8gMCA6IDEpLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBzdHJva2U6IGNvbXB1dGVkU3Ryb2tlV2lkdGggJiYgIWQgPyByZXN0LmZpbGwgOiAnbm9uZScsXG4gICAgZDogZFZhbHVlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIsIHtcbiAgICBpZDogY2xpcFBhdGhJZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIHg6IC1oYWxmU3Ryb2tlV2lkdGgsXG4gICAgeTogaGFsZlN0cm9rZVdpZHRoICogKGlzQ3VzdG9tU2hhcGUgPyAtMSA6IDEpLFxuICAgIHdpZHRoOiB3aWR0aCArIGNvbXB1dGVkU3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aFxuICB9KSkpO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9tYXAkZ2V0LmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKGRhdGEpKTtcbiAgICB9LFxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgbWFwLnNldChldmVudCwgWy4uLihtYXAuZ2V0KGV2ZW50KSB8fCBbXSksIGxpc3RlbmVyXSk7XG4gICAgfSxcbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgbWFwLnNldChldmVudCwgKChfbWFwJGdldDIgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5maWx0ZXIobCA9PiBsICE9PSBsaXN0ZW5lcikpIHx8IFtdKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IEZsb2F0aW5nTm9kZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IEZsb2F0aW5nVHJlZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnQgbm9kZSBpZCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBpZiBhdmFpbGFibGUuXG4gKiBSZXR1cm5zIGBudWxsYCBmb3IgdG9wLWxldmVsIGZsb2F0aW5nIGVsZW1lbnRzLlxuICovXG5jb25zdCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCA9ICgpID0+IHtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0O1xuICByZXR1cm4gKChfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdOb2RlQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfUmVhY3QkdXNlQ29udGV4dC5pZCkgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVhcmVzdCBmbG9hdGluZyB0cmVlIGNvbnRleHQsIGlmIGF2YWlsYWJsZS5cbiAqL1xuY29uc3QgdXNlRmxvYXRpbmdUcmVlID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ1RyZWVDb250ZXh0KTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBub2RlIGludG8gdGhlIGBGbG9hdGluZ1RyZWVgLCByZXR1cm5pbmcgaXRzIGlkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ05vZGVJZChjdXN0b21QYXJlbnRJZCkge1xuICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcmVhY3RQYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gY3VzdG9tUGFyZW50SWQgfHwgcmVhY3RQYXJlbnRJZDtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfTtcbiAgICB0cmVlID09IG51bGwgfHwgdHJlZS5hZGROb2RlKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0cmVlID09IG51bGwgfHwgdHJlZS5yZW1vdmVOb2RlKG5vZGUpO1xuICAgIH07XG4gIH0sIFt0cmVlLCBpZCwgcGFyZW50SWRdKTtcbiAgcmV0dXJuIGlkO1xufVxuLyoqXG4gKiBQcm92aWRlcyBwYXJlbnQgbm9kZSBjb250ZXh0IGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nTm9kZShwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ05vZGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9KSwgW2lkLCBwYXJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHdoZW4gdGhleSBhcmUgbm90IGNoaWxkcmVuIG9mXG4gKiBlYWNoIG90aGVyIG9uIHRoZSBET00uXG4gKiBUaGlzIGlzIG5vdCBuZWNlc3NhcnkgaW4gYWxsIGNhc2VzLCBleGNlcHQgd2hlbiB0aGVyZSBtdXN0IGJlIGV4cGxpY2l0IGNvbW11bmljYXRpb24gYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkIGZsb2F0aW5nIGVsZW1lbnRzLiBJdCBpcyBuZWNlc3NhcnkgZm9yOlxuICogLSBUaGUgYGJ1YmJsZXNgIG9wdGlvbiBpbiB0aGUgYHVzZURpc21pc3MoKWAgSG9va1xuICogLSBOZXN0ZWQgdmlydHVhbCBsaXN0IG5hdmlnYXRpb25cbiAqIC0gTmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgZWFjaCBvcGVuIG9uIGhvdmVyXG4gKiAtIEN1c3RvbSBjb21tdW5pY2F0aW9uIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCBmbG9hdGluZyBlbGVtZW50c1xuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1RyZWUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgbm9kZXNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCBhZGROb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IFsuLi5ub2Rlc1JlZi5jdXJyZW50LCBub2RlXTtcbiAgfSwgW10pO1xuICBjb25zdCByZW1vdmVOb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IG5vZGVzUmVmLmN1cnJlbnQuZmlsdGVyKG4gPT4gbiAhPT0gbm9kZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZXZlbnRzID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpWzBdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdUcmVlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBub2Rlc1JlZixcbiAgICAgIGFkZE5vZGUsXG4gICAgICByZW1vdmVOb2RlLFxuICAgICAgZXZlbnRzXG4gICAgfSksIFthZGROb2RlLCByZW1vdmVOb2RlLCBldmVudHNdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZShuYW1lKSB7XG4gIHJldHVybiBcImRhdGEtZmxvYXRpbmctdWktXCIgKyBuYW1lO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBzYWZlUG9seWdvbklkZW50aWZpZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdzYWZlLXBvbHlnb24nKTtcbmZ1bmN0aW9uIGdldERlbGF5KHZhbHVlLCBwcm9wLCBwb2ludGVyVHlwZSkge1xuICBpZiAocG9pbnRlclR5cGUgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZVtwcm9wXTtcbn1cbi8qKlxuICogT3BlbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hpbGUgaG92ZXJpbmcgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIGxpa2VcbiAqIENTUyBgOmhvdmVyYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlclxuICovXG5mdW5jdGlvbiB1c2VIb3Zlcihjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZXZlbnRzLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZGVsYXkgPSAwLFxuICAgIGhhbmRsZUNsb3NlID0gbnVsbCxcbiAgICBtb3VzZU9ubHkgPSBmYWxzZSxcbiAgICByZXN0TXMgPSAwLFxuICAgIG1vdmUgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IGhhbmRsZUNsb3NlUmVmID0gdXNlTGF0ZXN0UmVmKGhhbmRsZUNsb3NlKTtcbiAgY29uc3QgZGVsYXlSZWYgPSB1c2VMYXRlc3RSZWYoZGVsYXkpO1xuICBjb25zdCBvcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3QgaGFuZGxlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCByZXN0VGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gIGNvbnN0IGJsb2NrTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB1bmJpbmRNb3VzZU1vdmVSZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge30pO1xuICBjb25zdCByZXN0VGltZW91dFBlbmRpbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc0hvdmVyT3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRvcGVuO1xuICAgIGNvbnN0IHR5cGUgPSAoX2RhdGFSZWYkY3VycmVudCRvcGVuID0gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkb3Blbi50eXBlO1xuICAgIHJldHVybiAodHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS5pbmNsdWRlcygnbW91c2UnKSkgJiYgdHlwZSAhPT0gJ21vdXNlZG93bic7XG4gIH0sIFtkYXRhUmVmXSk7XG5cbiAgLy8gV2hlbiBjbG9zaW5nIGJlZm9yZSBvcGVuaW5nLCBjbGVhciB0aGUgZGVsYXkgdGltZW91dHMgdG8gY2FuY2VsIGl0XG4gIC8vIGZyb20gc2hvd2luZy5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgb3BlblxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAoIW9wZW4pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJlc3RUaW1lb3V0UGVuZGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBldmVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWhhbmRsZUNsb3NlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbkxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNIb3Zlck9wZW4oKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50KGVsZW1lbnRzLmZsb2F0aW5nKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGh0bWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTGVhdmUpO1xuICAgIH07XG4gIH0sIFtlbGVtZW50cy5mbG9hdGluZywgb3Blbiwgb25PcGVuQ2hhbmdlLCBlbmFibGVkLCBoYW5kbGVDbG9zZVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgY29uc3QgY2xvc2VXaXRoRGVsYXkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIHJ1bkVsc2VCcmFuY2gsIHJlYXNvbikge1xuICAgIGlmIChydW5FbHNlQnJhbmNoID09PSB2b2lkIDApIHtcbiAgICAgIHJ1bkVsc2VCcmFuY2ggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHtcbiAgICAgIHJlYXNvbiA9ICdob3Zlcic7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnY2xvc2UnLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2xvc2VEZWxheSAmJiAhaGFuZGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsIHJlYXNvbiksIGNsb3NlRGVsYXkpO1xuICAgIH0gZWxzZSBpZiAocnVuRWxzZUJyYW5jaCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCByZWFzb24pO1xuICAgIH1cbiAgfSwgW2RlbGF5UmVmLCBvbk9wZW5DaGFuZ2VdKTtcbiAgY29uc3QgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQoKTtcbiAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gIH0pO1xuICBjb25zdCBjbGVhclBvaW50ZXJFdmVudHMgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgaWYgKHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpLmJvZHk7XG4gICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIGJvZHkucmVtb3ZlQXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllcik7XG4gICAgICBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGlzQ2xpY2tMaWtlT3BlbkV2ZW50ID0gdXNlRWZmZWN0RXZlbnQoKCkgPT4ge1xuICAgIHJldHVybiBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUpIDogZmFsc2U7XG4gIH0pO1xuXG4gIC8vIFJlZ2lzdGVyaW5nIHRoZSBtb3VzZSBldmVudHMgb24gdGhlIHJlZmVyZW5jZSBkaXJlY3RseSB0byBieXBhc3MgUmVhY3Qnc1xuICAvLyBkZWxlZ2F0aW9uIHN5c3RlbS4gSWYgdGhlIGN1cnNvciB3YXMgb24gYSBkaXNhYmxlZCBlbGVtZW50IGFuZCB0aGVuIGVudGVyZWRcbiAgLy8gdGhlIHJlZmVyZW5jZSAobm8gZ2FwKSwgYG1vdXNlZW50ZXJgIGRvZXNuJ3QgZmlyZSBpbiB0aGUgZGVsZWdhdGlvbiBzeXN0ZW0uXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25Nb3VzZUVudGVyKGV2ZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChtb3VzZU9ubHkgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCkgfHwgcmVzdE1zID4gMCAmJiAhZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG9wZW5EZWxheSkge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFvcGVuUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIGlmICghb3Blbikge1xuICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSByZXR1cm47XG4gICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgcmVzdFRpbWVvdXRQZW5kaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChoYW5kbGVDbG9zZVJlZi5jdXJyZW50ICYmIGRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gUHJldmVudCBjbGVhcmluZyBgb25TY3JvbGxNb3VzZUxlYXZlYCB0aW1lb3V0LlxuICAgICAgICBpZiAoIW9wZW4pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgICAuLi5kYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0LFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAoIWlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQsIHRydWUsICdzYWZlLXBvbHlnb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlclJlZi5jdXJyZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBpbnRlcmFjdGl2aXR5IHdpdGhvdXQgYHNhZmVQb2x5Z29uYCBvbiB0b3VjaCBkZXZpY2VzLiBXaXRoIGFcbiAgICAgIC8vIHBvaW50ZXIsIGEgc2hvcnQgY2xvc2UgZGVsYXkgaXMgYW4gYWx0ZXJuYXRpdmUsIHNvIGl0IHNob3VsZCB3b3JrXG4gICAgICAvLyBjb25zaXN0ZW50bHkuXG4gICAgICBjb25zdCBzaG91bGRDbG9zZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcgPyAhY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNsb3NlcyBhZnRlciBzY3JvbGxpbmcgZXZlbiBpZiB0aGUgcG9pbnRlclxuICAgIC8vIGRpZCBub3QgbW92ZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvZGlzY3Vzc2lvbnMvMTY5MlxuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHJldHVybjtcbiAgICAgIGlmICghZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCkgcmV0dXJuO1xuICAgICAgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCA9PSBudWxsIHx8IGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQoe1xuICAgICAgICAuLi5kYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0LFxuICAgICAgICB0cmVlLFxuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgaWYgKCFpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KShldmVudCk7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSkge1xuICAgICAgdmFyIF9lbGVtZW50cyRmbG9hdGluZztcbiAgICAgIGNvbnN0IHJlZiA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZTtcbiAgICAgIG9wZW4gJiYgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgKF9lbGVtZW50cyRmbG9hdGluZyA9IGVsZW1lbnRzLmZsb2F0aW5nKSA9PSBudWxsIHx8IF9lbGVtZW50cyRmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIG1vdmUgJiYgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHZhciBfZWxlbWVudHMkZmxvYXRpbmcyO1xuICAgICAgICBvcGVuICYmIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgKF9lbGVtZW50cyRmbG9hdGluZzIgPSBlbGVtZW50cy5mbG9hdGluZykgPT0gbnVsbCB8fCBfZWxlbWVudHMkZmxvYXRpbmcyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgICBtb3ZlICYmIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZWxlbWVudHMsIGVuYWJsZWQsIGNvbnRleHQsIG1vdXNlT25seSwgcmVzdE1zLCBtb3ZlLCBjbG9zZVdpdGhEZWxheSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50cywgb25PcGVuQ2hhbmdlLCBvcGVuLCBvcGVuUmVmLCB0cmVlLCBkZWxheVJlZiwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWYsIGlzQ2xpY2tMaWtlT3BlbkV2ZW50XSk7XG5cbiAgLy8gQmxvY2sgcG9pbnRlci1ldmVudHMgb2YgZXZlcnkgZWxlbWVudCBvdGhlciB0aGFuIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nXG4gIC8vIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW4gYW5kIGhhcyBhIGBoYW5kbGVDbG9zZWAgaGFuZGxlci4gQWxzb1xuICAvLyBoYW5kbGVzIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzIyXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX2hhbmRsZUNsb3NlUmVmJGN1cnJlO1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmIChvcGVuICYmIChfaGFuZGxlQ2xvc2VSZWYkY3VycmUgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSAhPSBudWxsICYmIF9oYW5kbGVDbG9zZVJlZiRjdXJyZS5fX29wdGlvbnMuYmxvY2tQb2ludGVyRXZlbnRzICYmIGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGZsb2F0aW5nRWwgPSBlbGVtZW50cy5mbG9hdGluZztcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICAgIHZhciBfdHJlZSRub2Rlc1JlZiRjdXJyZW47XG4gICAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChlbGVtZW50cy5mbG9hdGluZykuYm9keTtcbiAgICAgICAgYm9keS5zZXRBdHRyaWJ1dGUoc2FmZVBvbHlnb25JZGVudGlmaWVyLCAnJyk7XG4gICAgICAgIGNvbnN0IHJlZiA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZTtcbiAgICAgICAgY29uc3QgcGFyZW50RmxvYXRpbmcgPSB0cmVlID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5lbGVtZW50cy5mbG9hdGluZztcbiAgICAgICAgaWYgKHBhcmVudEZsb2F0aW5nKSB7XG4gICAgICAgICAgcGFyZW50RmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgcmVmLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG4gICAgICAgIGZsb2F0aW5nRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIGZsb2F0aW5nRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHBhcmVudElkLCBlbGVtZW50cywgdHJlZSwgaGFuZGxlQ2xvc2VSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICByZXN0VGltZW91dFBlbmRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgIH1cbiAgfSwgW29wZW4sIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzZXRQb2ludGVyUmVmKGV2ZW50KSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyUmVmLFxuICAgICAgb25Qb2ludGVyRW50ZXI6IHNldFBvaW50ZXJSZWYsXG4gICAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoKSB7XG4gICAgICAgICAgaWYgKCFibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ICYmICFvcGVuUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBuYXRpdmVFdmVudCwgJ2hvdmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb3VzZU9ubHkgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4gfHwgcmVzdE1zID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWdub3JlIGluc2lnbmlmaWNhbnQgbW92ZW1lbnRzIHRvIGFjY291bnQgZm9yIHRyZW1vcnMuXG4gICAgICAgIGlmIChyZXN0VGltZW91dFBlbmRpbmdSZWYuY3VycmVudCAmJiBldmVudC5tb3ZlbWVudFggKiogMiArIGV2ZW50Lm1vdmVtZW50WSAqKiAyIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdFRpbWVvdXRQZW5kaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dChoYW5kbGVNb3VzZU1vdmUsIHJlc3RNcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbbW91c2VPbmx5LCBvbk9wZW5DaGFuZ2UsIG9wZW4sIG9wZW5SZWYsIHJlc3RNc10pO1xuICBjb25zdCBmbG9hdGluZyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKCFpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50Lm5hdGl2ZUV2ZW50LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgW2Nsb3NlV2l0aERlbGF5LCBpc0NsaWNrTGlrZU9wZW5FdmVudF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2UsIGZsb2F0aW5nXSk7XG59XG5cbmNvbnN0IE5PT1AgPSAoKSA9PiB7fTtcbmNvbnN0IEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGRlbGF5OiAwLFxuICBpbml0aWFsRGVsYXk6IDAsXG4gIHRpbWVvdXRNczogMCxcbiAgY3VycmVudElkOiBudWxsLFxuICBzZXRDdXJyZW50SWQ6IE5PT1AsXG4gIHNldFN0YXRlOiBOT09QLFxuICBpc0luc3RhbnRQaGFzZTogZmFsc2Vcbn0pO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2UgdGhlIHJldHVybiB2YWx1ZSBvZiBgdXNlRGVsYXlHcm91cCgpYCBpbnN0ZWFkLlxuICovXG5jb25zdCB1c2VEZWxheUdyb3VwQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCk7XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgZ3JvdXAgb2YgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBzaG91bGQgc2hhcmUgYVxuICogYGRlbGF5YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0RlbGF5R3JvdXBcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdEZWxheUdyb3VwKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMgPSAwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VSZWR1Y2VyKChwcmV2LCBuZXh0KSA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ubmV4dFxuICB9KSwge1xuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyxcbiAgICBpbml0aWFsRGVsYXk6IGRlbGF5LFxuICAgIGN1cnJlbnRJZDogbnVsbCxcbiAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxDdXJyZW50SWRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldEN1cnJlbnRJZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGN1cnJlbnRJZCA9PiB7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgY3VycmVudElkXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50SWQpIHtcbiAgICAgIGlmIChpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gc3RhdGUuY3VycmVudElkO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUuaXNJbnN0YW50UGhhc2UpIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuaXNJbnN0YW50UGhhc2UpIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbc3RhdGUuY3VycmVudElkLCBzdGF0ZS5pc0luc3RhbnRQaGFzZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgc2V0Q3VycmVudElkXG4gICAgfSksIFtzdGF0ZSwgc2V0Q3VycmVudElkXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBFbmFibGVzIGdyb3VwaW5nIHdoZW4gY2FsbGVkIGluc2lkZSBhIGNvbXBvbmVudCB0aGF0J3MgYSBjaGlsZCBvZiBhXG4gKiBgRmxvYXRpbmdEZWxheUdyb3VwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0RlbGF5R3JvdXBcbiAqL1xuZnVuY3Rpb24gdXNlRGVsYXlHcm91cChjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGZsb2F0aW5nSWRcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBpZDogb3B0aW9uSWQsXG4gICAgZW5hYmxlZCA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlkID0gb3B0aW9uSWQgIT0gbnVsbCA/IG9wdGlvbklkIDogZmxvYXRpbmdJZDtcbiAgY29uc3QgZ3JvdXBDb250ZXh0ID0gdXNlRGVsYXlHcm91cENvbnRleHQoKTtcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRJZCxcbiAgICBzZXRDdXJyZW50SWQsXG4gICAgaW5pdGlhbERlbGF5LFxuICAgIHNldFN0YXRlLFxuICAgIHRpbWVvdXRNc1xuICB9ID0gZ3JvdXBDb250ZXh0O1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKCFjdXJyZW50SWQpIHJldHVybjtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBkZWxheToge1xuICAgICAgICBvcGVuOiAxLFxuICAgICAgICBjbG9zZTogZ2V0RGVsYXkoaW5pdGlhbERlbGF5LCAnY2xvc2UnKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjdXJyZW50SWQgIT09IGlkKSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIGlkLCBvbk9wZW5DaGFuZ2UsIHNldFN0YXRlLCBjdXJyZW50SWQsIGluaXRpYWxEZWxheV0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gdW5zZXQoKSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBkZWxheTogaW5pdGlhbERlbGF5LFxuICAgICAgICBjdXJyZW50SWQ6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWN1cnJlbnRJZCkgcmV0dXJuO1xuICAgIGlmICghb3BlbiAmJiBjdXJyZW50SWQgPT09IGlkKSB7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh1bnNldCwgdGltZW91dE1zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB1bnNldCgpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHNldFN0YXRlLCBjdXJyZW50SWQsIGlkLCBvbk9wZW5DaGFuZ2UsIGluaXRpYWxEZWxheSwgdGltZW91dE1zXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoc2V0Q3VycmVudElkID09PSBOT09QIHx8ICFvcGVuKSByZXR1cm47XG4gICAgc2V0Q3VycmVudElkKGlkKTtcbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHNldEN1cnJlbnRJZCwgaWRdKTtcbiAgcmV0dXJuIGdyb3VwQ29udGV4dDtcbn1cblxubGV0IHJhZklkID0gMDtcbmZ1bmN0aW9uIGVucXVldWVGb2N1cyhlbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2UsXG4gICAgY2FuY2VsUHJldmlvdXMgPSB0cnVlLFxuICAgIHN5bmMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY2FuY2VsUHJldmlvdXMgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICBjb25zdCBleGVjID0gKCkgPT4gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLmZvY3VzKHtcbiAgICBwcmV2ZW50U2Nyb2xsXG4gIH0pO1xuICBpZiAoc3luYykge1xuICAgIGV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShleGVjKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmNlc3RvcnMobm9kZXMsIGlkKSB7XG4gIHZhciBfbm9kZXMkZmluZDtcbiAgbGV0IGFsbEFuY2VzdG9ycyA9IFtdO1xuICBsZXQgY3VycmVudFBhcmVudElkID0gKF9ub2RlcyRmaW5kID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLnBhcmVudElkO1xuICB3aGlsZSAoY3VycmVudFBhcmVudElkKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gY3VycmVudFBhcmVudElkKTtcbiAgICBjdXJyZW50UGFyZW50SWQgPSBjdXJyZW50Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudE5vZGUucGFyZW50SWQ7XG4gICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICBhbGxBbmNlc3RvcnMgPSBhbGxBbmNlc3RvcnMuY29uY2F0KGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbEFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZXMsIGlkKSB7XG4gIGxldCBhbGxDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICB2YXIgX25vZGUkY29udGV4dDtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnRJZCA9PT0gaWQgJiYgKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5vcGVuKTtcbiAgfSk7XG4gIGxldCBjdXJyZW50Q2hpbGRyZW4gPSBhbGxDaGlsZHJlbjtcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjdXJyZW50Q2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICB2YXIgX2N1cnJlbnRDaGlsZHJlbjtcbiAgICAgIHJldHVybiAoX2N1cnJlbnRDaGlsZHJlbiA9IGN1cnJlbnRDaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50Q2hpbGRyZW4uc29tZShuID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQyO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnRJZCA9PT0gbi5pZCAmJiAoKF9ub2RlJGNvbnRleHQyID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDIub3Blbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhbGxDaGlsZHJlbiA9IGFsbENoaWxkcmVuLmNvbmNhdChjdXJyZW50Q2hpbGRyZW4pO1xuICB9XG4gIHJldHVybiBhbGxDaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGdldERlZXBlc3ROb2RlKG5vZGVzLCBpZCkge1xuICBsZXQgZGVlcGVzdE5vZGVJZDtcbiAgbGV0IG1heERlcHRoID0gLTE7XG4gIGZ1bmN0aW9uIGZpbmREZWVwZXN0KG5vZGVJZCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPiBtYXhEZXB0aCkge1xuICAgICAgZGVlcGVzdE5vZGVJZCA9IG5vZGVJZDtcbiAgICAgIG1heERlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4obm9kZXMsIG5vZGVJZCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBmaW5kRGVlcGVzdChjaGlsZC5pZCwgZGVwdGggKyAxKTtcbiAgICB9KTtcbiAgfVxuICBmaW5kRGVlcGVzdChpZCwgMCk7XG4gIHJldHVybiBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gZGVlcGVzdE5vZGVJZCk7XG59XG5cbi8vIE1vZGlmaWVkIHRvIGFkZCBjb25kaXRpb25hbCBgYXJpYS1oaWRkZW5gIHN1cHBvcnQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGhlS2FzaGV5L2FyaWEtaGlkZGVuL2Jsb2IvOTIyMGM4ZjRhNGZkMzVmNjNiZWU1NTEwYTlmNDFhMzcyNjQzODJkNC9zcmMvaW5kZXgudHNcbmxldCBjb3VudGVyTWFwID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5sZXQgdW5jb250cm9sbGVkRWxlbWVudHNTZXQgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtTZXQoKTtcbmxldCBtYXJrZXJNYXAgPSB7fTtcbmxldCBsb2NrQ291bnQkMSA9IDA7XG5jb25zdCBzdXBwb3J0c0luZXJ0ID0gKCkgPT4gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnaW5lcnQnIGluIEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbmNvbnN0IHVud3JhcEhvc3QgPSBub2RlID0+IG5vZGUgJiYgKG5vZGUuaG9zdCB8fCB1bndyYXBIb3N0KG5vZGUucGFyZW50Tm9kZSkpO1xuY29uc3QgY29ycmVjdEVsZW1lbnRzID0gKHBhcmVudCwgdGFyZ2V0cykgPT4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBjb3JyZWN0ZWRUYXJnZXQgPSB1bndyYXBIb3N0KHRhcmdldCk7XG4gIGlmIChwYXJlbnQuY29udGFpbnMoY29ycmVjdGVkVGFyZ2V0KSkge1xuICAgIHJldHVybiBjb3JyZWN0ZWRUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVUb090aGVycyh1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMsIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KSB7XG4gIGNvbnN0IG1hcmtlck5hbWUgPSAnZGF0YS1mbG9hdGluZy11aS1pbmVydCc7XG4gIGNvbnN0IGNvbnRyb2xBdHRyaWJ1dGUgPSBpbmVydCA/ICdpbmVydCcgOiBhcmlhSGlkZGVuID8gJ2FyaWEtaGlkZGVuJyA6IG51bGw7XG4gIGNvbnN0IGF2b2lkRWxlbWVudHMgPSBjb3JyZWN0RWxlbWVudHMoYm9keSwgdW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgZWxlbWVudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGVsZW1lbnRzVG9TdG9wID0gbmV3IFNldChhdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgaGlkZGVuRWxlbWVudHMgPSBbXTtcbiAgaWYgKCFtYXJrZXJNYXBbbWFya2VyTmFtZV0pIHtcbiAgICBtYXJrZXJNYXBbbWFya2VyTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGNvbnN0IG1hcmtlckNvdW50ZXIgPSBtYXJrZXJNYXBbbWFya2VyTmFtZV07XG4gIGF2b2lkRWxlbWVudHMuZm9yRWFjaChrZWVwKTtcbiAgZGVlcChib2R5KTtcbiAgZWxlbWVudHNUb0tlZXAuY2xlYXIoKTtcbiAgZnVuY3Rpb24ga2VlcChlbCkge1xuICAgIGlmICghZWwgfHwgZWxlbWVudHNUb0tlZXAuaGFzKGVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50c1RvS2VlcC5hZGQoZWwpO1xuICAgIGVsLnBhcmVudE5vZGUgJiYga2VlcChlbC5wYXJlbnROb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWVwKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50IHx8IGVsZW1lbnRzVG9TdG9wLmhhcyhwYXJlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFtdLmZvckVhY2guY2FsbChwYXJlbnQuY2hpbGRyZW4sIG5vZGUgPT4ge1xuICAgICAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnc2NyaXB0JykgcmV0dXJuO1xuICAgICAgaWYgKGVsZW1lbnRzVG9LZWVwLmhhcyhub2RlKSkge1xuICAgICAgICBkZWVwKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGNvbnRyb2xBdHRyaWJ1dGUgPyBub2RlLmdldEF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGFscmVhZHlIaWRkZW4gPSBhdHRyICE9PSBudWxsICYmIGF0dHIgIT09ICdmYWxzZSc7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyTWFwLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgY291bnRlck1hcC5zZXQobm9kZSwgY291bnRlclZhbHVlKTtcbiAgICAgICAgbWFya2VyQ291bnRlci5zZXQobm9kZSwgbWFya2VyVmFsdWUpO1xuICAgICAgICBoaWRkZW5FbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoY291bnRlclZhbHVlID09PSAxICYmIGFscmVhZHlIaWRkZW4pIHtcbiAgICAgICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlclZhbHVlID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobWFya2VyTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeUhpZGRlbiAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSwgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxvY2tDb3VudCQxKys7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaGlkZGVuRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyTWFwLmdldChlbGVtZW50KSB8fCAwKSAtIDE7XG4gICAgICBjb25zdCBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChlbGVtZW50KSB8fCAwKSAtIDE7XG4gICAgICBjb3VudGVyTWFwLnNldChlbGVtZW50LCBjb3VudGVyVmFsdWUpO1xuICAgICAgbWFya2VyQ291bnRlci5zZXQoZWxlbWVudCwgbWFya2VyVmFsdWUpO1xuICAgICAgaWYgKCFjb3VudGVyVmFsdWUpIHtcbiAgICAgICAgaWYgKCF1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5oYXMoZWxlbWVudCkgJiYgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmRlbGV0ZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghbWFya2VyVmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobWFya2VyTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9ja0NvdW50JDEtLTtcbiAgICBpZiAoIWxvY2tDb3VudCQxKSB7XG4gICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvdW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgbWFya2VyTWFwID0ge307XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWFya090aGVycyhhdm9pZEVsZW1lbnRzLCBhcmlhSGlkZGVuLCBpbmVydCkge1xuICBpZiAoYXJpYUhpZGRlbiA9PT0gdm9pZCAwKSB7XG4gICAgYXJpYUhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGlmIChpbmVydCA9PT0gdm9pZCAwKSB7XG4gICAgaW5lcnQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoYXZvaWRFbGVtZW50c1swXSkuYm9keTtcbiAgcmV0dXJuIGFwcGx5QXR0cmlidXRlVG9PdGhlcnMoYXZvaWRFbGVtZW50cy5jb25jYXQoQXJyYXkuZnJvbShib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ1thcmlhLWxpdmVdJykpKSwgYm9keSwgYXJpYUhpZGRlbiwgaW5lcnQpO1xufVxuXG5jb25zdCBnZXRUYWJiYWJsZU9wdGlvbnMgPSAoKSA9PiAoe1xuICBnZXRTaGFkb3dSb290OiB0cnVlLFxuICBkaXNwbGF5Q2hlY2s6XG4gIC8vIEpTRE9NIGRvZXMgbm90IHN1cHBvcnQgdGhlIGB0YWJiYWJsZWAgbGlicmFyeS4gVG8gc29sdmUgdGhpcyB3ZSBjYW5cbiAgLy8gY2hlY2sgaWYgYFJlc2l6ZU9ic2VydmVyYCBpcyBhIHJlYWwgZnVuY3Rpb24gKG5vdCBwb2x5ZmlsbGVkKSwgd2hpY2hcbiAgLy8gZGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBKU0RPTS1saWtlLlxuICB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgUmVzaXplT2JzZXJ2ZXIudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpID8gJ2Z1bGwnIDogJ25vbmUnXG59KTtcbmZ1bmN0aW9uIGdldFRhYmJhYmxlSW4oY29udGFpbmVyLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgYWxsVGFiYmFibGUgPSB0YWJiYWJsZShjb250YWluZXIsIGdldFRhYmJhYmxlT3B0aW9ucygpKTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgYWxsVGFiYmFibGUucmV2ZXJzZSgpO1xuICB9XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gYWxsVGFiYmFibGUuaW5kZXhPZihhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGNvbnRhaW5lcikpKTtcbiAgY29uc3QgbmV4dFRhYmJhYmxlRWxlbWVudHMgPSBhbGxUYWJiYWJsZS5zbGljZShhY3RpdmVJbmRleCArIDEpO1xuICByZXR1cm4gbmV4dFRhYmJhYmxlRWxlbWVudHNbMF07XG59XG5mdW5jdGlvbiBnZXROZXh0VGFiYmFibGUoKSB7XG4gIHJldHVybiBnZXRUYWJiYWJsZUluKGRvY3VtZW50LmJvZHksICduZXh0Jyk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1RhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAncHJldicpO1xufVxuZnVuY3Rpb24gaXNPdXRzaWRlRXZlbnQoZXZlbnQsIGNvbnRhaW5lcikge1xuICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICByZXR1cm4gIXJlbGF0ZWRUYXJnZXQgfHwgIWNvbnRhaW5zKGNvbnRhaW5lckVsZW1lbnQsIHJlbGF0ZWRUYXJnZXQpO1xufVxuZnVuY3Rpb24gZGlzYWJsZUZvY3VzSW5zaWRlKGNvbnRhaW5lcikge1xuICBjb25zdCB0YWJiYWJsZUVsZW1lbnRzID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIHRhYmJhYmxlRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAnJztcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGFiaW5kZXhdJyk7XG4gIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgdGFiaW5kZXggPSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC50YWJpbmRleDtcbiAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gU2VlIERpZWdvIEhheidzIFNhbmRib3ggZm9yIG1ha2luZyB0aGlzIGxvZ2ljIHdvcmsgd2VsbCBvbiBTYWZhcmkvaU9TOlxuLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvRm9jdXNUcmFwLnRzeFxuXG5jb25zdCBISURERU5fU1RZTEVTID0ge1xuICBib3JkZXI6IDAsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFkZGluZzogMCxcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzFweCcsXG4gIHRvcDogMCxcbiAgbGVmdDogMFxufTtcbmxldCB0aW1lb3V0SWQ7XG5mdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50T25UYWIoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICBldmVudC50YXJnZXQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH1cbn1cbmNvbnN0IEZvY3VzR3VhcmQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGb2N1c0d1YXJkKHByb3BzLCByZWYpIHtcbiAgY29uc3QgW3JvbGUsIHNldFJvbGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICAvLyBVbmxpa2Ugb3RoZXIgc2NyZWVuIHJlYWRlcnMgc3VjaCBhcyBOVkRBIGFuZCBKQVdTLCB0aGUgdmlydHVhbCBjdXJzb3JcbiAgICAgIC8vIG9uIFZvaWNlT3ZlciBkb2VzIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQsIHNvIHdlIGNhbiB1c2UgdGhlIGZvY3VzXG4gICAgICAvLyB0cmFwIGVsZW1lbnQuIE9uIFNhZmFyaSwgb25seSBidXR0b25zIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQuXG4gICAgICAvLyBOQjogXCJncm91cFwiIHJvbGUgaW4gdGhlIFNhbmRib3ggbm8gbG9uZ2VyIGFwcGVhcnMgdG8gd29yaywgbXVzdCBiZSBhXG4gICAgICAvLyBidXR0b24gcm9sZS5cbiAgICAgIHNldFJvbGUoJ2J1dHRvbicpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2V0QWN0aXZlRWxlbWVudE9uVGFiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCByZXN0UHJvcHMgPSB7XG4gICAgcmVmLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIC8vIFJvbGUgaXMgb25seSBmb3IgVm9pY2VPdmVyXG4gICAgcm9sZSxcbiAgICAnYXJpYS1oaWRkZW4nOiByb2xlID8gdW5kZWZpbmVkIDogdHJ1ZSxcbiAgICBbY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpXTogJycsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHJlc3RQcm9wcykpO1xufSk7XG5cbmNvbnN0IFBvcnRhbENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IGF0dHIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKTtcbi8qKlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsI3VzZWZsb2F0aW5ncG9ydGFsbm9kZVxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ1BvcnRhbE5vZGUocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICByb290XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBbcG9ydGFsTm9kZSwgc2V0UG9ydGFsTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcG9ydGFsTm9kZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxOb2RlID09IG51bGwgfHwgcG9ydGFsTm9kZS5yZW1vdmUoKTtcbiAgICAgIC8vIEFsbG93IHRoZSBzdWJzZXF1ZW50IGxheW91dCBlZmZlY3RzIHRvIGNyZWF0ZSBhIG5ldyBub2RlIG9uIHVwZGF0ZXMuXG4gICAgICAvLyBUaGUgcG9ydGFsIG5vZGUgd2lsbCBzdGlsbCBiZSBjbGVhbmVkIHVwIG9uIHVubW91bnQuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI0NTRcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICAvLyBXYWl0IGZvciB0aGUgdW5pcXVlSWQgdG8gYmUgZ2VuZXJhdGVkIGJlZm9yZSBjcmVhdGluZyB0aGUgcG9ydGFsIG5vZGUgaW5cbiAgICAvLyBSZWFjdCA8MTggKHVzaW5nIGB1c2VGbG9hdGluZ0lkYCBpbnN0ZWFkIG9mIHRoZSBuYXRpdmUgYHVzZUlkYCkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNzc4XG4gICAgaWYgKCF1bmlxdWVJZCkgcmV0dXJuO1xuICAgIGlmIChwb3J0YWxOb2RlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBleGlzdGluZ0lkUm9vdCA9IGlkID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogbnVsbDtcbiAgICBpZiAoIWV4aXN0aW5nSWRSb290KSByZXR1cm47XG4gICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgZXhpc3RpbmdJZFJvb3QuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gc3ViUm9vdDtcbiAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICB9LCBbaWQsIHVuaXF1ZUlkXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICAvLyBXYWl0IGZvciB0aGUgcm9vdCB0byBleGlzdCBiZWZvcmUgY3JlYXRpbmcgdGhlIHBvcnRhbCBub2RlLiBUaGUgcm9vdCBtdXN0XG4gICAgLy8gYmUgc3RvcmVkIGluIHN0YXRlLCBub3QgYSByZWYsIGZvciB0aGlzIHRvIHdvcmsgcmVhY3RpdmVseS5cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmICghdW5pcXVlSWQpIHJldHVybjtcbiAgICBpZiAocG9ydGFsTm9kZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbGV0IGNvbnRhaW5lciA9IHJvb3QgfHwgKHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSk7XG4gICAgaWYgKGNvbnRhaW5lciAmJiAhaXNFbGVtZW50KGNvbnRhaW5lcikpIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgIGxldCBpZFdyYXBwZXIgPSBudWxsO1xuICAgIGlmIChpZCkge1xuICAgICAgaWRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZFdyYXBwZXIuaWQgPSBpZDtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpZFdyYXBwZXIpO1xuICAgIH1cbiAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICBjb250YWluZXIgPSBpZFdyYXBwZXIgfHwgY29udGFpbmVyO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBzdWJSb290O1xuICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gIH0sIFtpZCwgcm9vdCwgdW5pcXVlSWQsIHBvcnRhbENvbnRleHRdKTtcbiAgcmV0dXJuIHBvcnRhbE5vZGU7XG59XG4vKipcbiAqIFBvcnRhbHMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW50byBhIGdpdmVuIGNvbnRhaW5lciBlbGVtZW50IOKAlCBieSBkZWZhdWx0LFxuICogb3V0c2lkZSBvZiB0aGUgYXBwIHJvb3QgYW5kIGludG8gdGhlIGJvZHkuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2FuIGFwcGVhciBvdXRzaWRlIGFueVxuICogcG90ZW50aWFsIHBhcmVudCBjb250YWluZXJzIHRoYXQgY2F1c2UgY2xpcHBpbmcgKHN1Y2ggYXMgYG92ZXJmbG93OiBoaWRkZW5gKSxcbiAqIHdoaWxlIHJldGFpbmluZyBpdHMgbG9jYXRpb24gaW4gdGhlIFJlYWN0IHRyZWUuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdQb3J0YWxcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdQb3J0YWwocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkLFxuICAgIHJvb3QsXG4gICAgcHJlc2VydmVUYWJPcmRlciA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3J0YWxOb2RlID0gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKHtcbiAgICBpZCxcbiAgICByb290XG4gIH0pO1xuICBjb25zdCBbZm9jdXNNYW5hZ2VyU3RhdGUsIHNldEZvY3VzTWFuYWdlclN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBiZWZvcmVPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlck91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGJlZm9yZUluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG1vZGFsID0gZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm1vZGFsO1xuICBjb25zdCBvcGVuID0gZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm9wZW47XG4gIGNvbnN0IHNob3VsZFJlbmRlckd1YXJkcyA9XG4gIC8vIFRoZSBGb2N1c01hbmFnZXIgYW5kIHRoZXJlZm9yZSBmbG9hdGluZyBlbGVtZW50IGFyZSBjdXJyZW50bHkgb3Blbi9cbiAgLy8gcmVuZGVyZWQuXG4gICEhZm9jdXNNYW5hZ2VyU3RhdGUgJiZcbiAgLy8gR3VhcmRzIGFyZSBvbmx5IGZvciBub24tbW9kYWwgZm9jdXMgbWFuYWdlbWVudC5cbiAgIWZvY3VzTWFuYWdlclN0YXRlLm1vZGFsICYmXG4gIC8vIERvbid0IHJlbmRlciBpZiB1bm1vdW50IGlzIHRyYW5zaXRpb25pbmcuXG4gIGZvY3VzTWFuYWdlclN0YXRlLm9wZW4gJiYgcHJlc2VydmVUYWJPcmRlciAmJiAhIShyb290IHx8IHBvcnRhbE5vZGUpO1xuXG4gIC8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy90YWJiYWJsZS1wb3J0YWwtZjR0bmc/ZmlsZT0vc3JjL1RhYmJhYmxlUG9ydGFsLnRzeFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcG9ydGFsTm9kZSB8fCAhcHJlc2VydmVUYWJPcmRlciB8fCBtb2RhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcnRhbCBlbGVtZW50IGFyZSB0YWJiYWJsZSBvbmx5IHdoZW4gdGhlXG4gICAgLy8gcG9ydGFsIGhhcyBhbHJlYWR5IGJlZW4gZm9jdXNlZCwgZWl0aGVyIGJ5IHRhYmJpbmcgaW50byBhIGZvY3VzIHRyYXBcbiAgICAvLyBlbGVtZW50IG91dHNpZGUgb3IgdXNpbmcgdGhlIG1vdXNlLlxuICAgIGZ1bmN0aW9uIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIGlmIChwb3J0YWxOb2RlICYmIGlzT3V0c2lkZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICBjb25zdCBmb2N1c2luZyA9IGV2ZW50LnR5cGUgPT09ICdmb2N1c2luJztcbiAgICAgICAgY29uc3QgbWFuYWdlRm9jdXMgPSBmb2N1c2luZyA/IGVuYWJsZUZvY3VzSW5zaWRlIDogZGlzYWJsZUZvY3VzSW5zaWRlO1xuICAgICAgICBtYW5hZ2VGb2N1cyhwb3J0YWxOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTGlzdGVuIHRvIHRoZSBldmVudCBvbiB0aGUgY2FwdHVyZSBwaGFzZSBzbyB0aGV5IHJ1biBiZWZvcmUgdGhlIGZvY3VzXG4gICAgLy8gdHJhcCBlbGVtZW50cyBvbkZvY3VzIHByb3AgaXMgY2FsbGVkLlxuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3VzLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgICBwb3J0YWxOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgfTtcbiAgfSwgW3BvcnRhbE5vZGUsIHByZXNlcnZlVGFiT3JkZXIsIG1vZGFsXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwb3J0YWxOb2RlKSByZXR1cm47XG4gICAgaWYgKG9wZW4pIHJldHVybjtcbiAgICBlbmFibGVGb2N1c0luc2lkZShwb3J0YWxOb2RlKTtcbiAgfSwgW29wZW4sIHBvcnRhbE5vZGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcHJlc2VydmVUYWJPcmRlcixcbiAgICAgIGJlZm9yZU91dHNpZGVSZWYsXG4gICAgICBhZnRlck91dHNpZGVSZWYsXG4gICAgICBiZWZvcmVJbnNpZGVSZWYsXG4gICAgICBhZnRlckluc2lkZVJlZixcbiAgICAgIHBvcnRhbE5vZGUsXG4gICAgICBzZXRGb2N1c01hbmFnZXJTdGF0ZVxuICAgIH0pLCBbcHJlc2VydmVUYWJPcmRlciwgcG9ydGFsTm9kZV0pXG4gIH0sIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcIm91dHNpZGVcIixcbiAgICByZWY6IGJlZm9yZU91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2JlZm9yZUluc2lkZVJlZiRjdXJyO1xuICAgICAgICAoX2JlZm9yZUluc2lkZVJlZiRjdXJyID0gYmVmb3JlSW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2JlZm9yZUluc2lkZVJlZiRjdXJyLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2VGFiYmFibGUgPSBnZXRQcmV2aW91c1RhYmJhYmxlKCkgfHwgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5yZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImFyaWEtb3duc1wiOiBwb3J0YWxOb2RlLmlkLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH0pLCBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbE5vZGUpLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBhZnRlck91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2FmdGVySW5zaWRlUmVmJGN1cnJlO1xuICAgICAgICAoX2FmdGVySW5zaWRlUmVmJGN1cnJlID0gYWZ0ZXJJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYWZ0ZXJJbnNpZGVSZWYkY3VycmUuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRUYWJiYWJsZSA9IGdldE5leHRUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLmNsb3NlT25Gb2N1c091dCkgJiYgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5vbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnZm9jdXMtb3V0JykpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xufVxuY29uc3QgdXNlUG9ydGFsQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoUG9ydGFsQ29udGV4dCk7XG5cbmNvbnN0IEZPQ1VTQUJMRV9BVFRSSUJVVEUgPSAnZGF0YS1mbG9hdGluZy11aS1mb2N1c2FibGUnO1xuZnVuY3Rpb24gZ2V0RmxvYXRpbmdGb2N1c0VsZW1lbnQoZmxvYXRpbmdFbGVtZW50KSB7XG4gIGlmICghZmxvYXRpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVHJ5IHRvIGZpbmQgdGhlIGVsZW1lbnQgdGhhdCBoYXMgYHsuLi5nZXRGbG9hdGluZ1Byb3BzKCl9YCBzcHJlYWQgb24gaXQuXG4gIC8vIFRoaXMgaW5kaWNhdGVzIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIGFjdGluZyBhcyBhIHBvc2l0aW9uaW5nIHdyYXBwZXIsIGFuZFxuICAvLyBzbyBmb2N1cyBzaG91bGQgYmUgbWFuYWdlZCBvbiB0aGUgY2hpbGQgZWxlbWVudCB3aXRoIHRoZSBldmVudCBoYW5kbGVycyBhbmRcbiAgLy8gYXJpYSBwcm9wcy5cbiAgcmV0dXJuIGZsb2F0aW5nRWxlbWVudC5oYXNBdHRyaWJ1dGUoRk9DVVNBQkxFX0FUVFJJQlVURSkgPyBmbG9hdGluZ0VsZW1lbnQgOiBmbG9hdGluZ0VsZW1lbnQucXVlcnlTZWxlY3RvcihcIltcIiArIEZPQ1VTQUJMRV9BVFRSSUJVVEUgKyBcIl1cIikgfHwgZmxvYXRpbmdFbGVtZW50O1xufVxuXG5jb25zdCBMSVNUX0xJTUlUID0gMjA7XG5sZXQgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IFtdO1xuZnVuY3Rpb24gYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuZmlsdGVyKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbiAgbGV0IHRhYmJhYmxlRWwgPSBlbGVtZW50O1xuICBpZiAoIXRhYmJhYmxlRWwgfHwgZ2V0Tm9kZU5hbWUodGFiYmFibGVFbCkgPT09ICdib2R5JykgcmV0dXJuO1xuICBpZiAoIWlzVGFiYmFibGUodGFiYmFibGVFbCwgZ2V0VGFiYmFibGVPcHRpb25zKCkpKSB7XG4gICAgY29uc3QgdGFiYmFibGVDaGlsZCA9IHRhYmJhYmxlKHRhYmJhYmxlRWwsIGdldFRhYmJhYmxlT3B0aW9ucygpKVswXTtcbiAgICBpZiAodGFiYmFibGVDaGlsZCkge1xuICAgICAgdGFiYmFibGVFbCA9IHRhYmJhYmxlQ2hpbGQ7XG4gICAgfVxuICB9XG4gIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMucHVzaCh0YWJiYWJsZUVsKTtcbiAgaWYgKHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMubGVuZ3RoID4gTElTVF9MSU1JVCkge1xuICAgIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnNsaWNlKC1MSVNUX0xJTUlUKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICByZXR1cm4gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgpLnJldmVyc2UoKS5maW5kKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbn1cbmNvbnN0IFZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFZpc3VhbGx5SGlkZGVuRGlzbWlzcyhwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHJlZjogcmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSk7XG59KTtcbi8qKlxuICogUHJvdmlkZXMgZm9jdXMgbWFuYWdlbWVudCBmb3IgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdGb2N1c01hbmFnZXJcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdGb2N1c01hbmFnZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBvcmRlciA9IFsnY29udGVudCddLFxuICAgIGd1YXJkczogX2d1YXJkcyA9IHRydWUsXG4gICAgaW5pdGlhbEZvY3VzID0gMCxcbiAgICByZXR1cm5Gb2N1cyA9IHRydWUsXG4gICAgcmVzdG9yZUZvY3VzID0gZmFsc2UsXG4gICAgbW9kYWwgPSB0cnVlLFxuICAgIHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IGZhbHNlLFxuICAgIGNsb3NlT25Gb2N1c091dCA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIG5vZGVJZCxcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZXZlbnRzLFxuICAgIGRhdGFSZWYsXG4gICAgZmxvYXRpbmdJZCxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBpZ25vcmVJbml0aWFsRm9jdXMgPSB0eXBlb2YgaW5pdGlhbEZvY3VzID09PSAnbnVtYmVyJyAmJiBpbml0aWFsRm9jdXMgPCAwO1xuICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGEgY29tYm9ib3ggYW5kIGlzIHR5cGVhYmxlIChlLmcuIGlucHV0L3RleHRhcmVhKSxcbiAgLy8gdGhlcmUgYXJlIGRpZmZlcmVudCBmb2N1cyBzZW1hbnRpY3MuIFRoZSBndWFyZHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCwgYnV0XG4gIC8vIGFyaWEtaGlkZGVuIHNob3VsZCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyBzdGlsbC4gRnVydGhlciwgdGhlIHZpc3VhbGx5XG4gIC8vIGhpZGRlbiBkaXNtaXNzIGJ1dHRvbiBzaG91bGQgb25seSBhcHBlYXIgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgbm90IHRoZVxuICAvLyBzdGFydC5cbiAgY29uc3QgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID0gaXNUeXBlYWJsZUNvbWJvYm94KGRvbVJlZmVyZW5jZSkgJiYgaWdub3JlSW5pdGlhbEZvY3VzO1xuXG4gIC8vIEZvcmNlIHRoZSBndWFyZHMgdG8gYmUgcmVuZGVyZWQgaWYgdGhlIGBpbmVydGAgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gIGNvbnN0IGd1YXJkcyA9IHN1cHBvcnRzSW5lcnQoKSA/IF9ndWFyZHMgOiB0cnVlO1xuICBjb25zdCBvcmRlclJlZiA9IHVzZUxhdGVzdFJlZihvcmRlcik7XG4gIGNvbnN0IGluaXRpYWxGb2N1c1JlZiA9IHVzZUxhdGVzdFJlZihpbml0aWFsRm9jdXMpO1xuICBjb25zdCByZXR1cm5Gb2N1c1JlZiA9IHVzZUxhdGVzdFJlZihyZXR1cm5Gb2N1cyk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcG9ydGFsQ29udGV4dCA9IHVzZVBvcnRhbENvbnRleHQoKTtcbiAgY29uc3Qgc3RhcnREaXNtaXNzQnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBlbmREaXNtaXNzQnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBwcmV2ZW50UmV0dXJuRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc1BvaW50ZXJEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgdGFiYmFibGVJbmRleFJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gIGNvbnN0IGlzSW5zaWRlUG9ydGFsID0gcG9ydGFsQ29udGV4dCAhPSBudWxsO1xuICBjb25zdCBmbG9hdGluZ0ZvY3VzRWxlbWVudCA9IGdldEZsb2F0aW5nRm9jdXNFbGVtZW50KGZsb2F0aW5nKTtcbiAgY29uc3QgZ2V0VGFiYmFibGVDb250ZW50ID0gdXNlRWZmZWN0RXZlbnQoZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgICAgY29udGFpbmVyID0gZmxvYXRpbmdGb2N1c0VsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXIgPyB0YWJiYWJsZShjb250YWluZXIsIGdldFRhYmJhYmxlT3B0aW9ucygpKSA6IFtdO1xuICB9KTtcbiAgY29uc3QgZ2V0VGFiYmFibGVFbGVtZW50cyA9IHVzZUVmZmVjdEV2ZW50KGNvbnRhaW5lciA9PiB7XG4gICAgY29uc3QgY29udGVudCA9IGdldFRhYmJhYmxlQ29udGVudChjb250YWluZXIpO1xuICAgIHJldHVybiBvcmRlclJlZi5jdXJyZW50Lm1hcCh0eXBlID0+IHtcbiAgICAgIGlmIChkb21SZWZlcmVuY2UgJiYgdHlwZSA9PT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgcmV0dXJuIGRvbVJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZ0ZvY3VzRWxlbWVudCAmJiB0eXBlID09PSAnZmxvYXRpbmcnKSB7XG4gICAgICAgIHJldHVybiBmbG9hdGluZ0ZvY3VzRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmZpbHRlcihCb29sZWFuKS5mbGF0KCk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmICghbW9kYWwpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgICAgIC8vIFRoZSBmb2N1cyBndWFyZHMgaGF2ZSBub3RoaW5nIHRvIGZvY3VzLCBzbyB3ZSBuZWVkIHRvIHN0b3AgdGhlIGV2ZW50LlxuICAgICAgICBpZiAoY29udGFpbnMoZmxvYXRpbmdGb2N1c0VsZW1lbnQsIGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmdGb2N1c0VsZW1lbnQpKSkgJiYgZ2V0VGFiYmFibGVDb250ZW50KCkubGVuZ3RoID09PSAwICYmICFpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnRbMF0gPT09ICdyZWZlcmVuY2UnICYmIHRhcmdldCA9PT0gZG9tUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbZWxzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzFdID09PSAnZmxvYXRpbmcnICYmIHRhcmdldCA9PT0gZmxvYXRpbmdGb2N1c0VsZW1lbnQgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nRm9jdXNFbGVtZW50KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmdGb2N1c0VsZW1lbnQsIG1vZGFsLCBvcmRlclJlZiwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94LCBnZXRUYWJiYWJsZUNvbnRlbnQsIGdldFRhYmJhYmxlRWxlbWVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWZsb2F0aW5nKSByZXR1cm47XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNJbihldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGNvbnN0IHRhYmJhYmxlQ29udGVudCA9IGdldFRhYmJhYmxlQ29udGVudCgpO1xuICAgICAgY29uc3QgdGFiYmFibGVJbmRleCA9IHRhYmJhYmxlQ29udGVudC5pbmRleE9mKHRhcmdldCk7XG4gICAgICBpZiAodGFiYmFibGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGFiYmFibGVJbmRleFJlZi5jdXJyZW50ID0gdGFiYmFibGVJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGhhbmRsZUZvY3VzSW4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgaGFuZGxlRm9jdXNJbik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgZ2V0VGFiYmFibGVDb250ZW50XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKCFjbG9zZU9uRm9jdXNPdXQpIHJldHVybjtcblxuICAgIC8vIEluIFNhZmFyaSwgYnV0dG9ucyBsb3NlIGZvY3VzIHdoZW4gcHJlc3NpbmcgdGhlbS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bigpIHtcbiAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNPdXRzaWRlKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW92ZWRUb1VucmVsYXRlZE5vZGUgPSAhKGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoZmxvYXRpbmcsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQsIGZsb2F0aW5nKSB8fCBjb250YWlucyhwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUsIHJlbGF0ZWRUYXJnZXQpIHx8IHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpIHx8IHRyZWUgJiYgKGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0LCBfbm9kZSRjb250ZXh0MjtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucygoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9KSB8fCBnZXRBbmNlc3RvcnModHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQzLCBfbm9kZSRjb250ZXh0NDtcbiAgICAgICAgICByZXR1cm4gKChfbm9kZSRjb250ZXh0MyA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQzLmVsZW1lbnRzLmZsb2F0aW5nKSA9PT0gcmVsYXRlZFRhcmdldCB8fCAoKF9ub2RlJGNvbnRleHQ0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gcmVsYXRlZFRhcmdldDtcbiAgICAgICAgfSkpKTtcblxuICAgICAgICAvLyBSZXN0b3JlIGZvY3VzIHRvIHRoZSBwcmV2aW91cyB0YWJiYWJsZSBlbGVtZW50IGluZGV4IHRvIHByZXZlbnRcbiAgICAgICAgLy8gZm9jdXMgZnJvbSBiZWluZyBsb3N0IG91dHNpZGUgdGhlIGZsb2F0aW5nIHRyZWUuXG4gICAgICAgIGlmIChyZXN0b3JlRm9jdXMgJiYgbW92ZWRUb1VucmVsYXRlZE5vZGUgJiYgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCkpID09PSBnZXREb2N1bWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCkuYm9keSkge1xuICAgICAgICAgIC8vIExldCBgRmxvYXRpbmdQb3J0YWxgIGVmZmVjdCBrbm93cyB0aGF0IGZvY3VzIGlzIHN0aWxsIGluc2lkZSB0aGVcbiAgICAgICAgICAvLyBmbG9hdGluZyB0cmVlLlxuICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGZsb2F0aW5nRm9jdXNFbGVtZW50KSkge1xuICAgICAgICAgICAgZmxvYXRpbmdGb2N1c0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlSW5kZXggPSB0YWJiYWJsZUluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgY29uc3QgdGFiYmFibGVDb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KCk7XG4gICAgICAgICAgY29uc3Qgbm9kZVRvRm9jdXMgPSB0YWJiYWJsZUNvbnRlbnRbcHJldlRhYmJhYmxlSW5kZXhdIHx8IHRhYmJhYmxlQ29udGVudFt0YWJiYWJsZUNvbnRlbnQubGVuZ3RoIC0gMV0gfHwgZmxvYXRpbmdGb2N1c0VsZW1lbnQ7XG4gICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZVRvRm9jdXMpKSB7XG4gICAgICAgICAgICBub2RlVG9Gb2N1cy5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvY3VzIGRpZCBub3QgbW92ZSBpbnNpZGUgdGhlIGZsb2F0aW5nIHRyZWUsIGFuZCB0aGVyZSBhcmUgbm8gdGFiYmFibGVcbiAgICAgICAgLy8gcG9ydGFsIGd1YXJkcyB0byBoYW5kbGUgY2xvc2luZy5cbiAgICAgICAgaWYgKChpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyB0cnVlIDogIW1vZGFsKSAmJiByZWxhdGVkVGFyZ2V0ICYmIG1vdmVkVG9VbnJlbGF0ZWROb2RlICYmICFpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgLy8gRml4IFJlYWN0IDE4IFN0cmljdCBNb2RlIHJldHVybkZvY3VzIGR1ZSB0byBkb3VibGUgcmVuZGVyaW5nLlxuICAgICAgICByZWxhdGVkVGFyZ2V0ICE9PSBnZXRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKSkge1xuICAgICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnZm9jdXMtb3V0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcgJiYgaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgZG9tUmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgbW9kYWwsIG5vZGVJZCwgdHJlZSwgcG9ydGFsQ29udGV4dCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXQsIHJlc3RvcmVGb2N1cywgZ2V0VGFiYmFibGVDb250ZW50LCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3hdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BvcnRhbENvbnRleHQkcG9ydGFsO1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gRG9uJ3QgaGlkZSBwb3J0YWxzIG5lc3RlZCB3aXRoaW4gdGhlIHBhcmVudCBwb3J0YWwuXG4gICAgY29uc3QgcG9ydGFsTm9kZXMgPSBBcnJheS5mcm9tKChwb3J0YWxDb250ZXh0ID09IG51bGwgfHwgKF9wb3J0YWxDb250ZXh0JHBvcnRhbCA9IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3J0YWxDb250ZXh0JHBvcnRhbC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKSArIFwiXVwiKSkgfHwgW10pO1xuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgY29uc3QgaW5zaWRlRWxlbWVudHMgPSBbZmxvYXRpbmcsIC4uLnBvcnRhbE5vZGVzLCBzdGFydERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgZW5kRGlzbWlzc0J1dHRvblJlZi5jdXJyZW50LCBvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdyZWZlcmVuY2UnKSB8fCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyBkb21SZWZlcmVuY2UgOiBudWxsXS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuICAgICAgY29uc3QgY2xlYW51cCA9IG1vZGFsIHx8IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA/IG1hcmtPdGhlcnMoaW5zaWRlRWxlbWVudHMsIGd1YXJkcywgIWd1YXJkcykgOiBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBvcmRlclJlZiwgcG9ydGFsQ29udGV4dCwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94LCBndWFyZHNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhaXNIVE1MRWxlbWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCkpIHJldHVybjtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuXG4gICAgLy8gV2FpdCBmb3IgYW55IGxheW91dCBlZmZlY3Qgc3RhdGUgc2V0dGVycyB0byBleGVjdXRlIHRvIHNldCBgdGFiSW5kZXhgLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0VGFiYmFibGVFbGVtZW50cyhmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsRm9jdXNWYWx1ZSA9IGluaXRpYWxGb2N1c1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgZWxUb0ZvY3VzID0gKHR5cGVvZiBpbml0aWFsRm9jdXNWYWx1ZSA9PT0gJ251bWJlcicgPyBmb2N1c2FibGVFbGVtZW50c1tpbml0aWFsRm9jdXNWYWx1ZV0gOiBpbml0aWFsRm9jdXNWYWx1ZS5jdXJyZW50KSB8fCBmbG9hdGluZ0ZvY3VzRWxlbWVudDtcbiAgICAgIGNvbnN0IGZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgPSBjb250YWlucyhmbG9hdGluZ0ZvY3VzRWxlbWVudCwgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIGlmICghaWdub3JlSW5pdGlhbEZvY3VzICYmICFmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsICYmIG9wZW4pIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsVG9Gb2N1cywge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGVsVG9Gb2N1cyA9PT0gZmxvYXRpbmdGb2N1c0VsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZCwgb3BlbiwgZmxvYXRpbmdGb2N1c0VsZW1lbnQsIGlnbm9yZUluaXRpYWxGb2N1cywgZ2V0VGFiYmFibGVFbGVtZW50cywgaW5pdGlhbEZvY3VzUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nRm9jdXNFbGVtZW50KSByZXR1cm47XG4gICAgbGV0IHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IGZhbHNlO1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nRm9jdXNFbGVtZW50KTtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSBkYXRhUmVmLmN1cnJlbnQ7XG4gICAgbGV0IG9wZW5FdmVudCA9IGNvbnRleHREYXRhLm9wZW5FdmVudDtcbiAgICBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQocHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcblxuICAgIC8vIERpc21pc3NpbmcgdmlhIG91dHNpZGUgcHJlc3Mgc2hvdWxkIGFsd2F5cyBpZ25vcmUgYHJldHVybkZvY3VzYCB0b1xuICAgIC8vIHByZXZlbnQgdW53YW50ZWQgc2Nyb2xsaW5nLlxuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBvcGVuLFxuICAgICAgICByZWFzb24sXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBuZXN0ZWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgb3BlbkV2ZW50ID0gZXZlbnQ7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uID09PSAnZXNjYXBlLWtleScgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uID09PSAnaG92ZXInICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uICE9PSAnb3V0c2lkZS1wcmVzcycpIHJldHVybjtcbiAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzU2Nyb2xsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gIShpc1ZpcnR1YWxDbGljayhldmVudCkgfHwgaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgY29uc3QgZmFsbGJhY2tFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZmFsbGJhY2tFbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgZmFsbGJhY2tFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBPYmplY3QuYXNzaWduKGZhbGxiYWNrRWwuc3R5bGUsIEhJRERFTl9TVFlMRVMpO1xuICAgIGlmIChpc0luc2lkZVBvcnRhbCAmJiBkb21SZWZlcmVuY2UpIHtcbiAgICAgIGRvbVJlZmVyZW5jZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZmFsbGJhY2tFbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJldHVybkVsZW1lbnQoKSB7XG4gICAgICBpZiAodHlwZW9mIHJldHVybkZvY3VzUmVmLmN1cnJlbnQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkgfHwgZmFsbGJhY2tFbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5Gb2N1c1JlZi5jdXJyZW50LmN1cnJlbnQgfHwgZmFsbGJhY2tFbDtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgICAgY29uc3QgYWN0aXZlRWwgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlID0gY29udGFpbnMoZmxvYXRpbmcsIGFjdGl2ZUVsKSB8fCB0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKG5vZGUgPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDU7XG4gICAgICAgIHJldHVybiBjb250YWlucygoX25vZGUkY29udGV4dDUgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0NS5lbGVtZW50cy5mbG9hdGluZywgYWN0aXZlRWwpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBzaG91bGRGb2N1c1JlZmVyZW5jZSA9IGlzRm9jdXNJbnNpZGVGbG9hdGluZ1RyZWUgfHwgb3BlbkV2ZW50ICYmIFsnY2xpY2snLCAnbW91c2Vkb3duJ10uaW5jbHVkZXMob3BlbkV2ZW50LnR5cGUpO1xuICAgICAgaWYgKHNob3VsZEZvY3VzUmVmZXJlbmNlICYmIHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpIHtcbiAgICAgICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0dXJuRWxlbWVudCA9IGdldFJldHVybkVsZW1lbnQoKTtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIHJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgIXByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ICYmIGlzSFRNTEVsZW1lbnQocmV0dXJuRWxlbWVudCkgJiYgKFxuICAgICAgICAvLyBJZiB0aGUgZm9jdXMgbW92ZWQgc29tZXdoZXJlIGVsc2UgYWZ0ZXIgbW91bnQsIGF2b2lkIHJldHVybmluZyBmb2N1c1xuICAgICAgICAvLyBzaW5jZSBpdCBsaWtlbHkgZW50ZXJlZCBhIGRpZmZlcmVudCBlbGVtZW50IHdoaWNoIHNob3VsZCBiZVxuICAgICAgICAvLyByZXNwZWN0ZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjYwN1xuICAgICAgICByZXR1cm5FbGVtZW50ICE9PSBhY3RpdmVFbCAmJiBhY3RpdmVFbCAhPT0gZG9jLmJvZHkgPyBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIDogdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm5FbGVtZW50LmZvY3VzKHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZhbGxiYWNrRWwucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIHJlZnMsIGV2ZW50cywgdHJlZSwgbm9kZUlkLCBpc0luc2lkZVBvcnRhbCwgZG9tUmVmZXJlbmNlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVGhlIGByZXR1cm5Gb2N1c2AgY2xlYW51cCBiZWhhdmlvciBpcyBpbnNpZGUgYSBtaWNyb3Rhc2s7IGVuc3VyZSB3ZVxuICAgIC8vIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlIGJlZm9yZSByZXNldHRpbmcgdGhlIGZsYWcuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkXSk7XG5cbiAgLy8gU3luY2hyb25pemUgdGhlIGBjb250ZXh0YCAmIGBtb2RhbGAgdmFsdWUgdG8gdGhlIEZsb2F0aW5nUG9ydGFsIGNvbnRleHQuXG4gIC8vIEl0IHdpbGwgZGVjaWRlIHdoZXRoZXIgb3Igbm90IGl0IG5lZWRzIHRvIHJlbmRlciBpdHMgb3duIGd1YXJkcy5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmICghcG9ydGFsQ29udGV4dCkgcmV0dXJuO1xuICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUoe1xuICAgICAgbW9kYWwsXG4gICAgICBjbG9zZU9uRm9jdXNPdXQsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgcmVmc1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKG51bGwpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgcG9ydGFsQ29udGV4dCwgbW9kYWwsIG9wZW4sIG9uT3BlbkNoYW5nZSwgcmVmcywgY2xvc2VPbkZvY3VzT3V0XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWZsb2F0aW5nRm9jdXNFbGVtZW50KSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgaWYgKGlnbm9yZUluaXRpYWxGb2N1cykgcmV0dXJuO1xuICAgIGNvbnN0IGhhbmRsZU11dGF0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGFiSW5kZXggPSBmbG9hdGluZ0ZvY3VzRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICBjb25zdCB0YWJiYWJsZUNvbnRlbnQgPSBnZXRUYWJiYWJsZUNvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpO1xuICAgICAgY29uc3QgdGFiYmFibGVJbmRleCA9IHRhYmJhYmxlQ29udGVudC5pbmRleE9mKGFjdGl2ZUVsKTtcbiAgICAgIGlmICh0YWJiYWJsZUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0YWJiYWJsZUluZGV4UmVmLmN1cnJlbnQgPSB0YWJiYWJsZUluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgfHwgYWN0aXZlRWwgIT09IHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQgJiYgdGFiYmFibGVDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGFiSW5kZXggIT09ICcwJykge1xuICAgICAgICAgIGZsb2F0aW5nRm9jdXNFbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhYkluZGV4ICE9PSAnLTEnKSB7XG4gICAgICAgIGZsb2F0aW5nRm9jdXNFbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU11dGF0aW9uKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZ0ZvY3VzRWxlbWVudCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIGZsb2F0aW5nRm9jdXNFbGVtZW50LCByZWZzLCBvcmRlclJlZiwgZ2V0VGFiYmFibGVDb250ZW50LCBpZ25vcmVJbml0aWFsRm9jdXNdKTtcbiAgZnVuY3Rpb24gcmVuZGVyRGlzbWlzc0J1dHRvbihsb2NhdGlvbikge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhdmlzdWFsbHlIaWRkZW5EaXNtaXNzIHx8ICFtb2RhbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaXN1YWxseUhpZGRlbkRpc21pc3MsIHtcbiAgICAgIHJlZjogbG9jYXRpb24gPT09ICdzdGFydCcgPyBzdGFydERpc21pc3NCdXR0b25SZWYgOiBlbmREaXNtaXNzQnV0dG9uUmVmLFxuICAgICAgb25DbGljazogZXZlbnQgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudClcbiAgICB9LCB0eXBlb2YgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID09PSAnc3RyaW5nJyA/IHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA6ICdEaXNtaXNzJyk7XG4gIH1cbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID0gIWRpc2FibGVkICYmIGd1YXJkcyAmJiAobW9kYWwgPyAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94IDogdHJ1ZSkgJiYgKGlzSW5zaWRlUG9ydGFsIHx8IG1vZGFsKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwiaW5zaWRlXCIsXG4gICAgcmVmOiBwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LmJlZm9yZUluc2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgY29uc3QgZWxzID0gZ2V0VGFiYmFibGVFbGVtZW50cygpO1xuICAgICAgICBlbnF1ZXVlRm9jdXMob3JkZXJbMF0gPT09ICdyZWZlcmVuY2UnID8gZWxzWzBdIDogZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICB9IGVsc2UgaWYgKHBvcnRhbENvbnRleHQgIT0gbnVsbCAmJiBwb3J0YWxDb250ZXh0LnByZXNlcnZlVGFiT3JkZXIgJiYgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IG5leHRUYWJiYWJsZSA9IGdldE5leHRUYWJiYWJsZSgpIHx8IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgICBuZXh0VGFiYmFibGUgPT0gbnVsbCB8fCBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYmVmb3JlO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRiZWZvcmUgPSBwb3J0YWxDb250ZXh0LmJlZm9yZU91dHNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfcG9ydGFsQ29udGV4dCRiZWZvcmUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksICFpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggJiYgcmVuZGVyRGlzbWlzc0J1dHRvbignc3RhcnQnKSwgY2hpbGRyZW4sIHJlbmRlckRpc21pc3NCdXR0b24oJ2VuZCcpLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwiaW5zaWRlXCIsXG4gICAgcmVmOiBwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LmFmdGVySW5zaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoZ2V0VGFiYmFibGVFbGVtZW50cygpWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAocG9ydGFsQ29udGV4dCAhPSBudWxsICYmIHBvcnRhbENvbnRleHQucHJlc2VydmVUYWJPcmRlciAmJiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpIHtcbiAgICAgICAgaWYgKGNsb3NlT25Gb2N1c091dCkge1xuICAgICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2VGFiYmFibGUgPSBnZXRQcmV2aW91c1RhYmJhYmxlKCkgfHwgZG9tUmVmZXJlbmNlO1xuICAgICAgICAgIHByZXZUYWJiYWJsZSA9PSBudWxsIHx8IHByZXZUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9ydGFsQ29udGV4dCRhZnRlck87XG4gICAgICAgICAgKF9wb3J0YWxDb250ZXh0JGFmdGVyTyA9IHBvcnRhbENvbnRleHQuYWZ0ZXJPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX3BvcnRhbENvbnRleHQkYWZ0ZXJPLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cblxubGV0IGxvY2tDb3VudCA9IDA7XG5mdW5jdGlvbiBlbmFibGVTY3JvbGxMb2NrKCkge1xuICBjb25zdCBpc0lPUyA9IC9pUChob25lfGFkfG9kKXxpT1MvLnRlc3QoZ2V0UGxhdGZvcm0oKSk7XG4gIGNvbnN0IGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gIC8vIFJUTCA8Ym9keT4gc2Nyb2xsYmFyXG4gIGNvbnN0IHNjcm9sbGJhclggPSBNYXRoLnJvdW5kKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICBjb25zdCBwYWRkaW5nUHJvcCA9IHNjcm9sbGJhclggPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIGNvbnN0IHNjcm9sbFggPSBib2R5U3R5bGUubGVmdCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLmxlZnQpIDogd2luZG93LnNjcm9sbFg7XG4gIGNvbnN0IHNjcm9sbFkgPSBib2R5U3R5bGUudG9wID8gcGFyc2VGbG9hdChib2R5U3R5bGUudG9wKSA6IHdpbmRvdy5zY3JvbGxZO1xuICBib2R5U3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgaWYgKHNjcm9sbGJhcldpZHRoKSB7XG4gICAgYm9keVN0eWxlW3BhZGRpbmdQcm9wXSA9IHNjcm9sbGJhcldpZHRoICsgXCJweFwiO1xuICB9XG5cbiAgLy8gT25seSBpT1MgZG9lc24ndCByZXNwZWN0IGBvdmVyZmxvdzogaGlkZGVuYCBvbiBkb2N1bWVudC5ib2R5LCBhbmQgdGhpc1xuICAvLyB0ZWNobmlxdWUgaGFzIGZld2VyIHNpZGUgZWZmZWN0cy5cbiAgaWYgKGlzSU9TKSB7XG4gICAgdmFyIF93aW5kb3ckdmlzdWFsVmlld3BvciwgX3dpbmRvdyR2aXN1YWxWaWV3cG9yMjtcbiAgICAvLyBpT1MgMTIgZG9lcyBub3Qgc3VwcG9ydCBgdmlzdWFsVmlld3BvcnRgLlxuICAgIGNvbnN0IG9mZnNldExlZnQgPSAoKF93aW5kb3ckdmlzdWFsVmlld3BvciA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3Bvci5vZmZzZXRMZWZ0KSB8fCAwO1xuICAgIGNvbnN0IG9mZnNldFRvcCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3BvcjIub2Zmc2V0VG9wKSB8fCAwO1xuICAgIE9iamVjdC5hc3NpZ24oYm9keVN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHRvcDogLShzY3JvbGxZIC0gTWF0aC5mbG9vcihvZmZzZXRUb3ApKSArIFwicHhcIixcbiAgICAgIGxlZnQ6IC0oc2Nyb2xsWCAtIE1hdGguZmxvb3Iob2Zmc2V0TGVmdCkpICsgXCJweFwiLFxuICAgICAgcmlnaHQ6ICcwJ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgIFtwYWRkaW5nUHJvcF06ICcnXG4gICAgfSk7XG4gICAgaWYgKGlzSU9TKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgIHRvcDogJycsXG4gICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICByaWdodDogJydcbiAgICAgIH0pO1xuICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFgsIHNjcm9sbFkpO1xuICAgIH1cbiAgfTtcbn1cbmxldCBjbGVhbnVwID0gKCkgPT4ge307XG5cbi8qKlxuICogUHJvdmlkZXMgYmFzZSBzdHlsaW5nIGZvciBhIGZpeGVkIG92ZXJsYXkgZWxlbWVudCB0byBkaW0gY29udGVudCBvciBibG9ja1xuICogcG9pbnRlciBldmVudHMgYmVoaW5kIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEl0J3MgYSByZWd1bGFyIGA8ZGl2PmAsIHNvIGl0IGNhbiBiZSBzdHlsZWQgdmlhIGFueSBDU1Mgc29sdXRpb24geW91IHByZWZlci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ092ZXJsYXlcbiAqL1xuY29uc3QgRmxvYXRpbmdPdmVybGF5ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmxvYXRpbmdPdmVybGF5KHByb3BzLCByZWYpIHtcbiAgY29uc3Qge1xuICAgIGxvY2tTY3JvbGwgPSBmYWxzZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBwcm9wcztcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghbG9ja1Njcm9sbCkgcmV0dXJuO1xuICAgIGxvY2tDb3VudCsrO1xuICAgIGlmIChsb2NrQ291bnQgPT09IDEpIHtcbiAgICAgIGNsZWFudXAgPSBlbmFibGVTY3JvbGxMb2NrKCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsb2NrQ291bnQtLTtcbiAgICAgIGlmIChsb2NrQ291bnQgPT09IDApIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtsb2NrU2Nyb2xsXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWZcbiAgfSwgcmVzdCwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICAuLi5yZXN0LnN0eWxlXG4gICAgfVxuICB9KSk7XG59KTtcblxuZnVuY3Rpb24gaXNCdXR0b25UYXJnZXQoZXZlbnQpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZXZlbnQudGFyZ2V0KSAmJiBldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0JVVFRPTic7XG59XG5mdW5jdGlvbiBpc1NwYWNlSWdub3JlZChlbGVtZW50KSB7XG4gIHJldHVybiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KTtcbn1cbi8qKlxuICogT3BlbnMgb3IgY2xvc2VzIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gY2xpY2tpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUNsaWNrXG4gKi9cbmZ1bmN0aW9uIHVzZUNsaWNrKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGV2ZW50OiBldmVudE9wdGlvbiA9ICdjbGljaycsXG4gICAgdG9nZ2xlID0gdHJ1ZSxcbiAgICBpZ25vcmVNb3VzZSA9IGZhbHNlLFxuICAgIGtleWJvYXJkSGFuZGxlcnMgPSB0cnVlLFxuICAgIHN0aWNrSWZPcGVuID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGRpZEtleURvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgIH0sXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGVSZWYuY3VycmVudDtcblxuICAgICAgLy8gSWdub3JlIGFsbCBidXR0b25zIGV4Y2VwdCBmb3IgdGhlIFwibWFpblwiIGJ1dHRvbi5cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvblxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnY2xpY2snKSByZXR1cm47XG4gICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSwgdHJ1ZSkgJiYgaWdub3JlTW91c2UpIHJldHVybjtcbiAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiBzdGlja0lmT3BlbiA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgOiB0cnVlKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFByZXZlbnQgc3RlYWxpbmcgZm9jdXMgZnJvbSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgY29uc3QgcG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnbW91c2Vkb3duJyAmJiBwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlLCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkgcmV0dXJuO1xuICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlICYmIChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ICYmIHN0aWNrSWZPcGVuID8gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlID09PSAnY2xpY2snIDogdHJ1ZSkpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWtleWJvYXJkSGFuZGxlcnMgfHwgaXNCdXR0b25UYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiAhaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZ1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUpIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAha2V5Ym9hcmRIYW5kbGVycyB8fCBpc0J1dHRvblRhcmdldChldmVudCkgfHwgaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgZGlkS2V5RG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgIGRpZEtleURvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUpIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgW2RhdGFSZWYsIGRvbVJlZmVyZW5jZSwgZXZlbnRPcHRpb24sIGlnbm9yZU1vdXNlLCBrZXlib2FyZEhhbmRsZXJzLCBvbk9wZW5DaGFuZ2UsIG9wZW4sIHN0aWNrSWZPcGVuLCB0b2dnbGVdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2VcbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxFbGVtZW50KGRvbUVsZW1lbnQsIGRhdGEpIHtcbiAgbGV0IG9mZnNldFggPSBudWxsO1xuICBsZXQgb2Zmc2V0WSA9IG51bGw7XG4gIGxldCBpc0F1dG9VcGRhdGVFdmVudCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRFbGVtZW50OiBkb21FbGVtZW50IHx8IHVuZGVmaW5lZCxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICB2YXIgX2RhdGEkZGF0YVJlZiRjdXJyZW50O1xuICAgICAgY29uc3QgZG9tUmVjdCA9IChkb21FbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB8fCB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1hBeGlzID0gZGF0YS5heGlzID09PSAneCcgfHwgZGF0YS5heGlzID09PSAnYm90aCc7XG4gICAgICBjb25zdCBpc1lBeGlzID0gZGF0YS5heGlzID09PSAneScgfHwgZGF0YS5heGlzID09PSAnYm90aCc7XG4gICAgICBjb25zdCBjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSA9IFsnbW91c2VlbnRlcicsICdtb3VzZW1vdmUnXS5pbmNsdWRlcygoKF9kYXRhJGRhdGFSZWYkY3VycmVudCA9IGRhdGEuZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGRhdGFSZWYkY3VycmVudC50eXBlKSB8fCAnJykgJiYgZGF0YS5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJztcbiAgICAgIGxldCB3aWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICBsZXQgaGVpZ2h0ID0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICBsZXQgeCA9IGRvbVJlY3QueDtcbiAgICAgIGxldCB5ID0gZG9tUmVjdC55O1xuICAgICAgaWYgKG9mZnNldFggPT0gbnVsbCAmJiBkYXRhLnggJiYgaXNYQXhpcykge1xuICAgICAgICBvZmZzZXRYID0gZG9tUmVjdC54IC0gZGF0YS54O1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldFkgPT0gbnVsbCAmJiBkYXRhLnkgJiYgaXNZQXhpcykge1xuICAgICAgICBvZmZzZXRZID0gZG9tUmVjdC55IC0gZGF0YS55O1xuICAgICAgfVxuICAgICAgeCAtPSBvZmZzZXRYIHx8IDA7XG4gICAgICB5IC09IG9mZnNldFkgfHwgMDtcbiAgICAgIHdpZHRoID0gMDtcbiAgICAgIGhlaWdodCA9IDA7XG4gICAgICBpZiAoIWlzQXV0b1VwZGF0ZUV2ZW50IHx8IGNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlKSB7XG4gICAgICAgIHdpZHRoID0gZGF0YS5heGlzID09PSAneScgPyBkb21SZWN0LndpZHRoIDogMDtcbiAgICAgICAgaGVpZ2h0ID0gZGF0YS5heGlzID09PSAneCcgPyBkb21SZWN0LmhlaWdodCA6IDA7XG4gICAgICAgIHggPSBpc1hBeGlzICYmIGRhdGEueCAhPSBudWxsID8gZGF0YS54IDogeDtcbiAgICAgICAgeSA9IGlzWUF4aXMgJiYgZGF0YS55ICE9IG51bGwgPyBkYXRhLnkgOiB5O1xuICAgICAgfSBlbHNlIGlmIChpc0F1dG9VcGRhdGVFdmVudCAmJiAhY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUpIHtcbiAgICAgICAgaGVpZ2h0ID0gZGF0YS5heGlzID09PSAneCcgPyBkb21SZWN0LmhlaWdodCA6IGhlaWdodDtcbiAgICAgICAgd2lkdGggPSBkYXRhLmF4aXMgPT09ICd5JyA/IGRvbVJlY3Qud2lkdGggOiB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlzQXV0b1VwZGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICAgICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgICAgICBsZWZ0OiB4XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VCYXNlZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudCAhPSBudWxsICYmIGV2ZW50LmNsaWVudFggIT0gbnVsbDtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHJlbGF0aXZlIHRvIGEgY2xpZW50IHBvaW50IChpbiB0aGUgdmlld3BvcnQpLFxuICogc3VjaCBhcyB0aGUgbW91c2UgcG9zaXRpb24uIEJ5IGRlZmF1bHQsIGl0IGZvbGxvd3MgdGhlIG1vdXNlIGN1cnNvci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VDbGllbnRQb2ludFxuICovXG5mdW5jdGlvbiB1c2VDbGllbnRQb2ludChjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmcsXG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9LFxuICAgIHJlZnNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBheGlzID0gJ2JvdGgnLFxuICAgIHggPSBudWxsLFxuICAgIHkgPSBudWxsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgaW5pdGlhbFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGNsZWFudXBMaXN0ZW5lclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW3BvaW50ZXJUeXBlLCBzZXRQb2ludGVyVHlwZV0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbcmVhY3RpdmUsIHNldFJlYWN0aXZlXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gdXNlRWZmZWN0RXZlbnQoKHgsIHkpID0+IHtcbiAgICBpZiAoaW5pdGlhbFJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAvLyBQcmV2ZW50IHNldHRpbmcgaWYgdGhlIG9wZW4gZXZlbnQgd2FzIG5vdCBhIG1vdXNlLWxpa2Ugb25lXG4gICAgLy8gKGUuZy4gZm9jdXMgdG8gb3BlbiwgdGhlbiBob3ZlciBvdmVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCkuXG4gICAgLy8gT25seSBhcHBseSBpZiB0aGUgZXZlbnQgZXhpc3RzLlxuICAgIGlmIChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ICYmICFpc01vdXNlQmFzZWRFdmVudChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKGNyZWF0ZVZpcnR1YWxFbGVtZW50KGRvbVJlZmVyZW5jZSwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBheGlzLFxuICAgICAgZGF0YVJlZixcbiAgICAgIHBvaW50ZXJUeXBlXG4gICAgfSkpO1xuICB9KTtcbiAgY29uc3QgaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9IGVsc2UgaWYgKCFjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBjbGVhbnVwLCB0aGVyZSdzIG5vIGxpc3RlbmVyLCBidXQgd2Ugd2FudCB0byBlbnN1cmVcbiAgICAgIC8vIHdlIGFkZCB0aGUgbGlzdGVuZXIgaWYgdGhlIGN1cnNvciBsYW5kZWQgb24gdGhlIGZsb2F0aW5nIGVsZW1lbnQgYW5kXG4gICAgICAvLyB0aGVuIGJhY2sgb24gdGhlIHJlZmVyZW5jZSAoaS5lLiBpdCdzIGludGVyYWN0aXZlKS5cbiAgICAgIHNldFJlYWN0aXZlKFtdKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHRoZSBwb2ludGVyIGlzIGEgbW91c2UtbGlrZSBwb2ludGVyLCB3ZSB3YW50IHRvIGNvbnRpbnVlIGZvbGxvd2luZyB0aGVcbiAgLy8gbW91c2UgZXZlbiBpZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nIG91dC4gT24gdG91Y2hcbiAgLy8gZGV2aWNlcywgdGhpcyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdpbGwgbW92ZSB0b1xuICAvLyB0aGUgZGlzbWlzc2FsIHRvdWNoIHBvaW50LlxuICBjb25zdCBvcGVuQ2hlY2sgPSBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSA/IGZsb2F0aW5nIDogb3BlbjtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gRXhwbGljaXRseSBzcGVjaWZpZWQgYHhgL2B5YCBjb29yZGluYXRlcyBzaG91bGRuJ3QgYWRkIGEgbGlzdGVuZXIuXG4gICAgaWYgKCFvcGVuQ2hlY2sgfHwgIWVuYWJsZWQgfHwgeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhmbG9hdGluZyk7XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgaWYgKCFjb250YWlucyhmbG9hdGluZywgdGFyZ2V0KSkge1xuICAgICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgfHwgaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IGNsZWFudXA7XG4gICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShkb21SZWZlcmVuY2UpO1xuICB9LCBbb3BlbkNoZWNrLCBlbmFibGVkLCB4LCB5LCBmbG9hdGluZywgZGF0YVJlZiwgcmVmcywgZG9tUmVmZXJlbmNlLCBzZXRSZWZlcmVuY2VdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIoKTtcbiAgfSwgW2FkZExpc3RlbmVyLCByZWFjdGl2ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICFmbG9hdGluZykge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgJiYgb3Blbikge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzZXRQb2ludGVyVHlwZVJlZihfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBwb2ludGVyVHlwZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBzZXRQb2ludGVyVHlwZShwb2ludGVyVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyVHlwZVJlZixcbiAgICAgIG9uUG9pbnRlckVudGVyOiBzZXRQb2ludGVyVHlwZVJlZixcbiAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgIG9uTW91c2VFbnRlcjogaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmVcbiAgICB9O1xuICB9LCBbaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmVdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2VcbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlXSk7XG59XG5cbmNvbnN0IGJ1YmJsZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd24nLFxuICBtb3VzZWRvd246ICdvbk1vdXNlRG93bicsXG4gIGNsaWNrOiAnb25DbGljaydcbn07XG5jb25zdCBjYXB0dXJlSGFuZGxlcktleXMgPSB7XG4gIHBvaW50ZXJkb3duOiAnb25Qb2ludGVyRG93bkNhcHR1cmUnLFxuICBtb3VzZWRvd246ICdvbk1vdXNlRG93bkNhcHR1cmUnLFxuICBjbGljazogJ29uQ2xpY2tDYXB0dXJlJ1xufTtcbmNvbnN0IG5vcm1hbGl6ZVByb3AgPSBub3JtYWxpemFibGUgPT4ge1xuICB2YXIgX25vcm1hbGl6YWJsZSRlc2NhcGVLLCBfbm9ybWFsaXphYmxlJG91dHNpZGU7XG4gIHJldHVybiB7XG4gICAgZXNjYXBlS2V5OiB0eXBlb2Ygbm9ybWFsaXphYmxlID09PSAnYm9vbGVhbicgPyBub3JtYWxpemFibGUgOiAoX25vcm1hbGl6YWJsZSRlc2NhcGVLID0gbm9ybWFsaXphYmxlID09IG51bGwgPyB2b2lkIDAgOiBub3JtYWxpemFibGUuZXNjYXBlS2V5KSAhPSBudWxsID8gX25vcm1hbGl6YWJsZSRlc2NhcGVLIDogZmFsc2UsXG4gICAgb3V0c2lkZVByZXNzOiB0eXBlb2Ygbm9ybWFsaXphYmxlID09PSAnYm9vbGVhbicgPyBub3JtYWxpemFibGUgOiAoX25vcm1hbGl6YWJsZSRvdXRzaWRlID0gbm9ybWFsaXphYmxlID09IG51bGwgPyB2b2lkIDAgOiBub3JtYWxpemFibGUub3V0c2lkZVByZXNzKSAhPSBudWxsID8gX25vcm1hbGl6YWJsZSRvdXRzaWRlIDogdHJ1ZVxuICB9O1xufTtcbi8qKlxuICogQ2xvc2VzIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gYSBkaXNtaXNzYWwgaXMgcmVxdWVzdGVkIOKAlCBieSBkZWZhdWx0LCB3aGVuXG4gKiB0aGUgdXNlciBwcmVzc2VzIHRoZSBgZXNjYXBlYCBrZXkgb3Igb3V0c2lkZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VEaXNtaXNzXG4gKi9cbmZ1bmN0aW9uIHVzZURpc21pc3MoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhUmVmXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZXNjYXBlS2V5ID0gdHJ1ZSxcbiAgICBvdXRzaWRlUHJlc3M6IHVuc3RhYmxlX291dHNpZGVQcmVzcyA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIHJlZmVyZW5jZVByZXNzID0gZmFsc2UsXG4gICAgcmVmZXJlbmNlUHJlc3NFdmVudCA9ICdwb2ludGVyZG93bicsXG4gICAgYW5jZXN0b3JTY3JvbGwgPSBmYWxzZSxcbiAgICBidWJibGVzLFxuICAgIGNhcHR1cmVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IG91dHNpZGVQcmVzc0ZuID0gdXNlRWZmZWN0RXZlbnQodHlwZW9mIHVuc3RhYmxlX291dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyA/IHVuc3RhYmxlX291dHNpZGVQcmVzcyA6ICgpID0+IGZhbHNlKTtcbiAgY29uc3Qgb3V0c2lkZVByZXNzID0gdHlwZW9mIHVuc3RhYmxlX291dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyA/IG91dHNpZGVQcmVzc0ZuIDogdW5zdGFibGVfb3V0c2lkZVByZXNzO1xuICBjb25zdCBpbnNpZGVSZWFjdFRyZWVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICBlc2NhcGVLZXk6IGVzY2FwZUtleUJ1YmJsZXMsXG4gICAgb3V0c2lkZVByZXNzOiBvdXRzaWRlUHJlc3NCdWJibGVzXG4gIH0gPSBub3JtYWxpemVQcm9wKGJ1YmJsZXMpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlDYXB0dXJlLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQ2FwdHVyZVxuICB9ID0gbm9ybWFsaXplUHJvcChjYXB0dXJlKTtcbiAgY29uc3QgaXNDb21wb3NpbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjbG9zZU9uRXNjYXBlS2V5RG93biA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRmbG9hO1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCB8fCAhZXNjYXBlS2V5IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXYWl0IHVudGlsIElNRSBpcyBzZXR0bGVkLiBQcmVzc2luZyBgRXNjYXBlYCB3aGlsZSBjb21wb3Npbmcgc2hvdWxkXG4gICAgLy8gY2xvc2UgdGhlIGNvbXBvc2UgbWVudSwgYnV0IG5vdCB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgICBpZiAoaXNDb21wb3NpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSAoX2RhdGFSZWYkY3VycmVudCRmbG9hID0gZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkZmxvYS5ub2RlSWQ7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKCFlc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0O1xuICAgICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Lm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGlzUmVhY3RFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50LCAnZXNjYXBlLWtleScpO1xuICB9KTtcbiAgY29uc3QgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0MjtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0O1xuICAgICAgY2xvc2VPbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0MiA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkZmxvYTI7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50O1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAvLyBXaGVuIGNsaWNrIG91dHNpZGUgaXMgbGF6eSAoYGNsaWNrYCBldmVudCksIGhhbmRsZSBkcmFnZ2luZy5cbiAgICAvLyBEb24ndCBjbG9zZSBpZjpcbiAgICAvLyAtIFRoZSBjbGljayBzdGFydGVkIGluc2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgICAvLyAtIFRoZSBjbGljayBlbmRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGUgPSBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50O1xuICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBpZiAob3V0c2lkZVByZXNzRXZlbnQgPT09ICdjbGljaycgJiYgZW5kZWRPclN0YXJ0ZWRJbnNpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluc2lkZVJlYWN0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3V0c2lkZVByZXNzKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudChlbGVtZW50cy5mbG9hdGluZykucXVlcnlTZWxlY3RvckFsbChpbmVydFNlbGVjdG9yKTtcbiAgICBsZXQgdGFyZ2V0Um9vdEFuY2VzdG9yID0gaXNFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiBudWxsO1xuICAgIHdoaWxlICh0YXJnZXRSb290QW5jZXN0b3IgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXRSb290QW5jZXN0b3IpKSB7XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXRSb290QW5jZXN0b3IpO1xuICAgICAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShuZXh0UGFyZW50KSB8fCAhaXNFbGVtZW50KG5leHRQYXJlbnQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0Um9vdEFuY2VzdG9yID0gbmV4dFBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gYSB0aGlyZC1wYXJ0eSBlbGVtZW50IGluamVjdGVkIGFmdGVyIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgaWYgKG1hcmtlcnMubGVuZ3RoICYmIGlzRWxlbWVudCh0YXJnZXQpICYmICFpc1Jvb3RFbGVtZW50KHRhcmdldCkgJiZcbiAgICAvLyBDbGlja2VkIG9uIGEgZGlyZWN0IGFuY2VzdG9yIChlLmcuIEZsb2F0aW5nT3ZlcmxheSkuXG4gICAgIWNvbnRhaW5zKHRhcmdldCwgZWxlbWVudHMuZmxvYXRpbmcpICYmXG4gICAgLy8gSWYgdGhlIHRhcmdldCByb290IGVsZW1lbnQgY29udGFpbnMgbm9uZSBvZiB0aGUgbWFya2VycywgdGhlbiB0aGVcbiAgICAvLyBlbGVtZW50IHdhcyBpbmplY3RlZCBhZnRlciB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBBcnJheS5mcm9tKG1hcmtlcnMpLmV2ZXJ5KG1hcmtlciA9PiAhY29udGFpbnModGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgLy8gSW4gRmlyZWZveCwgYHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aGAgZm9yIGlubGluZVxuICAgICAgLy8gZWxlbWVudHMuXG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LmNsaWVudFdpZHRoID4gMCAmJiB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LmNsaWVudEhlaWdodCA+IDAgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgeENvbmQgPSBjYW5TY3JvbGxZICYmIGV2ZW50Lm9mZnNldFggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG5cbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSA8Ym9keT4gKG9yIHdpbmRvdylcbiAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgIC8vIGNoZWNrIGZvci4gUGx1cywgZm9yIG1vZGFsIGRpYWxvZ3Mgd2l0aCBiYWNrZHJvcHMsIGl0IGlzIG1vcmVcbiAgICAgIC8vIGltcG9ydGFudCB0aGF0IHRoZSBiYWNrZHJvcCBpcyBjaGVja2VkIGJ1dCBub3Qgc28gbXVjaCB0aGUgd2luZG93LlxuICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgeENvbmQgPSBldmVudC5vZmZzZXRYIDw9IHRhcmdldC5vZmZzZXRXaWR0aCAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHhDb25kIHx8IGNhblNjcm9sbFggJiYgZXZlbnQub2Zmc2V0WSA+IHRhcmdldC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSAoX2RhdGFSZWYkY3VycmVudCRmbG9hMiA9IGRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JGZsb2EyLm5vZGVJZDtcbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGVsZW1lbnRzLmZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBlbGVtZW50cy5kb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0My5yZW1vdmVFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQ0LmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMgPSBlc2NhcGVLZXlCdWJibGVzO1xuICAgIGRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMgPSBvdXRzaWRlUHJlc3NCdWJibGVzO1xuICAgIGxldCBjb21wb3NpdGlvblRpbWVvdXQgPSAtMTtcbiAgICBmdW5jdGlvbiBvblNjcm9sbChldmVudCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ2FuY2VzdG9yLXNjcm9sbCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVDb21wb3NpdGlvblN0YXJ0KCkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChjb21wb3NpdGlvblRpbWVvdXQpO1xuICAgICAgaXNDb21wb3NpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUNvbXBvc2l0aW9uRW5kKCkge1xuICAgICAgLy8gU2FmYXJpIGZpcmVzIGBjb21wb3NpdGlvbmVuZGAgYmVmb3JlIGBrZXlkb3duYCwgc28gd2UgbmVlZCB0byB3YWl0XG4gICAgICAvLyB1bnRpbCB0aGUgbmV4dCB0aWNrIHRvIHNldCBgaXNDb21wb3NpbmdgIHRvIGBmYWxzZWAuXG4gICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTY1MDA0XG4gICAgICBjb21wb3NpdGlvblRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlzQ29tcG9zaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAvLyAwbXMgb3IgMW1zIGRvbid0IHdvcmsgaW4gU2FmYXJpLiA1bXMgYXBwZWFycyB0byBjb25zaXN0ZW50bHkgd29yay5cbiAgICAgIC8vIE9ubHkgYXBwbHkgdG8gV2ViS2l0IGZvciB0aGUgdGVzdCB0byByZW1haW4gMG1zLlxuICAgICAgaXNXZWJLaXQoKSA/IDUgOiAwKTtcbiAgICB9XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgIGlmIChlc2NhcGVLZXkpIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgaGFuZGxlQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBoYW5kbGVDb21wb3NpdGlvbkVuZCk7XG4gICAgfVxuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtZW50cy5yZWZlcmVuY2UpICYmIGVsZW1lbnRzLnJlZmVyZW5jZSAmJiBlbGVtZW50cy5yZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50cy5yZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGVzY2FwZUtleSkge1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGVzY2FwZUtleUNhcHR1cmUgPyBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUgOiBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgaGFuZGxlQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIGhhbmRsZUNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChjb21wb3NpdGlvblRpbWVvdXQpO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBlbGVtZW50cywgZXNjYXBlS2V5LCBvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50LCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGFuY2VzdG9yU2Nyb2xsLCBlbmFibGVkLCBlc2NhcGVLZXlCdWJibGVzLCBvdXRzaWRlUHJlc3NCdWJibGVzLCBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSwgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlLCBjbG9zZU9uUHJlc3NPdXRzaWRlLCBvdXRzaWRlUHJlc3NDYXB0dXJlLCBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH0sIFtvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50XSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbktleURvd246IGNsb3NlT25Fc2NhcGVLZXlEb3duLFxuICAgIFtidWJibGVIYW5kbGVyS2V5c1tyZWZlcmVuY2VQcmVzc0V2ZW50XV06IGV2ZW50ID0+IHtcbiAgICAgIGlmIChyZWZlcmVuY2VQcmVzcykge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAncmVmZXJlbmNlLXByZXNzJyk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgW2Nsb3NlT25Fc2NhcGVLZXlEb3duLCBvbk9wZW5DaGFuZ2UsIHJlZmVyZW5jZVByZXNzLCByZWZlcmVuY2VQcmVzc0V2ZW50XSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uTW91c2VVcCgpIHtcbiAgICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgW2NhcHR1cmVIYW5kbGVyS2V5c1tvdXRzaWRlUHJlc3NFdmVudF1dOiAoKSA9PiB7XG4gICAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9KSwgW2Nsb3NlT25Fc2NhcGVLZXlEb3duLCBvdXRzaWRlUHJlc3NFdmVudF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2UsIGZsb2F0aW5nXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nUm9vdENvbnRleHQob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgb3BlbiA9IGZhbHNlLFxuICAgIG9uT3BlbkNoYW5nZTogb25PcGVuQ2hhbmdlUHJvcCxcbiAgICBlbGVtZW50czogZWxlbWVudHNQcm9wXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBmbG9hdGluZ0lkID0gdXNlSWQoKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZih7fSk7XG4gIGNvbnN0IFtldmVudHNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpO1xuICBjb25zdCBuZXN0ZWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpICE9IG51bGw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBvcHRpb25Eb21SZWZlcmVuY2UgPSBlbGVtZW50c1Byb3AucmVmZXJlbmNlO1xuICAgIGlmIChvcHRpb25Eb21SZWZlcmVuY2UgJiYgIWlzRWxlbWVudChvcHRpb25Eb21SZWZlcmVuY2UpKSB7XG4gICAgICBlcnJvcignQ2Fubm90IHBhc3MgYSB2aXJ0dWFsIGVsZW1lbnQgdG8gdGhlIGBlbGVtZW50cy5yZWZlcmVuY2VgIG9wdGlvbiwnLCAnYXMgaXQgbXVzdCBiZSBhIHJlYWwgRE9NIGVsZW1lbnQuIFVzZSBgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZSgpYCcsICdpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBbcG9zaXRpb25SZWZlcmVuY2UsIHNldFBvc2l0aW9uUmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKGVsZW1lbnRzUHJvcC5yZWZlcmVuY2UpO1xuICBjb25zdCBvbk9wZW5DaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCgob3BlbiwgZXZlbnQsIHJlYXNvbikgPT4ge1xuICAgIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPSBvcGVuID8gZXZlbnQgOiB1bmRlZmluZWQ7XG4gICAgZXZlbnRzLmVtaXQoJ29wZW5jaGFuZ2UnLCB7XG4gICAgICBvcGVuLFxuICAgICAgZXZlbnQsXG4gICAgICByZWFzb24sXG4gICAgICBuZXN0ZWRcbiAgICB9KTtcbiAgICBvbk9wZW5DaGFuZ2VQcm9wID09IG51bGwgfHwgb25PcGVuQ2hhbmdlUHJvcChvcGVuLCBldmVudCwgcmVhc29uKTtcbiAgfSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgc2V0UG9zaXRpb25SZWZlcmVuY2VcbiAgfSksIFtdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiBwb3NpdGlvblJlZmVyZW5jZSB8fCBlbGVtZW50c1Byb3AucmVmZXJlbmNlIHx8IG51bGwsXG4gICAgZmxvYXRpbmc6IGVsZW1lbnRzUHJvcC5mbG9hdGluZyB8fCBudWxsLFxuICAgIGRvbVJlZmVyZW5jZTogZWxlbWVudHNQcm9wLnJlZmVyZW5jZVxuICB9KSwgW3Bvc2l0aW9uUmVmZXJlbmNlLCBlbGVtZW50c1Byb3AucmVmZXJlbmNlLCBlbGVtZW50c1Byb3AuZmxvYXRpbmddKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBkYXRhUmVmLFxuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGVsZW1lbnRzLFxuICAgIGV2ZW50cyxcbiAgICBmbG9hdGluZ0lkLFxuICAgIHJlZnNcbiAgfSksIFtvcGVuLCBvbk9wZW5DaGFuZ2UsIGVsZW1lbnRzLCBldmVudHMsIGZsb2F0aW5nSWQsIHJlZnNdKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudCBhbmQgY29udGV4dCB0byBhZGQgaW50ZXJhY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgbm9kZUlkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpbnRlcm5hbFJvb3RDb250ZXh0ID0gdXNlRmxvYXRpbmdSb290Q29udGV4dCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlOiBudWxsLFxuICAgICAgZmxvYXRpbmc6IG51bGwsXG4gICAgICAuLi5vcHRpb25zLmVsZW1lbnRzXG4gICAgfVxuICB9KTtcbiAgY29uc3Qgcm9vdENvbnRleHQgPSBvcHRpb25zLnJvb3RDb250ZXh0IHx8IGludGVybmFsUm9vdENvbnRleHQ7XG4gIGNvbnN0IGNvbXB1dGVkRWxlbWVudHMgPSByb290Q29udGV4dC5lbGVtZW50cztcbiAgY29uc3QgW19kb21SZWZlcmVuY2UsIHNldERvbVJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3Bvc2l0aW9uUmVmZXJlbmNlLCBfc2V0UG9zaXRpb25SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IG9wdGlvbkRvbVJlZmVyZW5jZSA9IGNvbXB1dGVkRWxlbWVudHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXB1dGVkRWxlbWVudHMuZG9tUmVmZXJlbmNlO1xuICBjb25zdCBkb21SZWZlcmVuY2UgPSBvcHRpb25Eb21SZWZlcmVuY2UgfHwgX2RvbVJlZmVyZW5jZTtcbiAgY29uc3QgZG9tUmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZG9tUmVmZXJlbmNlKSB7XG4gICAgICBkb21SZWZlcmVuY2VSZWYuY3VycmVudCA9IGRvbVJlZmVyZW5jZTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2VdKTtcbiAgY29uc3QgcG9zaXRpb24gPSB1c2VGbG9hdGluZyQxKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICAuLi5jb21wdXRlZEVsZW1lbnRzLFxuICAgICAgLi4uKHBvc2l0aW9uUmVmZXJlbmNlICYmIHtcbiAgICAgICAgcmVmZXJlbmNlOiBwb3NpdGlvblJlZmVyZW5jZVxuICAgICAgfSlcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IGNvbXB1dGVkUG9zaXRpb25SZWZlcmVuY2UgPSBpc0VsZW1lbnQobm9kZSkgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb250ZXh0RWxlbWVudDogbm9kZVxuICAgIH0gOiBub2RlO1xuICAgIC8vIFN0b3JlIHRoZSBwb3NpdGlvblJlZmVyZW5jZSBpbiBzdGF0ZSBpZiB0aGUgRE9NIHJlZmVyZW5jZSBpcyBzcGVjaWZpZWQgZXh0ZXJuYWxseSB2aWEgdGhlXG4gICAgLy8gYGVsZW1lbnRzLnJlZmVyZW5jZWAgb3B0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCBpdCB3b24ndCBiZSBvdmVycmlkZGVuIG9uIGZ1dHVyZSByZW5kZXJzLlxuICAgIF9zZXRQb3NpdGlvblJlZmVyZW5jZShjb21wdXRlZFBvc2l0aW9uUmVmZXJlbmNlKTtcbiAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShjb21wdXRlZFBvc2l0aW9uUmVmZXJlbmNlKTtcbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKGlzRWxlbWVudChub2RlKSB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICBkb21SZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBzZXREb21SZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHBhc3NpbmcgYSB2aXJ0dWFsIGVsZW1lbnQgdG8gYHJlZmVyZW5jZWBcbiAgICAvLyBhZnRlciBpdCBoYXMgc2V0IHRoZSBET00gcmVmZXJlbmNlLlxuICAgIGlmIChpc0VsZW1lbnQocG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCkgfHwgcG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCA9PT0gbnVsbCB8fFxuICAgIC8vIERvbid0IGFsbG93IHNldHRpbmcgdmlydHVhbCBlbGVtZW50cyB1c2luZyB0aGUgb2xkIHRlY2huaXF1ZSBiYWNrIHRvXG4gICAgLy8gYG51bGxgIHRvIHN1cHBvcnQgYHBvc2l0aW9uUmVmZXJlbmNlYCArIGFuIHVuc3RhYmxlIGByZWZlcmVuY2VgXG4gICAgLy8gY2FsbGJhY2sgcmVmLlxuICAgIG5vZGUgIT09IG51bGwgJiYgIWlzRWxlbWVudChub2RlKSkge1xuICAgICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuICB9LCBbcG9zaXRpb24ucmVmc10pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLnJlZnMsXG4gICAgc2V0UmVmZXJlbmNlLFxuICAgIHNldFBvc2l0aW9uUmVmZXJlbmNlLFxuICAgIGRvbVJlZmVyZW5jZTogZG9tUmVmZXJlbmNlUmVmXG4gIH0pLCBbcG9zaXRpb24ucmVmcywgc2V0UmVmZXJlbmNlLCBzZXRQb3NpdGlvblJlZmVyZW5jZV0pO1xuICBjb25zdCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5lbGVtZW50cyxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVxuICB9KSwgW3Bvc2l0aW9uLmVsZW1lbnRzLCBkb21SZWZlcmVuY2VdKTtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbixcbiAgICAuLi5yb290Q29udGV4dCxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIG5vZGVJZFxuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgbm9kZUlkLCByb290Q29udGV4dF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcm9vdENvbnRleHQuZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29uc3Qgbm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIGNvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50c1xuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgY29udGV4dF0pO1xufVxuXG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIHRoZSByZWZlcmVuY2UgZWxlbWVudCBoYXMgZm9jdXMsIGxpa2UgQ1NTXG4gKiBgOmZvY3VzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGb2N1c1xuICovXG5mdW5jdGlvbiB1c2VGb2N1cyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgdmlzaWJsZU9ubHkgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYmxvY2tGb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qga2V5Ym9hcmRNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudHMuZG9tUmVmZXJlbmNlKTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2Ugd2FzIGZvY3VzZWQgYW5kIHRoZSB1c2VyIGxlZnQgdGhlIHRhYi93aW5kb3csIGFuZCB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IHdhcyBub3Qgb3BlbiwgdGhlIGZvY3VzIHNob3VsZCBiZSBibG9ja2VkIHdoZW4gdGhleVxuICAgIC8vIHJldHVybiB0byB0aGUgdGFiL3dpbmRvdy5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoIW9wZW4gJiYgaXNIVE1MRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpICYmIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSA9PT0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpKSkge1xuICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbktleURvd24oKSB7XG4gICAgICBrZXlib2FyZE1vZGFsaXR5UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgfTtcbiAgfSwgW2VsZW1lbnRzLmRvbVJlZmVyZW5jZSwgb3BlbiwgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICByZWFzb25cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ3JlZmVyZW5jZS1wcmVzcycgfHwgcmVhc29uID09PSAnZXNjYXBlLWtleScpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2V2ZW50cywgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkgcmV0dXJuO1xuICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIGlmIChibG9ja0ZvY3VzUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICBpZiAodmlzaWJsZU9ubHkgJiYgaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNYWMgU2FmYXJpIHVucmVsaWFibHkgbWF0Y2hlcyBgOmZvY3VzLXZpc2libGVgIG9uIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAvLyBpZiBmb2N1cyB3YXMgb3V0c2lkZSB0aGUgcGFnZSBpbml0aWFsbHkgLSB1c2UgdGhlIGZhbGxiYWNrXG4gICAgICAgICAgLy8gaW5zdGVhZC5cbiAgICAgICAgICBpZiAoaXNTYWZhcmkoKSAmJiBpc01hYygpKSB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIGlmICghdGFyZ2V0Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJykpIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIE9sZCBicm93c2VycyB3aWxsIHRocm93IGFuIGVycm9yIHdoZW4gdXNpbmcgYDpmb2N1cy12aXNpYmxlYC5cbiAgICAgICAgICBpZiAoIWtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCAmJiAhaXNUeXBlYWJsZUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnZm9jdXMnKTtcbiAgICB9LFxuICAgIG9uQmx1cihldmVudCkge1xuICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG5cbiAgICAgIC8vIEhpdCB0aGUgbm9uLW1vZGFsIGZvY3VzIG1hbmFnZW1lbnQgcG9ydGFsIGd1YXJkLiBGb2N1cyB3aWxsIGJlXG4gICAgICAvLyBtb3ZlZCBpbnRvIHRoZSBmbG9hdGluZyBlbGVtZW50IGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgICAgY29uc3QgbW92ZWRUb0ZvY3VzR3VhcmQgPSBpc0VsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpKSAmJiByZWxhdGVkVGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJykgPT09ICdvdXRzaWRlJztcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHdpbmRvdyBibHVyIGxpc3RlbmVyIHRvIGZpcmUuXG4gICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZhciBfZGF0YVJlZiRjdXJyZW50JGZsb2E7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UgPyBlbGVtZW50cy5kb21SZWZlcmVuY2Uub3duZXJEb2N1bWVudCA6IGRvY3VtZW50KTtcblxuICAgICAgICAvLyBGb2N1cyBsZWZ0IHRoZSBwYWdlLCBrZWVwIGl0IG9wZW4uXG4gICAgICAgIGlmICghcmVsYXRlZFRhcmdldCAmJiBhY3RpdmVFbCA9PT0gZWxlbWVudHMuZG9tUmVmZXJlbmNlKSByZXR1cm47XG5cbiAgICAgICAgLy8gV2hlbiBmb2N1c2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKGUuZy4gcmVndWxhciBjbGljayksIHRoZW5cbiAgICAgICAgLy8gY2xpY2tpbmcgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCwgcHJldmVudCBpdCBmcm9tIGhpZGluZy5cbiAgICAgICAgLy8gTm90ZTogaXQgbXVzdCBiZSBmb2N1c2FibGUsIGUuZy4gYHRhYmluZGV4PVwiLTFcImAuXG4gICAgICAgIC8vIFdlIGNhbiBub3QgcmVseSBvbiByZWxhdGVkVGFyZ2V0IHRvIHBvaW50IHRvIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgLy8gYXMgaXQgd2lsbCBvbmx5IHBvaW50IHRvIHRoZSBzaGFkb3cgaG9zdCBvZiB0aGUgbmV3bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgIC8vIGFuZCBub3QgdGhlIGVsZW1lbnQgdGhhdCBhY3R1YWxseSBoYXMgcmVjZWl2ZWQgZm9jdXMgaWYgaXQgaXMgbG9jYXRlZFxuICAgICAgICAvLyBpbnNpZGUgYSBzaGFkb3cgcm9vdC5cbiAgICAgICAgaWYgKGNvbnRhaW5zKChfZGF0YVJlZiRjdXJyZW50JGZsb2EgPSBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRmbG9hLnJlZnMuZmxvYXRpbmcuY3VycmVudCwgYWN0aXZlRWwpIHx8IGNvbnRhaW5zKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgYWN0aXZlRWwpIHx8IG1vdmVkVG9Gb2N1c0d1YXJkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgbmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KSwgW2RhdGFSZWYsIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgb25PcGVuQ2hhbmdlLCB2aXNpYmxlT25seV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZVxuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2VdKTtcbn1cblxuY29uc3QgQUNUSVZFX0tFWSA9ICdhY3RpdmUnO1xuY29uc3QgU0VMRUNURURfS0VZID0gJ3NlbGVjdGVkJztcbmZ1bmN0aW9uIG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsIGVsZW1lbnRLZXkpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBpc0l0ZW0gPSBlbGVtZW50S2V5ID09PSAnaXRlbSc7XG4gIGxldCBkb21Vc2VyUHJvcHMgPSB1c2VyUHJvcHM7XG4gIGlmIChpc0l0ZW0gJiYgdXNlclByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgW0FDVElWRV9LRVldOiBfLFxuICAgICAgW1NFTEVDVEVEX0tFWV06IF9fLFxuICAgICAgLi4udmFsaWRQcm9wc1xuICAgIH0gPSB1c2VyUHJvcHM7XG4gICAgZG9tVXNlclByb3BzID0gdmFsaWRQcm9wcztcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLihlbGVtZW50S2V5ID09PSAnZmxvYXRpbmcnICYmIHtcbiAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgIFtGT0NVU0FCTEVfQVRUUklCVVRFXTogJydcbiAgICB9KSxcbiAgICAuLi5kb21Vc2VyUHJvcHMsXG4gICAgLi4ucHJvcHNMaXN0Lm1hcCh2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBwcm9wc09yR2V0UHJvcHMgPSB2YWx1ZSA/IHZhbHVlW2VsZW1lbnRLZXldIDogbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNPckdldFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB1c2VyUHJvcHMgPyBwcm9wc09yR2V0UHJvcHModXNlclByb3BzKSA6IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcHNPckdldFByb3BzO1xuICAgIH0pLmNvbmNhdCh1c2VyUHJvcHMpLnJlZHVjZSgoYWNjLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmVudHJpZXMocHJvcHMpLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgICBpZiAoaXNJdGVtICYmIFtBQ1RJVkVfS0VZLCBTRUxFQ1RFRF9LRVldLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdvbicpID09PSAwKSB7XG4gICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgICAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCB8fCBfbWFwJGdldC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGFjY1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAoX21hcCRnZXQyID0gbWFwLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX21hcCRnZXQyLm1hcChmbiA9PiBmbiguLi5hcmdzKSkuZmluZCh2YWwgPT4gdmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KVxuICB9O1xufVxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgaW50ZXJhY3Rpb24gaG9va3MnIHByb3BzIGludG8gcHJvcCBnZXR0ZXJzLCBhbGxvd2luZ1xuICogZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdG8gYmUgY29tcG9zZWQgdG9nZXRoZXIgd2l0aG91dCBvdmVyd3JpdGluZyBvbmVcbiAqIGFub3RoZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSW50ZXJhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVyYWN0aW9ucyhwcm9wc0xpc3QpIHtcbiAgaWYgKHByb3BzTGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHNMaXN0ID0gW107XG4gIH1cbiAgY29uc3QgcmVmZXJlbmNlRGVwcyA9IHByb3BzTGlzdC5tYXAoa2V5ID0+IGtleSA9PSBudWxsID8gdm9pZCAwIDoga2V5LnJlZmVyZW5jZSk7XG4gIGNvbnN0IGZsb2F0aW5nRGVwcyA9IHByb3BzTGlzdC5tYXAoa2V5ID0+IGtleSA9PSBudWxsID8gdm9pZCAwIDoga2V5LmZsb2F0aW5nKTtcbiAgY29uc3QgaXRlbURlcHMgPSBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5pdGVtKTtcbiAgY29uc3QgZ2V0UmVmZXJlbmNlUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ3JlZmVyZW5jZScpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIHJlZmVyZW5jZURlcHMpO1xuICBjb25zdCBnZXRGbG9hdGluZ1Byb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdmbG9hdGluZycpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIGZsb2F0aW5nRGVwcyk7XG4gIGNvbnN0IGdldEl0ZW1Qcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnaXRlbScpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIGl0ZW1EZXBzKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBnZXRSZWZlcmVuY2VQcm9wcyxcbiAgICBnZXRGbG9hdGluZ1Byb3BzLFxuICAgIGdldEl0ZW1Qcm9wc1xuICB9KSwgW2dldFJlZmVyZW5jZVByb3BzLCBnZXRGbG9hdGluZ1Byb3BzLCBnZXRJdGVtUHJvcHNdKTtcbn1cblxubGV0IGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKSB7XG4gIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICByZXR1cm4gdmVydGljYWw7XG4gICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICByZXR1cm4gaG9yaXpvbnRhbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZlcnRpY2FsIHx8IGhvcml6b250YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWFpbk9yaWVudGF0aW9uS2V5KGtleSwgb3JpZW50YXRpb24pIHtcbiAgY29uc3QgdmVydGljYWwgPSBrZXkgPT09IEFSUk9XX1VQIHx8IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfTEVGVCB8fCBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICBjb25zdCBob3Jpem9udGFsID0gcnRsID8ga2V5ID09PSBBUlJPV19MRUZUIDoga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkgfHwga2V5ID09PSAnRW50ZXInIHx8IGtleSA9PT0gJyAnIHx8IGtleSA9PT0gJyc7XG59XG5mdW5jdGlvbiBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0RPV047XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0gcnRsID8ga2V5ID09PSBBUlJPV19SSUdIVCA6IGtleSA9PT0gQVJST1dfTEVGVDtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfVVA7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuLyoqXG4gKiBBZGRzIGFycm93IGtleS1iYXNlZCBuYXZpZ2F0aW9uIG9mIGEgbGlzdCBvZiBpdGVtcywgZWl0aGVyIHVzaW5nIHJlYWwgRE9NXG4gKiBmb2N1cyBvciB2aXJ0dWFsIGZvY3VzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUxpc3ROYXZpZ2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uKGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogdW5zdGFibGVfb25OYXZpZ2F0ZSA9ICgpID0+IHt9LFxuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsLFxuICAgIGFsbG93RXNjYXBlID0gZmFsc2UsXG4gICAgbG9vcCA9IGZhbHNlLFxuICAgIG5lc3RlZCA9IGZhbHNlLFxuICAgIHJ0bCA9IGZhbHNlLFxuICAgIHZpcnR1YWwgPSBmYWxzZSxcbiAgICBmb2N1c0l0ZW1Pbk9wZW4gPSAnYXV0bycsXG4gICAgZm9jdXNJdGVtT25Ib3ZlciA9IHRydWUsXG4gICAgb3Blbk9uQXJyb3dLZXlEb3duID0gdHJ1ZSxcbiAgICBkaXNhYmxlZEluZGljZXMgPSB1bmRlZmluZWQsXG4gICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnLFxuICAgIGNvbHMgPSAxLFxuICAgIHNjcm9sbEl0ZW1JbnRvVmlldyA9IHRydWUsXG4gICAgdmlydHVhbEl0ZW1SZWYsXG4gICAgaXRlbVNpemVzLFxuICAgIGRlbnNlID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGFsbG93RXNjYXBlKSB7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgd2FybignYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdyBlc2NhcGluZy4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICB3YXJuKCdgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdyBlc2NhcGluZy4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIGNvbHMgPiAxKSB7XG4gICAgICB3YXJuKCdJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlIGBvcmllbnRhdGlvbmAgc2hvdWxkJywgJ2JlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmxvYXRpbmdGb2N1c0VsZW1lbnQgPSBnZXRGbG9hdGluZ0ZvY3VzRWxlbWVudChlbGVtZW50cy5mbG9hdGluZyk7XG4gIGNvbnN0IGZsb2F0aW5nRm9jdXNFbGVtZW50UmVmID0gdXNlTGF0ZXN0UmVmKGZsb2F0aW5nRm9jdXNFbGVtZW50KTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vbk5hdmlnYXRlKTtcbiAgY29uc3QgdHlwZWFibGVDb21ib2JveFJlZmVyZW5jZSA9IGlzVHlwZWFibGVDb21ib2JveChlbGVtZW50cy5kb21SZWZlcmVuY2UpO1xuICBjb25zdCBmb2N1c0l0ZW1Pbk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoZm9jdXNJdGVtT25PcGVuKTtcbiAgY29uc3QgaW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IC0xKTtcbiAgY29uc3Qga2V5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc1BvaW50ZXJNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcHJldmlvdXNPbk5hdmlnYXRlUmVmID0gUmVhY3QudXNlUmVmKG9uTmF2aWdhdGUpO1xuICBjb25zdCBwcmV2aW91c01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoISFlbGVtZW50cy5mbG9hdGluZyk7XG4gIGNvbnN0IHByZXZpb3VzT3BlblJlZiA9IFJlYWN0LnVzZVJlZihvcGVuKTtcbiAgY29uc3QgZm9yY2VTeW5jRm9jdXMgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBmb3JjZVNjcm9sbEludG9WaWV3UmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZGlzYWJsZWRJbmRpY2VzUmVmID0gdXNlTGF0ZXN0UmVmKGRpc2FibGVkSW5kaWNlcyk7XG4gIGNvbnN0IGxhdGVzdE9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHNjcm9sbEl0ZW1JbnRvVmlld1JlZiA9IHVzZUxhdGVzdFJlZihzY3JvbGxJdGVtSW50b1ZpZXcpO1xuICBjb25zdCBzZWxlY3RlZEluZGV4UmVmID0gdXNlTGF0ZXN0UmVmKHNlbGVjdGVkSW5kZXgpO1xuICBjb25zdCBbYWN0aXZlSWQsIHNldEFjdGl2ZUlkXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IFt2aXJ0dWFsSWQsIHNldFZpcnR1YWxJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBmb2N1c0l0ZW0gPSB1c2VFZmZlY3RFdmVudChmdW5jdGlvbiAobGlzdFJlZiwgaW5kZXhSZWYsIGZvcmNlU2Nyb2xsSW50b1ZpZXcpIHtcbiAgICBpZiAoZm9yY2VTY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JjZVNjcm9sbEludG9WaWV3ID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bkZvY3VzKGl0ZW0pIHtcbiAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgIHNldEFjdGl2ZUlkKGl0ZW0uaWQpO1xuICAgICAgICB0cmVlID09IG51bGwgfHwgdHJlZS5ldmVudHMuZW1pdCgndmlydHVhbGZvY3VzJywgaXRlbSk7XG4gICAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoaXRlbSwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWUsXG4gICAgICAgICAgLy8gTWFjIFNhZmFyaSBkb2VzIG5vdCBtb3ZlIHRoZSB2aXJ0dWFsIGN1cnNvciB1bmxlc3MgdGhlIGZvY3VzIGNhbGxcbiAgICAgICAgICAvLyBpcyBzeW5jLiBIb3dldmVyLCBmb3IgdGhlIHZlcnkgZmlyc3QgZm9jdXMgY2FsbCwgd2UgbmVlZCB0byB3YWl0XG4gICAgICAgICAgLy8gZm9yIHRoZSBwb3NpdGlvbiB0byBiZSByZWFkeSBpbiBvcmRlciB0byBwcmV2ZW50IHVud2FudGVkXG4gICAgICAgICAgLy8gc2Nyb2xsaW5nLiBUaGlzIG1lYW5zIHRoZSB2aXJ0dWFsIGN1cnNvciB3aWxsIG5vdCBtb3ZlIHRvIHRoZSBmaXJzdFxuICAgICAgICAgIC8vIGl0ZW0gd2hlbiBmaXJzdCBvcGVuaW5nIHRoZSBmbG9hdGluZyBlbGVtZW50LCBidXQgd2lsbCBvblxuICAgICAgICAgIC8vIHN1YnNlcXVlbnQgY2FsbHMuIGBwcmV2ZW50U2Nyb2xsYCBpcyBzdXBwb3J0ZWQgaW4gbW9kZXJuIFNhZmFyaSxcbiAgICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICAvLyBpT1MgU2FmYXJpIG11c3QgYmUgYXN5bmMgb3IgdGhlIGZpcnN0IGl0ZW0gd2lsbCBub3QgYmUgZm9jdXNlZC5cbiAgICAgICAgICBzeW5jOiBpc01hYygpICYmIGlzU2FmYXJpKCkgPyBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgfHwgZm9yY2VTeW5jRm9jdXMuY3VycmVudCA6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbml0aWFsSXRlbSA9IGxpc3RSZWYuY3VycmVudFtpbmRleFJlZi5jdXJyZW50XTtcbiAgICBpZiAoaW5pdGlhbEl0ZW0pIHtcbiAgICAgIHJ1bkZvY3VzKGluaXRpYWxJdGVtKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IHdhaXRlZEl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhSZWYuY3VycmVudF0gfHwgaW5pdGlhbEl0ZW07XG4gICAgICBpZiAoIXdhaXRlZEl0ZW0pIHJldHVybjtcbiAgICAgIGlmICghaW5pdGlhbEl0ZW0pIHtcbiAgICAgICAgcnVuRm9jdXMod2FpdGVkSXRlbSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JvbGxJbnRvVmlld09wdGlvbnMgPSBzY3JvbGxJdGVtSW50b1ZpZXdSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHNob3VsZFNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXdPcHRpb25zICYmIGl0ZW0gJiYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgfHwgIWlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKHNob3VsZFNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIC8vIEpTRE9NIGRvZXNuJ3Qgc3VwcG9ydCBgLnNjcm9sbEludG9WaWV3KClgIGJ1dCBpdCdzIHdpZGVseSBzdXBwb3J0ZWRcbiAgICAgICAgLy8gYnkgYWxsIGJyb3dzZXJzLlxuICAgICAgICB3YWl0ZWRJdGVtLnNjcm9sbEludG9WaWV3ID09IG51bGwgfHwgd2FpdGVkSXRlbS5zY3JvbGxJbnRvVmlldyh0eXBlb2Ygc2Nyb2xsSW50b1ZpZXdPcHRpb25zID09PSAnYm9vbGVhbicgPyB7XG4gICAgICAgICAgYmxvY2s6ICduZWFyZXN0JyxcbiAgICAgICAgICBpbmxpbmU6ICduZWFyZXN0J1xuICAgICAgICB9IDogc2Nyb2xsSW50b1ZpZXdPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5mb2N1cyh7XG4gICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgLy8gU3luYyBgc2VsZWN0ZWRJbmRleGAgdG8gYmUgdGhlIGBhY3RpdmVJbmRleGAgdXBvbiBvcGVuaW5nIHRoZSBmbG9hdGluZ1xuICAvLyBlbGVtZW50LiBBbHNvLCByZXNldCBgYWN0aXZlSW5kZXhgIHVwb24gY2xvc2luZyB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmIChvcGVuICYmIGVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICBpZiAoZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgdGhlIHBvaW50ZXIgbW9kYWxpdHksIHdlIHdhbnQgdG8gZW5zdXJlIHRoZSBzZWxlY3RlZFxuICAgICAgICAvLyBpdGVtIGNvbWVzIGludG8gdmlldyB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW5lZC5cbiAgICAgICAgZm9yY2VTY3JvbGxJbnRvVmlld1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoc2VsZWN0ZWRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgLy8gU2luY2UgdGhlIHVzZXIgY2FuIHNwZWNpZnkgYG9uTmF2aWdhdGVgIGNvbmRpdGlvbmFsbHlcbiAgICAgIC8vIChvbk5hdmlnYXRlOiBvcGVuID8gc2V0QWN0aXZlSW5kZXggOiBzZXRTZWxlY3RlZEluZGV4KSxcbiAgICAgIC8vIHdlIHN0b3JlIGFuZCBjYWxsIHRoZSBwcmV2aW91cyBmdW5jdGlvbi5cbiAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50KG51bGwpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBzZWxlY3RlZEluZGV4LCBvbk5hdmlnYXRlXSk7XG5cbiAgLy8gU3luYyBgYWN0aXZlSW5kZXhgIHRvIGJlIHRoZSBmb2N1c2VkIGl0ZW0gd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAgLy8gb3Blbi5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmIChvcGVuICYmIGVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4UmVmLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdhcyBvcGVuIChlLmcuIHRoZSBsaXN0IGNoYW5nZWQpLlxuICAgICAgICBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWwgc3luYy5cbiAgICAgICAgaWYgKCghcHJldmlvdXNPcGVuUmVmLmN1cnJlbnQgfHwgIXByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSAmJiBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiAoa2V5UmVmLmN1cnJlbnQgIT0gbnVsbCB8fCBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9PT0gdHJ1ZSAmJiBrZXlSZWYuY3VycmVudCA9PSBudWxsKSkge1xuICAgICAgICAgIGxldCBydW5zID0gMDtcbiAgICAgICAgICBjb25zdCB3YWl0Rm9yTGlzdFBvcHVsYXRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChsaXN0UmVmLmN1cnJlbnRbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBsZXR0aW5nIHRoZSBicm93c2VyIHBhaW50IGlmIHBvc3NpYmxlIG9uIHRoZSBmaXJzdCB0cnksXG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgckFGLiBEb24ndCB0cnkgbW9yZSB0aGFuIHR3aWNlLCBzaW5jZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgLy8gaXMgd3Jvbmcgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICBpZiAocnVucyA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlZHVsZXIgPSBydW5zID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogcXVldWVNaWNyb3Rhc2s7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyKHdhaXRGb3JMaXN0UG9wdWxhdGVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBydW5zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0ga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCB8fCBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleVJlZi5jdXJyZW50LCBvcmllbnRhdGlvbiwgcnRsKSB8fCBuZXN0ZWQgPyBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCkgOiBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHdhaXRGb3JMaXN0UG9wdWxhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBhY3RpdmVJbmRleCkpIHtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGFjdGl2ZUluZGV4O1xuICAgICAgICBmb2N1c0l0ZW0obGlzdFJlZiwgaW5kZXhSZWYsIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCk7XG4gICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVJbmRleCwgc2VsZWN0ZWRJbmRleFJlZiwgbmVzdGVkLCBsaXN0UmVmLCBvcmllbnRhdGlvbiwgcnRsLCBvbk5hdmlnYXRlLCBmb2N1c0l0ZW0sIGRpc2FibGVkSW5kaWNlc1JlZl0pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGFyZW50IGZsb2F0aW5nIGVsZW1lbnQgaGFzIGZvY3VzIHdoZW4gYSBuZXN0ZWQgY2hpbGQgY2xvc2VzXG4gIC8vIHRvIGFsbG93IGFycm93IGtleSBuYXZpZ2F0aW9uIHRvIHdvcmsgYWZ0ZXIgdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSBjaGlsZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIHZhciBfbm9kZXMkZmluZDtcbiAgICBpZiAoIWVuYWJsZWQgfHwgZWxlbWVudHMuZmxvYXRpbmcgfHwgIXRyZWUgfHwgdmlydHVhbCB8fCAhcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSB0cmVlLm5vZGVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFyZW50ID0gKF9ub2RlcyRmaW5kID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IHBhcmVudElkKSkgPT0gbnVsbCB8fCAoX25vZGVzJGZpbmQgPSBfbm9kZXMkZmluZC5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQuZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgY29uc3QgYWN0aXZlRWwgPSBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgY29uc3QgdHJlZUNvbnRhaW5zQWN0aXZlRWwgPSBub2Rlcy5zb21lKG5vZGUgPT4gbm9kZS5jb250ZXh0ICYmIGNvbnRhaW5zKG5vZGUuY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgYWN0aXZlRWwpKTtcbiAgICBpZiAocGFyZW50ICYmICF0cmVlQ29udGFpbnNBY3RpdmVFbCAmJiBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KSB7XG4gICAgICBwYXJlbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBlbGVtZW50cy5mbG9hdGluZywgdHJlZSwgcGFyZW50SWQsIHZpcnR1YWxdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmICghdHJlZSkgcmV0dXJuO1xuICAgIGlmICghdmlydHVhbCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnRJZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVZpcnR1YWxGb2N1cyhpdGVtKSB7XG4gICAgICBzZXRWaXJ0dWFsSWQoaXRlbS5pZCk7XG4gICAgICBpZiAodmlydHVhbEl0ZW1SZWYpIHtcbiAgICAgICAgdmlydHVhbEl0ZW1SZWYuY3VycmVudCA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICAgIHRyZWUuZXZlbnRzLm9uKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0cmVlLmV2ZW50cy5vZmYoJ3ZpcnR1YWxmb2N1cycsIGhhbmRsZVZpcnR1YWxGb2N1cyk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHRyZWUsIHZpcnR1YWwsIHBhcmVudElkLCB2aXJ0dWFsSXRlbVJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcHJldmlvdXNPbk5hdmlnYXRlUmVmLmN1cnJlbnQgPSBvbk5hdmlnYXRlO1xuICAgIHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50ID0gISFlbGVtZW50cy5mbG9hdGluZztcbiAgfSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIGtleVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBwcmV2aW91c09wZW5SZWYuY3VycmVudCA9IG9wZW47XG4gIH0sIFtvcGVuXSk7XG4gIGNvbnN0IGhhc0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggIT0gbnVsbDtcbiAgY29uc3QgaXRlbSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIGlmICghb3BlbikgcmV0dXJuO1xuICAgICAgY29uc3QgaW5kZXggPSBsaXN0UmVmLmN1cnJlbnQuaW5kZXhPZihjdXJyZW50VGFyZ2V0KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgb25Gb2N1cyhfcmVmKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICB9LFxuICAgICAgb25DbGljazogX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gY3VycmVudFRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBTYWZhcmlcbiAgICAgIC4uLihmb2N1c0l0ZW1PbkhvdmVyICYmIHtcbiAgICAgICAgb25Nb3VzZU1vdmUoX3JlZjMpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICAgIH0gPSBfcmVmMztcbiAgICAgICAgICBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTGVhdmUoX3JlZjQpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgICAgaWYgKCFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50IHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgICBmb2N1c0l0ZW0obGlzdFJlZiwgaW5kZXhSZWYpO1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZmxvYXRpbmdGb2N1c0VsZW1lbnRSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0sIFtvcGVuLCBmbG9hdGluZ0ZvY3VzRWxlbWVudFJlZiwgZm9jdXNJdGVtLCBmb2N1c0l0ZW1PbkhvdmVyLCBsaXN0UmVmLCBvbk5hdmlnYXRlLCB2aXJ0dWFsXSk7XG4gIGNvbnN0IGNvbW1vbk9uS2V5RG93biA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgZm9yY2VTeW5jRm9jdXMuY3VycmVudCA9IHRydWU7XG5cbiAgICAvLyBXaGVuIGNvbXBvc2luZyBhIGNoYXJhY3RlciwgQ2hyb21lIGZpcmVzIEFycm93RG93biB0d2ljZS4gRmlyZWZveC9TYWZhcmlcbiAgICAvLyBkb24ndCBhcHBlYXIgdG8gc3VmZmVyIGZyb20gdGhpcy4gYGV2ZW50LmlzQ29tcG9zaW5nYCBpcyBhdm9pZGVkIGR1ZSB0b1xuICAgIC8vIFNhZmFyaSBub3Qgc3VwcG9ydGluZyBpdCBwcm9wZXJseSAoYWx0aG91Z2ggaXQncyBub3QgbmVlZGVkIGluIHRoZSBmaXJzdFxuICAgIC8vIHBsYWNlIGZvciBTYWZhcmksIGp1c3QgYXZvaWRpbmcgYW55IHBvc3NpYmxlIGlzc3VlcykuXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAyMjkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhbmltYXRpbmcgb3V0LCBpZ25vcmUgbmF2aWdhdGlvbi4gT3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBgYWN0aXZlSW5kZXhgIGdldHMgc2V0IHRvIDAgZGVzcGl0ZSBub3QgYmVpbmcgb3BlbiBzbyB0aGUgbmV4dCB0aW1lXG4gICAgLy8gdGhlIHVzZXIgQXJyb3dEb3ducywgdGhlIGZpcnN0IGl0ZW0gd29uJ3QgYmUgZm9jdXNlZC5cbiAgICBpZiAoIWxhdGVzdE9wZW5SZWYuY3VycmVudCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSBmbG9hdGluZ0ZvY3VzRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXN0ZWQgJiYgaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgaWYgKHZpcnR1YWwpIHtcbiAgICAgICAgICB0cmVlID09IG51bGwgfHwgdHJlZS5ldmVudHMuZW1pdCgndmlydHVhbGZvY3VzJywgZWxlbWVudHMuZG9tUmVmZXJlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5kb21SZWZlcmVuY2UuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSBpbmRleFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IG1pbkluZGV4ID0gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgaWYgKCF0eXBlYWJsZUNvbWJvYm94UmVmZXJlbmNlKSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnSG9tZScpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1pbkluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdyaWQgbmF2aWdhdGlvbi5cbiAgICBpZiAoY29scyA+IDEpIHtcbiAgICAgIGNvbnN0IHNpemVzID0gaXRlbVNpemVzIHx8IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IGxpc3RSZWYuY3VycmVudC5sZW5ndGhcbiAgICAgIH0sICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDFcbiAgICAgIH0pKTtcbiAgICAgIC8vIFRvIGNhbGN1bGF0ZSBtb3ZlbWVudHMgb24gdGhlIGdyaWQsIHdlIHVzZSBoeXBvdGhldGljYWwgY2VsbCBpbmRpY2VzXG4gICAgICAvLyBhcyBpZiBldmVyeSBpdGVtIHdhcyAxeDEsIHRoZW4gY29udmVydCBiYWNrIHRvIHJlYWwgaW5kaWNlcy5cbiAgICAgIGNvbnN0IGNlbGxNYXAgPSBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgIGNvbnN0IG1pbkdyaWRJbmRleCA9IGNlbGxNYXAuZmluZEluZGV4KGluZGV4ID0+IGluZGV4ICE9IG51bGwgJiYgIWlzRGlzYWJsZWQobGlzdFJlZi5jdXJyZW50LCBpbmRleCwgZGlzYWJsZWRJbmRpY2VzKSk7XG4gICAgICAvLyBsYXN0IGVuYWJsZWQgaW5kZXhcbiAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICFpc0Rpc2FibGVkKGxpc3RSZWYuY3VycmVudCwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICBjb25zdCBpbmRleCA9IGNlbGxNYXBbZ2V0R3JpZE5hdmlnYXRlZEluZGV4KHtcbiAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCAhPSBudWxsID8gbGlzdFJlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgfSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIHJ0bCxcbiAgICAgICAgY29scyxcbiAgICAgICAgLy8gdHJlYXQgdW5kZWZpbmVkIChlbXB0eSBncmlkIHNwYWNlcykgYXMgZGlzYWJsZWQgaW5kaWNlcyBzbyB3ZVxuICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICBkaXNhYmxlZEluZGljZXM6IGdldENlbGxJbmRpY2VzKFsuLi4oZGlzYWJsZWRJbmRpY2VzIHx8IGxpc3RSZWYuY3VycmVudC5tYXAoKF8sIGluZGV4KSA9PiBpc0Rpc2FibGVkKGxpc3RSZWYuY3VycmVudCwgaW5kZXgpID8gaW5kZXggOiB1bmRlZmluZWQpKSwgdW5kZWZpbmVkXSwgY2VsbE1hcCksXG4gICAgICAgIG1pbkluZGV4OiBtaW5HcmlkSW5kZXgsXG4gICAgICAgIG1heEluZGV4OiBtYXhHcmlkSW5kZXgsXG4gICAgICAgIHByZXZJbmRleDogZ2V0Q2VsbEluZGV4T2ZDb3JuZXIoaW5kZXhSZWYuY3VycmVudCA+IG1heEluZGV4ID8gbWluSW5kZXggOiBpbmRleFJlZi5jdXJyZW50LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgLy8gdXNlIGEgY29ybmVyIG1hdGNoaW5nIHRoZSBlZGdlIGNsb3Nlc3QgdG8gdGhlIGRpcmVjdGlvblxuICAgICAgICAvLyB3ZSdyZSBtb3ZpbmcgaW4gc28gd2UgZG9uJ3QgZW5kIHVwIGluIHRoZSBzYW1lIGl0ZW0uIFByZWZlclxuICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgZXZlbnQua2V5ID09PSBBUlJPV19ET1dOID8gJ2JsJyA6IGV2ZW50LmtleSA9PT0gKHJ0bCA/IEFSUk9XX0xFRlQgOiBBUlJPV19SSUdIVCkgPyAndHInIDogJ3RsJyksXG4gICAgICAgIHN0b3BFdmVudDogdHJ1ZVxuICAgICAgfSldO1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNNYWluT3JpZW50YXRpb25LZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbikpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBpbmRleCBpZiBubyBpdGVtIGlzIGZvY3VzZWQuXG4gICAgICBpZiAob3BlbiAmJiAhdmlydHVhbCAmJiBhY3RpdmVFbGVtZW50KGV2ZW50LmN1cnJlbnRUYXJnZXQub3duZXJEb2N1bWVudCkgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSA/IG1pbkluZGV4IDogbWF4SW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkpIHtcbiAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4ID49IG1heEluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoID8gLTEgOiBtaW5JbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBNYXRoLm1pbihtYXhJbmRleCwgZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPD0gbWluSW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IC0xID8gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA6IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWF4KG1pbkluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgaW5kZXhSZWYuY3VycmVudCkpIHtcbiAgICAgICAgb25OYXZpZ2F0ZShudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3QgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHZpcnR1YWwgJiYgb3BlbiAmJiBoYXNBY3RpdmVJbmRleCAmJiB7XG4gICAgICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogdmlydHVhbElkIHx8IGFjdGl2ZUlkXG4gICAgfTtcbiAgfSwgW3ZpcnR1YWwsIG9wZW4sIGhhc0FjdGl2ZUluZGV4LCB2aXJ0dWFsSWQsIGFjdGl2ZUlkXSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgICAgLi4uKCFpc1R5cGVhYmxlQ29tYm9ib3goZWxlbWVudHMuZG9tUmVmZXJlbmNlKSAmJiBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3ApLFxuICAgICAgb25LZXlEb3duOiBjb21tb25PbktleURvd24sXG4gICAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wLCBjb21tb25PbktleURvd24sIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgb3JpZW50YXRpb25dKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gY2hlY2tWaXJ0dWFsTW91c2UoZXZlbnQpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW4gPT09ICdhdXRvJyAmJiBpc1ZpcnR1YWxDbGljayhldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxQb2ludGVyKGV2ZW50KSB7XG4gICAgICAvLyBgcG9pbnRlcmRvd25gIGZpcmVzIGZpcnN0LCByZXNldCB0aGUgc3RhdGUgdGhlbiBwZXJmb3JtIHRoZSBjaGVja3MuXG4gICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IGZvY3VzSXRlbU9uT3BlbjtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW4gPT09ICdhdXRvJyAmJiBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCxcbiAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlzQXJyb3dLZXkgPSBldmVudC5rZXkuc3RhcnRzV2l0aCgnQXJyb3cnKTtcbiAgICAgICAgY29uc3QgaXNIb21lT3JFbmRLZXkgPSBbJ0hvbWUnLCAnRW5kJ10uaW5jbHVkZXMoZXZlbnQua2V5KTtcbiAgICAgICAgY29uc3QgaXNNb3ZlS2V5ID0gaXNBcnJvd0tleSB8fCBpc0hvbWVPckVuZEtleTtcbiAgICAgICAgY29uc3QgaXNDcm9zc09wZW5LZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgIGNvbnN0IGlzQ3Jvc3NDbG9zZUtleSA9IGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgIGNvbnN0IGlzTWFpbktleSA9IGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pO1xuICAgICAgICBjb25zdCBpc05hdmlnYXRpb25LZXkgPSAobmVzdGVkID8gaXNDcm9zc09wZW5LZXkgOiBpc01haW5LZXkpIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJyB8fCBldmVudC5rZXkudHJpbSgpID09PSAnJztcbiAgICAgICAgaWYgKHZpcnR1YWwgJiYgb3Blbikge1xuICAgICAgICAgIGNvbnN0IHJvb3ROb2RlID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLnBhcmVudElkID09IG51bGwpO1xuICAgICAgICAgIGNvbnN0IGRlZXBlc3ROb2RlID0gdHJlZSAmJiByb290Tm9kZSA/IGdldERlZXBlc3ROb2RlKHRyZWUubm9kZXNSZWYuY3VycmVudCwgcm9vdE5vZGUuaWQpIDogbnVsbDtcbiAgICAgICAgICBpZiAoaXNNb3ZlS2V5ICYmIGRlZXBlc3ROb2RlICYmIHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgICAgICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNDcm9zc09wZW5LZXkgfHwgaXNDcm9zc0Nsb3NlS2V5KSB7XG4gICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCwgX2RlZXBlc3ROb2RlJGNvbnRleHQyO1xuICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnRUYXJnZXQgPSAoKF9kZWVwZXN0Tm9kZSRjb250ZXh0ID0gZGVlcGVzdE5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kZWVwZXN0Tm9kZSRjb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgIGNvbnN0IGRpc3BhdGNoSXRlbSA9IGlzQ3Jvc3NDbG9zZUtleSAmJiAhaXNDdXJyZW50VGFyZ2V0ID8gKF9kZWVwZXN0Tm9kZSRjb250ZXh0MiA9IGRlZXBlc3ROb2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGVlcGVzdE5vZGUkY29udGV4dDIuZWxlbWVudHMuZG9tUmVmZXJlbmNlIDogaXNDcm9zc09wZW5LZXkgPyBsaXN0UmVmLmN1cnJlbnQuZmluZChpdGVtID0+IChpdGVtID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLmlkKSA9PT0gYWN0aXZlSWQpIDogbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoSXRlbSkge1xuICAgICAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hJdGVtLmRpc3BhdGNoRXZlbnQoZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgIHNldFZpcnR1YWxJZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGlzTWFpbktleSB8fCBpc0hvbWVPckVuZEtleSkgJiYgZGVlcGVzdE5vZGUuY29udGV4dCkge1xuICAgICAgICAgICAgICBpZiAoZGVlcGVzdE5vZGUuY29udGV4dC5vcGVuICYmIGRlZXBlc3ROb2RlLnBhcmVudElkICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IGRlZXBlc3ROb2RlLmNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kZWVwZXN0Tm9kZSRjb250ZXh0JDtcbiAgICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIChfZGVlcGVzdE5vZGUkY29udGV4dCQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT0gbnVsbCB8fCBfZGVlcGVzdE5vZGUkY29udGV4dCQuZGlzcGF0Y2hFdmVudChldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21tb25PbktleURvd24oZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBmbG9hdGluZyBlbGVtZW50IHNob3VsZCBub3Qgb3BlbiBvbiBhcnJvdyBrZXkgZG93biwgYXZvaWRcbiAgICAgICAgLy8gc2V0dGluZyBgYWN0aXZlSW5kZXhgIHdoaWxlIGl0J3MgY2xvc2VkLlxuICAgICAgICBpZiAoIW9wZW4gJiYgIW9wZW5PbkFycm93S2V5RG93biAmJiBpc0Fycm93S2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICBrZXlSZWYuY3VycmVudCA9IG5lc3RlZCAmJiBpc01haW5LZXkgPyBudWxsIDogZXZlbnQua2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNDcm9zc09wZW5LZXkpIHtcbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNYWluS2V5KSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKCFvcGVuICYmIG9wZW5PbkFycm93S2V5RG93bikge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1vbk9uS2V5RG93bihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRm9jdXMoKSB7XG4gICAgICAgIGlmIChvcGVuICYmICF2aXJ0dWFsKSB7XG4gICAgICAgICAgb25OYXZpZ2F0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUG9pbnRlckRvd246IGNoZWNrVmlydHVhbFBvaW50ZXIsXG4gICAgICBvbk1vdXNlRG93bjogY2hlY2tWaXJ0dWFsTW91c2UsXG4gICAgICBvbkNsaWNrOiBjaGVja1ZpcnR1YWxNb3VzZVxuICAgIH07XG4gIH0sIFthY3RpdmVJZCwgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wLCBjb21tb25PbktleURvd24sIGRpc2FibGVkSW5kaWNlc1JlZiwgZm9jdXNJdGVtT25PcGVuLCBsaXN0UmVmLCBuZXN0ZWQsIG9uTmF2aWdhdGUsIG9uT3BlbkNoYW5nZSwgb3Blbiwgb3Blbk9uQXJyb3dLZXlEb3duLCBvcmllbnRhdGlvbiwgcnRsLCBzZWxlY3RlZEluZGV4LCB0cmVlLCB2aXJ0dWFsLCB2aXJ0dWFsSXRlbVJlZl0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBpdGVtXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmcsIGl0ZW1dKTtcbn1cblxuY29uc3QgY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAgPSAvKiNfX1BVUkVfXyovbmV3IE1hcChbWydzZWxlY3QnLCAnbGlzdGJveCddLCBbJ2NvbWJvYm94JywgJ2xpc3Rib3gnXSwgWydsYWJlbCcsIGZhbHNlXV0pO1xuXG4vKipcbiAqIEFkZHMgYmFzZSBzY3JlZW4gcmVhZGVyIHByb3BzIHRvIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nIGVsZW1lbnRzIGZvciBhXG4gKiBnaXZlbiBmbG9hdGluZyBlbGVtZW50IGByb2xlYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VSb2xlXG4gKi9cbmZ1bmN0aW9uIHVzZVJvbGUoY29udGV4dCwgcHJvcHMpIHtcbiAgdmFyIF9jb21wb25lbnRSb2xlVG9BcmlhUjtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGZsb2F0aW5nSWRcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICByb2xlID0gJ2RpYWxvZydcbiAgfSA9IHByb3BzO1xuICBjb25zdCBhcmlhUm9sZSA9IChfY29tcG9uZW50Um9sZVRvQXJpYVIgPSBjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcC5nZXQocm9sZSkpICE9IG51bGwgPyBfY29tcG9uZW50Um9sZVRvQXJpYVIgOiByb2xlO1xuICBjb25zdCByZWZlcmVuY2VJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgaXNOZXN0ZWQgPSBwYXJlbnRJZCAhPSBudWxsO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoYXJpYVJvbGUgPT09ICd0b29sdGlwJyB8fCByb2xlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbXCJhcmlhLVwiICsgKHJvbGUgPT09ICdsYWJlbCcgPyAnbGFiZWxsZWRieScgOiAnZGVzY3JpYmVkYnknKV06IG9wZW4gPyBmbG9hdGluZ0lkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICdhcmlhLWhhc3BvcHVwJzogYXJpYVJvbGUgPT09ICdhbGVydGRpYWxvZycgPyAnZGlhbG9nJyA6IGFyaWFSb2xlLFxuICAgICAgJ2FyaWEtY29udHJvbHMnOiBvcGVuID8gZmxvYXRpbmdJZCA6IHVuZGVmaW5lZCxcbiAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ2xpc3Rib3gnICYmIHtcbiAgICAgICAgcm9sZTogJ2NvbWJvYm94J1xuICAgICAgfSksXG4gICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgIGlkOiByZWZlcmVuY2VJZFxuICAgICAgfSksXG4gICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiBpc05lc3RlZCAmJiB7XG4gICAgICAgIHJvbGU6ICdtZW51aXRlbSdcbiAgICAgIH0pLFxuICAgICAgLi4uKHJvbGUgPT09ICdzZWxlY3QnICYmIHtcbiAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ25vbmUnXG4gICAgICB9KSxcbiAgICAgIC4uLihyb2xlID09PSAnY29tYm9ib3gnICYmIHtcbiAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnXG4gICAgICB9KVxuICAgIH07XG4gIH0sIFthcmlhUm9sZSwgZmxvYXRpbmdJZCwgaXNOZXN0ZWQsIG9wZW4sIHJlZmVyZW5jZUlkLCByb2xlXSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZmxvYXRpbmdQcm9wcyA9IHtcbiAgICAgIGlkOiBmbG9hdGluZ0lkLFxuICAgICAgLi4uKGFyaWFSb2xlICYmIHtcbiAgICAgICAgcm9sZTogYXJpYVJvbGVcbiAgICAgIH0pXG4gICAgfTtcbiAgICBpZiAoYXJpYVJvbGUgPT09ICd0b29sdGlwJyB8fCByb2xlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm4gZmxvYXRpbmdQcm9wcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZsb2F0aW5nUHJvcHMsXG4gICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiByZWZlcmVuY2VJZFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbYXJpYVJvbGUsIGZsb2F0aW5nSWQsIHJlZmVyZW5jZUlkLCByb2xlXSk7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VDYWxsYmFjayhfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgc2VsZWN0ZWRcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICAgIHJvbGU6ICdvcHRpb24nLFxuICAgICAgLi4uKGFjdGl2ZSAmJiB7XG4gICAgICAgIGlkOiBmbG9hdGluZ0lkICsgXCItb3B0aW9uXCJcbiAgICAgIH0pXG4gICAgfTtcblxuICAgIC8vIEZvciBgbWVudWAsIHdlIGFyZSB1bmFibGUgdG8gdGVsbCBpZiB0aGUgaXRlbSBpcyBhIGBtZW51aXRlbXJhZGlvYFxuICAgIC8vIG9yIGBtZW51aXRlbWNoZWNrYm94YC4gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHJlYXNvbnMsIGFsc29cbiAgICAvLyBhdm9pZCBkZWZhdWx0aW5nIHRvIGBtZW51aXRlbWAgYXMgaXQgbWF5IG92ZXJ3cml0ZSBjdXN0b20gcm9sZSBwcm9wcy5cbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBhY3RpdmUgJiYgc2VsZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ2NvbWJvYm94JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgICAgIC4uLihhY3RpdmUgJiYge1xuICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH0sIFtmbG9hdGluZ0lkLCByb2xlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIGl0ZW1cbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlLCBmbG9hdGluZywgaXRlbV0pO1xufVxuXG4vLyBDb252ZXJ0cyBhIEpTIHN0eWxlIGtleSBsaWtlIGBiYWNrZ3JvdW5kQ29sb3JgIHRvIGEgQ1NTIHRyYW5zaXRpb24tcHJvcGVydHlcbi8vIGxpa2UgYGJhY2tncm91bmQtY29sb3JgLlxuY29uc3QgY2FtZWxDYXNlVG9LZWJhYkNhc2UgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCAoJCwgb2ZzKSA9PiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpKTtcbmZ1bmN0aW9uIGV4ZWNXaXRoQXJnc09yUmV0dXJuKHZhbHVlT3JGbiwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlT3JGbiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlT3JGbihhcmdzKSA6IHZhbHVlT3JGbjtcbn1cbmZ1bmN0aW9uIHVzZURlbGF5VW5tb3VudChvcGVuLCBkdXJhdGlvbk1zKSB7XG4gIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShvcGVuKTtcbiAgaWYgKG9wZW4gJiYgIWlzTW91bnRlZCkge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiAmJiBpc01vdW50ZWQpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldElzTW91bnRlZChmYWxzZSksIGR1cmF0aW9uTXMpO1xuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gIH0sIFtvcGVuLCBpc01vdW50ZWQsIGR1cmF0aW9uTXNdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgYSBzdGF0dXMgc3RyaW5nIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsXG4gKiBjb3JyZWN0bHkgaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0YXR1c1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpc051bWJlckR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJztcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKCd1bm1vdW50ZWQnKTtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGNsb3NlRHVyYXRpb24pO1xuICBpZiAoIWlzTW91bnRlZCAmJiBzdGF0dXMgPT09ICdjbG9zZScpIHtcbiAgICBzZXRTdGF0dXMoJ3VubW91bnRlZCcpO1xuICB9XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWZsb2F0aW5nKSByZXR1cm47XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHNldFN0YXR1cygnaW5pdGlhbCcpO1xuICAgICAgY29uc3QgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzZXRTdGF0dXMoJ29wZW4nKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgfTtcbiAgICB9XG4gICAgc2V0U3RhdHVzKCdjbG9zZScpO1xuICB9LCBbb3BlbiwgZmxvYXRpbmddKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIHN0eWxlcyB0byBhcHBseSBDU1MgdHJhbnNpdGlvbnMgdG8gYSBmbG9hdGluZyBlbGVtZW50LCBjb3JyZWN0bHlcbiAqIGhhbmRsaW5nIHBsYWNlbWVudC1hd2FyZSB0cmFuc2l0aW9ucy4gV3JhcHBlciBhcm91bmQgYHVzZVRyYW5zaXRpb25TdGF0dXNgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0eWxlc1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3R5bGVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5pdGlhbDogdW5zdGFibGVfaW5pdGlhbCA9IHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgIG9wZW46IHVuc3RhYmxlX29wZW4sXG4gICAgY2xvc2U6IHVuc3RhYmxlX2Nsb3NlLFxuICAgIGNvbW1vbjogdW5zdGFibGVfY29tbW9uLFxuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGxhY2VtZW50ID0gY29udGV4dC5wbGFjZW1lbnQ7XG4gIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgZm5BcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHNpZGUsXG4gICAgcGxhY2VtZW50XG4gIH0pLCBbc2lkZSwgcGxhY2VtZW50XSk7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBvcGVuRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24ub3BlbikgfHwgMDtcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0eWxlcywgc2V0U3R5bGVzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+ICh7XG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfY29tbW9uLCBmbkFyZ3MpLFxuICAgIC4uLmV4ZWNXaXRoQXJnc09yUmV0dXJuKHVuc3RhYmxlX2luaXRpYWwsIGZuQXJncylcbiAgfSkpO1xuICBjb25zdCB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9ID0gdXNlVHJhbnNpdGlvblN0YXR1cyhjb250ZXh0LCB7XG4gICAgZHVyYXRpb25cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfaW5pdGlhbCk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfb3Blbik7XG4gIGNvbnN0IGNsb3NlUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2Nsb3NlKTtcbiAgY29uc3QgY29tbW9uUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2NvbW1vbik7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oaW5pdGlhbFJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IGNsb3NlU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oY2xvc2VSZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBjb21tb25TdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihjb21tb25SZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBvcGVuU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4ob3BlblJlZi5jdXJyZW50LCBmbkFyZ3MpIHx8IE9iamVjdC5rZXlzKGluaXRpYWxTdHlsZXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGFjY1trZXldID0gJyc7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBpZiAoc3RhdHVzID09PSAnaW5pdGlhbCcpIHtcbiAgICAgIHNldFN0eWxlcyhzdHlsZXMgPT4gKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBzdHlsZXMudHJhbnNpdGlvblByb3BlcnR5LFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLmluaXRpYWxTdHlsZXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gJ29wZW4nKSB7XG4gICAgICBzZXRTdHlsZXMoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKG9wZW5TdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IG9wZW5EdXJhdGlvbiArIFwibXNcIixcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5vcGVuU3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gJ2Nsb3NlJykge1xuICAgICAgY29uc3Qgc3R5bGVzID0gY2xvc2VTdHlsZXMgfHwgaW5pdGlhbFN0eWxlcztcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMoc3R5bGVzKS5tYXAoY2FtZWxDYXNlVG9LZWJhYkNhc2UpLmpvaW4oJywnKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBjbG9zZUR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLnN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY2xvc2VEdXJhdGlvbiwgY2xvc2VSZWYsIGluaXRpYWxSZWYsIG9wZW5SZWYsIGNvbW1vblJlZiwgb3BlbkR1cmF0aW9uLCBzdGF0dXMsIGZuQXJnc10pO1xuICByZXR1cm4ge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdHlsZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhIG1hdGNoaW5nIGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gZm9jdXMgYW4gaXRlbSBhcyB0aGUgdXNlclxuICogdHlwZXMsIG9mdGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uKClgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVR5cGVhaGVhZFxuICovXG5mdW5jdGlvbiB1c2VUeXBlYWhlYWQoY29udGV4dCwgcHJvcHMpIHtcbiAgdmFyIF9yZWY7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGRhdGFSZWZcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBsaXN0UmVmLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTWF0Y2g6IHVuc3RhYmxlX29uTWF0Y2gsXG4gICAgb25UeXBpbmdDaGFuZ2U6IHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlLFxuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGZpbmRNYXRjaCA9IG51bGwsXG4gICAgcmVzZXRNcyA9IDc1MCxcbiAgICBpZ25vcmVLZXlzID0gW10sXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGxcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0aW1lb3V0SWRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qgc3RyaW5nUmVmID0gUmVhY3QudXNlUmVmKCcnKTtcbiAgY29uc3QgcHJldkluZGV4UmVmID0gUmVhY3QudXNlUmVmKChfcmVmID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZiA6IC0xKTtcbiAgY29uc3QgbWF0Y2hJbmRleFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb25NYXRjaCA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTWF0Y2gpO1xuICBjb25zdCBvblR5cGluZ0NoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlKTtcbiAgY29uc3QgZmluZE1hdGNoUmVmID0gdXNlTGF0ZXN0UmVmKGZpbmRNYXRjaCk7XG4gIGNvbnN0IGlnbm9yZUtleXNSZWYgPSB1c2VMYXRlc3RSZWYoaWdub3JlS2V5cyk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIC8vIFN5bmMgYXJyb3cga2V5IG5hdmlnYXRpb24gYnV0IG5vdCB0eXBlYWhlYWQgbmF2aWdhdGlvbi5cbiAgICBpZiAob3BlbiAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gJycpIHtcbiAgICAgIHZhciBfcmVmMjtcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gKF9yZWYyID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZjIgOiAtMTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZWxlY3RlZEluZGV4LCBhY3RpdmVJbmRleF0pO1xuICBjb25zdCBzZXRUeXBpbmdDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIWRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICBvblR5cGluZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudC50eXBpbmcgPSB2YWx1ZTtcbiAgICAgICAgb25UeXBpbmdDaGFuZ2UodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG9uS2V5RG93biA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICBmdW5jdGlvbiBnZXRNYXRjaGluZ0luZGV4KGxpc3QsIG9yZGVyZWRMaXN0LCBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHN0ciA9IGZpbmRNYXRjaFJlZi5jdXJyZW50ID8gZmluZE1hdGNoUmVmLmN1cnJlbnQob3JkZXJlZExpc3QsIHN0cmluZykgOiBvcmRlcmVkTGlzdC5maW5kKHRleHQgPT4gKHRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZy50b0xvY2FsZUxvd2VyQ2FzZSgpKSkgPT09IDApO1xuICAgICAgcmV0dXJuIHN0ciA/IGxpc3QuaW5kZXhPZihzdHIpIDogLTE7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RDb250ZW50ID0gbGlzdFJlZi5jdXJyZW50O1xuICAgIGlmIChzdHJpbmdSZWYuY3VycmVudC5sZW5ndGggPiAwICYmIHN0cmluZ1JlZi5jdXJyZW50WzBdICE9PSAnICcpIHtcbiAgICAgIGlmIChnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBsaXN0Q29udGVudCwgc3RyaW5nUmVmLmN1cnJlbnQpID09PSAtMSkge1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICcgJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGlzdENvbnRlbnQgPT0gbnVsbCB8fCBpZ25vcmVLZXlzUmVmLmN1cnJlbnQuaW5jbHVkZXMoZXZlbnQua2V5KSB8fFxuICAgIC8vIENoYXJhY3RlciBrZXkuXG4gICAgZXZlbnQua2V5Lmxlbmd0aCAhPT0gMSB8fFxuICAgIC8vIE1vZGlmaWVyIGtleS5cbiAgICBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIGV2ZW50LmtleSAhPT0gJyAnKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgc2V0VHlwaW5nQ2hhbmdlKHRydWUpO1xuICAgIH1cblxuICAgIC8vIEJhaWwgb3V0IGlmIHRoZSBsaXN0IGNvbnRhaW5zIGEgd29yZCBsaWtlIFwibGxhbWFcIiBvciBcImFhcm9uXCIuIFRPRE86XG4gICAgLy8gYWxsb3cgaXQgaW4gdGhpcyBjYXNlLCB0b28uXG4gICAgY29uc3QgYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyID0gbGlzdENvbnRlbnQuZXZlcnkodGV4dCA9PiB7XG4gICAgICB2YXIgX3RleHQkLCBfdGV4dCQyO1xuICAgICAgcmV0dXJuIHRleHQgPyAoKF90ZXh0JCA9IHRleHRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGV4dCQudG9Mb2NhbGVMb3dlckNhc2UoKSkgIT09ICgoX3RleHQkMiA9IHRleHRbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGV4dCQyLnRvTG9jYWxlTG93ZXJDYXNlKCkpIDogdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIEFsbG93cyB0aGUgdXNlciB0byBjeWNsZSB0aHJvdWdoIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBsZXR0ZXJcbiAgICAvLyBpbiByYXBpZCBzdWNjZXNzaW9uLlxuICAgIGlmIChhbGxvd1JhcGlkU3VjY2Vzc2lvbk9mRmlyc3RMZXR0ZXIgJiYgc3RyaW5nUmVmLmN1cnJlbnQgPT09IGV2ZW50LmtleSkge1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBzdHJpbmdSZWYuY3VycmVudCArPSBldmVudC5rZXk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICB0aW1lb3V0SWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICB9LCByZXNldE1zKTtcbiAgICBjb25zdCBwcmV2SW5kZXggPSBwcmV2SW5kZXhSZWYuY3VycmVudDtcbiAgICBjb25zdCBpbmRleCA9IGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIFsuLi5saXN0Q29udGVudC5zbGljZSgocHJldkluZGV4IHx8IDApICsgMSksIC4uLmxpc3RDb250ZW50LnNsaWNlKDAsIChwcmV2SW5kZXggfHwgMCkgKyAxKV0sIHN0cmluZ1JlZi5jdXJyZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBvbk1hdGNoKGluZGV4KTtcbiAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IGluZGV4O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbktleURvd25cbiAgfSksIFtvbktleURvd25dKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25LZXlEb3duLFxuICAgICAgb25LZXlVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW29uS2V5RG93biwgc2V0VHlwaW5nQ2hhbmdlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmddKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBhbiBpbm5lciBlbGVtZW50IGluc2lkZSBvZiBpdCBpc1xuICogYW5jaG9yZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmNvbnN0IGlubmVyID0gcHJvcHMgPT4gKHtcbiAgbmFtZTogJ2lubmVyJyxcbiAgb3B0aW9uczogcHJvcHMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdFJlZixcbiAgICAgIG92ZXJmbG93UmVmLFxuICAgICAgb25GYWxsYmFja0NoYW5nZSxcbiAgICAgIG9mZnNldDogaW5uZXJPZmZzZXQgPSAwLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWluSXRlbXNWaXNpYmxlID0gNCxcbiAgICAgIHJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkID0gMCxcbiAgICAgIHNjcm9sbFJlZixcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgIH0gPSBldmFsdWF0ZShwcm9wcywgc3RhdGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3RzLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9ID0gc3RhdGU7XG4gICAgY29uc3QgaXRlbSA9IGxpc3RSZWYuY3VycmVudFtpbmRleF07XG4gICAgY29uc3Qgc2Nyb2xsRWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZmxvYXRpbmc7XG5cbiAgICAvLyBWYWxpZCBjb21iaW5hdGlvbnM6XG4gICAgLy8gMS4gRmxvYXRpbmcgZWxlbWVudCBpcyB0aGUgc2Nyb2xsUmVmIGFuZCBoYXMgYSBib3JkZXIgKGRlZmF1bHQpXG4gICAgLy8gMi4gRmxvYXRpbmcgZWxlbWVudCBpcyBub3QgdGhlIHNjcm9sbFJlZiwgZmxvYXRpbmcgZWxlbWVudCBoYXMgYSBib3JkZXJcbiAgICAvLyAzLiBGbG9hdGluZyBlbGVtZW50IGlzIG5vdCB0aGUgc2Nyb2xsUmVmLCBzY3JvbGxSZWYgaGFzIGEgYm9yZGVyXG4gICAgLy8gRmxvYXRpbmcgPiB7Li4uZ2V0RmxvYXRpbmdQcm9wcygpfSB3cmFwcGVyID4gc2Nyb2xsUmVmID4gaXRlbXMgaXMgbm90XG4gICAgLy8gYWxsb3dlZCBhcyBWb2ljZU92ZXIgZG9lc24ndCB3b3JrLlxuICAgIGNvbnN0IGNsaWVudFRvcCA9IGZsb2F0aW5nLmNsaWVudFRvcCB8fCBzY3JvbGxFbC5jbGllbnRUb3A7XG4gICAgY29uc3QgZmxvYXRpbmdJc0JvcmRlcmVkID0gZmxvYXRpbmcuY2xpZW50VG9wICE9PSAwO1xuICAgIGNvbnN0IHNjcm9sbEVsSXNCb3JkZXJlZCA9IHNjcm9sbEVsLmNsaWVudFRvcCAhPT0gMDtcbiAgICBjb25zdCBmbG9hdGluZ0lzU2Nyb2xsRWwgPSBmbG9hdGluZyA9PT0gc2Nyb2xsRWw7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCFzdGF0ZS5wbGFjZW1lbnQuc3RhcnRzV2l0aCgnYm90dG9tJykpIHtcbiAgICAgICAgd2FybignYHBsYWNlbWVudGAgc2lkZSBtdXN0IGJlIFwiYm90dG9tXCIgd2hlbiB1c2luZyB0aGUgYGlubmVyYCcsICdtaWRkbGV3YXJlLicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEFyZ3MgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLihhd2FpdCBvZmZzZXQoLWl0ZW0ub2Zmc2V0VG9wIC0gZmxvYXRpbmcuY2xpZW50VG9wIC0gcmVjdHMucmVmZXJlbmNlLmhlaWdodCAvIDIgLSBpdGVtLm9mZnNldEhlaWdodCAvIDIgLSBpbm5lck9mZnNldCkuZm4oc3RhdGUpKVxuICAgIH07XG4gICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0KG5leHRBcmdzLCBzY3JvbGxFbC5zY3JvbGxIZWlnaHQgKyBjbGllbnRUb3AgKyBmbG9hdGluZy5jbGllbnRUb3ApLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgIGNvbnN0IHJlZk92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3cobmV4dEFyZ3MsIHtcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZZID0gbWF4KDAsIG92ZXJmbG93LnRvcCk7XG4gICAgY29uc3QgbmV4dFkgPSBuZXh0QXJncy55ICsgZGlmZlk7XG4gICAgY29uc3QgaXNTY3JvbGxhYmxlID0gc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsRWwuY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IHJvdW5kZXIgPSBpc1Njcm9sbGFibGUgPyB2ID0+IHYgOiByb3VuZDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSByb3VuZGVyKG1heCgwLCBzY3JvbGxFbC5zY3JvbGxIZWlnaHQgKyAoZmxvYXRpbmdJc0JvcmRlcmVkICYmIGZsb2F0aW5nSXNTY3JvbGxFbCB8fCBzY3JvbGxFbElzQm9yZGVyZWQgPyBjbGllbnRUb3AgKiAyIDogMCkgLSBkaWZmWSAtIG1heCgwLCBvdmVyZmxvdy5ib3R0b20pKSk7XG4gICAgc2Nyb2xsRWwuc3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgXCJweFwiO1xuICAgIHNjcm9sbEVsLnNjcm9sbFRvcCA9IGRpZmZZO1xuXG4gICAgLy8gVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSwgZmFsbGJhY2sgdG8gc3RhbmRhcmQgYW5jaG9yZWQgcG9zaXRpb25pbmdcbiAgICBpZiAob25GYWxsYmFja0NoYW5nZSkge1xuICAgICAgY29uc3Qgc2hvdWxkRmFsbGJhY2sgPSBzY3JvbGxFbC5vZmZzZXRIZWlnaHQgPCBpdGVtLm9mZnNldEhlaWdodCAqIG1pbihtaW5JdGVtc1Zpc2libGUsIGxpc3RSZWYuY3VycmVudC5sZW5ndGgpIC0gMSB8fCByZWZPdmVyZmxvdy50b3AgPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkIHx8IHJlZk92ZXJmbG93LmJvdHRvbSA+PSAtcmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQ7XG4gICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4gb25GYWxsYmFja0NoYW5nZShzaG91bGRGYWxsYmFjaykpO1xuICAgIH1cbiAgICBpZiAob3ZlcmZsb3dSZWYpIHtcbiAgICAgIG92ZXJmbG93UmVmLmN1cnJlbnQgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0KHtcbiAgICAgICAgLi4ubmV4dEFyZ3MsXG4gICAgICAgIHk6IG5leHRZXG4gICAgICB9LCBzY3JvbGxFbC5vZmZzZXRIZWlnaHQgKyBjbGllbnRUb3AgKyBmbG9hdGluZy5jbGllbnRUb3ApLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeTogbmV4dFlcbiAgICB9O1xuICB9XG59KTtcbi8qKlxuICogQ2hhbmdlcyB0aGUgYGlubmVyYCBtaWRkbGV3YXJlJ3MgYG9mZnNldGAgdXBvbiBhIGB3aGVlbGAgZXZlbnQgdG9cbiAqIGV4cGFuZCB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGhlaWdodCwgcmV2ZWFsaW5nIG1vcmUgbGlzdCBpdGVtcy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbm5lclxuICovXG5mdW5jdGlvbiB1c2VJbm5lck9mZnNldChjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIG92ZXJmbG93UmVmLFxuICAgIHNjcm9sbFJlZixcbiAgICBvbkNoYW5nZTogdW5zdGFibGVfb25DaGFuZ2VcbiAgfSA9IHByb3BzO1xuICBjb25zdCBvbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uQ2hhbmdlKTtcbiAgY29uc3QgY29udHJvbGxlZFNjcm9sbGluZ1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHByZXZTY3JvbGxUb3BSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGluaXRpYWxPdmVyZmxvd1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbldoZWVsKGUpIHtcbiAgICAgIGlmIChlLmN0cmxLZXkgfHwgIWVsIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkWSA9IGUuZGVsdGFZO1xuICAgICAgY29uc3QgaXNBdFRvcCA9IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wID49IC0wLjU7XG4gICAgICBjb25zdCBpc0F0Qm90dG9tID0gb3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPj0gLTAuNTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1Njcm9sbCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHNpZ24gPSBkWSA8IDAgPyAtMSA6IDE7XG4gICAgICBjb25zdCBtZXRob2QgPSBkWSA8IDAgPyAnbWF4JyA6ICdtaW4nO1xuICAgICAgaWYgKGVsLnNjcm9sbEhlaWdodCA8PSBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0VG9wICYmIGRZID4gMCB8fCAhaXNBdEJvdHRvbSAmJiBkWSA8IDApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKGQgPT4gZCArIE1hdGhbbWV0aG9kXShkWSwgcmVtYWluaW5nU2Nyb2xsICogc2lnbikpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoL2ZpcmVmb3gvaS50ZXN0KGdldFVzZXJBZ2VudCgpKSkge1xuICAgICAgICAvLyBOZWVkZWQgdG8gcHJvcGFnYXRlIHNjcm9sbGluZyBkdXJpbmcgbW9tZW50dW0gc2Nyb2xsaW5nIHBoYXNlIG9uY2VcbiAgICAgICAgLy8gaXQgZ2V0cyBsaW1pdGVkIGJ5IHRoZSBib3VuZGFyeS4gVVggaW1wcm92ZW1lbnQsIG5vdCBjcml0aWNhbC5cbiAgICAgICAgZWwuc2Nyb2xsVG9wICs9IGRZO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICBpZiAob3BlbiAmJiBlbCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5LlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAuLi5vdmVyZmxvd1JlZi5jdXJyZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBvdmVyZmxvd1JlZiwgc2Nyb2xsUmVmLCBvbkNoYW5nZV0pO1xuICBjb25zdCBmbG9hdGluZyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbktleURvd24oKSB7XG4gICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25XaGVlbCgpIHtcbiAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgb25TY3JvbGwoKSB7XG4gICAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICAgIGlmICghb3ZlcmZsb3dSZWYuY3VycmVudCB8fCAhZWwgfHwgIWNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbERpZmYgPSBlbC5zY3JvbGxUb3AgLSBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA8IC0xIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wIDwgLTAuNSAmJiBzY3JvbGxEaWZmID4gMSkge1xuICAgICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiBvbkNoYW5nZShkID0+IGQgKyBzY3JvbGxEaWZmKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gW0ZpcmVmb3hdIFdhaXQgZm9yIHRoZSBoZWlnaHQgY2hhbmdlIHRvIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgfSk7XG4gICAgfVxuICB9KSwgW2VsZW1lbnRzLmZsb2F0aW5nLCBvbkNoYW5nZSwgb3ZlcmZsb3dSZWYsIHNjcm9sbFJlZl0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIGZsb2F0aW5nXG4gIH0gOiB7fSwgW2VuYWJsZWQsIGZsb2F0aW5nXSk7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRJblBvbHlnb24ocG9pbnQsIHBvbHlnb24pIHtcbiAgY29uc3QgW3gsIHldID0gcG9pbnQ7XG4gIGxldCBpc0luc2lkZSA9IGZhbHNlO1xuICBjb25zdCBsZW5ndGggPSBwb2x5Z29uLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgY29uc3QgW3hpLCB5aV0gPSBwb2x5Z29uW2ldIHx8IFswLCAwXTtcbiAgICBjb25zdCBbeGosIHlqXSA9IHBvbHlnb25bal0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHlpID49IHkgIT09IHlqID49IHkgJiYgeCA8PSAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpO1xuICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgIGlzSW5zaWRlID0gIWlzSW5zaWRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNJbnNpZGU7XG59XG5mdW5jdGlvbiBpc0luc2lkZShwb2ludCwgcmVjdCkge1xuICByZXR1cm4gcG9pbnRbMF0gPj0gcmVjdC54ICYmIHBvaW50WzBdIDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgcG9pbnRbMV0gPj0gcmVjdC55ICYmIHBvaW50WzFdIDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzYWZlIHBvbHlnb24gYXJlYSB0aGF0IHRoZSB1c2VyIGNhbiB0cmF2ZXJzZSB3aXRob3V0IGNsb3NpbmcgdGhlXG4gKiBmbG9hdGluZyBlbGVtZW50IG9uY2UgbGVhdmluZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXIjc2FmZXBvbHlnb25cbiAqL1xuZnVuY3Rpb24gc2FmZVBvbHlnb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBidWZmZXIgPSAwLjUsXG4gICAgYmxvY2tQb2ludGVyRXZlbnRzID0gZmFsc2UsXG4gICAgcmVxdWlyZUludGVudCA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGxldCBoYXNMYW5kZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RYID0gbnVsbDtcbiAgbGV0IGxhc3RZID0gbnVsbDtcbiAgbGV0IGxhc3RDdXJzb3JUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGZ1bmN0aW9uIGdldEN1cnNvclNwZWVkKHgsIHkpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSBsYXN0Q3Vyc29yVGltZTtcbiAgICBpZiAobGFzdFggPT09IG51bGwgfHwgbGFzdFkgPT09IG51bGwgfHwgZWxhcHNlZFRpbWUgPT09IDApIHtcbiAgICAgIGxhc3RYID0geDtcbiAgICAgIGxhc3RZID0geTtcbiAgICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsdGFYID0geCAtIGxhc3RYO1xuICAgIGNvbnN0IGRlbHRhWSA9IHkgLSBsYXN0WTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xuICAgIGNvbnN0IHNwZWVkID0gZGlzdGFuY2UgLyBlbGFwc2VkVGltZTsgLy8gcHggLyBtc1xuXG4gICAgbGFzdFggPSB4O1xuICAgIGxhc3RZID0geTtcbiAgICBsYXN0Q3Vyc29yVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHJldHVybiBzcGVlZDtcbiAgfVxuICBjb25zdCBmbiA9IF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb25DbG9zZSxcbiAgICAgIG5vZGVJZCxcbiAgICAgIHRyZWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgb25DbG9zZSgpO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBpZiAoIWVsZW1lbnRzLmRvbVJlZmVyZW5jZSB8fCAhZWxlbWVudHMuZmxvYXRpbmcgfHwgcGxhY2VtZW50ID09IG51bGwgfHwgeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGNsaWVudFBvaW50ID0gW2NsaWVudFgsIGNsaWVudFldO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGNvbnN0IGlzTGVhdmUgPSBldmVudC50eXBlID09PSAnbW91c2VsZWF2ZSc7XG4gICAgICBjb25zdCBpc092ZXJGbG9hdGluZ0VsID0gY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIHRhcmdldCk7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VFbCA9IGNvbnRhaW5zKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlZlJlY3QgPSBlbGVtZW50cy5kb21SZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCByZWN0ID0gZWxlbWVudHMuZmxvYXRpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzaWRlID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21SaWdodCA9IHggPiByZWN0LnJpZ2h0IC0gcmVjdC53aWR0aCAvIDI7XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPSB5ID4gcmVjdC5ib3R0b20gLSByZWN0LmhlaWdodCAvIDI7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VSZWN0ID0gaXNJbnNpZGUoY2xpZW50UG9pbnQsIHJlZlJlY3QpO1xuICAgICAgY29uc3QgaXNGbG9hdGluZ1dpZGVyID0gcmVjdC53aWR0aCA+IHJlZlJlY3Qud2lkdGg7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nVGFsbGVyID0gcmVjdC5oZWlnaHQgPiByZWZSZWN0LmhlaWdodDtcbiAgICAgIGNvbnN0IGxlZnQgPSAoaXNGbG9hdGluZ1dpZGVyID8gcmVmUmVjdCA6IHJlY3QpLmxlZnQ7XG4gICAgICBjb25zdCByaWdodCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkucmlnaHQ7XG4gICAgICBjb25zdCB0b3AgPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS50b3A7XG4gICAgICBjb25zdCBib3R0b20gPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS5ib3R0b207XG4gICAgICBpZiAoaXNPdmVyRmxvYXRpbmdFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzTGVhdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCAmJiAhaXNMZWF2ZSkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgb3ZlcmxhcHBpbmcgZmxvYXRpbmcgZWxlbWVudCBmcm9tIGJlaW5nIHN0dWNrIGluIGFuIG9wZW4tY2xvc2VcbiAgICAgIC8vIGxvb3A6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTkxMFxuICAgICAgaWYgKGlzTGVhdmUgJiYgaXNFbGVtZW50KGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmIGNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCBldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSBuZXN0ZWQgY2hpbGQgaXMgb3BlbiwgYWJvcnQuXG4gICAgICBpZiAodHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0Lm9wZW47XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwb2ludGVyIGlzIGxlYXZpbmcgZnJvbSB0aGUgb3Bwb3NpdGUgc2lkZSwgdGhlIFwiYnVmZmVyXCIgbG9naWNcbiAgICAgIC8vIGNyZWF0ZXMgYSBwb2ludCB3aGVyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW1haW5zIG9wZW4sIGJ1dCBzaG91bGQgYmVcbiAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAvLyBBIGNvbnN0YW50IG9mIDEgaGFuZGxlcyBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMuXG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgJiYgeSA+PSByZWZSZWN0LmJvdHRvbSAtIDEgfHwgc2lkZSA9PT0gJ2JvdHRvbScgJiYgeSA8PSByZWZSZWN0LnRvcCArIDEgfHwgc2lkZSA9PT0gJ2xlZnQnICYmIHggPj0gcmVmUmVjdC5yaWdodCAtIDEgfHwgc2lkZSA9PT0gJ3JpZ2h0JyAmJiB4IDw9IHJlZlJlY3QubGVmdCArIDEpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElnbm9yZSB3aGVuIHRoZSBjdXJzb3IgaXMgd2l0aGluIHRoZSByZWN0YW5ndWxhciB0cm91Z2ggYmV0d2VlbiB0aGVcbiAgICAgIC8vIHR3byBlbGVtZW50cy4gU2luY2UgdGhlIHRyaWFuZ2xlIGlzIGNyZWF0ZWQgZnJvbSB0aGUgY3Vyc29yIHBvaW50LFxuICAgICAgLy8gd2hpY2ggY2FuIHN0YXJ0IGJleW9uZCB0aGUgcmVmIGVsZW1lbnQncyBlZGdlLCB0cmF2ZXJzaW5nIGJhY2sgYW5kXG4gICAgICAvLyBmb3J0aCBmcm9tIHRoZSByZWYgdG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2FuIGNhdXNlIGl0IHRvIGNsb3NlLiBUaGlzXG4gICAgICAvLyBlbnN1cmVzIGl0IGFsd2F5cyByZW1haW5zIG9wZW4gaW4gdGhhdCBjYXNlLlxuICAgICAgbGV0IHJlY3RQb2x5ID0gW107XG4gICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVmUmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlY3QucmlnaHQgLSAxLCBib3R0b21dLCBbcmVjdC5yaWdodCAtIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCB0b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgYm90dG9tXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVmUmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWZSZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIHRvcF0sIFtyZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFBvbHlnb24oX3JlZjMpIHtcbiAgICAgICAgbGV0IFt4LCB5XSA9IF9yZWYzO1xuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3BdLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wIDogcmVjdC5ib3R0b20gLSBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QudG9wICsgYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbV0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b20gOiByZWN0LnRvcCArIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbLi4uY29tbW9uUG9pbnRzLCBjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd29dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCA6IHJlY3QubGVmdCArIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1BvaW50SW5Qb2x5Z29uKFtjbGllbnRYLCBjbGllbnRZXSwgcmVjdFBvbHkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNMYW5kZWQgJiYgIWlzT3ZlclJlZmVyZW5jZVJlY3QpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTGVhdmUgJiYgcmVxdWlyZUludGVudCkge1xuICAgICAgICBjb25zdCBjdXJzb3JTcGVlZCA9IGdldEN1cnNvclNwZWVkKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBjb25zdCBjdXJzb3JTcGVlZFRocmVzaG9sZCA9IDAuMTtcbiAgICAgICAgaWYgKGN1cnNvclNwZWVkICE9PSBudWxsICYmIGN1cnNvclNwZWVkIDwgY3Vyc29yU3BlZWRUaHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1BvaW50SW5Qb2x5Z29uKFtjbGllbnRYLCBjbGllbnRZXSwgZ2V0UG9seWdvbihbeCwgeV0pKSkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmICghaGFzTGFuZGVkICYmIHJlcXVpcmVJbnRlbnQpIHtcbiAgICAgICAgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoY2xvc2UsIDQwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBmbi5fX29wdGlvbnMgPSB7XG4gICAgYmxvY2tQb2ludGVyRXZlbnRzXG4gIH07XG4gIHJldHVybiBmbjtcbn1cblxuZXhwb3J0IHsgQ29tcG9zaXRlLCBDb21wb3NpdGVJdGVtLCBGbG9hdGluZ0Fycm93LCBGbG9hdGluZ0RlbGF5R3JvdXAsIEZsb2F0aW5nRm9jdXNNYW5hZ2VyLCBGbG9hdGluZ0xpc3QsIEZsb2F0aW5nTm9kZSwgRmxvYXRpbmdPdmVybGF5LCBGbG9hdGluZ1BvcnRhbCwgRmxvYXRpbmdUcmVlLCBpbm5lciwgc2FmZVBvbHlnb24sIHVzZUNsaWNrLCB1c2VDbGllbnRQb2ludCwgdXNlRGVsYXlHcm91cCwgdXNlRGVsYXlHcm91cENvbnRleHQsIHVzZURpc21pc3MsIHVzZUZsb2F0aW5nLCB1c2VGbG9hdGluZ05vZGVJZCwgdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQsIHVzZUZsb2F0aW5nUG9ydGFsTm9kZSwgdXNlRmxvYXRpbmdSb290Q29udGV4dCwgdXNlRmxvYXRpbmdUcmVlLCB1c2VGb2N1cywgdXNlSG92ZXIsIHVzZUlkLCB1c2VJbm5lck9mZnNldCwgdXNlSW50ZXJhY3Rpb25zLCB1c2VMaXN0SXRlbSwgdXNlTGlzdE5hdmlnYXRpb24sIHVzZU1lcmdlUmVmcywgdXNlUm9sZSwgdXNlVHJhbnNpdGlvblN0YXR1cywgdXNlVHJhbnNpdGlvblN0eWxlcywgdXNlVHlwZWFoZWFkIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ index),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* binding */ rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(app-pages-browser)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(app-pages-browser)/./node_modules/@tiptap/pm/keymap/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(app-pages-browser)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(app-pages-browser)/./node_modules/@tiptap/pm/transform/dist/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(app-pages-browser)/./node_modules/@tiptap/pm/commands/dist/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(app-pages-browser)/./node_modules/@tiptap/pm/schema-list/dist/index.js\");\n\n\n\n\n\n\n\n\n/**\n * Takes a Transaction & Editor State and turns it into a chainable state object\n * @param config The transaction and state to create the chainable state from\n * @returns A chainable Editor state object\n */\nfunction createChainableState(config) {\n    const { state, transaction } = config;\n    let { selection } = transaction;\n    let { doc } = transaction;\n    let { storedMarks } = transaction;\n    return {\n        ...state,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        plugins: state.plugins,\n        schema: state.schema,\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n        get storedMarks() {\n            return storedMarks;\n        },\n        get selection() {\n            return selection;\n        },\n        get doc() {\n            return doc;\n        },\n        get tr() {\n            selection = transaction.selection;\n            doc = transaction.doc;\n            storedMarks = transaction.storedMarks;\n            return transaction;\n        },\n    };\n}\n\nclass CommandManager {\n    constructor(props) {\n        this.editor = props.editor;\n        this.rawCommands = this.editor.extensionManager.commands;\n        this.customState = props.state;\n    }\n    get hasCustomState() {\n        return !!this.customState;\n    }\n    get state() {\n        return this.customState || this.editor.state;\n    }\n    get commands() {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const { tr } = state;\n        const props = this.buildProps(tr);\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n            const method = (...args) => {\n                const callback = command(...args)(props);\n                if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n                    view.dispatch(tr);\n                }\n                return callback;\n            };\n            return [name, method];\n        }));\n    }\n    get chain() {\n        return () => this.createChain();\n    }\n    get can() {\n        return () => this.createCan();\n    }\n    createChain(startTr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const callbacks = [];\n        const hasStartTransaction = !!startTr;\n        const tr = startTr || state.tr;\n        const run = () => {\n            if (!hasStartTransaction\n                && shouldDispatch\n                && !tr.getMeta('preventDispatch')\n                && !this.hasCustomState) {\n                view.dispatch(tr);\n            }\n            return callbacks.every(callback => callback === true);\n        };\n        const chain = {\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n                const chainedCommand = (...args) => {\n                    const props = this.buildProps(tr, shouldDispatch);\n                    const callback = command(...args)(props);\n                    callbacks.push(callback);\n                    return chain;\n                };\n                return [name, chainedCommand];\n            })),\n            run,\n        };\n        return chain;\n    }\n    createCan(startTr) {\n        const { rawCommands, state } = this;\n        const dispatch = false;\n        const tr = startTr || state.tr;\n        const props = this.buildProps(tr, dispatch);\n        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args) => command(...args)({ ...props, dispatch: undefined })];\n        }));\n        return {\n            ...formattedCommands,\n            chain: () => this.createChain(tr, dispatch),\n        };\n    }\n    buildProps(tr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const props = {\n            tr,\n            editor,\n            view,\n            state: createChainableState({\n                state,\n                transaction: tr,\n            }),\n            dispatch: shouldDispatch ? () => undefined : undefined,\n            chain: () => this.createChain(tr, shouldDispatch),\n            can: () => this.createCan(tr),\n            get commands() {\n                return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n                    return [name, (...args) => command(...args)(props)];\n                }));\n            },\n        };\n        return props;\n    }\n}\n\nclass EventEmitter {\n    constructor() {\n        this.callbacks = {};\n    }\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach(callback => callback.apply(this, args));\n        }\n        return this;\n    }\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n            }\n            else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    once(event, fn) {\n        const onceFn = (...args) => {\n            this.off(event, onceFn);\n            fn.apply(this, args);\n        };\n        return this.on(event, onceFn);\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n\n/**\n * Returns a field from an extension\n * @param extension The Tiptap extension\n * @param field The field, for example `renderHTML` or `priority`\n * @param context The context object that should be passed as `this` into the function\n * @returns The field value\n */\nfunction getExtensionField(extension, field, context) {\n    if (extension.config[field] === undefined && extension.parent) {\n        return getExtensionField(extension.parent, field, context);\n    }\n    if (typeof extension.config[field] === 'function') {\n        const value = extension.config[field].bind({\n            ...context,\n            parent: extension.parent\n                ? getExtensionField(extension.parent, field, context)\n                : null,\n        });\n        return value;\n    }\n    return extension.config[field];\n}\n\nfunction splitExtensions(extensions) {\n    const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n    const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n    const markExtensions = extensions.filter(extension => extension.type === 'mark');\n    return {\n        baseExtensions,\n        nodeExtensions,\n        markExtensions,\n    };\n}\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nfunction getAttributesFromExtensions(extensions) {\n    const extensionAttributes = [];\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n    const defaultAttribute = {\n        default: null,\n        rendered: true,\n        renderHTML: null,\n        parseHTML: null,\n        keepOnSplit: true,\n        isRequired: false,\n    };\n    extensions.forEach(extension => {\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            extensions: nodeAndMarkExtensions,\n        };\n        const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n        if (!addGlobalAttributes) {\n            return;\n        }\n        const globalAttributes = addGlobalAttributes();\n        globalAttributes.forEach(globalAttribute => {\n            globalAttribute.types.forEach(type => {\n                Object\n                    .entries(globalAttribute.attributes)\n                    .forEach(([name, attribute]) => {\n                    extensionAttributes.push({\n                        type,\n                        name,\n                        attribute: {\n                            ...defaultAttribute,\n                            ...attribute,\n                        },\n                    });\n                });\n            });\n        });\n    });\n    nodeAndMarkExtensions.forEach(extension => {\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        const addAttributes = getExtensionField(extension, 'addAttributes', context);\n        if (!addAttributes) {\n            return;\n        }\n        // TODO: remove `as Attributes`\n        const attributes = addAttributes();\n        Object\n            .entries(attributes)\n            .forEach(([name, attribute]) => {\n            const mergedAttr = {\n                ...defaultAttribute,\n                ...attribute,\n            };\n            if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === 'function') {\n                mergedAttr.default = mergedAttr.default();\n            }\n            if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n                delete mergedAttr.default;\n            }\n            extensionAttributes.push({\n                type: extension.name,\n                name,\n                attribute: mergedAttr,\n            });\n        });\n    });\n    return extensionAttributes;\n}\n\nfunction getNodeType(nameOrType, schema) {\n    if (typeof nameOrType === 'string') {\n        if (!schema.nodes[nameOrType]) {\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.nodes[nameOrType];\n    }\n    return nameOrType;\n}\n\nfunction mergeAttributes(...objects) {\n    return objects\n        .filter(item => !!item)\n        .reduce((items, item) => {\n        const mergedAttributes = { ...items };\n        Object.entries(item).forEach(([key, value]) => {\n            const exists = mergedAttributes[key];\n            if (!exists) {\n                mergedAttributes[key] = value;\n                return;\n            }\n            if (key === 'class') {\n                const valueClasses = value ? String(value).split(' ') : [];\n                const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(' ') : [];\n                const insertClasses = valueClasses.filter(valueClass => !existingClasses.includes(valueClass));\n                mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ');\n            }\n            else if (key === 'style') {\n                const newStyles = value ? value.split(';').map((style) => style.trim()).filter(Boolean) : [];\n                const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(';').map((style) => style.trim()).filter(Boolean) : [];\n                const styleMap = new Map();\n                existingStyles.forEach(style => {\n                    const [property, val] = style.split(':').map(part => part.trim());\n                    styleMap.set(property, val);\n                });\n                newStyles.forEach(style => {\n                    const [property, val] = style.split(':').map(part => part.trim());\n                    styleMap.set(property, val);\n                });\n                mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join('; ');\n            }\n            else {\n                mergedAttributes[key] = value;\n            }\n        });\n        return mergedAttributes;\n    }, {});\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n    return extensionAttributes\n        .filter(attribute => attribute.type === nodeOrMark.type.name)\n        .filter(item => item.attribute.rendered)\n        .map(item => {\n        if (!item.attribute.renderHTML) {\n            return {\n                [item.name]: nodeOrMark.attrs[item.name],\n            };\n        }\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n    })\n        .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nfunction callOrReturn(value, context = undefined, ...props) {\n    if (isFunction(value)) {\n        if (context) {\n            return value.bind(context)(...props);\n        }\n        return value(...props);\n    }\n    return value;\n}\n\nfunction isEmptyObject(value = {}) {\n    return Object.keys(value).length === 0 && value.constructor === Object;\n}\n\nfunction fromString(value) {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n        return Number(value);\n    }\n    if (value === 'true') {\n        return true;\n    }\n    if (value === 'false') {\n        return false;\n    }\n    return value;\n}\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n    if ('style' in parseRule) {\n        return parseRule;\n    }\n    return {\n        ...parseRule,\n        getAttrs: (node) => {\n            const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n            if (oldAttributes === false) {\n                return false;\n            }\n            const newAttributes = extensionAttributes.reduce((items, item) => {\n                const value = item.attribute.parseHTML\n                    ? item.attribute.parseHTML(node)\n                    : fromString((node).getAttribute(item.name));\n                if (value === null || value === undefined) {\n                    return items;\n                }\n                return {\n                    ...items,\n                    [item.name]: value,\n                };\n            }, {});\n            return { ...oldAttributes, ...newAttributes };\n        },\n    };\n}\n\nfunction cleanUpSchemaItem(data) {\n    return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n        if (key === 'attrs' && isEmptyObject(value)) {\n            return false;\n        }\n        return value !== null && value !== undefined;\n    }));\n}\n/**\n * Creates a new Prosemirror schema based on the given extensions.\n * @param extensions An array of Tiptap extensions\n * @param editor The editor instance\n * @returns A Prosemirror schema\n */\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n    var _a;\n    const allAttributes = getAttributesFromExtensions(extensions);\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n    const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n        };\n        const extraNodeFields = extensions.reduce((fields, e) => {\n            const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n            return {\n                ...fields,\n                ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraNodeFields,\n            content: callOrReturn(getExtensionField(extension, 'content', context)),\n            marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\n            inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n            atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n            selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n            draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\n            whitespace: callOrReturn(getExtensionField(extension, 'whitespace', context)),\n            linebreakReplacement: callOrReturn(getExtensionField(extension, 'linebreakReplacement', context)),\n            defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n            isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n                var _a;\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\n            })),\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\n        if (renderHTML) {\n            schema.toDOM = node => renderHTML({\n                node,\n                HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n            });\n        }\n        const renderText = getExtensionField(extension, 'renderText', context);\n        if (renderText) {\n            schema.toText = renderText;\n        }\n        return [extension.name, schema];\n    }));\n    const marks = Object.fromEntries(markExtensions.map(extension => {\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n        };\n        const extraMarkFields = extensions.reduce((fields, e) => {\n            const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n            return {\n                ...fields,\n                ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraMarkFields,\n            inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n            excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\n            spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n                var _a;\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\n            })),\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\n        if (renderHTML) {\n            schema.toDOM = mark => renderHTML({\n                mark,\n                HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n            });\n        }\n        return [extension.name, schema];\n    }));\n    return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode,\n        nodes,\n        marks,\n    });\n}\n\n/**\n * Tries to get a node or mark type by its name.\n * @param name The name of the node or mark type\n * @param schema The Prosemiror schema to search in\n * @returns The node or mark type, or null if it doesn't exist\n */\nfunction getSchemaTypeByName(name, schema) {\n    return schema.nodes[name] || schema.marks[name] || null;\n}\n\nfunction isExtensionRulesEnabled(extension, enabled) {\n    if (Array.isArray(enabled)) {\n        return enabled.some(enabledExtension => {\n            const name = typeof enabledExtension === 'string'\n                ? enabledExtension\n                : enabledExtension.name;\n            return name === extension.name;\n        });\n    }\n    return enabled;\n}\n\nfunction getHTMLFromFragment(fragment, schema) {\n    const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n    const temporaryDocument = document.implementation.createHTMLDocument();\n    const container = temporaryDocument.createElement('div');\n    container.appendChild(documentFragment);\n    return container.innerHTML;\n}\n\n/**\n * Returns the text content of a resolved prosemirror position\n * @param $from The resolved position to get the text content from\n * @param maxMatch The maximum number of characters to match\n * @returns The text content\n */\nconst getTextContentFromNodes = ($from, maxMatch = 500) => {\n    let textBefore = '';\n    const sliceEndPos = $from.parentOffset;\n    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n        var _a, _b;\n        const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            node,\n            pos,\n            parent,\n            index,\n        }))\n            || node.textContent\n            || '%leaf%';\n        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n    });\n    return textBefore;\n};\n\nfunction isRegExp(value) {\n    return Object.prototype.toString.call(value) === '[object RegExp]';\n}\n\nclass InputRule {\n    constructor(config) {\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n    if (isRegExp(find)) {\n        return find.exec(text);\n    }\n    const inputRuleMatch = find(text);\n    if (!inputRuleMatch) {\n        return null;\n    }\n    const result = [inputRuleMatch.text];\n    result.index = inputRuleMatch.index;\n    result.input = text;\n    result.data = inputRuleMatch.data;\n    if (inputRuleMatch.replaceWith) {\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n        }\n        result.push(inputRuleMatch.replaceWith);\n    }\n    return result;\n};\nfunction run$1(config) {\n    var _a;\n    const { editor, from, to, text, rules, plugin, } = config;\n    const { view } = editor;\n    if (view.composing) {\n        return false;\n    }\n    const $from = view.state.doc.resolve(from);\n    if (\n    // check for code node\n    $from.parent.type.spec.code\n        // check for code mark\n        || !!((_a = ($from.nodeBefore || $from.nodeAfter)) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n        return false;\n    }\n    let matched = false;\n    const textBefore = getTextContentFromNodes($from) + text;\n    rules.forEach(rule => {\n        if (matched) {\n            return;\n        }\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\n        if (!match) {\n            return;\n        }\n        const tr = view.state.tr;\n        const state = createChainableState({\n            state: view.state,\n            transaction: tr,\n        });\n        const range = {\n            from: from - (match[0].length - text.length),\n            to,\n        };\n        const { commands, chain, can } = new CommandManager({\n            editor,\n            state,\n        });\n        const handler = rule.handler({\n            state,\n            range,\n            match,\n            commands,\n            chain,\n            can,\n        });\n        // stop if there are no changes\n        if (handler === null || !tr.steps.length) {\n            return;\n        }\n        // store transform as meta data\n        // so we can undo input rules within the `undoInputRules` command\n        tr.setMeta(plugin, {\n            transform: tr,\n            from,\n            to,\n            text,\n        });\n        view.dispatch(tr);\n        matched = true;\n    });\n    return matched;\n}\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nfunction inputRulesPlugin(props) {\n    const { editor, rules } = props;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        state: {\n            init() {\n                return null;\n            },\n            apply(tr, prev, state) {\n                const stored = tr.getMeta(plugin);\n                if (stored) {\n                    return stored;\n                }\n                // if InputRule is triggered by insertContent()\n                const simulatedInputMeta = tr.getMeta('applyInputRules');\n                const isSimulatedInput = !!simulatedInputMeta;\n                if (isSimulatedInput) {\n                    setTimeout(() => {\n                        let { text } = simulatedInputMeta;\n                        if (typeof text === 'string') {\n                            text = text;\n                        }\n                        else {\n                            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                        }\n                        const { from } = simulatedInputMeta;\n                        const to = from + text.length;\n                        run$1({\n                            editor,\n                            from,\n                            to,\n                            text,\n                            rules,\n                            plugin,\n                        });\n                    });\n                }\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            },\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run$1({\n                    editor,\n                    from,\n                    to,\n                    text,\n                    rules,\n                    plugin,\n                });\n            },\n            handleDOMEvents: {\n                compositionend: view => {\n                    setTimeout(() => {\n                        const { $cursor } = view.state.selection;\n                        if ($cursor) {\n                            run$1({\n                                editor,\n                                from: $cursor.pos,\n                                to: $cursor.pos,\n                                text: '',\n                                rules,\n                                plugin,\n                            });\n                        }\n                    });\n                    return false;\n                },\n            },\n            // add support for input rules to trigger on enter\n            // this is useful for example for code blocks\n            handleKeyDown(view, event) {\n                if (event.key !== 'Enter') {\n                    return false;\n                }\n                const { $cursor } = view.state.selection;\n                if ($cursor) {\n                    return run$1({\n                        editor,\n                        from: $cursor.pos,\n                        to: $cursor.pos,\n                        text: '\\n',\n                        rules,\n                        plugin,\n                    });\n                }\n                return false;\n            },\n        },\n        // @ts-ignore\n        isInputRules: true,\n    });\n    return plugin;\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n    if (getType(value) !== 'Object') {\n        return false;\n    }\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\n\nfunction mergeDeep(target, source) {\n    const output = { ...target };\n    if (isPlainObject(target) && isPlainObject(source)) {\n        Object.keys(source).forEach(key => {\n            if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n                output[key] = mergeDeep(target[key], source[key]);\n            }\n            else {\n                output[key] = source[key];\n            }\n        });\n    }\n    return output;\n}\n\n/**\n * The Mark class is used to create custom mark extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nclass Mark {\n    constructor(config = {}) {\n        this.type = 'mark';\n        this.name = 'mark';\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {},\n        };\n        this.config = {\n            ...this.config,\n            ...config,\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n                name: this.name,\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n            name: this.name,\n            options: this.options,\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Mark(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: () => {\n                return mergeDeep(this.options, options);\n            },\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Mark(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n            name: extension.name,\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n            name: extension.name,\n            options: extension.options,\n        }));\n        return extension;\n    }\n    static handleExit({ editor, mark }) {\n        const { tr } = editor.state;\n        const currentPos = editor.state.selection.$from;\n        const isAtEnd = currentPos.pos === currentPos.end();\n        if (isAtEnd) {\n            const currentMarks = currentPos.marks();\n            const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (!isInMark) {\n                return false;\n            }\n            const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (removeMark) {\n                tr.removeStoredMark(removeMark);\n            }\n            tr.insertText(' ', currentPos.pos);\n            editor.view.dispatch(tr);\n            return true;\n        }\n        return false;\n    }\n}\n\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\n/**\n * Paste rules are used to react to pasted content.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nclass PasteRule {\n    constructor(config) {\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst pasteRuleMatcherHandler = (text, find, event) => {\n    if (isRegExp(find)) {\n        return [...text.matchAll(find)];\n    }\n    const matches = find(text, event);\n    if (!matches) {\n        return [];\n    }\n    return matches.map(pasteRuleMatch => {\n        const result = [pasteRuleMatch.text];\n        result.index = pasteRuleMatch.index;\n        result.input = text;\n        result.data = pasteRuleMatch.data;\n        if (pasteRuleMatch.replaceWith) {\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n            }\n            result.push(pasteRuleMatch.replaceWith);\n        }\n        return result;\n    });\n};\nfunction run(config) {\n    const { editor, state, from, to, rule, pasteEvent, dropEvent, } = config;\n    const { commands, chain, can } = new CommandManager({\n        editor,\n        state,\n    });\n    const handlers = [];\n    state.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isTextblock || node.type.spec.code) {\n            return;\n        }\n        const resolvedFrom = Math.max(from, pos);\n        const resolvedTo = Math.min(to, pos + node.content.size);\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n        matches.forEach(match => {\n            if (match.index === undefined) {\n                return;\n            }\n            const start = resolvedFrom + match.index + 1;\n            const end = start + match[0].length;\n            const range = {\n                from: state.tr.mapping.map(start),\n                to: state.tr.mapping.map(end),\n            };\n            const handler = rule.handler({\n                state,\n                range,\n                match,\n                commands,\n                chain,\n                can,\n                pasteEvent,\n                dropEvent,\n            });\n            handlers.push(handler);\n        });\n    });\n    const success = handlers.every(handler => handler !== null);\n    return success;\n}\n// When dragging across editors, must get another editor instance to delete selection content.\nlet tiptapDragFromOtherEditor = null;\nconst createClipboardPasteEvent = (text) => {\n    var _a;\n    const event = new ClipboardEvent('paste', {\n        clipboardData: new DataTransfer(),\n    });\n    (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData('text/html', text);\n    return event;\n};\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nfunction pasteRulesPlugin(props) {\n    const { editor, rules } = props;\n    let dragSourceElement = null;\n    let isPastedFromProseMirror = false;\n    let isDroppedFromProseMirror = false;\n    let pasteEvent = typeof ClipboardEvent !== 'undefined' ? new ClipboardEvent('paste') : null;\n    let dropEvent;\n    try {\n        dropEvent = typeof DragEvent !== 'undefined' ? new DragEvent('drop') : null;\n    }\n    catch {\n        dropEvent = null;\n    }\n    const processEvent = ({ state, from, to, rule, pasteEvt, }) => {\n        const tr = state.tr;\n        const chainableState = createChainableState({\n            state,\n            transaction: tr,\n        });\n        const handler = run({\n            editor,\n            state: chainableState,\n            from: Math.max(from - 1, 0),\n            to: to.b - 1,\n            rule,\n            pasteEvent: pasteEvt,\n            dropEvent,\n        });\n        if (!handler || !tr.steps.length) {\n            return;\n        }\n        try {\n            dropEvent = typeof DragEvent !== 'undefined' ? new DragEvent('drop') : null;\n        }\n        catch {\n            dropEvent = null;\n        }\n        pasteEvent = typeof ClipboardEvent !== 'undefined' ? new ClipboardEvent('paste') : null;\n        return tr;\n    };\n    const plugins = rules.map(rule => {\n        return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n            // we register a global drag handler to track the current drag source element\n            view(view) {\n                const handleDragstart = (event) => {\n                    var _a;\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target))\n                        ? view.dom.parentElement\n                        : null;\n                    if (dragSourceElement) {\n                        tiptapDragFromOtherEditor = editor;\n                    }\n                };\n                const handleDragend = () => {\n                    if (tiptapDragFromOtherEditor) {\n                        tiptapDragFromOtherEditor = null;\n                    }\n                };\n                window.addEventListener('dragstart', handleDragstart);\n                window.addEventListener('dragend', handleDragend);\n                return {\n                    destroy() {\n                        window.removeEventListener('dragstart', handleDragstart);\n                        window.removeEventListener('dragend', handleDragend);\n                    },\n                };\n            },\n            props: {\n                handleDOMEvents: {\n                    drop: (view, event) => {\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n                        dropEvent = event;\n                        if (!isDroppedFromProseMirror) {\n                            const dragFromOtherEditor = tiptapDragFromOtherEditor;\n                            if (dragFromOtherEditor) {\n                                // setTimeout to avoid the wrong content after drop, timeout arg can't be empty or 0\n                                setTimeout(() => {\n                                    const selection = dragFromOtherEditor.state.selection;\n                                    if (selection) {\n                                        dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });\n                                    }\n                                }, 10);\n                            }\n                        }\n                        return false;\n                    },\n                    paste: (_view, event) => {\n                        var _a;\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n                        pasteEvent = event;\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n                        return false;\n                    },\n                },\n            },\n            appendTransaction: (transactions, oldState, state) => {\n                const transaction = transactions[0];\n                const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n                const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n                // if PasteRule is triggered by insertContent()\n                const simulatedPasteMeta = transaction.getMeta('applyPasteRules');\n                const isSimulatedPaste = !!simulatedPasteMeta;\n                if (!isPaste && !isDrop && !isSimulatedPaste) {\n                    return;\n                }\n                // Handle simulated paste\n                if (isSimulatedPaste) {\n                    let { text } = simulatedPasteMeta;\n                    if (typeof text === 'string') {\n                        text = text;\n                    }\n                    else {\n                        text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                    }\n                    const { from } = simulatedPasteMeta;\n                    const to = from + text.length;\n                    const pasteEvt = createClipboardPasteEvent(text);\n                    return processEvent({\n                        rule,\n                        state,\n                        from,\n                        to: { b: to },\n                        pasteEvt,\n                    });\n                }\n                // handle actual paste/drop\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\n                // stop if there is no changed range\n                if (!isNumber(from) || !to || from === to.b) {\n                    return;\n                }\n                return processEvent({\n                    rule,\n                    state,\n                    from,\n                    to,\n                    pasteEvt: pasteEvent,\n                });\n            },\n        });\n    });\n    return plugins;\n}\n\nfunction findDuplicates(items) {\n    const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n    return Array.from(new Set(filtered));\n}\n\nclass ExtensionManager {\n    constructor(extensions, editor) {\n        this.splittableMarks = [];\n        this.editor = editor;\n        this.extensions = ExtensionManager.resolve(extensions);\n        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n        this.setupExtensions();\n    }\n    /**\n     * Returns a flattened and sorted extension list while\n     * also checking for duplicated extensions and warns the user.\n     * @param extensions An array of Tiptap extensions\n     * @returns An flattened and sorted array of Tiptap extensions\n     */\n    static resolve(extensions) {\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n        const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n        if (duplicatedNames.length) {\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n                .map(item => `'${item}'`)\n                .join(', ')}]. This can lead to issues.`);\n        }\n        return resolvedExtensions;\n    }\n    /**\n     * Create a flattened array of extensions by traversing the `addExtensions` field.\n     * @param extensions An array of Tiptap extensions\n     * @returns A flattened array of Tiptap extensions\n     */\n    static flatten(extensions) {\n        return (extensions\n            .map(extension => {\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n            };\n            const addExtensions = getExtensionField(extension, 'addExtensions', context);\n            if (addExtensions) {\n                return [extension, ...this.flatten(addExtensions())];\n            }\n            return extension;\n        })\n            // `Infinity` will break TypeScript so we set a number that is probably high enough\n            .flat(10));\n    }\n    /**\n     * Sort extensions by priority.\n     * @param extensions An array of Tiptap extensions\n     * @returns A sorted array of Tiptap extensions by priority\n     */\n    static sort(extensions) {\n        const defaultPriority = 100;\n        return extensions.sort((a, b) => {\n            const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n            const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n            if (priorityA > priorityB) {\n                return -1;\n            }\n            if (priorityA < priorityB) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    /**\n     * Get all commands from the extensions.\n     * @returns An object with all commands where the key is the command name and the value is the command function\n     */\n    get commands() {\n        return this.extensions.reduce((commands, extension) => {\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema),\n            };\n            const addCommands = getExtensionField(extension, 'addCommands', context);\n            if (!addCommands) {\n                return commands;\n            }\n            return {\n                ...commands,\n                ...addCommands(),\n            };\n        }, {});\n    }\n    /**\n     * Get all registered Prosemirror plugins from the extensions.\n     * @returns An array of Prosemirror plugins\n     */\n    get plugins() {\n        const { editor } = this;\n        // With ProseMirror, first plugins within an array are executed first.\n        // In Tiptap, we provide the ability to override plugins,\n        // so it feels more natural to run plugins at the end of an array first.\n        // That’s why we have to reverse the `extensions` array and sort again\n        // based on the `priority` option.\n        const extensions = ExtensionManager.sort([...this.extensions].reverse());\n        const inputRules = [];\n        const pasteRules = [];\n        const allPlugins = extensions\n            .map(extension => {\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getSchemaTypeByName(extension.name, this.schema),\n            };\n            const plugins = [];\n            const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n            let defaultBindings = {};\n            // bind exit handling\n            if (extension.type === 'mark' && getExtensionField(extension, 'exitable', context)) {\n                defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });\n            }\n            if (addKeyboardShortcuts) {\n                const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n                    return [shortcut, () => method({ editor })];\n                }));\n                defaultBindings = { ...defaultBindings, ...bindings };\n            }\n            const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\n            plugins.push(keyMapPlugin);\n            const addInputRules = getExtensionField(extension, 'addInputRules', context);\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n                inputRules.push(...addInputRules());\n            }\n            const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n                pasteRules.push(...addPasteRules());\n            }\n            const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n            if (addProseMirrorPlugins) {\n                const proseMirrorPlugins = addProseMirrorPlugins();\n                plugins.push(...proseMirrorPlugins);\n            }\n            return plugins;\n        })\n            .flat();\n        return [\n            inputRulesPlugin({\n                editor,\n                rules: inputRules,\n            }),\n            ...pasteRulesPlugin({\n                editor,\n                rules: pasteRules,\n            }),\n            ...allPlugins,\n        ];\n    }\n    /**\n     * Get all attributes from the extensions.\n     * @returns An array of attributes\n     */\n    get attributes() {\n        return getAttributesFromExtensions(this.extensions);\n    }\n    /**\n     * Get all node views from the extensions.\n     * @returns An object with all node views where the key is the node name and the value is the node view function\n     */\n    get nodeViews() {\n        const { editor } = this;\n        const { nodeExtensions } = splitExtensions(this.extensions);\n        return Object.fromEntries(nodeExtensions\n            .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n            .map(extension => {\n            const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getNodeType(extension.name, this.schema),\n            };\n            const addNodeView = getExtensionField(extension, 'addNodeView', context);\n            if (!addNodeView) {\n                return [];\n            }\n            const nodeview = (node, view, getPos, decorations, innerDecorations) => {\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n                return addNodeView()({\n                    // pass-through\n                    node,\n                    view,\n                    getPos: getPos,\n                    decorations,\n                    innerDecorations,\n                    // tiptap-specific\n                    editor,\n                    extension,\n                    HTMLAttributes,\n                });\n            };\n            return [extension.name, nodeview];\n        }));\n    }\n    /**\n     * Go through all extensions, create extension storages & setup marks\n     * & bind editor event listener.\n     */\n    setupExtensions() {\n        this.extensions.forEach(extension => {\n            var _a;\n            // store extension storage in editor\n            this.editor.extensionStorage[extension.name] = extension.storage;\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema),\n            };\n            if (extension.type === 'mark') {\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n                if (keepOnSplit) {\n                    this.splittableMarks.push(extension.name);\n                }\n            }\n            const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n            const onCreate = getExtensionField(extension, 'onCreate', context);\n            const onUpdate = getExtensionField(extension, 'onUpdate', context);\n            const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n            const onTransaction = getExtensionField(extension, 'onTransaction', context);\n            const onFocus = getExtensionField(extension, 'onFocus', context);\n            const onBlur = getExtensionField(extension, 'onBlur', context);\n            const onDestroy = getExtensionField(extension, 'onDestroy', context);\n            if (onBeforeCreate) {\n                this.editor.on('beforeCreate', onBeforeCreate);\n            }\n            if (onCreate) {\n                this.editor.on('create', onCreate);\n            }\n            if (onUpdate) {\n                this.editor.on('update', onUpdate);\n            }\n            if (onSelectionUpdate) {\n                this.editor.on('selectionUpdate', onSelectionUpdate);\n            }\n            if (onTransaction) {\n                this.editor.on('transaction', onTransaction);\n            }\n            if (onFocus) {\n                this.editor.on('focus', onFocus);\n            }\n            if (onBlur) {\n                this.editor.on('blur', onBlur);\n            }\n            if (onDestroy) {\n                this.editor.on('destroy', onDestroy);\n            }\n        });\n    }\n}\n\n/**\n * The Extension class is the base class for all extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nclass Extension {\n    constructor(config = {}) {\n        this.type = 'extension';\n        this.name = 'extension';\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {},\n        };\n        this.config = {\n            ...this.config,\n            ...config,\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n                name: this.name,\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n            name: this.name,\n            options: this.options,\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Extension(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: () => {\n                return mergeDeep(this.options, options);\n            },\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Extension({ ...this.config, ...extendedConfig });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n            name: extension.name,\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n            name: extension.name,\n            options: extension.options,\n        }));\n        return extension;\n    }\n}\n\n/**\n * Gets the text between two positions in a Prosemirror node\n * and serializes it using the given text serializers and block separator (see getText)\n * @param startNode The Prosemirror node to start from\n * @param range The range of the text to get\n * @param options Options for the text serializer & block separator\n * @returns The text between the two positions\n */\nfunction getTextBetween(startNode, range, options) {\n    const { from, to } = range;\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\n    let text = '';\n    startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n        var _a;\n        if (node.isBlock && pos > from) {\n            text += blockSeparator;\n        }\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n        if (textSerializer) {\n            if (parent) {\n                text += textSerializer({\n                    node,\n                    pos,\n                    parent,\n                    index,\n                    range,\n                });\n            }\n            // do not descend into child nodes when there exists a serializer\n            return false;\n        }\n        if (node.isText) {\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n        }\n    });\n    return text;\n}\n\n/**\n * Find text serializers `toText` in a Prosemirror schema\n * @param schema The Prosemirror schema to search in\n * @returns A record of text serializers by node name\n */\nfunction getTextSerializersFromSchema(schema) {\n    return Object.fromEntries(Object.entries(schema.nodes)\n        .filter(([, node]) => node.spec.toText)\n        .map(([name, node]) => [name, node.spec.toText]));\n}\n\nconst ClipboardTextSerializer = Extension.create({\n    name: 'clipboardTextSerializer',\n    addOptions() {\n        return {\n            blockSeparator: undefined,\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clipboardTextSerializer'),\n                props: {\n                    clipboardTextSerializer: () => {\n                        const { editor } = this;\n                        const { state, schema } = editor;\n                        const { doc, selection } = state;\n                        const { ranges } = selection;\n                        const from = Math.min(...ranges.map(range => range.$from.pos));\n                        const to = Math.max(...ranges.map(range => range.$to.pos));\n                        const textSerializers = getTextSerializersFromSchema(schema);\n                        const range = { from, to };\n                        return getTextBetween(doc, range, {\n                            ...(this.options.blockSeparator !== undefined\n                                ? { blockSeparator: this.options.blockSeparator }\n                                : {}),\n                            textSerializers,\n                        });\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst blur = () => ({ editor, view }) => {\n    requestAnimationFrame(() => {\n        var _a;\n        if (!editor.isDestroyed) {\n            view.dom.blur();\n            // Browsers should remove the caret on blur but safari does not.\n            // See: https://github.com/ueberdosis/tiptap/issues/2405\n            (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n        }\n    });\n    return true;\n};\n\nconst clearContent = (emitUpdate = false) => ({ commands }) => {\n    return commands.setContent('', emitUpdate);\n};\n\nconst clearNodes = () => ({ state, tr, dispatch }) => {\n    const { selection } = tr;\n    const { ranges } = selection;\n    if (!dispatch) {\n        return true;\n    }\n    ranges.forEach(({ $from, $to }) => {\n        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (node.type.isText) {\n                return;\n            }\n            const { doc, mapping } = tr;\n            const $mappedFrom = doc.resolve(mapping.map(pos));\n            const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n            const nodeRange = $mappedFrom.blockRange($mappedTo);\n            if (!nodeRange) {\n                return;\n            }\n            const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.liftTarget)(nodeRange);\n            if (node.type.isTextblock) {\n                const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n                tr.setNodeMarkup(nodeRange.start, defaultType);\n            }\n            if (targetLiftDepth || targetLiftDepth === 0) {\n                tr.lift(nodeRange, targetLiftDepth);\n            }\n        });\n    });\n    return true;\n};\n\nconst command = fn => props => {\n    return fn(props);\n};\n\nconst createParagraphNear = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);\n};\n\nconst cut = (originRange, targetPos) => ({ editor, tr }) => {\n    const { state } = editor;\n    const contentSlice = state.doc.slice(originRange.from, originRange.to);\n    tr.deleteRange(originRange.from, originRange.to);\n    const newPos = tr.mapping.map(targetPos);\n    tr.insert(newPos, contentSlice.content);\n    tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(newPos - 1)));\n    return true;\n};\n\nconst deleteCurrentNode = () => ({ tr, dispatch }) => {\n    const { selection } = tr;\n    const currentNode = selection.$anchor.node();\n    // if there is content inside the current node, break out of this command\n    if (currentNode.content.size > 0) {\n        return false;\n    }\n    const $pos = tr.selection.$anchor;\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\n        const node = $pos.node(depth);\n        if (node.type === currentNode.type) {\n            if (dispatch) {\n                const from = $pos.before(depth);\n                const to = $pos.after(depth);\n                tr.delete(from, to).scrollIntoView();\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\nconst deleteNode = typeOrName => ({ tr, state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const $pos = tr.selection.$anchor;\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\n        const node = $pos.node(depth);\n        if (node.type === type) {\n            if (dispatch) {\n                const from = $pos.before(depth);\n                const to = $pos.after(depth);\n                tr.delete(from, to).scrollIntoView();\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\nconst deleteRange = range => ({ tr, dispatch }) => {\n    const { from, to } = range;\n    if (dispatch) {\n        tr.delete(from, to);\n    }\n    return true;\n};\n\nconst deleteSelection = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);\n};\n\nconst enter = () => ({ commands }) => {\n    return commands.keyboardShortcut('Enter');\n};\n\nconst exitCode = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);\n};\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nfunction objectIncludes(object1, object2, options = { strict: true }) {\n    const keys = Object.keys(object2);\n    if (!keys.length) {\n        return true;\n    }\n    return keys.every(key => {\n        if (options.strict) {\n            return object2[key] === object1[key];\n        }\n        if (isRegExp(object2[key])) {\n            return object2[key].test(object1[key]);\n        }\n        return object2[key] === object1[key];\n    });\n}\n\nfunction findMarkInSet(marks, type, attributes = {}) {\n    return marks.find(item => {\n        return (item.type === type\n            && objectIncludes(\n            // Only check equality for the attributes that are provided\n            Object.fromEntries(Object.keys(attributes).map(k => [k, item.attrs[k]])), attributes));\n    });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n    return !!findMarkInSet(marks, type, attributes);\n}\n/**\n * Get the range of a mark at a resolved position.\n */\nfunction getMarkRange(\n/**\n * The position to get the mark range for.\n */\n$pos, \n/**\n * The mark type to get the range for.\n */\ntype, \n/**\n * The attributes to match against.\n * If not provided, only the first mark at the position will be matched.\n */\nattributes) {\n    var _a;\n    if (!$pos || !type) {\n        return;\n    }\n    let start = $pos.parent.childAfter($pos.parentOffset);\n    // If the cursor is at the start of a text node that does not have the mark, look backward\n    if (!start.node || !start.node.marks.some(mark => mark.type === type)) {\n        start = $pos.parent.childBefore($pos.parentOffset);\n    }\n    // If there is no text node with the mark even backward, return undefined\n    if (!start.node || !start.node.marks.some(mark => mark.type === type)) {\n        return;\n    }\n    // Default to only matching against the first mark's attributes\n    attributes = attributes || ((_a = start.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);\n    // We now know that the cursor is either at the start, middle or end of a text node with the specified mark\n    // so we can look it up on the targeted mark\n    const mark = findMarkInSet([...start.node.marks], type, attributes);\n    if (!mark) {\n        return;\n    }\n    let startIndex = start.index;\n    let startPos = $pos.start() + start.offset;\n    let endIndex = startIndex + 1;\n    let endPos = startPos + start.node.nodeSize;\n    while (startIndex > 0\n        && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {\n        startIndex -= 1;\n        startPos -= $pos.parent.child(startIndex).nodeSize;\n    }\n    while (endIndex < $pos.parent.childCount\n        && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n        endPos += $pos.parent.child(endIndex).nodeSize;\n        endIndex += 1;\n    }\n    return {\n        from: startPos,\n        to: endPos,\n    };\n}\n\nfunction getMarkType(nameOrType, schema) {\n    if (typeof nameOrType === 'string') {\n        if (!schema.marks[nameOrType]) {\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.marks[nameOrType];\n    }\n    return nameOrType;\n}\n\nconst extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n    const type = getMarkType(typeOrName, state.schema);\n    const { doc, selection } = tr;\n    const { $from, from, to } = selection;\n    if (dispatch) {\n        const range = getMarkRange($from, type, attributes);\n        if (range && range.from <= from && range.to >= to) {\n            const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);\n            tr.setSelection(newSelection);\n        }\n    }\n    return true;\n};\n\nconst first = commands => props => {\n    const items = typeof commands === 'function'\n        ? commands(props)\n        : commands;\n    for (let i = 0; i < items.length; i += 1) {\n        if (items[i](props)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nfunction isTextSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n}\n\nfunction minMax(value = 0, min = 0, max = 0) {\n    return Math.min(Math.max(value, min), max);\n}\n\nfunction resolveFocusPosition(doc, position = null) {\n    if (!position) {\n        return null;\n    }\n    const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);\n    const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);\n    if (position === 'start' || position === true) {\n        return selectionAtStart;\n    }\n    if (position === 'end') {\n        return selectionAtEnd;\n    }\n    const minPos = selectionAtStart.from;\n    const maxPos = selectionAtEnd.to;\n    if (position === 'all') {\n        return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n    }\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\n\nfunction isAndroid() {\n    return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);\n}\n\nfunction isiOS() {\n    return [\n        'iPad Simulator',\n        'iPhone Simulator',\n        'iPod Simulator',\n        'iPad',\n        'iPhone',\n        'iPod',\n    ].includes(navigator.platform)\n        // iPad on iOS 13 detection\n        || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);\n}\n\nconst focus = (position = null, options = {}) => ({ editor, view, tr, dispatch, }) => {\n    options = {\n        scrollIntoView: true,\n        ...options,\n    };\n    const delayedFocus = () => {\n        // focus within `requestAnimationFrame` breaks focus on iOS and Android\n        // so we have to call this\n        if (isiOS() || isAndroid()) {\n            view.dom.focus();\n        }\n        // For React we have to focus asynchronously. Otherwise wild things happen.\n        // see: https://github.com/ueberdosis/tiptap/issues/1520\n        requestAnimationFrame(() => {\n            if (!editor.isDestroyed) {\n                view.focus();\n                if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n                    editor.commands.scrollIntoView();\n                }\n            }\n        });\n    };\n    if ((view.hasFocus() && position === null) || position === false) {\n        return true;\n    }\n    // we don’t try to resolve a NodeSelection or CellSelection\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n        delayedFocus();\n        return true;\n    }\n    // pass through tr.doc instead of editor.state.doc\n    // since transactions could change the editors state before this command has been run\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n    const isSameSelection = editor.state.selection.eq(selection);\n    if (dispatch) {\n        if (!isSameSelection) {\n            tr.setSelection(selection);\n        }\n        // `tr.setSelection` resets the stored marks\n        // so we’ll restore them if the selection is the same as before\n        if (isSameSelection && tr.storedMarks) {\n            tr.setStoredMarks(tr.storedMarks);\n        }\n        delayedFocus();\n    }\n    return true;\n};\n\nconst forEach = (items, fn) => props => {\n    return items.every((item, index) => fn(item, { ...props, index }));\n};\n\nconst insertContent = (value, options) => ({ tr, commands }) => {\n    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\n};\n\nconst removeWhitespaces = (node) => {\n    const children = node.childNodes;\n    for (let i = children.length - 1; i >= 0; i -= 1) {\n        const child = children[i];\n        if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n            node.removeChild(child);\n        }\n        else if (child.nodeType === 1) {\n            removeWhitespaces(child);\n        }\n    }\n    return node;\n};\nfunction elementFromString(value) {\n    // add a wrapper to preserve leading and trailing whitespace\n    const wrappedValue = `<body>${value}</body>`;\n    const html = new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n    return removeWhitespaces(html);\n}\n\n/**\n * Takes a JSON or HTML content and creates a Prosemirror node or fragment from it.\n * @param content The JSON or HTML content to create the node from\n * @param schema The Prosemirror schema to use for the node\n * @param options Options for the parser\n * @returns The created Prosemirror node or fragment\n */\nfunction createNodeFromContent(content, schema, options) {\n    if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n        return content;\n    }\n    options = {\n        slice: true,\n        parseOptions: {},\n        ...options,\n    };\n    const isJSONContent = typeof content === 'object' && content !== null;\n    const isTextContent = typeof content === 'string';\n    if (isJSONContent) {\n        try {\n            const isArrayContent = Array.isArray(content) && content.length > 0;\n            // if the JSON Content is an array of nodes, create a fragment for each node\n            if (isArrayContent) {\n                return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n            }\n            const node = schema.nodeFromJSON(content);\n            if (options.errorOnInvalidContent) {\n                node.check();\n            }\n            return node;\n        }\n        catch (error) {\n            if (options.errorOnInvalidContent) {\n                throw new Error('[tiptap error]: Invalid JSON content', { cause: error });\n            }\n            console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n            return createNodeFromContent('', schema, options);\n        }\n    }\n    if (isTextContent) {\n        // Check for invalid content\n        if (options.errorOnInvalidContent) {\n            let hasInvalidContent = false;\n            let invalidContent = '';\n            // A copy of the current schema with a catch-all node at the end\n            const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n                topNode: schema.spec.topNode,\n                marks: schema.spec.marks,\n                // Prosemirror's schemas are executed such that: the last to execute, matches last\n                // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n                nodes: schema.spec.nodes.append({\n                    __tiptap__private__unknown__catch__all__node: {\n                        content: 'inline*',\n                        group: 'block',\n                        parseDOM: [\n                            {\n                                tag: '*',\n                                getAttrs: e => {\n                                    // If this is ever called, we know that the content has something that we don't know how to handle in the schema\n                                    hasInvalidContent = true;\n                                    // Try to stringify the element for a more helpful error message\n                                    invalidContent = typeof e === 'string' ? e : e.outerHTML;\n                                    return null;\n                                },\n                            },\n                        ],\n                    },\n                }),\n            });\n            if (options.slice) {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n            }\n            else {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n            }\n            if (options.errorOnInvalidContent && hasInvalidContent) {\n                throw new Error('[tiptap error]: Invalid HTML content', { cause: new Error(`Invalid element found: ${invalidContent}`) });\n            }\n        }\n        const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n        if (options.slice) {\n            return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n        }\n        return parser.parse(elementFromString(content), options.parseOptions);\n    }\n    return createNodeFromContent('', schema, options);\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    const last = tr.steps.length - 1;\n    if (last < startLen) {\n        return;\n    }\n    const step = tr.steps[last];\n    if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceAroundStep)) {\n        return;\n    }\n    const map = tr.mapping.maps[last];\n    let end = 0;\n    map.forEach((_from, _to, _newFrom, newTo) => {\n        if (end === 0) {\n            end = newTo;\n        }\n    });\n    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst isFragment = (nodeOrFragment) => {\n    return !('type' in nodeOrFragment);\n};\nconst insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\n    var _a;\n    if (dispatch) {\n        options = {\n            parseOptions: editor.options.parseOptions,\n            updateSelection: true,\n            applyInputRules: false,\n            applyPasteRules: false,\n            ...options,\n        };\n        let content;\n        try {\n            content = createNodeFromContent(value, editor.schema, {\n                parseOptions: {\n                    preserveWhitespace: 'full',\n                    ...options.parseOptions,\n                },\n                errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck,\n            });\n        }\n        catch (e) {\n            editor.emit('contentError', {\n                editor,\n                error: e,\n                disableCollaboration: () => {\n                    if (editor.storage.collaboration) {\n                        editor.storage.collaboration.isDisabled = true;\n                    }\n                },\n            });\n            return false;\n        }\n        let { from, to } = typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to };\n        let isOnlyTextContent = true;\n        let isOnlyBlockContent = true;\n        const nodes = isFragment(content) ? content : [content];\n        nodes.forEach(node => {\n            // check if added node is valid\n            node.check();\n            isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n            isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n        });\n        // check if we can replace the wrapping node by\n        // the newly inserted content\n        // example:\n        // replace an empty paragraph by an inserted image\n        // instead of inserting the image below the paragraph\n        if (from === to && isOnlyBlockContent) {\n            const { parent } = tr.doc.resolve(from);\n            const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n            if (isEmptyTextBlock) {\n                from -= 1;\n                to += 1;\n            }\n        }\n        let newContent;\n        // if there is only plain text we have to use `insertText`\n        // because this will keep the current marks\n        if (isOnlyTextContent) {\n            // if value is string, we can use it directly\n            // otherwise if it is an array, we have to join it\n            if (Array.isArray(value)) {\n                newContent = value.map(v => v.text || '').join('');\n            }\n            else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n                let text = '';\n                value.forEach(node => {\n                    if (node.text) {\n                        text += node.text;\n                    }\n                });\n                newContent = text;\n            }\n            else if (typeof value === 'object' && !!value && !!value.text) {\n                newContent = value.text;\n            }\n            else {\n                newContent = value;\n            }\n            tr.insertText(newContent, from, to);\n        }\n        else {\n            newContent = content;\n            tr.replaceWith(from, to, newContent);\n        }\n        // set cursor at end of inserted content\n        if (options.updateSelection) {\n            selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n        }\n        if (options.applyInputRules) {\n            tr.setMeta('applyInputRules', { from, text: newContent });\n        }\n        if (options.applyPasteRules) {\n            tr.setMeta('applyPasteRules', { from, text: newContent });\n        }\n    }\n    return true;\n};\n\nconst joinUp = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);\n};\nconst joinDown = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);\n};\nconst joinBackward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);\n};\nconst joinForward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);\n};\n\nconst joinItemBackward = () => ({ state, dispatch, tr, }) => {\n    try {\n        const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n        if (point === null || point === undefined) {\n            return false;\n        }\n        tr.join(point, 2);\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\n\nconst joinItemForward = () => ({ state, dispatch, tr, }) => {\n    try {\n        const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, +1);\n        if (point === null || point === undefined) {\n            return false;\n        }\n        tr.join(point, 2);\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\n\nconst joinTextblockBackward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockBackward)(state, dispatch);\n};\n\nconst joinTextblockForward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockForward)(state, dispatch);\n};\n\nfunction isMacOS() {\n    return typeof navigator !== 'undefined'\n        ? /Mac/.test(navigator.platform)\n        : false;\n}\n\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result === 'Space') {\n        result = ' ';\n    }\n    let alt;\n    let ctrl;\n    let shift;\n    let meta;\n    for (let i = 0; i < parts.length - 1; i += 1) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n            meta = true;\n        }\n        else if (/^a(lt)?$/i.test(mod)) {\n            alt = true;\n        }\n        else if (/^(c|ctrl|control)$/i.test(mod)) {\n            ctrl = true;\n        }\n        else if (/^s(hift)?$/i.test(mod)) {\n            shift = true;\n        }\n        else if (/^mod$/i.test(mod)) {\n            if (isiOS() || isMacOS()) {\n                meta = true;\n            }\n            else {\n                ctrl = true;\n            }\n        }\n        else {\n            throw new Error(`Unrecognized modifier name: ${mod}`);\n        }\n    }\n    if (alt) {\n        result = `Alt-${result}`;\n    }\n    if (ctrl) {\n        result = `Ctrl-${result}`;\n    }\n    if (meta) {\n        result = `Meta-${result}`;\n    }\n    if (shift) {\n        result = `Shift-${result}`;\n    }\n    return result;\n}\nconst keyboardShortcut = name => ({ editor, view, tr, dispatch, }) => {\n    const keys = normalizeKeyName(name).split(/-(?!$)/);\n    const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n    const event = new KeyboardEvent('keydown', {\n        key: key === 'Space'\n            ? ' '\n            : key,\n        altKey: keys.includes('Alt'),\n        ctrlKey: keys.includes('Ctrl'),\n        metaKey: keys.includes('Meta'),\n        shiftKey: keys.includes('Shift'),\n        bubbles: true,\n        cancelable: true,\n    });\n    const capturedTransaction = editor.captureTransaction(() => {\n        view.someProp('handleKeyDown', f => f(view, event));\n    });\n    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n        const newStep = step.map(tr.mapping);\n        if (newStep && dispatch) {\n            tr.maybeStep(newStep);\n        }\n    });\n    return true;\n};\n\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n    const { from, to, empty } = state.selection;\n    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n    const nodeRanges = [];\n    state.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isText) {\n            return;\n        }\n        const relativeFrom = Math.max(from, pos);\n        const relativeTo = Math.min(to, pos + node.nodeSize);\n        nodeRanges.push({\n            node,\n            from: relativeFrom,\n            to: relativeTo,\n        });\n    });\n    const selectionRange = to - from;\n    const matchedNodeRanges = nodeRanges\n        .filter(nodeRange => {\n        if (!type) {\n            return true;\n        }\n        return type.name === nodeRange.node.type.name;\n    })\n        .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\n    if (empty) {\n        return !!matchedNodeRanges.length;\n    }\n    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n    return range >= selectionRange;\n}\n\nconst lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (!isActive) {\n        return false;\n    }\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);\n};\n\nconst liftEmptyBlock = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);\n};\n\nconst liftListItem = typeOrName => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);\n};\n\nconst newlineInCode = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);\n};\n\n/**\n * Get the type of a schema item by its name.\n * @param name The name of the schema item\n * @param schema The Prosemiror schema to search in\n * @returns The type of the schema item (`node` or `mark`), or null if it doesn't exist\n */\nfunction getSchemaTypeNameByName(name, schema) {\n    if (schema.nodes[name]) {\n        return 'node';\n    }\n    if (schema.marks[name]) {\n        return 'mark';\n    }\n    return null;\n}\n\n/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nfunction deleteProps(obj, propOrProps) {\n    const props = typeof propOrProps === 'string'\n        ? [propOrProps]\n        : propOrProps;\n    return Object\n        .keys(obj)\n        .reduce((newObj, prop) => {\n        if (!props.includes(prop)) {\n            newObj[prop] = obj[prop];\n        }\n        return newObj;\n    }, {});\n}\n\nconst resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n        return false;\n    }\n    if (schemaType === 'node') {\n        nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n        markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n        tr.selection.ranges.forEach(range => {\n            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n                if (nodeType && nodeType === node.type) {\n                    tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n                }\n                if (markType && node.marks.length) {\n                    node.marks.forEach(mark => {\n                        if (markType === mark.type) {\n                            tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n                        }\n                    });\n                }\n            });\n        });\n    }\n    return true;\n};\n\nconst scrollIntoView = () => ({ tr, dispatch }) => {\n    if (dispatch) {\n        tr.scrollIntoView();\n    }\n    return true;\n};\n\nconst selectAll = () => ({ tr, dispatch }) => {\n    if (dispatch) {\n        const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection(tr.doc);\n        tr.setSelection(selection);\n    }\n    return true;\n};\n\nconst selectNodeBackward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);\n};\n\nconst selectNodeForward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);\n};\n\nconst selectParentNode = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);\n};\n\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockEnd = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);\n};\n\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockStart = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);\n};\n\n/**\n * Create a new Prosemirror document node from content.\n * @param content The JSON or HTML content to create the document from\n * @param schema The Prosemirror schema to use for the document\n * @param parseOptions Options for the parser\n * @returns The created Prosemirror document node\n */\nfunction createDocument(content, schema, parseOptions = {}, options = {}) {\n    return createNodeFromContent(content, schema, {\n        slice: false,\n        parseOptions,\n        errorOnInvalidContent: options.errorOnInvalidContent,\n    });\n}\n\nconst setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr, dispatch, commands, }) => {\n    var _a, _b;\n    const { doc } = tr;\n    // This is to keep backward compatibility with the previous behavior\n    // TODO remove this in the next major version\n    if (parseOptions.preserveWhitespace !== 'full') {\n        const document = createDocument(content, editor.schema, parseOptions, {\n            errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck,\n        });\n        if (dispatch) {\n            tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n        }\n        return true;\n    }\n    if (dispatch) {\n        tr.setMeta('preventUpdate', !emitUpdate);\n    }\n    return commands.insertContentAt({ from: 0, to: doc.content.size }, content, {\n        parseOptions,\n        errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck,\n    });\n};\n\nfunction getMarkAttributes(state, typeOrName) {\n    const type = getMarkType(typeOrName, state.schema);\n    const { from, to, empty } = state.selection;\n    const marks = [];\n    if (empty) {\n        if (state.storedMarks) {\n            marks.push(...state.storedMarks);\n        }\n        marks.push(...state.selection.$head.marks());\n    }\n    else {\n        state.doc.nodesBetween(from, to, node => {\n            marks.push(...node.marks);\n        });\n    }\n    const mark = marks.find(markItem => markItem.type.name === type.name);\n    if (!mark) {\n        return {};\n    }\n    return { ...mark.attrs };\n}\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n * @param oldDoc The Prosemirror node to start from\n * @param transactions The transactions to combine\n * @returns A new `Transform` with all steps of the passed transactions\n */\nfunction combineTransactionSteps(oldDoc, transactions) {\n    const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.Transform(oldDoc);\n    transactions.forEach(transaction => {\n        transaction.steps.forEach(step => {\n            transform.step(step);\n        });\n    });\n    return transform;\n}\n\n/**\n * Gets the default block type at a given match\n * @param match The content match to get the default block type from\n * @returns The default block type or null\n */\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i += 1) {\n        const { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\n            return type;\n        }\n    }\n    return null;\n}\n\n/**\n * Find children inside a Prosemirror node that match a predicate.\n * @param node The Prosemirror node to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */\nfunction findChildren(node, predicate) {\n    const nodesWithPos = [];\n    node.descendants((child, pos) => {\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos,\n            });\n        }\n    });\n    return nodesWithPos;\n}\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n * @param node The Prosemirror node to search in\n * @param range The range to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */\nfunction findChildrenInRange(node, range, predicate) {\n    const nodesWithPos = [];\n    // if (range.from === range.to) {\n    //   const nodeAt = node.nodeAt(range.from)\n    //   if (nodeAt) {\n    //     nodesWithPos.push({\n    //       node: nodeAt,\n    //       pos: range.from,\n    //     })\n    //   }\n    // }\n    node.nodesBetween(range.from, range.to, (child, pos) => {\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos,\n            });\n        }\n    });\n    return nodesWithPos;\n}\n\n/**\n * Finds the closest parent node to a resolved position that matches a predicate.\n * @param $pos The resolved position to search from\n * @param predicate The predicate to match\n * @returns The closest parent node to the resolved position that matches the predicate\n * @example ```js\n * findParentNodeClosestToPos($from, node => node.type.name === 'paragraph')\n * ```\n */\nfunction findParentNodeClosestToPos($pos, predicate) {\n    for (let i = $pos.depth; i > 0; i -= 1) {\n        const node = $pos.node(i);\n        if (predicate(node)) {\n            return {\n                pos: i > 0 ? $pos.before(i) : 0,\n                start: $pos.start(i),\n                depth: i,\n                node,\n            };\n        }\n    }\n}\n\n/**\n * Finds the closest parent node to the current selection that matches a predicate.\n * @param predicate The predicate to match\n * @returns A command that finds the closest parent node to the current selection that matches the predicate\n * @example ```js\n * findParentNode(node => node.type.name === 'paragraph')\n * ```\n */\nfunction findParentNode(predicate) {\n    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\nfunction getSchema(extensions, editor) {\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\n    return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n\n/**\n * Generate HTML from a JSONContent\n * @param doc The JSONContent to generate HTML from\n * @param extensions The extensions to use for the schema\n * @returns The generated HTML\n */\nfunction generateHTML(doc, extensions) {\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getHTMLFromFragment(contentNode.content, schema);\n}\n\n/**\n * Generate JSONContent from HTML\n * @param html The HTML to generate JSONContent from\n * @param extensions The extensions to use for the schema\n * @returns The generated JSONContent\n */\nfunction generateJSON(html, extensions) {\n    const schema = getSchema(extensions);\n    const dom = elementFromString(html);\n    return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n\n/**\n * Gets the text of a Prosemirror node\n * @param node The Prosemirror node\n * @param options Options for the text serializer & block separator\n * @returns The text of the node\n * @example ```js\n * const text = getText(node, { blockSeparator: '\\n' })\n * ```\n */\nfunction getText(node, options) {\n    const range = {\n        from: 0,\n        to: node.content.size,\n    };\n    return getTextBetween(node, range, options);\n}\n\n/**\n * Generate raw text from a JSONContent\n * @param doc The JSONContent to generate text from\n * @param extensions The extensions to use for the schema\n * @param options Options for the text generation f.e. blockSeparator or textSerializers\n * @returns The generated text\n */\nfunction generateText(doc, extensions, options) {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getText(contentNode, {\n        blockSeparator,\n        textSerializers: {\n            ...getTextSerializersFromSchema(schema),\n            ...textSerializers,\n        },\n    });\n}\n\nfunction getNodeAttributes(state, typeOrName) {\n    const type = getNodeType(typeOrName, state.schema);\n    const { from, to } = state.selection;\n    const nodes = [];\n    state.doc.nodesBetween(from, to, node => {\n        nodes.push(node);\n    });\n    const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n    if (!node) {\n        return {};\n    }\n    return { ...node.attrs };\n}\n\n/**\n * Get node or mark attributes by type or name on the current editor state\n * @param state The current editor state\n * @param typeOrName The node or mark type or name\n * @returns The attributes of the node or mark or an empty object\n */\nfunction getAttributes(state, typeOrName) {\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (schemaType === 'node') {\n        return getNodeAttributes(state, typeOrName);\n    }\n    if (schemaType === 'mark') {\n        return getMarkAttributes(state, typeOrName);\n    }\n    return {};\n}\n\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nfunction removeDuplicates(array, by = JSON.stringify) {\n    const seen = {};\n    return array.filter(item => {\n        const key = by(item);\n        return Object.prototype.hasOwnProperty.call(seen, key)\n            ? false\n            : (seen[key] = true);\n    });\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes) {\n    const uniqueChanges = removeDuplicates(changes);\n    return uniqueChanges.length === 1\n        ? uniqueChanges\n        : uniqueChanges.filter((change, index) => {\n            const rest = uniqueChanges.filter((_, i) => i !== index);\n            return !rest.some(otherChange => {\n                return change.oldRange.from >= otherChange.oldRange.from\n                    && change.oldRange.to <= otherChange.oldRange.to\n                    && change.newRange.from >= otherChange.newRange.from\n                    && change.newRange.to <= otherChange.newRange.to;\n            });\n        });\n}\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nfunction getChangedRanges(transform) {\n    const { mapping, steps } = transform;\n    const changes = [];\n    mapping.maps.forEach((stepMap, index) => {\n        const ranges = [];\n        // This accounts for step changes where no range was actually altered\n        // e.g. when setting a mark, node attribute, etc.\n        // @ts-ignore\n        if (!stepMap.ranges.length) {\n            const { from, to } = steps[index];\n            if (from === undefined || to === undefined) {\n                return;\n            }\n            ranges.push({ from, to });\n        }\n        else {\n            stepMap.forEach((from, to) => {\n                ranges.push({ from, to });\n            });\n        }\n        ranges.forEach(({ from, to }) => {\n            const newStart = mapping.slice(index).map(from, -1);\n            const newEnd = mapping.slice(index).map(to);\n            const oldStart = mapping.invert().map(newStart, -1);\n            const oldEnd = mapping.invert().map(newEnd);\n            changes.push({\n                oldRange: {\n                    from: oldStart,\n                    to: oldEnd,\n                },\n                newRange: {\n                    from: newStart,\n                    to: newEnd,\n                },\n            });\n        });\n    });\n    return simplifyChangedRanges(changes);\n}\n\nfunction getDebugJSON(node, startOffset = 0) {\n    const isTopNode = node.type === node.type.schema.topNodeType;\n    const increment = isTopNode ? 0 : 1;\n    const from = startOffset;\n    const to = from + node.nodeSize;\n    const marks = node.marks.map(mark => {\n        const output = {\n            type: mark.type.name,\n        };\n        if (Object.keys(mark.attrs).length) {\n            output.attrs = { ...mark.attrs };\n        }\n        return output;\n    });\n    const attrs = { ...node.attrs };\n    const output = {\n        type: node.type.name,\n        from,\n        to,\n    };\n    if (Object.keys(attrs).length) {\n        output.attrs = attrs;\n    }\n    if (marks.length) {\n        output.marks = marks;\n    }\n    if (node.content.childCount) {\n        output.content = [];\n        node.forEach((child, offset) => {\n            var _a;\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n        });\n    }\n    if (node.text) {\n        output.text = node.text;\n    }\n    return output;\n}\n\nfunction getMarksBetween(from, to, doc) {\n    const marks = [];\n    // get all inclusive marks on empty selection\n    if (from === to) {\n        doc\n            .resolve(from)\n            .marks()\n            .forEach(mark => {\n            const $pos = doc.resolve(from);\n            const range = getMarkRange($pos, mark.type);\n            if (!range) {\n                return;\n            }\n            marks.push({\n                mark,\n                ...range,\n            });\n        });\n    }\n    else {\n        doc.nodesBetween(from, to, (node, pos) => {\n            if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === undefined) {\n                return;\n            }\n            marks.push(...node.marks.map(mark => ({\n                from: pos,\n                to: pos + node.nodeSize,\n                mark,\n            })));\n        });\n    }\n    return marks;\n}\n\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */\nconst getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {\n    const $pos = state.doc.resolve(pos);\n    let currentDepth = maxDepth;\n    let node = null;\n    while (currentDepth > 0 && node === null) {\n        const currentNode = $pos.node(currentDepth);\n        if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n            node = currentNode;\n        }\n        else {\n            currentDepth -= 1;\n        }\n    }\n    return [node, currentDepth];\n};\n\n/**\n * Return attributes of an extension that should be splitted by keepOnSplit flag\n * @param extensionAttributes Array of extension attributes\n * @param typeName The type of the extension\n * @param attributes The attributes of the extension\n * @returns The splitted attributes\n */\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n    return Object.fromEntries(Object\n        .entries(attributes)\n        .filter(([name]) => {\n        const extensionAttribute = extensionAttributes.find(item => {\n            return item.type === typeName && item.name === name;\n        });\n        if (!extensionAttribute) {\n            return false;\n        }\n        return extensionAttribute.attribute.keepOnSplit;\n    }));\n}\n\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n    const { empty, ranges } = state.selection;\n    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n    if (empty) {\n        return !!(state.storedMarks || state.selection.$from.marks())\n            .filter(mark => {\n            if (!type) {\n                return true;\n            }\n            return type.name === mark.type.name;\n        })\n            .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }));\n    }\n    let selectionRange = 0;\n    const markRanges = [];\n    ranges.forEach(({ $from, $to }) => {\n        const from = $from.pos;\n        const to = $to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n            if (!node.isText && !node.marks.length) {\n                return;\n            }\n            const relativeFrom = Math.max(from, pos);\n            const relativeTo = Math.min(to, pos + node.nodeSize);\n            const range = relativeTo - relativeFrom;\n            selectionRange += range;\n            markRanges.push(...node.marks.map(mark => ({\n                mark,\n                from: relativeFrom,\n                to: relativeTo,\n            })));\n        });\n    });\n    if (selectionRange === 0) {\n        return false;\n    }\n    // calculate range of matched mark\n    const matchedRange = markRanges\n        .filter(markRange => {\n        if (!type) {\n            return true;\n        }\n        return type.name === markRange.mark.type.name;\n    })\n        .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n    // calculate range of marks that excludes the searched mark\n    // for example `code` doesn’t allow any other marks\n    const excludedRange = markRanges\n        .filter(markRange => {\n        if (!type) {\n            return true;\n        }\n        return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n    })\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n    // we only include the result of `excludedRange`\n    // if there is a match at all\n    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n    return range >= selectionRange;\n}\n\nfunction isActive(state, name, attributes = {}) {\n    if (!name) {\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n    }\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\n    if (schemaType === 'node') {\n        return isNodeActive(state, name, attributes);\n    }\n    if (schemaType === 'mark') {\n        return isMarkActive(state, name, attributes);\n    }\n    return false;\n}\n\nconst isAtEndOfNode = (state, nodeType) => {\n    const { $from, $to, $anchor } = state.selection;\n    if (nodeType) {\n        const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection);\n        if (!parentNode) {\n            return false;\n        }\n        const $parentPos = state.doc.resolve(parentNode.pos + 1);\n        if ($anchor.pos + 1 === $parentPos.end()) {\n            return true;\n        }\n        return false;\n    }\n    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\n\nconst isAtStartOfNode = (state) => {\n    const { $from, $to } = state.selection;\n    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\n\nfunction isList(name, extensions) {\n    const { nodeExtensions } = splitExtensions(extensions);\n    const extension = nodeExtensions.find(item => item.name === name);\n    if (!extension) {\n        return false;\n    }\n    const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n    };\n    const group = callOrReturn(getExtensionField(extension, 'group', context));\n    if (typeof group !== 'string') {\n        return false;\n    }\n    return group.split(' ').includes('list');\n}\n\n/**\n * Returns true if the given prosemirror node is empty.\n */\nfunction isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false, } = {}) {\n    var _a;\n    if (ignoreWhitespace) {\n        if (node.type.name === 'hardBreak') {\n            // Hard breaks are considered empty\n            return true;\n        }\n        if (node.isText) {\n            return /^\\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : '');\n        }\n    }\n    if (node.isText) {\n        return !node.text;\n    }\n    if (node.isAtom || node.isLeaf) {\n        return false;\n    }\n    if (node.content.childCount === 0) {\n        return true;\n    }\n    if (checkChildren) {\n        let isContentEmpty = true;\n        node.content.forEach(childNode => {\n            if (isContentEmpty === false) {\n                // Exit early for perf\n                return;\n            }\n            if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {\n                isContentEmpty = false;\n            }\n        });\n        return isContentEmpty;\n    }\n    return false;\n}\n\nfunction isNodeSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;\n}\n\nfunction posToDOMRect(view, from, to) {\n    const minPos = 0;\n    const maxPos = view.state.doc.content.size;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const start = view.coordsAtPos(resolvedFrom);\n    const end = view.coordsAtPos(resolvedEnd, -1);\n    const top = Math.min(start.top, end.top);\n    const bottom = Math.max(start.bottom, end.bottom);\n    const left = Math.min(start.left, end.left);\n    const right = Math.max(start.right, end.right);\n    const width = right - left;\n    const height = bottom - top;\n    const x = left;\n    const y = top;\n    const data = {\n        top,\n        bottom,\n        left,\n        right,\n        width,\n        height,\n        x,\n        y,\n    };\n    return {\n        ...data,\n        toJSON: () => data,\n    };\n}\n\n/**\n * The actual implementation of the rewriteUnknownContent function\n */\nfunction rewriteUnknownContentInner({ json, validMarks, validNodes, options, rewrittenContent = [], }) {\n    if (json.marks && Array.isArray(json.marks)) {\n        json.marks = json.marks.filter(mark => {\n            const name = typeof mark === 'string' ? mark : mark.type;\n            if (validMarks.has(name)) {\n                return true;\n            }\n            rewrittenContent.push({\n                original: JSON.parse(JSON.stringify(mark)),\n                unsupported: name,\n            });\n            // Just ignore any unknown marks\n            return false;\n        });\n    }\n    if (json.content && Array.isArray(json.content)) {\n        json.content = json.content\n            .map(value => rewriteUnknownContentInner({\n            json: value,\n            validMarks,\n            validNodes,\n            options,\n            rewrittenContent,\n        }).json)\n            .filter(a => a !== null && a !== undefined);\n    }\n    if (json.type && !validNodes.has(json.type)) {\n        rewrittenContent.push({\n            original: JSON.parse(JSON.stringify(json)),\n            unsupported: json.type,\n        });\n        if (json.content && Array.isArray(json.content) && ((options === null || options === void 0 ? void 0 : options.fallbackToParagraph) !== false)) {\n            // Just treat it like a paragraph and hope for the best\n            json.type = 'paragraph';\n            return {\n                json,\n                rewrittenContent,\n            };\n        }\n        // or just omit it entirely\n        return {\n            json: null,\n            rewrittenContent,\n        };\n    }\n    return { json, rewrittenContent };\n}\n/**\n * Rewrite unknown nodes and marks within JSON content\n * Allowing for user within the editor\n */\nfunction rewriteUnknownContent(\n/**\n * The JSON content to clean of unknown nodes and marks\n */\njson, \n/**\n * The schema to use for validation\n */\nschema, \n/**\n * Options for the cleaning process\n */\noptions) {\n    return rewriteUnknownContentInner({\n        json,\n        validNodes: new Set(Object.keys(schema.nodes)),\n        validMarks: new Set(Object.keys(schema.marks)),\n        options,\n    });\n}\n\nfunction canSetMark(state, tr, newMarkType) {\n    var _a;\n    const { selection } = tr;\n    let cursor = null;\n    if (isTextSelection(selection)) {\n        cursor = selection.$cursor;\n    }\n    if (cursor) {\n        const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n        // There can be no current marks that exclude the new mark\n        return (!!newMarkType.isInSet(currentMarks)\n            || !currentMarks.some(mark => mark.type.excludes(newMarkType)));\n    }\n    const { ranges } = selection;\n    return ranges.some(({ $from, $to }) => {\n        let someNodeSupportsMark = $from.depth === 0\n            ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\n            : false;\n        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n            // If we already found a mark that we can enable, return false to bypass the remaining search\n            if (someNodeSupportsMark) {\n                return false;\n            }\n            if (node.isInline) {\n                const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n                const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\n                    || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\n                someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n            }\n            return !someNodeSupportsMark;\n        });\n        return someNodeSupportsMark;\n    });\n}\nconst setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n    const { selection } = tr;\n    const { empty, ranges } = selection;\n    const type = getMarkType(typeOrName, state.schema);\n    if (dispatch) {\n        if (empty) {\n            const oldAttributes = getMarkAttributes(state, type);\n            tr.addStoredMark(type.create({\n                ...oldAttributes,\n                ...attributes,\n            }));\n        }\n        else {\n            ranges.forEach(range => {\n                const from = range.$from.pos;\n                const to = range.$to.pos;\n                state.doc.nodesBetween(from, to, (node, pos) => {\n                    const trimmedFrom = Math.max(pos, from);\n                    const trimmedTo = Math.min(pos + node.nodeSize, to);\n                    const someHasMark = node.marks.find(mark => mark.type === type);\n                    // if there is already a mark of this type\n                    // we know that we have to merge its attributes\n                    // otherwise we add a fresh new mark\n                    if (someHasMark) {\n                        node.marks.forEach(mark => {\n                            if (type === mark.type) {\n                                tr.addMark(trimmedFrom, trimmedTo, type.create({\n                                    ...mark.attrs,\n                                    ...attributes,\n                                }));\n                            }\n                        });\n                    }\n                    else {\n                        tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n                    }\n                });\n            });\n        }\n    }\n    return canSetMark(state, tr, type);\n};\n\nconst setMeta = (key, value) => ({ tr }) => {\n    tr.setMeta(key, value);\n    return true;\n};\n\nconst setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    let attributesToCopy;\n    if (state.selection.$anchor.sameParent(state.selection.$head)) {\n        // only copy attributes if the selection is pointing to a node of the same type\n        attributesToCopy = state.selection.$anchor.parent.attrs;\n    }\n    // TODO: use a fallback like insertContent?\n    if (!type.isTextblock) {\n        console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n        return false;\n    }\n    return (chain()\n        // try to convert node to default node if needed\n        .command(({ commands }) => {\n        const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, { ...attributesToCopy, ...attributes })(state);\n        if (canSetBlock) {\n            return true;\n        }\n        return commands.clearNodes();\n    })\n        .command(({ state: updatedState }) => {\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);\n    })\n        .run());\n};\n\nconst setNodeSelection = position => ({ tr, dispatch }) => {\n    if (dispatch) {\n        const { doc } = tr;\n        const from = minMax(position, 0, doc.content.size);\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);\n        tr.setSelection(selection);\n    }\n    return true;\n};\n\nconst setTextSelection = position => ({ tr, dispatch }) => {\n    if (dispatch) {\n        const { doc } = tr;\n        const { from, to } = typeof position === 'number' ? { from: position, to: position } : position;\n        const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;\n        const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;\n        const resolvedFrom = minMax(from, minPos, maxPos);\n        const resolvedEnd = minMax(to, minPos, maxPos);\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n        tr.setSelection(selection);\n    }\n    return true;\n};\n\nconst sinkListItem = typeOrName => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);\n};\n\nfunction ensureMarks(state, splittableMarks) {\n    const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n    if (marks) {\n        const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n        state.tr.ensureMarks(filteredMarks);\n    }\n}\nconst splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor, }) => {\n    const { selection, doc } = tr;\n    const { $from, $to } = selection;\n    const extensionAttributes = editor.extensionManager.attributes;\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {\n        if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(doc, $from.pos)) {\n            return false;\n        }\n        if (dispatch) {\n            if (keepMarks) {\n                ensureMarks(state, editor.extensionManager.splittableMarks);\n            }\n            tr.split($from.pos).scrollIntoView();\n        }\n        return true;\n    }\n    if (!$from.parent.isBlock) {\n        return false;\n    }\n    const atEnd = $to.parentOffset === $to.parent.content.size;\n    const deflt = $from.depth === 0\n        ? undefined\n        : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt\n        ? [\n            {\n                type: deflt,\n                attrs: newAttributes,\n            },\n        ]\n        : undefined;\n    let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n    if (!types\n        && !can\n        && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\n        can = true;\n        types = deflt\n            ? [\n                {\n                    type: deflt,\n                    attrs: newAttributes,\n                },\n            ]\n            : undefined;\n    }\n    if (dispatch) {\n        if (can) {\n            if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n                tr.deleteSelection();\n            }\n            tr.split(tr.mapping.map($from.pos), 1, types);\n            if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n                const first = tr.mapping.map($from.before());\n                const $first = tr.doc.resolve(first);\n                if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n                    tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n        }\n        if (keepMarks) {\n            ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n        tr.scrollIntoView();\n    }\n    return can;\n};\n\nconst splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor, }) => {\n    var _a;\n    const type = getNodeType(typeOrName, state.schema);\n    const { $from, $to } = state.selection;\n    // @ts-ignore\n    // eslint-disable-next-line\n    const node = state.selection.node;\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n        return false;\n    }\n    const grandParent = $from.node(-1);\n    if (grandParent.type !== type) {\n        return false;\n    }\n    const extensionAttributes = editor.extensionManager.attributes;\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n        // In an empty block. If this is a nested list, the wrapping\n        // list item should be split. Otherwise, bail out and let next\n        // command handle lifting.\n        if ($from.depth === 2\n            || $from.node(-3).type !== type\n            || $from.index(-2) !== $from.node(-2).childCount - 1) {\n            return false;\n        }\n        if (dispatch) {\n            let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n            // eslint-disable-next-line\n            const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n            // Build a fragment containing empty versions of the structure\n            // from the outer list item to the parent node of the cursor\n            for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n                wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n            }\n            // eslint-disable-next-line\n            const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n            // Add a second list item with an empty default start node\n            const newNextTypeAttributes = {\n                ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n                ...overrideAttrs,\n            };\n            const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n            wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType) || undefined));\n            const start = $from.before($from.depth - (depthBefore - 1));\n            tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n            let sel = -1;\n            tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n                if (sel > -1) {\n                    return false;\n                }\n                if (n.isTextblock && n.content.size === 0) {\n                    sel = pos + 1;\n                }\n            });\n            if (sel > -1) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));\n            }\n            tr.scrollIntoView();\n        }\n        return true;\n    }\n    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    const newTypeAttributes = {\n        ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n        ...overrideAttrs,\n    };\n    const newNextTypeAttributes = {\n        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n        ...overrideAttrs,\n    };\n    tr.delete($from.pos, $to.pos);\n    const types = nextType\n        ? [\n            { type, attrs: newTypeAttributes },\n            { type: nextType, attrs: newNextTypeAttributes },\n        ]\n        : [{ type, attrs: newTypeAttributes }];\n    if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, $from.pos, 2)) {\n        return false;\n    }\n    if (dispatch) {\n        const { selection, storedMarks } = state;\n        const { splittableMarks } = editor.extensionManager;\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\n        tr.split($from.pos, 2, types).scrollIntoView();\n        if (!marks || !dispatch) {\n            return true;\n        }\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n        tr.ensureMarks(filteredMarks);\n    }\n    return true;\n};\n\nconst joinListBackwards = (tr, listType) => {\n    const list = findParentNode(node => node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n    if (before === undefined) {\n        return true;\n    }\n    const nodeBefore = tr.doc.nodeAt(before);\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, list.pos);\n    if (!canJoinBackwards) {\n        return true;\n    }\n    tr.join(list.pos);\n    return true;\n};\nconst joinListForwards = (tr, listType) => {\n    const list = findParentNode(node => node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const after = tr.doc.resolve(list.start).after(list.depth);\n    if (after === undefined) {\n        return true;\n    }\n    const nodeAfter = tr.doc.nodeAt(after);\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, after);\n    if (!canJoinForwards) {\n        return true;\n    }\n    tr.join(after);\n    return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands, can, }) => {\n    const { extensions, splittableMarks } = editor.extensionManager;\n    const listType = getNodeType(listTypeOrName, state.schema);\n    const itemType = getNodeType(itemTypeOrName, state.schema);\n    const { selection, storedMarks } = state;\n    const { $from, $to } = selection;\n    const range = $from.blockRange($to);\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\n    if (!range) {\n        return false;\n    }\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n        // remove list\n        if (parentList.node.type === listType) {\n            return commands.liftListItem(itemType);\n        }\n        // change list type\n        if (isList(parentList.node.type.name, extensions)\n            && listType.validContent(parentList.node.content)\n            && dispatch) {\n            return chain()\n                .command(() => {\n                tr.setNodeMarkup(parentList.pos, listType);\n                return true;\n            })\n                .command(() => joinListBackwards(tr, listType))\n                .command(() => joinListForwards(tr, listType))\n                .run();\n        }\n    }\n    if (!keepMarks || !marks || !dispatch) {\n        return chain()\n            // try to convert node to default node if needed\n            .command(() => {\n            const canWrapInList = can().wrapInList(listType, attributes);\n            if (canWrapInList) {\n                return true;\n            }\n            return commands.clearNodes();\n        })\n            .wrapInList(listType, attributes)\n            .command(() => joinListBackwards(tr, listType))\n            .command(() => joinListForwards(tr, listType))\n            .run();\n    }\n    return (chain()\n        // try to convert node to default node if needed\n        .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes);\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n        tr.ensureMarks(filteredMarks);\n        if (canWrapInList) {\n            return true;\n        }\n        return commands.clearNodes();\n    })\n        .wrapInList(listType, attributes)\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run());\n};\n\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n    const { extendEmptyMarkRange = false } = options;\n    const type = getMarkType(typeOrName, state.schema);\n    const isActive = isMarkActive(state, type, attributes);\n    if (isActive) {\n        return commands.unsetMark(type, { extendEmptyMarkRange });\n    }\n    return commands.setMark(type, attributes);\n};\n\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    let attributesToCopy;\n    if (state.selection.$anchor.sameParent(state.selection.$head)) {\n        // only copy attributes if the selection is pointing to a node of the same type\n        attributesToCopy = state.selection.$anchor.parent.attrs;\n    }\n    if (isActive) {\n        return commands.setNode(toggleType, attributesToCopy);\n    }\n    // If the node is not active, we want to set the new node type with the given attributes\n    // Copying over the attributes from the current node if the selection is pointing to a node of the same type\n    return commands.setNode(type, { ...attributesToCopy, ...attributes });\n};\n\nconst toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n        return commands.lift(type);\n    }\n    return commands.wrapIn(type, attributes);\n};\n\nconst undoInputRule = () => ({ state, dispatch }) => {\n    const plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i += 1) {\n        const plugin = plugins[i];\n        let undoable;\n        // @ts-ignore\n        // eslint-disable-next-line\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                const tr = state.tr;\n                const toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                }\n                if (undoable.text) {\n                    const marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\nconst unsetAllMarks = () => ({ tr, dispatch }) => {\n    const { selection } = tr;\n    const { empty, ranges } = selection;\n    if (empty) {\n        return true;\n    }\n    if (dispatch) {\n        ranges.forEach(range => {\n            tr.removeMark(range.$from.pos, range.$to.pos);\n        });\n    }\n    return true;\n};\n\nconst unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n    var _a;\n    const { extendEmptyMarkRange = false } = options;\n    const { selection } = tr;\n    const type = getMarkType(typeOrName, state.schema);\n    const { $from, empty, ranges } = selection;\n    if (!dispatch) {\n        return true;\n    }\n    if (empty && extendEmptyMarkRange) {\n        let { from, to } = selection;\n        const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n        const range = getMarkRange($from, type, attrs);\n        if (range) {\n            from = range.from;\n            to = range.to;\n        }\n        tr.removeMark(from, to, type);\n    }\n    else {\n        ranges.forEach(range => {\n            tr.removeMark(range.$from.pos, range.$to.pos, type);\n        });\n    }\n    tr.removeStoredMark(type);\n    return true;\n};\n\nconst updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n        return false;\n    }\n    if (schemaType === 'node') {\n        nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n        markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n        tr.selection.ranges.forEach((range) => {\n            const from = range.$from.pos;\n            const to = range.$to.pos;\n            let lastPos;\n            let lastNode;\n            let trimmedFrom;\n            let trimmedTo;\n            if (tr.selection.empty) {\n                state.doc.nodesBetween(from, to, (node, pos) => {\n                    if (nodeType && nodeType === node.type) {\n                        trimmedFrom = Math.max(pos, from);\n                        trimmedTo = Math.min(pos + node.nodeSize, to);\n                        lastPos = pos;\n                        lastNode = node;\n                    }\n                });\n            }\n            else {\n                state.doc.nodesBetween(from, to, (node, pos) => {\n                    if (pos < from && nodeType && nodeType === node.type) {\n                        trimmedFrom = Math.max(pos, from);\n                        trimmedTo = Math.min(pos + node.nodeSize, to);\n                        lastPos = pos;\n                        lastNode = node;\n                    }\n                    if (pos >= from && pos <= to) {\n                        if (nodeType && nodeType === node.type) {\n                            tr.setNodeMarkup(pos, undefined, {\n                                ...node.attrs,\n                                ...attributes,\n                            });\n                        }\n                        if (markType && node.marks.length) {\n                            node.marks.forEach((mark) => {\n                                if (markType === mark.type) {\n                                    const trimmedFrom2 = Math.max(pos, from);\n                                    const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                                    tr.addMark(trimmedFrom2, trimmedTo2, markType.create({\n                                        ...mark.attrs,\n                                        ...attributes,\n                                    }));\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n            if (lastNode) {\n                if (lastPos !== undefined) {\n                    tr.setNodeMarkup(lastPos, undefined, {\n                        ...lastNode.attrs,\n                        ...attributes,\n                    });\n                }\n                if (markType && lastNode.marks.length) {\n                    lastNode.marks.forEach((mark) => {\n                        if (markType === mark.type) {\n                            tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                                ...mark.attrs,\n                                ...attributes,\n                            }));\n                        }\n                    });\n                }\n            }\n        });\n    }\n    return true;\n};\n\nconst wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);\n};\n\nconst wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);\n};\n\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  cut: cut,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinBackward: joinBackward,\n  joinDown: joinDown,\n  joinForward: joinForward,\n  joinItemBackward: joinItemBackward,\n  joinItemForward: joinItemForward,\n  joinTextblockBackward: joinTextblockBackward,\n  joinTextblockForward: joinTextblockForward,\n  joinUp: joinUp,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\n\nconst Commands = Extension.create({\n    name: 'commands',\n    addCommands() {\n        return {\n            ...commands,\n        };\n    },\n});\n\nconst Drop = Extension.create({\n    name: 'drop',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tiptapDrop'),\n                props: {\n                    handleDrop: (_, e, slice, moved) => {\n                        this.editor.emit('drop', {\n                            editor: this.editor,\n                            event: e,\n                            slice,\n                            moved,\n                        });\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst Editable = Extension.create({\n    name: 'editable',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('editable'),\n                props: {\n                    editable: () => this.editor.options.editable,\n                },\n            }),\n        ];\n    },\n});\n\nconst focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('focusEvents');\nconst FocusEvents = Extension.create({\n    name: 'focusEvents',\n    addProseMirrorPlugins() {\n        const { editor } = this;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: focusEventsPluginKey,\n                props: {\n                    handleDOMEvents: {\n                        focus: (view, event) => {\n                            editor.isFocused = true;\n                            const transaction = editor.state.tr\n                                .setMeta('focus', { event })\n                                .setMeta('addToHistory', false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                        blur: (view, event) => {\n                            editor.isFocused = false;\n                            const transaction = editor.state.tr\n                                .setMeta('blur', { event })\n                                .setMeta('addToHistory', false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst Keymap = Extension.create({\n    name: 'keymap',\n    addKeyboardShortcuts() {\n        const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n            () => commands.undoInputRule(),\n            // maybe convert first text block node to default node\n            () => commands.command(({ tr }) => {\n                const { selection, doc } = tr;\n                const { empty, $anchor } = selection;\n                const { pos, parent } = $anchor;\n                const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n                const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n                const parentPos = $anchor.pos - $anchor.parentOffset;\n                const isAtStart = (parentIsIsolating && $parentPos.parent.childCount === 1)\n                    ? parentPos === $anchor.pos\n                    : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;\n                if (!empty\n                    || !parent.type.isTextblock\n                    || parent.textContent.length\n                    || !isAtStart\n                    || (isAtStart && $anchor.parent.type.name === 'paragraph') // prevent clearNodes when no nodes to clear, otherwise history stack is appended\n                ) {\n                    return false;\n                }\n                return commands.clearNodes();\n            }),\n            () => commands.deleteSelection(),\n            () => commands.joinBackward(),\n            () => commands.selectNodeBackward(),\n        ]);\n        const handleDelete = () => this.editor.commands.first(({ commands }) => [\n            () => commands.deleteSelection(),\n            () => commands.deleteCurrentNode(),\n            () => commands.joinForward(),\n            () => commands.selectNodeForward(),\n        ]);\n        const handleEnter = () => this.editor.commands.first(({ commands }) => [\n            () => commands.newlineInCode(),\n            () => commands.createParagraphNear(),\n            () => commands.liftEmptyBlock(),\n            () => commands.splitBlock(),\n        ]);\n        const baseKeymap = {\n            Enter: handleEnter,\n            'Mod-Enter': () => this.editor.commands.exitCode(),\n            Backspace: handleBackspace,\n            'Mod-Backspace': handleBackspace,\n            'Shift-Backspace': handleBackspace,\n            Delete: handleDelete,\n            'Mod-Delete': handleDelete,\n            'Mod-a': () => this.editor.commands.selectAll(),\n        };\n        const pcKeymap = {\n            ...baseKeymap,\n        };\n        const macKeymap = {\n            ...baseKeymap,\n            'Ctrl-h': handleBackspace,\n            'Alt-Backspace': handleBackspace,\n            'Ctrl-d': handleDelete,\n            'Ctrl-Alt-Backspace': handleDelete,\n            'Alt-Delete': handleDelete,\n            'Alt-d': handleDelete,\n            'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n            'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n        };\n        if (isiOS() || isMacOS()) {\n            return macKeymap;\n        }\n        return pcKeymap;\n    },\n    addProseMirrorPlugins() {\n        return [\n            // With this plugin we check if the whole document was selected and deleted.\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n            // to a paragraph if necessary.\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n            // with many other commands.\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clearDocument'),\n                appendTransaction: (transactions, oldState, newState) => {\n                    if (transactions.some(tr => tr.getMeta('composition'))) {\n                        return;\n                    }\n                    const docChanges = transactions.some(transaction => transaction.docChanged)\n                        && !oldState.doc.eq(newState.doc);\n                    const ignoreTr = transactions.some(transaction => transaction.getMeta('preventClearDocument'));\n                    if (!docChanges || ignoreTr) {\n                        return;\n                    }\n                    const { empty, from, to } = oldState.selection;\n                    const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;\n                    const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;\n                    const allWasSelected = from === allFrom && to === allEnd;\n                    if (empty || !allWasSelected) {\n                        return;\n                    }\n                    const isEmpty = isNodeEmpty(newState.doc);\n                    if (!isEmpty) {\n                        return;\n                    }\n                    const tr = newState.tr;\n                    const state = createChainableState({\n                        state: newState,\n                        transaction: tr,\n                    });\n                    const { commands } = new CommandManager({\n                        editor: this.editor,\n                        state,\n                    });\n                    commands.clearNodes();\n                    if (!tr.steps.length) {\n                        return;\n                    }\n                    return tr;\n                },\n            }),\n        ];\n    },\n});\n\nconst Paste = Extension.create({\n    name: 'paste',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tiptapPaste'),\n                props: {\n                    handlePaste: (_view, e, slice) => {\n                        this.editor.emit('paste', {\n                            editor: this.editor,\n                            event: e,\n                            slice,\n                        });\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst Tabindex = Extension.create({\n    name: 'tabindex',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tabindex'),\n                props: {\n                    attributes: () => (this.editor.isEditable ? { tabindex: '0' } : {}),\n                },\n            }),\n        ];\n    },\n});\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Drop: Drop,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Paste: Paste,\n  Tabindex: Tabindex,\n  focusEventsPluginKey: focusEventsPluginKey\n});\n\nclass NodePos {\n    get name() {\n        return this.node.type.name;\n    }\n    constructor(pos, editor, isBlock = false, node = null) {\n        this.currentNode = null;\n        this.actualDepth = null;\n        this.isBlock = isBlock;\n        this.resolvedPos = pos;\n        this.editor = editor;\n        this.currentNode = node;\n    }\n    get node() {\n        return this.currentNode || this.resolvedPos.node();\n    }\n    get element() {\n        return this.editor.view.domAtPos(this.pos).node;\n    }\n    get depth() {\n        var _a;\n        return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;\n    }\n    get pos() {\n        return this.resolvedPos.pos;\n    }\n    get content() {\n        return this.node.content;\n    }\n    set content(content) {\n        let from = this.from;\n        let to = this.to;\n        if (this.isBlock) {\n            if (this.content.size === 0) {\n                console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n                return;\n            }\n            from = this.from + 1;\n            to = this.to - 1;\n        }\n        this.editor.commands.insertContentAt({ from, to }, content);\n    }\n    get attributes() {\n        return this.node.attrs;\n    }\n    get textContent() {\n        return this.node.textContent;\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get from() {\n        if (this.isBlock) {\n            return this.pos;\n        }\n        return this.resolvedPos.start(this.resolvedPos.depth);\n    }\n    get range() {\n        return {\n            from: this.from,\n            to: this.to,\n        };\n    }\n    get to() {\n        if (this.isBlock) {\n            return this.pos + this.size;\n        }\n        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n    }\n    get parent() {\n        if (this.depth === 0) {\n            return null;\n        }\n        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n        const $pos = this.resolvedPos.doc.resolve(parentPos);\n        return new NodePos($pos, this.editor);\n    }\n    get before() {\n        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.from - 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get after() {\n        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.to + 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get children() {\n        const children = [];\n        this.node.content.forEach((node, offset) => {\n            const isBlock = node.isBlock && !node.isTextblock;\n            const isNonTextAtom = node.isAtom && !node.isText;\n            const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n            const $pos = this.resolvedPos.doc.resolve(targetPos);\n            if (!isBlock && $pos.depth <= this.depth) {\n                return;\n            }\n            const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n            if (isBlock) {\n                childNodePos.actualDepth = this.depth + 1;\n            }\n            children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n        });\n        return children;\n    }\n    get firstChild() {\n        return this.children[0] || null;\n    }\n    get lastChild() {\n        const children = this.children;\n        return children[children.length - 1] || null;\n    }\n    closest(selector, attributes = {}) {\n        let node = null;\n        let currentNode = this.parent;\n        while (currentNode && !node) {\n            if (currentNode.node.type.name === selector) {\n                if (Object.keys(attributes).length > 0) {\n                    const nodeAttributes = currentNode.node.attrs;\n                    const attrKeys = Object.keys(attributes);\n                    for (let index = 0; index < attrKeys.length; index += 1) {\n                        const key = attrKeys[index];\n                        if (nodeAttributes[key] !== attributes[key]) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    node = currentNode;\n                }\n            }\n            currentNode = currentNode.parent;\n        }\n        return node;\n    }\n    querySelector(selector, attributes = {}) {\n        return this.querySelectorAll(selector, attributes, true)[0] || null;\n    }\n    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n        let nodes = [];\n        if (!this.children || this.children.length === 0) {\n            return nodes;\n        }\n        const attrKeys = Object.keys(attributes);\n        /**\n         * Finds all children recursively that match the selector and attributes\n         * If firstItemOnly is true, it will return the first item found\n         */\n        this.children.forEach(childPos => {\n            // If we already found a node and we only want the first item, we dont need to keep going\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            if (childPos.node.type.name === selector) {\n                const doesAllAttributesMatch = attrKeys.every(key => attributes[key] === childPos.node.attrs[key]);\n                if (doesAllAttributesMatch) {\n                    nodes.push(childPos);\n                }\n            }\n            // If we already found a node and we only want the first item, we can stop here and skip the recursion\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n        });\n        return nodes;\n    }\n    setAttribute(attributes) {\n        const { tr } = this.editor.state;\n        tr.setNodeMarkup(this.from, undefined, {\n            ...this.node.attrs,\n            ...attributes,\n        });\n        this.editor.view.dispatch(tr);\n    }\n}\n\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\n\nfunction createStyleTag(style, nonce, suffix) {\n    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`);\n    if (tiptapStyleTag !== null) {\n        return tiptapStyleTag;\n    }\n    const styleNode = document.createElement('style');\n    if (nonce) {\n        styleNode.setAttribute('nonce', nonce);\n    }\n    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '');\n    styleNode.innerHTML = style;\n    document.getElementsByTagName('head')[0].appendChild(styleNode);\n    return styleNode;\n}\n\nclass Editor extends EventEmitter {\n    constructor(options = {}) {\n        super();\n        this.isFocused = false;\n        /**\n         * The editor is considered initialized after the `create` event has been emitted.\n         */\n        this.isInitialized = false;\n        this.extensionStorage = {};\n        this.options = {\n            element: document.createElement('div'),\n            content: '',\n            injectCSS: true,\n            injectNonce: undefined,\n            extensions: [],\n            autofocus: false,\n            editable: true,\n            editorProps: {},\n            parseOptions: {},\n            coreExtensionOptions: {},\n            enableInputRules: true,\n            enablePasteRules: true,\n            enableCoreExtensions: true,\n            enableContentCheck: false,\n            onBeforeCreate: () => null,\n            onCreate: () => null,\n            onUpdate: () => null,\n            onSelectionUpdate: () => null,\n            onTransaction: () => null,\n            onFocus: () => null,\n            onBlur: () => null,\n            onDestroy: () => null,\n            onContentError: ({ error }) => { throw error; },\n            onPaste: () => null,\n            onDrop: () => null,\n        };\n        this.isCapturingTransaction = false;\n        this.capturedTransaction = null;\n        this.setOptions(options);\n        this.createExtensionManager();\n        this.createCommandManager();\n        this.createSchema();\n        this.on('beforeCreate', this.options.onBeforeCreate);\n        this.emit('beforeCreate', { editor: this });\n        this.on('contentError', this.options.onContentError);\n        this.createView();\n        this.injectCSS();\n        this.on('create', this.options.onCreate);\n        this.on('update', this.options.onUpdate);\n        this.on('selectionUpdate', this.options.onSelectionUpdate);\n        this.on('transaction', this.options.onTransaction);\n        this.on('focus', this.options.onFocus);\n        this.on('blur', this.options.onBlur);\n        this.on('destroy', this.options.onDestroy);\n        this.on('drop', ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));\n        this.on('paste', ({ event, slice }) => this.options.onPaste(event, slice));\n        window.setTimeout(() => {\n            if (this.isDestroyed) {\n                return;\n            }\n            this.commands.focus(this.options.autofocus);\n            this.emit('create', { editor: this });\n            this.isInitialized = true;\n        }, 0);\n    }\n    /**\n     * Returns the editor storage.\n     */\n    get storage() {\n        return this.extensionStorage;\n    }\n    /**\n     * An object of all registered commands.\n     */\n    get commands() {\n        return this.commandManager.commands;\n    }\n    /**\n     * Create a command chain to call multiple commands at once.\n     */\n    chain() {\n        return this.commandManager.chain();\n    }\n    /**\n     * Check if a command or a command chain can be executed. Without executing it.\n     */\n    can() {\n        return this.commandManager.can();\n    }\n    /**\n     * Inject CSS styles.\n     */\n    injectCSS() {\n        if (this.options.injectCSS && document) {\n            this.css = createStyleTag(style, this.options.injectNonce);\n        }\n    }\n    /**\n     * Update editor options.\n     *\n     * @param options A list of options\n     */\n    setOptions(options = {}) {\n        this.options = {\n            ...this.options,\n            ...options,\n        };\n        if (!this.view || !this.state || this.isDestroyed) {\n            return;\n        }\n        if (this.options.editorProps) {\n            this.view.setProps(this.options.editorProps);\n        }\n        this.view.updateState(this.state);\n    }\n    /**\n     * Update editable state of the editor.\n     */\n    setEditable(editable, emitUpdate = true) {\n        this.setOptions({ editable });\n        if (emitUpdate) {\n            this.emit('update', { editor: this, transaction: this.state.tr });\n        }\n    }\n    /**\n     * Returns whether the editor is editable.\n     */\n    get isEditable() {\n        // since plugins are applied after creating the view\n        // `editable` is always `true` for one tick.\n        // that’s why we also have to check for `options.editable`\n        return this.options.editable && this.view && this.view.editable;\n    }\n    /**\n     * Returns the editor state.\n     */\n    get state() {\n        return this.view.state;\n    }\n    /**\n     * Register a ProseMirror plugin.\n     *\n     * @param plugin A ProseMirror plugin\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\n     * @returns The new editor state\n     */\n    registerPlugin(plugin, handlePlugins) {\n        const plugins = isFunction(handlePlugins)\n            ? handlePlugins(plugin, [...this.state.plugins])\n            : [...this.state.plugins, plugin];\n        const state = this.state.reconfigure({ plugins });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Unregister a ProseMirror plugin.\n     *\n     * @param nameOrPluginKeyToRemove The plugins name\n     * @returns The new editor state or undefined if the editor is destroyed\n     */\n    unregisterPlugin(nameOrPluginKeyToRemove) {\n        if (this.isDestroyed) {\n            return undefined;\n        }\n        const prevPlugins = this.state.plugins;\n        let plugins = prevPlugins;\n        [].concat(nameOrPluginKeyToRemove).forEach(nameOrPluginKey => {\n            // @ts-ignore\n            const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n            // @ts-ignore\n            plugins = prevPlugins.filter(plugin => !plugin.key.startsWith(name));\n        });\n        if (prevPlugins.length === plugins.length) {\n            // No plugin was removed, so we don’t need to update the state\n            return undefined;\n        }\n        const state = this.state.reconfigure({\n            plugins,\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Creates an extension manager.\n     */\n    createExtensionManager() {\n        var _a, _b;\n        const coreExtensions = this.options.enableCoreExtensions ? [\n            Editable,\n            ClipboardTextSerializer.configure({\n                blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator,\n            }),\n            Commands,\n            FocusEvents,\n            Keymap,\n            Tabindex,\n            Drop,\n            Paste,\n        ].filter(ext => {\n            if (typeof this.options.enableCoreExtensions === 'object') {\n                return this.options.enableCoreExtensions[ext.name] !== false;\n            }\n            return true;\n        }) : [];\n        const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n            return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n        });\n        this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\n     * Creates an command manager.\n     */\n    createCommandManager() {\n        this.commandManager = new CommandManager({\n            editor: this,\n        });\n    }\n    /**\n     * Creates a ProseMirror schema.\n     */\n    createSchema() {\n        this.schema = this.extensionManager.schema;\n    }\n    /**\n     * Creates a ProseMirror view.\n     */\n    createView() {\n        var _a;\n        let doc;\n        try {\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });\n        }\n        catch (e) {\n            if (!(e instanceof Error) || !['[tiptap error]: Invalid JSON content', '[tiptap error]: Invalid HTML content'].includes(e.message)) {\n                // Not the content error we were expecting\n                throw e;\n            }\n            this.emit('contentError', {\n                editor: this,\n                error: e,\n                disableCollaboration: () => {\n                    if (this.storage.collaboration) {\n                        this.storage.collaboration.isDisabled = true;\n                    }\n                    // To avoid syncing back invalid content, reinitialize the extensions without the collaboration extension\n                    this.options.extensions = this.options.extensions.filter(extension => extension.name !== 'collaboration');\n                    // Restart the initialization process by recreating the extension manager with the new set of extensions\n                    this.createExtensionManager();\n                },\n            });\n            // Content is invalid, but attempt to create it anyway, stripping out the invalid parts\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });\n        }\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\n        this.view = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(this.options.element, {\n            ...this.options.editorProps,\n            attributes: {\n                // add `role=\"textbox\"` to the editor element\n                role: 'textbox',\n                ...(_a = this.options.editorProps) === null || _a === void 0 ? void 0 : _a.attributes,\n            },\n            dispatchTransaction: this.dispatchTransaction.bind(this),\n            state: _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                doc,\n                selection: selection || undefined,\n            }),\n        });\n        // `editor.view` is not yet available at this time.\n        // Therefore we will add all plugins and node views directly afterwards.\n        const newState = this.state.reconfigure({\n            plugins: this.extensionManager.plugins,\n        });\n        this.view.updateState(newState);\n        this.createNodeViews();\n        this.prependClass();\n        // Let’s store the editor instance in the DOM element.\n        // So we’ll have access to it for tests.\n        // @ts-ignore\n        const dom = this.view.dom;\n        dom.editor = this;\n    }\n    /**\n     * Creates all node views.\n     */\n    createNodeViews() {\n        if (this.view.isDestroyed) {\n            return;\n        }\n        this.view.setProps({\n            nodeViews: this.extensionManager.nodeViews,\n        });\n    }\n    /**\n     * Prepend class name to element.\n     */\n    prependClass() {\n        this.view.dom.className = `tiptap ${this.view.dom.className}`;\n    }\n    captureTransaction(fn) {\n        this.isCapturingTransaction = true;\n        fn();\n        this.isCapturingTransaction = false;\n        const tr = this.capturedTransaction;\n        this.capturedTransaction = null;\n        return tr;\n    }\n    /**\n     * The callback over which to send transactions (state updates) produced by the view.\n     *\n     * @param transaction An editor state transaction\n     */\n    dispatchTransaction(transaction) {\n        // if the editor / the view of the editor was destroyed\n        // the transaction should not be dispatched as there is no view anymore.\n        if (this.view.isDestroyed) {\n            return;\n        }\n        if (this.isCapturingTransaction) {\n            if (!this.capturedTransaction) {\n                this.capturedTransaction = transaction;\n                return;\n            }\n            transaction.steps.forEach(step => { var _a; return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step); });\n            return;\n        }\n        const state = this.state.apply(transaction);\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\n        this.emit('beforeTransaction', {\n            editor: this,\n            transaction,\n            nextState: state,\n        });\n        this.view.updateState(state);\n        this.emit('transaction', {\n            editor: this,\n            transaction,\n        });\n        if (selectionHasChanged) {\n            this.emit('selectionUpdate', {\n                editor: this,\n                transaction,\n            });\n        }\n        const focus = transaction.getMeta('focus');\n        const blur = transaction.getMeta('blur');\n        if (focus) {\n            this.emit('focus', {\n                editor: this,\n                event: focus.event,\n                transaction,\n            });\n        }\n        if (blur) {\n            this.emit('blur', {\n                editor: this,\n                event: blur.event,\n                transaction,\n            });\n        }\n        if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n            return;\n        }\n        this.emit('update', {\n            editor: this,\n            transaction,\n        });\n    }\n    /**\n     * Get attributes of the currently selected node or mark.\n     */\n    getAttributes(nameOrType) {\n        return getAttributes(this.state, nameOrType);\n    }\n    isActive(nameOrAttributes, attributesOrUndefined) {\n        const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n        const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n        return isActive(this.state, name, attributes);\n    }\n    /**\n     * Get the document as JSON.\n     */\n    getJSON() {\n        return this.state.doc.toJSON();\n    }\n    /**\n     * Get the document as HTML.\n     */\n    getHTML() {\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\n    }\n    /**\n     * Get the document as text.\n     */\n    getText(options) {\n        const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\n        return getText(this.state.doc, {\n            blockSeparator,\n            textSerializers: {\n                ...getTextSerializersFromSchema(this.schema),\n                ...textSerializers,\n            },\n        });\n    }\n    /**\n     * Check if there is no content.\n     */\n    get isEmpty() {\n        return isNodeEmpty(this.state.doc);\n    }\n    /**\n     * Get the number of characters for the current document.\n     *\n     * @deprecated\n     */\n    getCharacterCount() {\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n        return this.state.doc.content.size - 2;\n    }\n    /**\n     * Destroy the editor.\n     */\n    destroy() {\n        this.emit('destroy');\n        if (this.view) {\n            // Cleanup our reference to prevent circular references which caused memory leaks\n            // @ts-ignore\n            const dom = this.view.dom;\n            if (dom && dom.editor) {\n                delete dom.editor;\n            }\n            this.view.destroy();\n        }\n        this.removeAllListeners();\n    }\n    /**\n     * Check if the editor is already destroyed.\n     */\n    get isDestroyed() {\n        var _a;\n        // @ts-ignore\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n    }\n    $node(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;\n    }\n    $nodes(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n    }\n    $pos(pos) {\n        const $pos = this.state.doc.resolve(pos);\n        return new NodePos($pos, this);\n    }\n    get $doc() {\n        return this.$pos(0);\n    }\n}\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction markInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n                    .filter(item => {\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\n                })\n                    .filter(item => item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                const markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        },\n    });\n}\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction nodeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const { tr } = state;\n            const start = range.from;\n            let end = range.to;\n            const newNode = config.type.create(attributes);\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                let matchStart = start + offset;\n                if (matchStart > end) {\n                    matchStart = end;\n                }\n                else {\n                    end = matchStart + match[1].length;\n                }\n                // insert last typed character\n                const lastChar = match[0][match[0].length - 1];\n                tr.insertText(lastChar, start + match[0].length - 1);\n                // insert node from input rule\n                tr.replaceWith(matchStart, end, newNode);\n            }\n            else if (match[0]) {\n                const insertionStart = config.type.isInline ? start : start - 1;\n                tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n            }\n            tr.scrollIntoView();\n        },\n    });\n}\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction textblockTypeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            const $start = state.doc.resolve(range.from);\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n                return null;\n            }\n            state.tr\n                .delete(range.from, range.to)\n                .setBlockType(range.from, range.from, config.type, attributes);\n        },\n    });\n}\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction textInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        },\n    });\n}\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction wrappingInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match, chain, }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const tr = state.tr.delete(range.from, range.to);\n            const $start = tr.doc.resolve(range.from);\n            const blockRange = $start.blockRange();\n            const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.findWrapping)(blockRange, config.type, attributes);\n            if (!wrapping) {\n                return null;\n            }\n            tr.wrap(blockRange, wrapping);\n            if (config.keepMarks && config.editor) {\n                const { selection, storedMarks } = state;\n                const { splittableMarks } = config.editor.extensionManager;\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\n                if (marks) {\n                    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n                    tr.ensureMarks(filteredMarks);\n                }\n            }\n            if (config.keepAttributes) {\n                /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n                const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\n                chain().updateAttributes(nodeType, attributes).run();\n            }\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\n            if (before\n                && before.type === config.type\n                && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, range.from - 1)\n                && (!config.joinPredicate || config.joinPredicate(match, before))) {\n                tr.join(range.from - 1);\n            }\n        },\n    });\n}\n\n/**\n * The Node class is used to create custom node extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nclass Node {\n    constructor(config = {}) {\n        this.type = 'node';\n        this.name = 'node';\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {},\n        };\n        this.config = {\n            ...this.config,\n            ...config,\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n                name: this.name,\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n            name: this.name,\n            options: this.options,\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Node(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: () => {\n                return mergeDeep(this.options, options);\n            },\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Node(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n            name: extension.name,\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n            name: extension.name,\n            options: extension.options,\n        }));\n        return extension;\n    }\n}\n\n/**\n * Node views are used to customize the rendered DOM structure of a node.\n * @see https://tiptap.dev/guide/node-views\n */\nclass NodeView {\n    constructor(component, props, options) {\n        this.isDragging = false;\n        this.component = component;\n        this.editor = props.editor;\n        this.options = {\n            stopEvent: null,\n            ignoreMutation: null,\n            ...options,\n        };\n        this.extension = props.extension;\n        this.node = props.node;\n        this.decorations = props.decorations;\n        this.innerDecorations = props.innerDecorations;\n        this.view = props.view;\n        this.HTMLAttributes = props.HTMLAttributes;\n        this.getPos = props.getPos;\n        this.mount();\n    }\n    mount() {\n        // eslint-disable-next-line\n        return;\n    }\n    get dom() {\n        return this.editor.view.dom;\n    }\n    get contentDOM() {\n        return null;\n    }\n    onDragStart(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const { view } = this.editor;\n        const target = event.target;\n        // get the drag handle element\n        // `closest` is not available for text nodes so we may have to use its parent\n        const dragHandle = target.nodeType === 3\n            ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]')\n            : target.closest('[data-drag-handle]');\n        if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        // calculate offset for drag element if we use a different drag handle element\n        if (this.dom !== dragHandle) {\n            const domBox = this.dom.getBoundingClientRect();\n            const handleBox = dragHandle.getBoundingClientRect();\n            // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n            const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n            const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n            x = handleBox.x - domBox.x + offsetX;\n            y = handleBox.y - domBox.y + offsetY;\n        }\n        const clonedNode = this.dom.cloneNode(true);\n        (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(clonedNode, x, y);\n        const pos = this.getPos();\n        if (typeof pos !== 'number') {\n            return;\n        }\n        // we need to tell ProseMirror that we want to move the whole node\n        // so we create a NodeSelection\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, pos);\n        const transaction = view.state.tr.setSelection(selection);\n        view.dispatch(transaction);\n    }\n    stopEvent(event) {\n        var _a;\n        if (!this.dom) {\n            return false;\n        }\n        if (typeof this.options.stopEvent === 'function') {\n            return this.options.stopEvent({ event });\n        }\n        const target = event.target;\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n        // any event from child nodes should be handled by ProseMirror\n        if (!isInElement) {\n            return false;\n        }\n        const isDragEvent = event.type.startsWith('drag');\n        const isDropEvent = event.type === 'drop';\n        const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\n        // any input event within node views should be ignored by ProseMirror\n        if (isInput && !isDropEvent && !isDragEvent) {\n            return true;\n        }\n        const { isEditable } = this.editor;\n        const { isDragging } = this;\n        const isDraggable = !!this.node.type.spec.draggable;\n        const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);\n        const isCopyEvent = event.type === 'copy';\n        const isPasteEvent = event.type === 'paste';\n        const isCutEvent = event.type === 'cut';\n        const isClickEvent = event.type === 'mousedown';\n        // ProseMirror tries to drag selectable nodes\n        // even if `draggable` is set to `false`\n        // this fix prevents that\n        if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n            event.preventDefault();\n        }\n        if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n            event.preventDefault();\n            return false;\n        }\n        // we have to store that dragging started\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\n            const dragHandle = target.closest('[data-drag-handle]');\n            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n            if (isValidDragHandle) {\n                this.isDragging = true;\n                document.addEventListener('dragend', () => {\n                    this.isDragging = false;\n                }, { once: true });\n                document.addEventListener('drop', () => {\n                    this.isDragging = false;\n                }, { once: true });\n                document.addEventListener('mouseup', () => {\n                    this.isDragging = false;\n                }, { once: true });\n            }\n        }\n        // these events are handled by prosemirror\n        if (isDragging\n            || isDropEvent\n            || isCopyEvent\n            || isPasteEvent\n            || isCutEvent\n            || (isClickEvent && isSelectable)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n     * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n     * @return `true` if it can safely be ignored.\n     */\n    ignoreMutation(mutation) {\n        if (!this.dom || !this.contentDOM) {\n            return true;\n        }\n        if (typeof this.options.ignoreMutation === 'function') {\n            return this.options.ignoreMutation({ mutation });\n        }\n        // a leaf/atom node is like a black box for ProseMirror\n        // and should be fully handled by the node view\n        if (this.node.isLeaf || this.node.isAtom) {\n            return true;\n        }\n        // ProseMirror should handle any selections\n        if (mutation.type === 'selection') {\n            return false;\n        }\n        // try to prevent a bug on iOS and Android that will break node views on enter\n        // this is because ProseMirror can’t preventDispatch on enter\n        // this will lead to a re-render of the node view on enter\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\n        // see: https://github.com/ueberdosis/tiptap/issues/2534\n        if (this.dom.contains(mutation.target)\n            && mutation.type === 'childList'\n            && (isiOS() || isAndroid())\n            && this.editor.isFocused) {\n            const changedNodes = [\n                ...Array.from(mutation.addedNodes),\n                ...Array.from(mutation.removedNodes),\n            ];\n            // we’ll check if every changed node is contentEditable\n            // to make sure it’s probably mutated by ProseMirror\n            if (changedNodes.every(node => node.isContentEditable)) {\n                return false;\n            }\n        }\n        // we will allow mutation contentDOM with attributes\n        // so we can for example adding classes within our node view\n        if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n            return true;\n        }\n        // ProseMirror should handle any changes within contentDOM\n        if (this.contentDOM.contains(mutation.target)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Update the attributes of the prosemirror node.\n     */\n    updateAttributes(attributes) {\n        this.editor.commands.command(({ tr }) => {\n            const pos = this.getPos();\n            if (typeof pos !== 'number') {\n                return false;\n            }\n            tr.setNodeMarkup(pos, undefined, {\n                ...this.node.attrs,\n                ...attributes,\n            });\n            return true;\n        });\n    }\n    /**\n     * Delete the node.\n     */\n    deleteNode() {\n        const from = this.getPos();\n        if (typeof from !== 'number') {\n            return;\n        }\n        const to = from + this.node.nodeSize;\n        this.editor.commands.deleteRange({ from, to });\n    }\n}\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nfunction markPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match, pasteEvent, }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            let markEnd = range.to;\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n                    .filter(item => {\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\n                })\n                    .filter(item => item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        },\n    });\n}\n\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nfunction nodePasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler({ match, chain, range, pasteEvent, }) {\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            const content = callOrReturn(config.getContent, undefined, attributes);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const node = { type: config.type.name, attrs: attributes };\n            if (content) {\n                node.content = content;\n            }\n            if (match.input) {\n                chain().deleteRange(range).insertContentAt(range.from, node);\n            }\n        },\n    });\n}\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nfunction textPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        },\n    });\n}\n\nclass Tracker {\n    constructor(transaction) {\n        this.transaction = transaction;\n        this.currentStep = this.transaction.steps.length;\n    }\n    map(position) {\n        let deleted = false;\n        const mappedPosition = this.transaction.steps\n            .slice(this.currentStep)\n            .reduce((newPosition, step) => {\n            const mapResult = step.getMap().mapResult(newPosition);\n            if (mapResult.deleted) {\n                deleted = true;\n            }\n            return mapResult.pos;\n        }, position);\n        return {\n            position: mappedPosition,\n            deleted,\n        };\n    }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUg7QUFDNUU7QUFDRjtBQUMwRDtBQUNvQztBQUNzaUI7QUFDM2lCOztBQUVwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxVQUFVLFlBQVk7QUFDdEIsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFB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Q2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSx3REFBd0Q7QUFDeEQsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtRUFBbUUsZUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0ZBQWdGLGVBQWU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTYrQztBQUM3K0MiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxjb3JlXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgVGV4dFNlbGVjdGlvbiwgU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3JztcbmltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJztcbmltcG9ydCB7IFNjaGVtYSwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE5vZGUgYXMgTm9kZSQxLCBET01QYXJzZXIsIFNsaWNlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCc7XG5pbXBvcnQgeyBsaWZ0VGFyZ2V0LCBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGpvaW5Qb2ludCwgVHJhbnNmb3JtLCBjYW5TcGxpdCwgY2FuSm9pbiwgZmluZFdyYXBwaW5nIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nO1xuaW1wb3J0IHsgY3JlYXRlUGFyYWdyYXBoTmVhciBhcyBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEsIGRlbGV0ZVNlbGVjdGlvbiBhcyBkZWxldGVTZWxlY3Rpb24kMSwgZXhpdENvZGUgYXMgZXhpdENvZGUkMSwgam9pblVwIGFzIGpvaW5VcCQxLCBqb2luRG93biBhcyBqb2luRG93biQxLCBqb2luQmFja3dhcmQgYXMgam9pbkJhY2t3YXJkJDEsIGpvaW5Gb3J3YXJkIGFzIGpvaW5Gb3J3YXJkJDEsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCBhcyBqb2luVGV4dGJsb2NrQmFja3dhcmQkMSwgam9pblRleHRibG9ja0ZvcndhcmQgYXMgam9pblRleHRibG9ja0ZvcndhcmQkMSwgbGlmdCBhcyBsaWZ0JDEsIGxpZnRFbXB0eUJsb2NrIGFzIGxpZnRFbXB0eUJsb2NrJDEsIG5ld2xpbmVJbkNvZGUgYXMgbmV3bGluZUluQ29kZSQxLCBzZWxlY3ROb2RlQmFja3dhcmQgYXMgc2VsZWN0Tm9kZUJhY2t3YXJkJDEsIHNlbGVjdE5vZGVGb3J3YXJkIGFzIHNlbGVjdE5vZGVGb3J3YXJkJDEsIHNlbGVjdFBhcmVudE5vZGUgYXMgc2VsZWN0UGFyZW50Tm9kZSQxLCBzZWxlY3RUZXh0YmxvY2tFbmQgYXMgc2VsZWN0VGV4dGJsb2NrRW5kJDEsIHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIHNlbGVjdFRleHRibG9ja1N0YXJ0JDEsIHNldEJsb2NrVHlwZSwgd3JhcEluIGFzIHdyYXBJbiQxIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcyc7XG5pbXBvcnQgeyBsaWZ0TGlzdEl0ZW0gYXMgbGlmdExpc3RJdGVtJDEsIHNpbmtMaXN0SXRlbSBhcyBzaW5rTGlzdEl0ZW0kMSwgd3JhcEluTGlzdCBhcyB3cmFwSW5MaXN0JDEgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0JztcblxuLyoqXG4gKiBUYWtlcyBhIFRyYW5zYWN0aW9uICYgRWRpdG9yIFN0YXRlIGFuZCB0dXJucyBpdCBpbnRvIGEgY2hhaW5hYmxlIHN0YXRlIG9iamVjdFxuICogQHBhcmFtIGNvbmZpZyBUaGUgdHJhbnNhY3Rpb24gYW5kIHN0YXRlIHRvIGNyZWF0ZSB0aGUgY2hhaW5hYmxlIHN0YXRlIGZyb21cbiAqIEByZXR1cm5zIEEgY2hhaW5hYmxlIEVkaXRvciBzdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnKSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZztcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uO1xuICAgIGxldCB7IGRvYyB9ID0gdHJhbnNhY3Rpb247XG4gICAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXG4gICAgICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgICAgIHBsdWdpbnM6IHN0YXRlLnBsdWdpbnMsXG4gICAgICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxuICAgICAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgICAgIHRvSlNPTjogc3RhdGUudG9KU09OLmJpbmQoc3RhdGUpLFxuICAgICAgICBnZXQgc3RvcmVkTWFya3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkTWFya3M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZG9jKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHRyKCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgICAgICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrcztcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3I7XG4gICAgICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzO1xuICAgICAgICB0aGlzLmN1c3RvbVN0YXRlID0gcHJvcHMuc3RhdGU7XG4gICAgfVxuICAgIGdldCBoYXNDdXN0b21TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21TdGF0ZSB8fCB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCBtZXRob2RdO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldCBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4oKTtcbiAgICB9XG4gICAgZ2V0IGNhbigpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2FuKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNoYWluKHN0YXJ0VHIsIHNob3VsZERpc3BhdGNoID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHI7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50cjtcbiAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYXNTdGFydFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgJiYgc2hvdWxkRGlzcGF0Y2hcbiAgICAgICAgICAgICAgICAmJiAhdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJylcbiAgICAgICAgICAgICAgICAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrcy5ldmVyeShjYWxsYmFjayA9PiBjYWxsYmFjayA9PT0gdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHJ1bixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH1cbiAgICBjcmVhdGVDYW4oc3RhcnRUcikge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgZGlzcGF0Y2gpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQoLi4uYXJncykoeyAuLi5wcm9wcywgZGlzcGF0Y2g6IHVuZGVmaW5lZCB9KV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdHRlZENvbW1hbmRzLFxuICAgICAgICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIGRpc3BhdGNoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIHRyLFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgc2hvdWxkRGlzcGF0Y2gpLFxuICAgICAgICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXG4gICAgICAgICAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZCguLi5hcmdzKShwcm9wcyldO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgfVxuICAgIG9uKGV2ZW50LCBmbikge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGZuKSB7XG4gICAgICAgIGNvbnN0IG9uY2VGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9mZihldmVudCwgb25jZUZuKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudCwgb25jZUZuKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZmllbGQgZnJvbSBhbiBleHRlbnNpb25cbiAqIEBwYXJhbSBleHRlbnNpb24gVGhlIFRpcHRhcCBleHRlbnNpb25cbiAqIEBwYXJhbSBmaWVsZCBUaGUgZmllbGQsIGZvciBleGFtcGxlIGByZW5kZXJIVE1MYCBvciBgcHJpb3JpdHlgXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGFzIGB0aGlzYCBpbnRvIHRoZSBmdW5jdGlvblxuICogQHJldHVybnMgVGhlIGZpZWxkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgZmllbGQsIGNvbnRleHQpIHtcbiAgICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb24ucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnRcbiAgICAgICAgICAgICAgICA/IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnZXh0ZW5zaW9uJyk7XG4gICAgY29uc3Qgbm9kZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdub2RlJyk7XG4gICAgY29uc3QgbWFya0V4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZUV4dGVuc2lvbnMsXG4gICAgICAgIG5vZGVFeHRlbnNpb25zLFxuICAgICAgICBtYXJrRXh0ZW5zaW9ucyxcbiAgICB9O1xufVxuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gYGFkZEF0dHJpYnV0ZWAgYW5kIGBhZGRHbG9iYWxBdHRyaWJ1dGVgLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgTGlzdCBvZiBleHRlbnNpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IFtdO1xuICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc107XG4gICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZSA9IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IHRydWUsXG4gICAgICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogbnVsbCxcbiAgICAgICAga2VlcE9uU3BsaXQ6IHRydWUsXG4gICAgICAgIGlzUmVxdWlyZWQ6IGZhbHNlLFxuICAgIH07XG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBleHRlbnNpb25zOiBub2RlQW5kTWFya0V4dGVuc2lvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZEdsb2JhbEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRHbG9iYWxBdHRyaWJ1dGVzJywgY29udGV4dCk7XG4gICAgICAgIGlmICghYWRkR2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdsb2JhbEF0dHJpYnV0ZXMgPSBhZGRHbG9iYWxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMuZm9yRWFjaChnbG9iYWxBdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC5lbnRyaWVzKGdsb2JhbEF0dHJpYnV0ZS5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBub2RlQW5kTWFya0V4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkQXR0cmlidXRlcycsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobWVyZ2VkQXR0ciA9PT0gbnVsbCB8fCBtZXJnZWRBdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXJnZWRBdHRyLmlzUmVxdWlyZWQpICYmIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZU9yVHlwZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0c1xuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxuICAgICAgICAucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9O1xuICAgICAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQ2xhc3NlcyA9IHZhbHVlID8gU3RyaW5nKHZhbHVlKS5zcGxpdCgnICcpIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDbGFzc2VzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRDbGFzc2VzID0gdmFsdWVDbGFzc2VzLmZpbHRlcih2YWx1ZUNsYXNzID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcykpO1xuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFsuLi5leGlzdGluZ0NsYXNzZXMsIC4uLmluc2VydENsYXNzZXNdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0eWxlcyA9IHZhbHVlID8gdmFsdWUuc3BsaXQoJzsnKS5tYXAoKHN0eWxlKSA9PiBzdHlsZS50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3R5bGVzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCc7JykubWFwKChzdHlsZSkgPT4gc3R5bGUudHJpbSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1N0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWxdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlTWFwLnNldChwcm9wZXJ0eSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlLnNwbGl0KCc6JykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZU1hcC5zZXQocHJvcGVydHksIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gQXJyYXkuZnJvbShzdHlsZU1hcC5lbnRyaWVzKCkpLm1hcCgoW3Byb3BlcnR5LCB2YWxdKSA9PiBgJHtwcm9wZXJ0eX06ICR7dmFsfWApLmpvaW4oJzsgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzO1xuICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGVPck1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xuICAgICAgICAuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gbm9kZU9yTWFyay50eXBlLm5hbWUpXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZClcbiAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtpdGVtLm5hbWVdOiBub2RlT3JNYXJrLmF0dHJzW2l0ZW0ubmFtZV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9O1xuICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT4gbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSksIHt9KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogT3B0aW9uYWxseSBjYWxscyBgdmFsdWVgIGFzIGEgZnVuY3Rpb24uXG4gKiBPdGhlcndpc2UgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuXG4gKiBAcGFyYW0gdmFsdWUgRnVuY3Rpb24gb3IgYW55IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIGZ1bmN0aW9uLlxuICogQHBhcmFtIHByb3BzIE9wdGlvbmFsIHByb3BzIHRvIHBhc3MgdG8gZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhbGxPclJldHVybih2YWx1ZSwgY29udGV4dCA9IHVuZGVmaW5lZCwgLi4ucHJvcHMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGNvbnRleHQpKC4uLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUoLi4ucHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1lcmdlcyBleHRlbnNpb24gYXR0cmlidXRlcyBpbnRvIHBhcnNlcnVsZSBhdHRyaWJ1dGVzIChgYXR0cnNgIG9yIGBnZXRBdHRyc2ApLlxuICogQ2FuY2VscyB3aGVuIGBnZXRBdHRyc2AgcmV0dXJuZWQgYGZhbHNlYC5cbiAqIEBwYXJhbSBwYXJzZVJ1bGUgUHJvc2VNaXJyb3IgUGFyc2VSdWxlXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gaW5qZWN0XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoJ3N0eWxlJyBpbiBwYXJzZVJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUnVsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFyc2VSdWxlLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnM7XG4gICAgICAgICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUxcbiAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgOiBmcm9tU3RyaW5nKChub2RlKS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW0oZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09ICdhdHRycycgJiYgaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9KSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUHJvc2VtaXJyb3Igc2NoZW1hIGJhc2VkIG9uIHRoZSBnaXZlbiBleHRlbnNpb25zLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAqIEBwYXJhbSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZVxuICogQHJldHVybnMgQSBQcm9zZW1pcnJvciBzY2hlbWFcbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCB0b3BOb2RlID0gKF9hID0gbm9kZUV4dGVuc2lvbnMuZmluZChleHRlbnNpb24gPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAndG9wTm9kZScpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMobm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmROb2RlU2NoZW1hJywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTm9kZVNjaGVtYSA/IGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICAgICAgY29udGVudDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2NvbnRlbnQnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxuICAgICAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGlubGluZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2lubGluZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxuICAgICAgICAgICAgc2VsZWN0YWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3NlbGVjdGFibGUnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdkcmFnZ2FibGUnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIHdoaXRlc3BhY2U6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICd3aGl0ZXNwYWNlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdsaW5lYnJlYWtSZXBsYWNlbWVudCcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZGVmaW5pbmcnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBpc29sYXRpbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdpc29sYXRpbmcnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogKF9hID0gZXh0ZW5zaW9uQXR0cmlidXRlID09PSBudWxsIHx8IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQgfV07XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCkpO1xuICAgICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlckhUTUwnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgICAgIHNjaGVtYS50b0RPTSA9IG5vZGUgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlclRleHQnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbmRlclRleHQpIHtcbiAgICAgICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSkpO1xuICAgIGNvbnN0IG1hcmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKG1hcmtFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZChlLCAnZXh0ZW5kTWFya1NjaGVtYScsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgLi4uKGV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGV4Y2x1ZGVzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZXhjbHVkZXMnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IChfYSA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBleHRlbnNpb25BdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0IH1dO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpKTtcbiAgICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdyZW5kZXJIVE1MJywgY29udGV4dCk7XG4gICAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgICAgICBzY2hlbWEudG9ET00gPSBtYXJrID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgICAgICAgIG1hcmssXG4gICAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICAgICAgdG9wTm9kZSxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIG1hcmtzLFxuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGdldCBhIG5vZGUgb3IgbWFyayB0eXBlIGJ5IGl0cyBuYW1lLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5vZGUgb3IgbWFyayB0eXBlXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcm9yIHNjaGVtYSB0byBzZWFyY2ggaW5cbiAqIEByZXR1cm5zIFRoZSBub2RlIG9yIG1hcmsgdHlwZSwgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVCeU5hbWUobmFtZSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlbmFibGVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWQuc29tZShlbmFibGVkRXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGVuYWJsZWRFeHRlbnNpb25cbiAgICAgICAgICAgICAgICA6IGVuYWJsZWRFeHRlbnNpb24ubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBnZXRIVE1MRnJvbUZyYWdtZW50KGZyYWdtZW50LCBzY2hlbWEpIHtcbiAgICBjb25zdCBkb2N1bWVudEZyYWdtZW50ID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSkuc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGVtcG9yYXJ5RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiBhIHJlc29sdmVkIHByb3NlbWlycm9yIHBvc2l0aW9uXG4gKiBAcGFyYW0gJGZyb20gVGhlIHJlc29sdmVkIHBvc2l0aW9uIHRvIGdldCB0aGUgdGV4dCBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBtYXhNYXRjaCBUaGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIHRleHQgY29udGVudFxuICovXG5jb25zdCBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbSwgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9ICcnO1xuICAgIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0O1xuICAgICRmcm9tLnBhcmVudC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBtYXhNYXRjaCksIHNsaWNlRW5kUG9zLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNodW5rID0gKChfYiA9IChfYSA9IG5vZGUudHlwZS5zcGVjKS50b1RleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgfHwgbm9kZS50ZXh0Q29udGVudFxuICAgICAgICAgICAgfHwgJyVsZWFmJSc7XG4gICAgICAgIHRleHRCZWZvcmUgKz0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0ID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0QmVmb3JlO1xufTtcblxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmNsYXNzIElucHV0UnVsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgICB9XG59XG5jb25zdCBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kKSA9PiB7XG4gICAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgICAgIHJldHVybiBmaW5kLmV4ZWModGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KTtcbiAgICBpZiAoIWlucHV0UnVsZU1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF07XG4gICAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICByZXN1bHQuZGF0YSA9IGlucHV0UnVsZU1hdGNoLmRhdGE7XG4gICAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcImlucHV0UnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gcnVuJDEoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbiwgfSA9IGNvbmZpZztcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCAkZnJvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGVcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xuICAgICAgICB8fCAhISgoX2EgPSAoJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZS5zcGVjLmNvZGUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtYXRjaGVkID0gZmFsc2U7XG4gICAgY29uc3QgdGV4dEJlZm9yZSA9IGdldFRleHRDb250ZW50RnJvbU5vZGVzKCRmcm9tKSArIHRleHQ7XG4gICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyKHRleHRCZWZvcmUsIHJ1bGUuZmluZCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIGNhbixcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IG51bGwgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRyYW5zZm9ybSBhcyBtZXRhIGRhdGFcbiAgICAgICAgLy8gc28gd2UgY2FuIHVuZG8gaW5wdXQgcnVsZXMgd2l0aGluIHRoZSBgdW5kb0lucHV0UnVsZXNgIGNvbW1hbmRcbiAgICAgICAgdHIuc2V0TWV0YShwbHVnaW4sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXRjaGVkO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuICogaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5wdXRSdWxlc1BsdWdpbihwcm9wcykge1xuICAgIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBwcmV2LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHRyLmdldE1ldGEocGx1Z2luKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIElucHV0UnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGVkSW5wdXRNZXRhID0gdHIuZ2V0TWV0YSgnYXBwbHlJbnB1dFJ1bGVzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRJbnB1dCA9ICEhc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgIGlmIChpc1NpbXVsYXRlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgdGV4dCB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQuZnJvbSh0ZXh0KSwgc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW4kMSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW4kMSh7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25lbmQ6IHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1biQxKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuJDEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnXFxuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpc0lucHV0UnVsZXM6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbjtcbn1cblxuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVzcXVlZWIvaXMtd2hhdC9ibG9iLzg4ZDZlNGNhOTJmYjJiYWFiNjAwM2M1NGUwMmVlZGY0ZTcyOWU1YWIvc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmIGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIFRoZSBNYXJrIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGN1c3RvbSBtYXJrIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXG4gKi9cbmNsYXNzIE1hcmsge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtYXJrJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ21hcmsnO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhjb25maWcuZGVmYXVsdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9KSkgfHwge307XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgYWRkT3B0aW9uczogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZURlZXAodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBbHdheXMgcHJlc2VydmUgdGhlIGN1cnJlbnQgbmFtZVxuICAgICAgICBleHRlbnNpb24ubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwYXJlbnQgdG8gYmUgb3VyIHBhcmVudFxuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBNYXJrKGV4dGVuZGVkQ29uZmlnKTtcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb247XG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWU7XG4gICAgICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBzdGF0aWMgaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyayB9KSB7XG4gICAgICAgIGNvbnN0IHsgdHIgfSA9IGVkaXRvci5zdGF0ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSBjdXJyZW50UG9zLnBvcyA9PT0gY3VycmVudFBvcy5lbmQoKTtcbiAgICAgICAgaWYgKGlzQXRFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IGN1cnJlbnRQb3MubWFya3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IChtID09PSBudWxsIHx8IG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcbiAgICAgICAgICAgIGlmICghaXNJbk1hcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiAobSA9PT0gbnVsbCB8fCBtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtLnR5cGUubmFtZSkgPT09IG1hcmsubmFtZSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlTWFyaykge1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KCcgJywgY3VycmVudFBvcy5wb3MpO1xuICAgICAgICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBQYXN0ZSBydWxlcyBhcmUgdXNlZCB0byByZWFjdCB0byBwYXN0ZWQgY29udGVudC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmNsYXNzIFBhc3RlUnVsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgICB9XG59XG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kLCBldmVudCkgPT4ge1xuICAgIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgICAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0LCBldmVudCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXMubWFwKHBhc3RlUnVsZU1hdGNoID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdO1xuICAgICAgICByZXN1bHQuaW5kZXggPSBwYXN0ZVJ1bGVNYXRjaC5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhO1xuICAgICAgICBpZiAocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICAgICAgICAgIGlmICghcGFzdGVSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBydW4oY29uZmlnKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIHN0YXRlLCBmcm9tLCB0bywgcnVsZSwgcGFzdGVFdmVudCwgZHJvcEV2ZW50LCB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc3RhdGUsXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLnR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpO1xuICAgICAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHJlc29sdmVkRnJvbSArIG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICAgICAgICAgIHRvOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChlbmQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIGNhbixcbiAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50LFxuICAgICAgICAgICAgICAgIGRyb3BFdmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG59XG4vLyBXaGVuIGRyYWdnaW5nIGFjcm9zcyBlZGl0b3JzLCBtdXN0IGdldCBhbm90aGVyIGVkaXRvciBpbnN0YW5jZSB0byBkZWxldGUgc2VsZWN0aW9uIGNvbnRlbnQuXG5sZXQgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IG51bGw7XG5jb25zdCBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50ID0gKHRleHQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgfSk7XG4gICAgKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERhdGEoJ3RleHQvaHRtbCcsIHRleHQpO1xuICAgIHJldHVybiBldmVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcbiAqIHRleHQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wcykge1xuICAgIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gICAgbGV0IGRyYWdTb3VyY2VFbGVtZW50ID0gbnVsbDtcbiAgICBsZXQgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2U7XG4gICAgbGV0IHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcbiAgICBsZXQgZHJvcEV2ZW50O1xuICAgIHRyeSB7XG4gICAgICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbDtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBkcm9wRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzRXZlbnQgPSAoeyBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZ0LCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IGNoYWluYWJsZVN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcnVuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgICAgICAgIGZyb206IE1hdGgubWF4KGZyb20gLSAxLCAwKSxcbiAgICAgICAgICAgIHRvOiB0by5iIC0gMSxcbiAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICBwYXN0ZUV2ZW50OiBwYXN0ZUV2dCxcbiAgICAgICAgICAgIGRyb3BFdmVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBkcm9wRXZlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH07XG4gICAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgLy8gd2UgcmVnaXN0ZXIgYSBnbG9iYWwgZHJhZyBoYW5kbGVyIHRvIHRyYWNrIHRoZSBjdXJyZW50IGRyYWcgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICAgIHZpZXcodmlldykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZURyYWdzdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gKChfYSA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2aWV3LmRvbS5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnU291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlRHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGRyYWdTb3VyY2VFbGVtZW50ID09PSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdGcm9tT3RoZXJFZGl0b3IgPSB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmFnRnJvbU90aGVyRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldFRpbWVvdXQgdG8gYXZvaWQgdGhlIHdyb25nIGNvbnRlbnQgYWZ0ZXIgZHJvcCwgdGltZW91dCBhcmcgY2FuJ3QgYmUgZW1wdHkgb3IgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRyYWdGcm9tT3RoZXJFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdGcm9tT3RoZXJFZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tOiBzZWxlY3Rpb24uZnJvbSwgdG86IHNlbGVjdGlvbi50byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFzdGU6IChfdmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoX2EgPSBldmVudC5jbGlwYm9hcmREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhKGh0bWwgPT09IG51bGwgfHwgaHRtbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHRtbC5pbmNsdWRlcygnZGF0YS1wbS1zbGljZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yO1xuICAgICAgICAgICAgICAgIC8vIGlmIFBhc3RlUnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGVkUGFzdGVNZXRhID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYXBwbHlQYXN0ZVJ1bGVzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRQYXN0ZSA9ICEhc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wICYmICFpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNpbXVsYXRlZCBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmIChpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZ2V0SFRNTEZyb21GcmFnbWVudChGcmFnbWVudC5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdGVFdnQgPSBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50KHRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogeyBiOiB0byB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVFdnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgYWN0dWFsIHBhc3RlL2Ryb3BcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgICAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBjaGFuZ2VkIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihmcm9tKSB8fCAhdG8gfHwgZnJvbSA9PT0gdG8uYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlRXZ0OiBwYXN0ZUV2ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbnM7XG59XG5cbmZ1bmN0aW9uIGZpbmREdXBsaWNhdGVzKGl0ZW1zKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBpdGVtcy5maWx0ZXIoKGVsLCBpbmRleCkgPT4gaXRlbXMuaW5kZXhPZihlbCkgIT09IGluZGV4KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkKSk7XG59XG5cbmNsYXNzIEV4dGVuc2lvbk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnMsIGVkaXRvcikge1xuICAgICAgICB0aGlzLnNwbGl0dGFibGVNYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5zZXR1cEV4dGVuc2lvbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBhbmQgc29ydGVkIGV4dGVuc2lvbiBsaXN0IHdoaWxlXG4gICAgICogYWxzbyBjaGVja2luZyBmb3IgZHVwbGljYXRlZCBleHRlbnNpb25zIGFuZCB3YXJucyB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIEFuIGZsYXR0ZW5lZCBhbmQgc29ydGVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICovXG4gICAgc3RhdGljIHJlc29sdmUoZXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuKGV4dGVuc2lvbnMpKTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlZE5hbWVzID0gZmluZER1cGxpY2F0ZXMocmVzb2x2ZWRFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4gZXh0ZW5zaW9uLm5hbWUpKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogRHVwbGljYXRlIGV4dGVuc2lvbiBuYW1lcyBmb3VuZDogWyR7ZHVwbGljYXRlZE5hbWVzXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IGAnJHtpdGVtfSdgKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfV0uIFRoaXMgY2FuIGxlYWQgdG8gaXNzdWVzLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZsYXR0ZW5lZCBhcnJheSBvZiBleHRlbnNpb25zIGJ5IHRyYXZlcnNpbmcgdGhlIGBhZGRFeHRlbnNpb25zYCBmaWVsZC5cbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIEEgZmxhdHRlbmVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICovXG4gICAgc3RhdGljIGZsYXR0ZW4oZXh0ZW5zaW9ucykge1xuICAgICAgICByZXR1cm4gKGV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEV4dGVuc2lvbnMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZGRFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24sIC4uLnRoaXMuZmxhdHRlbihhZGRFeHRlbnNpb25zKCkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgICAgIH0pXG4gICAgICAgICAgICAvLyBgSW5maW5pdHlgIHdpbGwgYnJlYWsgVHlwZVNjcmlwdCBzbyB3ZSBzZXQgYSBudW1iZXIgdGhhdCBpcyBwcm9iYWJseSBoaWdoIGVub3VnaFxuICAgICAgICAgICAgLmZsYXQoMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydCBleHRlbnNpb25zIGJ5IHByaW9yaXR5LlxuICAgICAqIEBwYXJhbSBleHRlbnNpb25zIEFuIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICogQHJldHVybnMgQSBzb3J0ZWQgYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnMgYnkgcHJpb3JpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgc29ydChleHRlbnNpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQoYSwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlCID0gZ2V0RXh0ZW5zaW9uRmllbGQoYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgICAgICAgICAgaWYgKHByaW9yaXR5QSA+IHByaW9yaXR5Qikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBjb21tYW5kcyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBjb21tYW5kcyB3aGVyZSB0aGUga2V5IGlzIHRoZSBjb21tYW5kIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY29tbWFuZCBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5yZWR1Y2UoKGNvbW1hbmRzLCBleHRlbnNpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRDb21tYW5kcycsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgICAgICAgICAgLi4uYWRkQ29tbWFuZHMoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWdpc3RlcmVkIFByb3NlbWlycm9yIHBsdWdpbnMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBQcm9zZW1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICAvLyBXaXRoIFByb3NlTWlycm9yLCBmaXJzdCBwbHVnaW5zIHdpdGhpbiBhbiBhcnJheSBhcmUgZXhlY3V0ZWQgZmlyc3QuXG4gICAgICAgIC8vIEluIFRpcHRhcCwgd2UgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byBvdmVycmlkZSBwbHVnaW5zLFxuICAgICAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cbiAgICAgICAgLy8gVGhhdOKAmXMgd2h5IHdlIGhhdmUgdG8gcmV2ZXJzZSB0aGUgYGV4dGVuc2lvbnNgIGFycmF5IGFuZCBzb3J0IGFnYWluXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBgcHJpb3JpdHlgIG9wdGlvbi5cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpO1xuICAgICAgICBjb25zdCBpbnB1dFJ1bGVzID0gW107XG4gICAgICAgIGNvbnN0IHBhc3RlUnVsZXMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJywgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdEJpbmRpbmdzID0ge307XG4gICAgICAgICAgICAvLyBiaW5kIGV4aXQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnICYmIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2V4aXRhYmxlJywgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmluZGluZ3MuQXJyb3dSaWdodCA9ICgpID0+IE1hcmsuaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyazogZXh0ZW5zaW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSkubWFwKChbc2hvcnRjdXQsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzaG9ydGN1dCwgKCkgPT4gbWV0aG9kKHsgZWRpdG9yIH0pXTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEJpbmRpbmdzID0geyAuLi5kZWZhdWx0QmluZGluZ3MsIC4uLmJpbmRpbmdzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKTtcbiAgICAgICAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pO1xuICAgICAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZElucHV0UnVsZXMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFJ1bGVzLnB1c2goLi4uYWRkSW5wdXRSdWxlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRQYXN0ZVJ1bGVzJywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVQYXN0ZVJ1bGVzKSAmJiBhZGRQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgcGFzdGVSdWxlcy5wdXNoKC4uLmFkZFBhc3RlUnVsZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRQcm9zZU1pcnJvclBsdWdpbnMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKTtcbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2goLi4ucHJvc2VNaXJyb3JQbHVnaW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZsYXQoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBydWxlczogaW5wdXRSdWxlcyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLi4ucGFzdGVSdWxlc1BsdWdpbih7XG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHJ1bGVzOiBwYXN0ZVJ1bGVzLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAuLi5hbGxQbHVnaW5zLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBub2RlIHZpZXdzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIG5vZGUgdmlld3Mgd2hlcmUgdGhlIGtleSBpcyB0aGUgbm9kZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG5vZGUgdmlldyBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBub2RlVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhub2RlRXh0ZW5zaW9uc1xuICAgICAgICAgICAgLmZpbHRlcihleHRlbnNpb24gPT4gISFnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGROb2RlVmlldycpKVxuICAgICAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghYWRkTm9kZVZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RldmlldyA9IChub2RlLCB2aWV3LCBnZXRQb3MsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVWaWV3KCkoe1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9zOiBnZXRQb3MsXG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aXB0YXAtc3BlY2lmaWNcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyB0aHJvdWdoIGFsbCBleHRlbnNpb25zLCBjcmVhdGUgZXh0ZW5zaW9uIHN0b3JhZ2VzICYgc2V0dXAgbWFya3NcbiAgICAgKiAmIGJpbmQgZWRpdG9yIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGV4dGVuc2lvbiBzdG9yYWdlIGluIGVkaXRvclxuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0gPSBleHRlbnNpb24uc3RvcmFnZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZWVwT25TcGxpdCA9IChfYSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdrZWVwT25TcGxpdCcsIGNvbnRleHQpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2VlcE9uU3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdHRhYmxlTWFya3MucHVzaChleHRlbnNpb24ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJlZm9yZUNyZWF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25DcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkNyZWF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblVwZGF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25TZWxlY3Rpb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblNlbGVjdGlvblVwZGF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uVHJhbnNhY3Rpb24nLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkZvY3VzJywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvbkJsdXIgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJsdXInLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRGVzdHJveSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uRGVzdHJveScsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdjcmVhdGUnLCBvbkNyZWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgb25CbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgRXh0ZW5zaW9uIGNsYXNzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuY2xhc3MgRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZXh0ZW5zaW9uJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ2V4dGVuc2lvbic7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pKSB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuc2lvbihjb25maWcpO1xuICAgIH1cbiAgICBjb25maWd1cmUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgICAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCh7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGFkZE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWx3YXlzIHByZXNlcnZlIHRoZSBjdXJyZW50IG5hbWVcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIC8vIFNldCB0aGUgcGFyZW50IHRvIGJlIG91ciBwYXJlbnRcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBleHRlbmQoZXh0ZW5kZWRDb25maWcgPSB7fSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uKHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pO1xuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICB9KSk7XG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgYmV0d2VlbiB0d28gcG9zaXRpb25zIGluIGEgUHJvc2VtaXJyb3Igbm9kZVxuICogYW5kIHNlcmlhbGl6ZXMgaXQgdXNpbmcgdGhlIGdpdmVuIHRleHQgc2VyaWFsaXplcnMgYW5kIGJsb2NrIHNlcGFyYXRvciAoc2VlIGdldFRleHQpXG4gKiBAcGFyYW0gc3RhcnROb2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHRleHQgdG8gZ2V0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGV4dCBzZXJpYWxpemVyICYgYmxvY2sgc2VwYXJhdG9yXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBiZXR3ZWVuIHRoZSB0d28gcG9zaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRCZXR3ZWVuKHN0YXJ0Tm9kZSwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgcG9zID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycyA9PT0gbnVsbCB8fCB0ZXh0U2VyaWFsaXplcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRTZXJpYWxpemVyc1tub2RlLnR5cGUubmFtZV07XG4gICAgICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdGV4dFNlcmlhbGl6ZXIoe1xuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG8gbm90IGRlc2NlbmQgaW50byBjaGlsZCBub2RlcyB3aGVuIHRoZXJlIGV4aXN0cyBhIHNlcmlhbGl6ZXJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIHRleHQgKz0gKF9hID0gbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0O1xufVxuXG4vKipcbiAqIEZpbmQgdGV4dCBzZXJpYWxpemVycyBgdG9UZXh0YCBpbiBhIFByb3NlbWlycm9yIHNjaGVtYVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHNlYXJjaCBpblxuICogQHJldHVybnMgQSByZWNvcmQgb2YgdGV4dCBzZXJpYWxpemVycyBieSBub2RlIG5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcylcbiAgICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAgIC5tYXAoKFtuYW1lLCBub2RlXSkgPT4gW25hbWUsIG5vZGUuc3BlYy50b1RleHRdKSk7XG59XG5cbmNvbnN0IENsaXBib2FyZFRleHRTZXJpYWxpemVyID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2tTZXBhcmF0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBzY2hlbWEgfSA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTZXJpYWxpemVycyA9IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4odGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGJsb2NrU2VwYXJhdG9yOiB0aGlzLm9wdGlvbnMuYmxvY2tTZXBhcmF0b3IgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2VyaWFsaXplcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBibHVyID0gKCkgPT4gKHsgZWRpdG9yLCB2aWV3IH0pID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAvLyBCcm93c2VycyBzaG91bGQgcmVtb3ZlIHRoZSBjYXJldCBvbiBibHVyIGJ1dCBzYWZhcmkgZG9lcyBub3QuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjQwNVxuICAgICAgICAgICAgKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmdldFNlbGVjdGlvbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGNsZWFyQ29udGVudCA9IChlbWl0VXBkYXRlID0gZmFsc2UpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Q29udGVudCgnJywgZW1pdFVwZGF0ZSk7XG59O1xuXG5jb25zdCBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKCFkaXNwYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBtYXBwaW5nIH0gPSB0cjtcbiAgICAgICAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSk7XG4gICAgICAgICAgICBjb25zdCAkbWFwcGVkVG8gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSk7XG4gICAgICAgICAgICBjb25zdCBub2RlUmFuZ2UgPSAkbWFwcGVkRnJvbS5ibG9ja1JhbmdlKCRtYXBwZWRUbyk7XG4gICAgICAgICAgICBpZiAoIW5vZGVSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExpZnREZXB0aCA9IGxpZnRUYXJnZXQobm9kZVJhbmdlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSk7XG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRMaWZ0RGVwdGggfHwgdGFyZ2V0TGlmdERlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdHIubGlmdChub2RlUmFuZ2UsIHRhcmdldExpZnREZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgY29tbWFuZCA9IGZuID0+IHByb3BzID0+IHtcbiAgICByZXR1cm4gZm4ocHJvcHMpO1xufTtcblxuY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhciA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcmFncmFwaE5lYXIkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgY3V0ID0gKG9yaWdpblJhbmdlLCB0YXJnZXRQb3MpID0+ICh7IGVkaXRvciwgdHIgfSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBjb250ZW50U2xpY2UgPSBzdGF0ZS5kb2Muc2xpY2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pO1xuICAgIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcbiAgICBjb25zdCBuZXdQb3MgPSB0ci5tYXBwaW5nLm1hcCh0YXJnZXRQb3MpO1xuICAgIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IFRleHRTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUobmV3UG9zIC0gMSkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGRlbGV0ZUN1cnJlbnROb2RlID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBzZWxlY3Rpb24uJGFuY2hvci5ub2RlKCk7XG4gICAgLy8gaWYgdGhlcmUgaXMgY29udGVudCBpbnNpZGUgdGhlIGN1cnJlbnQgbm9kZSwgYnJlYWsgb3V0IG9mIHRoaXMgY29tbWFuZFxuICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50LnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xuICAgIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBjdXJyZW50Tm9kZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgZGVsZXRlTm9kZSA9IHR5cGVPck5hbWUgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xuICAgIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgZGVsZXRlUmFuZ2UgPSByYW5nZSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGRlbGV0ZVNlbGVjdGlvbiA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGRlbGV0ZVNlbGVjdGlvbiQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBlbnRlciA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dCgnRW50ZXInKTtcbn07XG5cbmNvbnN0IGV4aXRDb2RlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gZXhpdENvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBvYmplY3QxIGluY2x1ZGVzIG9iamVjdDJcbiAqIEBwYXJhbSBvYmplY3QxIE9iamVjdFxuICogQHBhcmFtIG9iamVjdDIgT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKG9iamVjdDEsIG9iamVjdDIsIG9wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9KSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBrZXlzLmV2ZXJ5KGtleSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldLnRlc3Qob2JqZWN0MVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIHJldHVybiBtYXJrcy5maW5kKGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gKGl0ZW0udHlwZSA9PT0gdHlwZVxuICAgICAgICAgICAgJiYgb2JqZWN0SW5jbHVkZXMoXG4gICAgICAgICAgICAvLyBPbmx5IGNoZWNrIGVxdWFsaXR5IGZvciB0aGUgYXR0cmlidXRlcyB0aGF0IGFyZSBwcm92aWRlZFxuICAgICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcChrID0+IFtrLCBpdGVtLmF0dHJzW2tdXSkpLCBhdHRyaWJ1dGVzKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc01hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgcmV0dXJuICEhZmluZE1hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyk7XG59XG4vKipcbiAqIEdldCB0aGUgcmFuZ2Ugb2YgYSBtYXJrIGF0IGEgcmVzb2x2ZWQgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmtSYW5nZShcbi8qKlxuICogVGhlIHBvc2l0aW9uIHRvIGdldCB0aGUgbWFyayByYW5nZSBmb3IuXG4gKi9cbiRwb3MsIFxuLyoqXG4gKiBUaGUgbWFyayB0eXBlIHRvIGdldCB0aGUgcmFuZ2UgZm9yLlxuICovXG50eXBlLCBcbi8qKlxuICogVGhlIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIElmIG5vdCBwcm92aWRlZCwgb25seSB0aGUgZmlyc3QgbWFyayBhdCB0aGUgcG9zaXRpb24gd2lsbCBiZSBtYXRjaGVkLlxuICovXG5hdHRyaWJ1dGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghJHBvcyB8fCAhdHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQWZ0ZXIoJHBvcy5wYXJlbnRPZmZzZXQpO1xuICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlIHRoYXQgZG9lcyBub3QgaGF2ZSB0aGUgbWFyaywgbG9vayBiYWNrd2FyZFxuICAgIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkge1xuICAgICAgICBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQmVmb3JlKCRwb3MucGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdGV4dCBub2RlIHdpdGggdGhlIG1hcmsgZXZlbiBiYWNrd2FyZCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlZmF1bHQgdG8gb25seSBtYXRjaGluZyBhZ2FpbnN0IHRoZSBmaXJzdCBtYXJrJ3MgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8ICgoX2EgPSBzdGFydC5ub2RlLm1hcmtzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpO1xuICAgIC8vIFdlIG5vdyBrbm93IHRoYXQgdGhlIGN1cnNvciBpcyBlaXRoZXIgYXQgdGhlIHN0YXJ0LCBtaWRkbGUgb3IgZW5kIG9mIGEgdGV4dCBub2RlIHdpdGggdGhlIHNwZWNpZmllZCBtYXJrXG4gICAgLy8gc28gd2UgY2FuIGxvb2sgaXQgdXAgb24gdGhlIHRhcmdldGVkIG1hcmtcbiAgICBjb25zdCBtYXJrID0gZmluZE1hcmtJblNldChbLi4uc3RhcnQubm9kZS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIGlmICghbWFyaykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXg7XG4gICAgbGV0IHN0YXJ0UG9zID0gJHBvcy5zdGFydCgpICsgc3RhcnQub2Zmc2V0O1xuICAgIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyAxO1xuICAgIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemU7XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPiAwXG4gICAgICAgICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKSkge1xuICAgICAgICBzdGFydEluZGV4IC09IDE7XG4gICAgICAgIHN0YXJ0UG9zIC09ICRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpLm5vZGVTaXplO1xuICAgIH1cbiAgICB3aGlsZSAoZW5kSW5kZXggPCAkcG9zLnBhcmVudC5jaGlsZENvdW50XG4gICAgICAgICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKSkge1xuICAgICAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplO1xuICAgICAgICBlbmRJbmRleCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBzdGFydFBvcyxcbiAgICAgICAgdG86IGVuZFBvcyxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZU9yVHlwZTtcbn1cblxuY29uc3QgZXh0ZW5kTWFya1JhbmdlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyAkZnJvbSwgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZmlyc3QgPSBjb21tYW5kcyA9PiBwcm9wcyA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjb21tYW5kcyhwcm9wcylcbiAgICAgICAgOiBjb21tYW5kcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpdGVtc1tpXShwcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1pbk1heCh2YWx1ZSA9IDAsIG1pbiA9IDAsIG1heCA9IDApIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgcG9zaXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uQXRTdGFydCA9IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYyk7XG4gICAgY29uc3Qgc2VsZWN0aW9uQXRFbmQgPSBTZWxlY3Rpb24uYXRFbmQoZG9jKTtcbiAgICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcgfHwgcG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkF0U3RhcnQ7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkF0RW5kO1xuICAgIH1cbiAgICBjb25zdCBtaW5Qb3MgPSBzZWxlY3Rpb25BdFN0YXJ0LmZyb207XG4gICAgY29uc3QgbWF4UG9zID0gc2VsZWN0aW9uQXRFbmQudG87XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYWxsJykge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBtaW5NYXgoMCwgbWluUG9zLCBtYXhQb3MpLCBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpKTtcbn1cblxuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdBbmRyb2lkJyB8fCAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbmZ1bmN0aW9uIGlzaU9TKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdpUGFkIFNpbXVsYXRvcicsXG4gICAgICAgICdpUGhvbmUgU2ltdWxhdG9yJyxcbiAgICAgICAgJ2lQb2QgU2ltdWxhdG9yJyxcbiAgICAgICAgJ2lQYWQnLFxuICAgICAgICAnaVBob25lJyxcbiAgICAgICAgJ2lQb2QnLFxuICAgIF0uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgICAgICAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cbiAgICAgICAgfHwgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ01hYycpICYmICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudCk7XG59XG5cbmNvbnN0IGZvY3VzID0gKHBvc2l0aW9uID0gbnVsbCwgb3B0aW9ucyA9IHt9KSA9PiAoeyBlZGl0b3IsIHZpZXcsIHRyLCBkaXNwYXRjaCwgfSkgPT4ge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgZGVsYXllZEZvY3VzID0gKCkgPT4ge1xuICAgICAgICAvLyBmb2N1cyB3aXRoaW4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYnJlYWtzIGZvY3VzIG9uIGlPUyBhbmQgQW5kcm9pZFxuICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIGNhbGwgdGhpc1xuICAgICAgICBpZiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgdmlldy5kb20uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgUmVhY3Qgd2UgaGF2ZSB0byBmb2N1cyBhc3luY2hyb25vdXNseS4gT3RoZXJ3aXNlIHdpbGQgdGhpbmdzIGhhcHBlbi5cbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzE1MjBcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmICgodmlldy5oYXNGb2N1cygpICYmIHBvc2l0aW9uID09PSBudWxsKSB8fCBwb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHdlIGRvbuKAmXQgdHJ5IHRvIHJlc29sdmUgYSBOb2RlU2VsZWN0aW9uIG9yIENlbGxTZWxlY3Rpb25cbiAgICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICBkZWxheWVkRm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHBhc3MgdGhyb3VnaCB0ci5kb2MgaW5zdGVhZCBvZiBlZGl0b3Iuc3RhdGUuZG9jXG4gICAgLy8gc2luY2UgdHJhbnNhY3Rpb25zIGNvdWxkIGNoYW5nZSB0aGUgZWRpdG9ycyBzdGF0ZSBiZWZvcmUgdGhpcyBjb21tYW5kIGhhcyBiZWVuIHJ1blxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKHRyLmRvYywgcG9zaXRpb24pIHx8IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3QgaXNTYW1lU2VsZWN0aW9uID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYHRyLnNldFNlbGVjdGlvbmAgcmVzZXRzIHRoZSBzdG9yZWQgbWFya3NcbiAgICAgICAgLy8gc28gd2XigJlsbCByZXN0b3JlIHRoZW0gaWYgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICAgICAgaWYgKGlzU2FtZVNlbGVjdGlvbiAmJiB0ci5zdG9yZWRNYXJrcykge1xuICAgICAgICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGF5ZWRGb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGZvckVhY2ggPSAoaXRlbXMsIGZuKSA9PiBwcm9wcyA9PiB7XG4gICAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpO1xufTtcblxuY29uc3QgaW5zZXJ0Q29udGVudCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogdHIuc2VsZWN0aW9uLmZyb20sIHRvOiB0ci5zZWxlY3Rpb24udG8gfSwgdmFsdWUsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgcmVtb3ZlV2hpdGVzcGFjZXMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgY2hpbGQubm9kZVZhbHVlICYmIC9eKFxcblxcc1xcc3xcXG4pJC8udGVzdChjaGlsZC5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgcmVtb3ZlV2hpdGVzcGFjZXMoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcbmZ1bmN0aW9uIGVsZW1lbnRGcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgY29uc3Qgd3JhcHBlZFZhbHVlID0gYDxib2R5PiR7dmFsdWV9PC9ib2R5PmA7XG4gICAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHk7XG4gICAgcmV0dXJuIHJlbW92ZVdoaXRlc3BhY2VzKGh0bWwpO1xufVxuXG4vKipcbiAqIFRha2VzIGEgSlNPTiBvciBIVE1MIGNvbnRlbnQgYW5kIGNyZWF0ZXMgYSBQcm9zZW1pcnJvciBub2RlIG9yIGZyYWdtZW50IGZyb20gaXQuXG4gKiBAcGFyYW0gY29udGVudCBUaGUgSlNPTiBvciBIVE1MIGNvbnRlbnQgdG8gY3JlYXRlIHRoZSBub2RlIGZyb21cbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlycm9yIHNjaGVtYSB0byB1c2UgZm9yIHRoZSBub2RlXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgcGFyc2VyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBQcm9zZW1pcnJvciBub2RlIG9yIGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIE5vZGUkMSB8fCBjb250ZW50IGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHNsaWNlOiB0cnVlLFxuICAgICAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgaXNKU09OQ29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiBjb250ZW50ICE9PSBudWxsO1xuICAgIGNvbnN0IGlzVGV4dENvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZyc7XG4gICAgaWYgKGlzSlNPTkNvbnRlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQXJyYXlDb250ZW50ID0gQXJyYXkuaXNBcnJheShjb250ZW50KSAmJiBjb250ZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAvLyBpZiB0aGUgSlNPTiBDb250ZW50IGlzIGFuIGFycmF5IG9mIG5vZGVzLCBjcmVhdGUgYSBmcmFnbWVudCBmb3IgZWFjaCBub2RlXG4gICAgICAgICAgICBpZiAoaXNBcnJheUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KGNvbnRlbnQubWFwKGl0ZW0gPT4gc2NoZW1hLm5vZGVGcm9tSlNPTihpdGVtKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSlNPTiBjb250ZW50JywgeyBjYXVzZTogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC4nLCAnUGFzc2VkIHZhbHVlOicsIGNvbnRlbnQsICdFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1RleHRDb250ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIGNvbnRlbnRcbiAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgaGFzSW52YWxpZENvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbnZhbGlkQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgLy8gQSBjb3B5IG9mIHRoZSBjdXJyZW50IHNjaGVtYSB3aXRoIGEgY2F0Y2gtYWxsIG5vZGUgYXQgdGhlIGVuZFxuICAgICAgICAgICAgY29uc3QgY29udGVudENoZWNrU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgICAgICAgICAgICAgdG9wTm9kZTogc2NoZW1hLnNwZWMudG9wTm9kZSxcbiAgICAgICAgICAgICAgICBtYXJrczogc2NoZW1hLnNwZWMubWFya3MsXG4gICAgICAgICAgICAgICAgLy8gUHJvc2VtaXJyb3IncyBzY2hlbWFzIGFyZSBleGVjdXRlZCBzdWNoIHRoYXQ6IHRoZSBsYXN0IHRvIGV4ZWN1dGUsIG1hdGNoZXMgbGFzdFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gYWRkIGEgY2F0Y2gtYWxsIG5vZGUgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZW1hIHRvIGNhdGNoIGFueSBjb250ZW50IHRoYXQgd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlXG4gICAgICAgICAgICAgICAgbm9kZXM6IHNjaGVtYS5zcGVjLm5vZGVzLmFwcGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIF9fdGlwdGFwX19wcml2YXRlX191bmtub3duX19jYXRjaF9fYWxsX19ub2RlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICcqJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBldmVyIGNhbGxlZCwgd2Uga25vdyB0aGF0IHRoZSBjb250ZW50IGhhcyBzb21ldGhpbmcgdGhhdCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGUgaW4gdGhlIHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzSW52YWxpZENvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHN0cmluZ2lmeSB0aGUgZWxlbWVudCBmb3IgYSBtb3JlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZENvbnRlbnQgPSB0eXBlb2YgZSA9PT0gJ3N0cmluZycgPyBlIDogZS5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgICAgICAgICAgICBET01QYXJzZXIuZnJvbVNjaGVtYShjb250ZW50Q2hlY2tTY2hlbWEpLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERPTVBhcnNlci5mcm9tU2NoZW1hKGNvbnRlbnRDaGVja1NjaGVtYSkucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCAmJiBoYXNJbnZhbGlkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50JywgeyBjYXVzZTogbmV3IEVycm9yKGBJbnZhbGlkIGVsZW1lbnQgZm91bmQ6ICR7aW52YWxpZENvbnRlbnR9YCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpO1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci1zdGF0ZS9ibG9iL21hc3Rlci9zcmMvc2VsZWN0aW9uLmpzI0w0NjZcbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGNvbnN0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0IDwgc3RhcnRMZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF07XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgICAgICBpZiAoZW5kID09PSAwKSB7XG4gICAgICAgICAgICBlbmQgPSBuZXdUbztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IGlzRnJhZ21lbnQgPSAobm9kZU9yRnJhZ21lbnQpID0+IHtcbiAgICByZXR1cm4gISgndHlwZScgaW4gbm9kZU9yRnJhZ21lbnQpO1xufTtcbmNvbnN0IGluc2VydENvbnRlbnRBdCA9IChwb3NpdGlvbiwgdmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJzZU9wdGlvbnM6IGVkaXRvci5vcHRpb25zLnBhcnNlT3B0aW9ucyxcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGFwcGx5SW5wdXRSdWxlczogZmFsc2UsXG4gICAgICAgICAgICBhcHBseVBhc3RlUnVsZXM6IGZhbHNlLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9hID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlZGl0b3IuZW1pdCgnY29udGVudEVycm9yJywge1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ29sbGFib3JhdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbi5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSAnbnVtYmVyJyA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogeyBmcm9tOiBwb3NpdGlvbi5mcm9tLCB0bzogcG9zaXRpb24udG8gfTtcbiAgICAgICAgbGV0IGlzT25seVRleHRDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gaXNGcmFnbWVudChjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhZGRlZCBub2RlIGlzIHZhbGlkXG4gICAgICAgICAgICBub2RlLmNoZWNrKCk7XG4gICAgICAgICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZTtcbiAgICAgICAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlcGxhY2UgdGhlIHdyYXBwaW5nIG5vZGUgYnlcbiAgICAgICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAgICAgLy8gZXhhbXBsZTpcbiAgICAgICAgLy8gcmVwbGFjZSBhbiBlbXB0eSBwYXJhZ3JhcGggYnkgYW4gaW5zZXJ0ZWQgaW1hZ2VcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICAgICAgaWYgKGZyb20gPT09IHRvICYmIGlzT25seUJsb2NrQ29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9IHBhcmVudC5pc1RleHRibG9jayAmJiAhcGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICFwYXJlbnQuY2hpbGRDb3VudDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5VGV4dEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZnJvbSAtPSAxO1xuICAgICAgICAgICAgICAgIHRvICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgcGxhaW4gdGV4dCB3ZSBoYXZlIHRvIHVzZSBgaW5zZXJ0VGV4dGBcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIHdpbGwga2VlcCB0aGUgY3VycmVudCBtYXJrc1xuICAgICAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIHN0cmluZywgd2UgY2FuIHVzZSBpdCBkaXJlY3RseVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGl0IGlzIGFuIGFycmF5LCB3ZSBoYXZlIHRvIGpvaW4gaXRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS5tYXAodiA9PiB2LnRleHQgfHwgJycpLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZSAmJiAhIXZhbHVlLnRleHQpIHtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gdmFsdWUudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmluc2VydFRleHQobmV3Q29udGVudCwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgbmV3Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGN1cnNvciBhdCBlbmQgb2YgaW5zZXJ0ZWQgY29udGVudFxuICAgICAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwbHlJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseUlucHV0UnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwbHlQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseVBhc3RlUnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBqb2luVXAgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luVXAkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbmNvbnN0IGpvaW5Eb3duID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pbkRvd24kMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbmNvbnN0IGpvaW5CYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGpvaW5CYWNrd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuY29uc3Qgam9pbkZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luRm9yd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBqb2luSXRlbUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuY29uc3Qgam9pbkl0ZW1Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgKzEpO1xuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pblRleHRibG9ja0JhY2t3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pblRleHRibG9ja0ZvcndhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuZnVuY3Rpb24gaXNNYWNPUygpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAgICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PT0gJ1NwYWNlJykge1xuICAgICAgICByZXN1bHQgPSAnICc7XG4gICAgfVxuICAgIGxldCBhbHQ7XG4gICAgbGV0IGN0cmw7XG4gICAgbGV0IHNoaWZ0O1xuICAgIGxldCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IGBBbHQtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKGN0cmwpIHtcbiAgICAgICAgcmVzdWx0ID0gYEN0cmwtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKG1ldGEpIHtcbiAgICAgICAgcmVzdWx0ID0gYE1ldGEtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKHNoaWZ0KSB7XG4gICAgICAgIHJlc3VsdCA9IGBTaGlmdC0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qga2V5Ym9hcmRTaG9ydGN1dCA9IG5hbWUgPT4gKHsgZWRpdG9yLCB2aWV3LCB0ciwgZGlzcGF0Y2gsIH0pID0+IHtcbiAgICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgY29uc3Qga2V5ID0ga2V5cy5maW5kKGl0ZW0gPT4gIVsnQWx0JywgJ0N0cmwnLCAnTWV0YScsICdTaGlmdCddLmluY2x1ZGVzKGl0ZW0pKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgICAgICBrZXk6IGtleSA9PT0gJ1NwYWNlJ1xuICAgICAgICAgICAgPyAnICdcbiAgICAgICAgICAgIDoga2V5LFxuICAgICAgICBhbHRLZXk6IGtleXMuaW5jbHVkZXMoJ0FsdCcpLFxuICAgICAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKCdDdHJsJyksXG4gICAgICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoJ01ldGEnKSxcbiAgICAgICAgc2hpZnRLZXk6IGtleXMuaW5jbHVkZXMoJ1NoaWZ0JyksXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgY2FwdHVyZWRUcmFuc2FjdGlvbiA9IGVkaXRvci5jYXB0dXJlVHJhbnNhY3Rpb24oKCkgPT4ge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKCdoYW5kbGVLZXlEb3duJywgZiA9PiBmKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG4gICAgY2FwdHVyZWRUcmFuc2FjdGlvbiA9PT0gbnVsbCB8fCBjYXB0dXJlZFRyYW5zYWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXB0dXJlZFRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKTtcbiAgICAgICAgaWYgKG5ld1N0ZXAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHRyLm1heWJlU3RlcChuZXdTdGVwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGw7XG4gICAgY29uc3Qgbm9kZVJhbmdlcyA9IFtdO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgbm9kZVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb207XG4gICAgY29uc3QgbWF0Y2hlZE5vZGVSYW5nZXMgPSBub2RlUmFuZ2VzXG4gICAgICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihub2RlUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSk7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiAhIW1hdGNoZWROb2RlUmFuZ2VzLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMCk7XG4gICAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xufVxuXG5jb25zdCBsaWZ0ID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsaWZ0JDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gbGlmdEVtcHR5QmxvY2skMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgbGlmdExpc3RJdGVtID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIHJldHVybiBsaWZ0TGlzdEl0ZW0kMSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgbmV3bGluZUluQ29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG5ld2xpbmVJbkNvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgYSBzY2hlbWEgaXRlbSBieSBpdHMgbmFtZS5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgaXRlbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgc2NoZW1hIGl0ZW0gKGBub2RlYCBvciBgbWFya2ApLCBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZSwgc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gJ25vZGUnO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiAnbWFyayc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHByb3BlcnR5IG9yIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSBvYmogT2JqZWN0XG4gKiBAcGFyYW0ga2V5IEtleSB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlUHJvcHMob2JqLCBwcm9wT3JQcm9wcykge1xuICAgIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSAnc3RyaW5nJ1xuICAgICAgICA/IFtwcm9wT3JQcm9wc11cbiAgICAgICAgOiBwcm9wT3JQcm9wcztcbiAgICByZXR1cm4gT2JqZWN0XG4gICAgICAgIC5rZXlzKG9iailcbiAgICAgICAgLnJlZHVjZSgobmV3T2JqLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sIHt9KTtcbn1cblxuY29uc3QgcmVzZXRBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBub2RlVHlwZSA9IG51bGw7XG4gICAgbGV0IG1hcmtUeXBlID0gbnVsbDtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgICAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCBkZWxldGVQcm9wcyhub2RlLmF0dHJzLCBhdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZWxlY3RBbGwgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgQWxsU2VsZWN0aW9uKHRyLmRvYyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdE5vZGVCYWNrd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBzZWxlY3ROb2RlRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdE5vZGVGb3J3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBzZWxlY3RQYXJlbnROb2RlJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdFRleHRibG9ja0VuZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBAdHMtaWdub3JlXG4vLyBUT0RPOiBhZGQgdHlwZXMgdG8gQHR5cGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdFRleHRibG9ja1N0YXJ0JDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFByb3NlbWlycm9yIGRvY3VtZW50IG5vZGUgZnJvbSBjb250ZW50LlxuICogQHBhcmFtIGNvbnRlbnQgVGhlIEpTT04gb3IgSFRNTCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgZG9jdW1lbnQgZnJvbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHVzZSBmb3IgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0gcGFyc2VPcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBwYXJzZXJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIFByb3NlbWlycm9yIGRvY3VtZW50IG5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgc2NoZW1hLCBwYXJzZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHtcbiAgICAgICAgc2xpY2U6IGZhbHNlLFxuICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQsXG4gICAgfSk7XG59XG5cbmNvbnN0IHNldENvbnRlbnQgPSAoY29udGVudCwgZW1pdFVwZGF0ZSA9IGZhbHNlLCBwYXJzZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBkaXNwYXRjaCwgY29tbWFuZHMsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcbiAgICAvLyBUaGlzIGlzIHRvIGtlZXAgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBiZWhhdmlvclxuICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxuICAgIGlmIChwYXJzZU9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSAnZnVsbCcpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBjcmVhdGVEb2N1bWVudChjb250ZW50LCBlZGl0b3Iuc2NoZW1hLCBwYXJzZU9wdGlvbnMsIHtcbiAgICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9hID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQpLnNldE1ldGEoJ3ByZXZlbnRVcGRhdGUnLCAhZW1pdFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogMCwgdG86IGRvYy5jb250ZW50LnNpemUgfSwgY29udGVudCwge1xuICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9iID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCBtYXJrcyA9IFtdO1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQobWFya0l0ZW0gPT4gbWFya0l0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xuICAgIGlmICghbWFyaykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IC4uLm1hcmsuYXR0cnMgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBUcmFuc2Zvcm1gIGJhc2VkIG9uIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9ucy5cbiAqIEBwYXJhbSBvbGREb2MgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc3RhcnQgZnJvbVxuICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUaGUgdHJhbnNhY3Rpb25zIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIEEgbmV3IGBUcmFuc2Zvcm1gIHdpdGggYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZERvYywgdHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpO1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBhdCBhIGdpdmVuIG1hdGNoXG4gKiBAcGFyYW0gbWF0Y2ggVGhlIGNvbnRlbnQgbWF0Y2ggdG8gZ2V0IHRoZSBkZWZhdWx0IGJsb2NrIHR5cGUgZnJvbVxuICogQHJldHVybnMgVGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBjaGlsZHJlbiBpbnNpZGUgYSBQcm9zZW1pcnJvciBub2RlIHRoYXQgbWF0Y2ggYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgd2l0aCB0aGVpciBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gZmluZENoaWxkcmVuKG5vZGUsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICAgIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XG59XG5cbi8qKlxuICogU2FtZSBhcyBgZmluZENoaWxkcmVuYCBidXQgc2VhcmNoZXMgb25seSB3aXRoaW4gYSBgcmFuZ2VgLlxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW5JblJhbmdlKG5vZGUsIHJhbmdlLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBub2Rlc1dpdGhQb3MgPSBbXTtcbiAgICAvLyBpZiAocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8pIHtcbiAgICAvLyAgIGNvbnN0IG5vZGVBdCA9IG5vZGUubm9kZUF0KHJhbmdlLmZyb20pXG4gICAgLy8gICBpZiAobm9kZUF0KSB7XG4gICAgLy8gICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAvLyAgICAgICBub2RlOiBub2RlQXQsXG4gICAgLy8gICAgICAgcG9zOiByYW5nZS5mcm9tLFxuICAgIC8vICAgICB9KVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gYSByZXNvbHZlZCBwb3NpdGlvbiB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gJHBvcyBUaGUgcmVzb2x2ZWQgcG9zaXRpb24gdG8gc2VhcmNoIGZyb21cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gdGhlIHJlc29sdmVkIHBvc2l0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlXG4gKiBAZXhhbXBsZSBgYGBqc1xuICogZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJGZyb20sIG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKCRwb3MsIHByZWRpY2F0ZSkge1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcbiAgICAgICAgICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIGEgcHJlZGljYXRlLlxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBIGNvbW1hbmQgdGhhdCBmaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJylcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gKHNlbGVjdGlvbikgPT4gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLiRmcm9tLCBwcmVkaWNhdGUpO1xufVxuXG5mdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xuICAgIHJldHVybiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhyZXNvbHZlZEV4dGVuc2lvbnMsIGVkaXRvcik7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgSFRNTCBmcm9tIGEgSlNPTkNvbnRlbnRcbiAqIEBwYXJhbSBkb2MgVGhlIEpTT05Db250ZW50IHRvIGdlbmVyYXRlIEhUTUwgZnJvbVxuICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbnMgdG8gdXNlIGZvciB0aGUgc2NoZW1hXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEhUTUxcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVIVE1MKGRvYywgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUkMS5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQoY29udGVudE5vZGUuY29udGVudCwgc2NoZW1hKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBKU09OQ29udGVudCBmcm9tIEhUTUxcbiAqIEBwYXJhbSBodG1sIFRoZSBIVE1MIHRvIGdlbmVyYXRlIEpTT05Db250ZW50IGZyb21cbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBKU09OQ29udGVudFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbCwgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKTtcbiAgICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgb2YgYSBQcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgc2VyaWFsaXplciAmIGJsb2NrIHNlcGFyYXRvclxuICogQHJldHVybnMgVGhlIHRleHQgb2YgdGhlIG5vZGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBjb25zdCB0ZXh0ID0gZ2V0VGV4dChub2RlLCB7IGJsb2NrU2VwYXJhdG9yOiAnXFxuJyB9KVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldFRleHQobm9kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogbm9kZS5jb250ZW50LnNpemUsXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHJhdyB0ZXh0IGZyb20gYSBKU09OQ29udGVudFxuICogQHBhcmFtIGRvYyBUaGUgSlNPTkNvbnRlbnQgdG8gZ2VuZXJhdGUgdGV4dCBmcm9tXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9ucyB0byB1c2UgZm9yIHRoZSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0ZXh0IGdlbmVyYXRpb24gZi5lLiBibG9ja1NlcGFyYXRvciBvciB0ZXh0U2VyaWFsaXplcnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgdGV4dFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRleHQoZG9jLCBleHRlbnNpb25zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlJDEuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xuICAgIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcbiAgICAgICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQobm9kZUl0ZW0gPT4gbm9kZUl0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfTtcbn1cblxuLyoqXG4gKiBHZXQgbm9kZSBvciBtYXJrIGF0dHJpYnV0ZXMgYnkgdHlwZSBvciBuYW1lIG9uIHRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICogQHBhcmFtIHN0YXRlIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgb3IgbWFyayB0eXBlIG9yIG5hbWVcbiAqIEByZXR1cm5zIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlIG9yIG1hcmsgb3IgYW4gZW1wdHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgIHJldHVybiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgcmV0dXJuIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogU3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncyBhbmQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhhcnJheSwgYnkgPSBKU09OLnN0cmluZ2lmeSkge1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBieShpdGVtKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuLCBrZXkpXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IChzZWVuW2tleV0gPSB0cnVlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgcmFuZ2VzIGFuZCByYW5nZXMgdGhhdCBhcmVcbiAqIGZ1bGx5IGNhcHR1cmVkIGJ5IG90aGVyIHJhbmdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpIHtcbiAgICBjb25zdCB1bmlxdWVDaGFuZ2VzID0gcmVtb3ZlRHVwbGljYXRlcyhjaGFuZ2VzKTtcbiAgICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB1bmlxdWVDaGFuZ2VzXG4gICAgICAgIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuICFyZXN0LnNvbWUob3RoZXJDaGFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50b1xuICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50bztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlZCByYW5nZXNcbiAqIGJhc2VkIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzdGF0ZSBvZiBhbGwgc3RlcHMuXG4gKi9cbmZ1bmN0aW9uIGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKSB7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBzdGVwcyB9ID0gdHJhbnNmb3JtO1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBtYXBwaW5nLm1hcHMuZm9yRWFjaCgoc3RlcE1hcCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgICAgIC8vIFRoaXMgYWNjb3VudHMgZm9yIHN0ZXAgY2hhbmdlcyB3aGVyZSBubyByYW5nZSB3YXMgYWN0dWFsbHkgYWx0ZXJlZFxuICAgICAgICAvLyBlLmcuIHdoZW4gc2V0dGluZyBhIG1hcmssIG5vZGUgYXR0cmlidXRlLCBldGMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKGZyb20sIC0xKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcCh0byk7XG4gICAgICAgICAgICBjb25zdCBvbGRTdGFydCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld1N0YXJ0LCAtMSk7XG4gICAgICAgICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdG86IG9sZEVuZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB0bzogbmV3RW5kLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGUsIHN0YXJ0T2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMTtcbiAgICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXQ7XG4gICAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZTtcbiAgICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgICBjb25zdCBhdHRycyA9IHsgLi4ubm9kZS5hdHRycyB9O1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLm5hbWUsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgIH07XG4gICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0LmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIGlmIChtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0Lm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICBvdXRwdXQuY29udGVudCA9IFtdO1xuICAgICAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IG91dHB1dC5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChnZXREZWJ1Z0pTT04oY2hpbGQsIHN0YXJ0T2Zmc2V0ICsgb2Zmc2V0ICsgaW5jcmVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgIG91dHB1dC50ZXh0ID0gbm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXJrc0JldHdlZW4oZnJvbSwgdG8sIGRvYykge1xuICAgIGNvbnN0IG1hcmtzID0gW107XG4gICAgLy8gZ2V0IGFsbCBpbmNsdXNpdmUgbWFya3Mgb24gZW1wdHkgc2VsZWN0aW9uXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgIGRvY1xuICAgICAgICAgICAgLnJlc29sdmUoZnJvbSlcbiAgICAgICAgICAgIC5tYXJrcygpXG4gICAgICAgICAgICAuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRwb3MsIG1hcmsudHlwZSk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLm5vZGVTaXplKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya3MucHVzaCguLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgIG1hcmssXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSBvciBuYW1lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgZWRpdG9yIHN0YXRlLlxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgdHlwZSBvciBuYW1lLlxuICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXG4gKiBAcGFyYW0gbWF4RGVwdGggVGhlIG1heGltdW0gZGVwdGggdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5vZGUgYW5kIHRoZSBkZXB0aCBhcyBhbiBhcnJheS5cbiAqL1xuY29uc3QgZ2V0Tm9kZUF0UG9zaXRpb24gPSAoc3RhdGUsIHR5cGVPck5hbWUsIHBvcywgbWF4RGVwdGggPSAyMCkgPT4ge1xuICAgIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGxldCBjdXJyZW50RGVwdGggPSBtYXhEZXB0aDtcbiAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9ICRwb3Mubm9kZShjdXJyZW50RGVwdGgpO1xuICAgICAgICBpZiAoKGN1cnJlbnROb2RlID09PSBudWxsIHx8IGN1cnJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS50eXBlLm5hbWUpID09PSB0eXBlT3JOYW1lKSB7XG4gICAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW25vZGUsIGN1cnJlbnREZXB0aF07XG59O1xuXG4vKipcbiAqIFJldHVybiBhdHRyaWJ1dGVzIG9mIGFuIGV4dGVuc2lvbiB0aGF0IHNob3VsZCBiZSBzcGxpdHRlZCBieSBrZWVwT25TcGxpdCBmbGFnXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBBcnJheSBvZiBleHRlbnNpb24gYXR0cmlidXRlc1xuICogQHBhcmFtIHR5cGVOYW1lIFRoZSB0eXBlIG9mIHRoZSBleHRlbnNpb25cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBleHRlbnNpb25cbiAqIEByZXR1cm5zIFRoZSBzcGxpdHRlZCBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCB0eXBlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0XG4gICAgICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlTmFtZSAmJiBpdGVtLm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWV4dGVuc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG4gICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrLnR5cGUubmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5kKG1hcmsgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgICB9XG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gMDtcbiAgICBjb25zdCBtYXJrUmFuZ2VzID0gW107XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3M7XG4gICAgICAgIGNvbnN0IHRvID0gJHRvLnBvcztcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiAhbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbTtcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlO1xuICAgICAgICAgICAgbWFya1Jhbmdlcy5wdXNoKC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICAgICAgICBtYXJrLFxuICAgICAgICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb25SYW5nZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXRjaGVkIG1hcmtcbiAgICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcbiAgICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWFya3MgdGhhdCBleGNsdWRlcyB0aGUgc2VhcmNoZWQgbWFya1xuICAgIC8vIGZvciBleGFtcGxlIGBjb2RlYCBkb2VzbuKAmXQgYWxsb3cgYW55IG90aGVyIG1hcmtzXG4gICAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrUmFuZ2UubWFyay50eXBlICE9PSB0eXBlICYmIG1hcmtSYW5nZS5tYXJrLnR5cGUuZXhjbHVkZXModHlwZSk7XG4gICAgfSlcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcbiAgICAvLyB3ZSBvbmx5IGluY2x1ZGUgdGhlIHJlc3VsdCBvZiBgZXhjbHVkZWRSYW5nZWBcbiAgICAvLyBpZiB0aGVyZSBpcyBhIG1hdGNoIGF0IGFsbFxuICAgIGNvbnN0IHJhbmdlID0gbWF0Y2hlZFJhbmdlID4gMCA/IG1hdGNoZWRSYW5nZSArIGV4Y2x1ZGVkUmFuZ2UgOiBtYXRjaGVkUmFuZ2U7XG4gICAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xufVxuXG5mdW5jdGlvbiBpc0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZSwgbm9kZVR5cGUpID0+IHtcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8sICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gc3RhdGUuZG9jLnJlc29sdmUocGFyZW50Tm9kZS5wb3MgKyAxKTtcbiAgICAgICAgaWYgKCRhbmNob3IucG9zICsgMSA9PT0gJHBhcmVudFBvcy5lbmQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpc0xpc3QobmFtZSwgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfTtcbiAgICBjb25zdCBncm91cCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKTtcbiAgICBpZiAodHlwZW9mIGdyb3VwICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcm9zZW1pcnJvciBub2RlIGlzIGVtcHR5LlxuICovXG5mdW5jdGlvbiBpc05vZGVFbXB0eShub2RlLCB7IGNoZWNrQ2hpbGRyZW4gPSB0cnVlLCBpZ25vcmVXaGl0ZXNwYWNlID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09ICdoYXJkQnJlYWsnKSB7XG4gICAgICAgICAgICAvLyBIYXJkIGJyZWFrcyBhcmUgY29uc2lkZXJlZCBlbXB0eVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gL15cXHMqJC9tLnRlc3QoKF9hID0gbm9kZS50ZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVybiAhbm9kZS50ZXh0O1xuICAgIH1cbiAgICBpZiAobm9kZS5pc0F0b20gfHwgbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjaGVja0NoaWxkcmVuKSB7XG4gICAgICAgIGxldCBpc0NvbnRlbnRFbXB0eSA9IHRydWU7XG4gICAgICAgIG5vZGUuY29udGVudC5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDb250ZW50RW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBmb3IgcGVyZlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOb2RlRW1wdHkoY2hpbGROb2RlLCB7IGlnbm9yZVdoaXRlc3BhY2UsIGNoZWNrQ2hpbGRyZW4gfSkpIHtcbiAgICAgICAgICAgICAgICBpc0NvbnRlbnRFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzQ29udGVudEVtcHR5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0bykge1xuICAgIGNvbnN0IG1pblBvcyA9IDA7XG4gICAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcbiAgICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKTtcbiAgICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSk7XG4gICAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKTtcbiAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdCk7XG4gICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KTtcbiAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgY29uc3QgeCA9IGxlZnQ7XG4gICAgY29uc3QgeSA9IHRvcDtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICB0b0pTT046ICgpID0+IGRhdGEsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSByZXdyaXRlVW5rbm93bkNvbnRlbnQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoeyBqc29uLCB2YWxpZE1hcmtzLCB2YWxpZE5vZGVzLCBvcHRpb25zLCByZXdyaXR0ZW5Db250ZW50ID0gW10sIH0pIHtcbiAgICBpZiAoanNvbi5tYXJrcyAmJiBBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKSB7XG4gICAgICAgIGpzb24ubWFya3MgPSBqc29uLm1hcmtzLmZpbHRlcihtYXJrID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbWFyayA9PT0gJ3N0cmluZycgPyBtYXJrIDogbWFyay50eXBlO1xuICAgICAgICAgICAgaWYgKHZhbGlkTWFya3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1hcmspKSxcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZDogbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSnVzdCBpZ25vcmUgYW55IHVua25vd24gbWFya3NcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpKSB7XG4gICAgICAgIGpzb24uY29udGVudCA9IGpzb24uY29udGVudFxuICAgICAgICAgICAgLm1hcCh2YWx1ZSA9PiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAgICAgICAgICBqc29uOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbGlkTWFya3MsXG4gICAgICAgICAgICB2YWxpZE5vZGVzLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHJld3JpdHRlbkNvbnRlbnQsXG4gICAgICAgIH0pLmpzb24pXG4gICAgICAgICAgICAuZmlsdGVyKGEgPT4gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpZiAoanNvbi50eXBlICYmICF2YWxpZE5vZGVzLmhhcyhqc29uLnR5cGUpKSB7XG4gICAgICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShqc29uKSksXG4gICAgICAgICAgICB1bnN1cHBvcnRlZDoganNvbi50eXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGpzb24uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGpzb24uY29udGVudCkgJiYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2tUb1BhcmFncmFwaCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgLy8gSnVzdCB0cmVhdCBpdCBsaWtlIGEgcGFyYWdyYXBoIGFuZCBob3BlIGZvciB0aGUgYmVzdFxuICAgICAgICAgICAganNvbi50eXBlID0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3IganVzdCBvbWl0IGl0IGVudGlyZWx5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqc29uOiBudWxsLFxuICAgICAgICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsganNvbiwgcmV3cml0dGVuQ29udGVudCB9O1xufVxuLyoqXG4gKiBSZXdyaXRlIHVua25vd24gbm9kZXMgYW5kIG1hcmtzIHdpdGhpbiBKU09OIGNvbnRlbnRcbiAqIEFsbG93aW5nIGZvciB1c2VyIHdpdGhpbiB0aGUgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJld3JpdGVVbmtub3duQ29udGVudChcbi8qKlxuICogVGhlIEpTT04gY29udGVudCB0byBjbGVhbiBvZiB1bmtub3duIG5vZGVzIGFuZCBtYXJrc1xuICovXG5qc29uLCBcbi8qKlxuICogVGhlIHNjaGVtYSB0byB1c2UgZm9yIHZhbGlkYXRpb25cbiAqL1xuc2NoZW1hLCBcbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGNsZWFuaW5nIHByb2Nlc3NcbiAqL1xub3B0aW9ucykge1xuICAgIHJldHVybiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAgICAgIGpzb24sXG4gICAgICAgIHZhbGlkTm9kZXM6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm5vZGVzKSksXG4gICAgICAgIHZhbGlkTWFya3M6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm1hcmtzKSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGUsIHRyLCBuZXdNYXJrVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgbGV0IGN1cnNvciA9IG51bGw7XG4gICAgaWYgKGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yO1xuICAgIH1cbiAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IChfYSA9IHN0YXRlLnN0b3JlZE1hcmtzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXJzb3IubWFya3MoKTtcbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIG5vIGN1cnJlbnQgbWFya3MgdGhhdCBleGNsdWRlIHRoZSBuZXcgbWFya1xuICAgICAgICByZXR1cm4gKCEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpXG4gICAgICAgICAgICB8fCAhY3VycmVudE1hcmtzLnNvbWUobWFyayA9PiBtYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgICAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgICAgICAgPyBzdGF0ZS5kb2MuaW5saW5lQ29udGVudCAmJiBzdGF0ZS5kb2MudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbWFyayB0aGF0IHdlIGNhbiBlbmFibGUsIHJldHVybiBmYWxzZSB0byBieXBhc3MgdGhlIHJlbWFpbmluZyBzZWFyY2hcbiAgICAgICAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmlzSW5saW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpXG4gICAgICAgICAgICAgICAgICAgIHx8ICFub2RlLm1hcmtzLnNvbWUob3RoZXJNYXJrID0+IG90aGVyTWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICB9KTtcbn1cbmNvbnN0IHNldE1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKTtcbiAgICAgICAgICAgIHRyLmFkZFN0b3JlZE1hcmsodHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIC4uLm9sZEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvcztcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBtYXJrIG9mIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgd2UgaGF2ZSB0byBtZXJnZSBpdHMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIGEgZnJlc2ggbmV3IG1hcmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbWVIYXNNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhblNldE1hcmsoc3RhdGUsIHRyLCB0eXBlKTtcbn07XG5cbmNvbnN0IHNldE1ldGEgPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xuICAgIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZXROb2RlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgICAvLyBvbmx5IGNvcHkgYXR0cmlidXRlcyBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGF0dHJpYnV0ZXNUb0NvcHkgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnQuYXR0cnM7XG4gICAgfVxuICAgIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBDdXJyZW50bHkgXCJzZXROb2RlKClcIiBvbmx5IHN1cHBvcnRzIHRleHQgYmxvY2sgbm9kZXMuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjaGFpbigpXG4gICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhblNldEJsb2NrID0gc2V0QmxvY2tUeXBlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KShzdGF0ZSk7XG4gICAgICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICB9KVxuICAgICAgICAuY29tbWFuZCgoeyBzdGF0ZTogdXBkYXRlZFN0YXRlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkodXBkYXRlZFN0YXRlLCBkaXNwYXRjaCk7XG4gICAgfSlcbiAgICAgICAgLnJ1bigpKTtcbn07XG5cbmNvbnN0IHNldE5vZGVTZWxlY3Rpb24gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgICAgIGNvbnN0IGZyb20gPSBtaW5NYXgocG9zaXRpb24sIDAsIGRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZXRUZXh0U2VsZWN0aW9uID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgeyBkb2MgfSA9IHRyO1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvbjtcbiAgICAgICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbTtcbiAgICAgICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbi5hdEVuZChkb2MpLnRvO1xuICAgICAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xuICAgICAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzaW5rTGlzdEl0ZW0gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIHNpbmtMaXN0SXRlbSQxKHR5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZSwgc3BsaXR0YWJsZU1hcmtzKSB7XG4gICAgY29uc3QgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgIGlmIChtYXJrcykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzID09PSBudWxsIHx8IHNwbGl0dGFibGVNYXJrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgIHN0YXRlLnRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgIH1cbn1cbmNvbnN0IHNwbGl0QmxvY2sgPSAoeyBrZWVwTWFya3MgPSB0cnVlIH0gPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yLCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpO1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KGRvYywgJGZyb20ucG9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICAgICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgICBsZXQgdHlwZXMgPSBhdEVuZCAmJiBkZWZsdFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgIGlmICghdHlwZXNcbiAgICAgICAgJiYgIWNhblxuICAgICAgICAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNhbiA9IHRydWU7XG4gICAgICAgIHR5cGVzID0gZGVmbHRcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbjtcbn07XG5cbmNvbnN0IHNwbGl0TGlzdEl0ZW0gPSAodHlwZU9yTmFtZSwgb3ZlcnJpZGVBdHRycyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZTtcbiAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09PSAyXG4gICAgICAgICAgICB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSB0eXBlXG4gICAgICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgY29uc3QgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKSxcbiAgICAgICAgICAgICAgICAuLi5vdmVycmlkZUF0dHJzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUeXBlID0gKChfYSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMpKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobi5pc1RleHRibG9jayAmJiBuLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgIGNvbnN0IG5ld1R5cGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgZ3JhbmRQYXJlbnQudHlwZS5uYW1lLCBncmFuZFBhcmVudC5hdHRycyksXG4gICAgICAgIC4uLm92ZXJyaWRlQXR0cnMsXG4gICAgfTtcbiAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgICAgICAuLi5vdmVycmlkZUF0dHJzLFxuICAgIH07XG4gICAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxuICAgICAgICA/IFtcbiAgICAgICAgICAgIHsgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6IG5leHRUeXBlLCBhdHRyczogbmV3TmV4dFR5cGVBdHRyaWJ1dGVzIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV07XG4gICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIGlmICghbWFya3MgfHwgIWRpc3BhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGpvaW5MaXN0QmFja3dhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aCk7XG4gICAgaWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpO1xuICAgIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVCZWZvcmUgPT09IG51bGwgfHwgbm9kZUJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZUJlZm9yZS50eXBlKSAmJiBjYW5Kb2luKHRyLmRvYywgbGlzdC5wb3MpO1xuICAgIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHIuam9pbihsaXN0LnBvcyk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3Qgam9pbkxpc3RGb3J3YXJkcyA9ICh0ciwgbGlzdFR5cGUpID0+IHtcbiAgICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xuICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZShsaXN0LnN0YXJ0KS5hZnRlcihsaXN0LmRlcHRoKTtcbiAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcik7XG4gICAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IChub2RlQWZ0ZXIgPT09IG51bGwgfHwgbm9kZUFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlQWZ0ZXIudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGFmdGVyKTtcbiAgICBpZiAoIWNhbkpvaW5Gb3J3YXJkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHIuam9pbihhZnRlcik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgdG9nZ2xlTGlzdCA9IChsaXN0VHlwZU9yTmFtZSwgaXRlbVR5cGVPck5hbWUsIGtlZXBNYXJrcywgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluLCBjb21tYW5kcywgY2FuLCB9KSA9PiB7XG4gICAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKTtcbiAgICBpZiAocmFuZ2UuZGVwdGggPj0gMSAmJiBwYXJlbnRMaXN0ICYmIHJhbmdlLmRlcHRoIC0gcGFyZW50TGlzdC5kZXB0aCA8PSAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSBsaXN0XG4gICAgICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoYW5nZSBsaXN0IHR5cGVcbiAgICAgICAgaWYgKGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKVxuICAgICAgICAgICAgJiYgbGlzdFR5cGUudmFsaWRDb250ZW50KHBhcmVudExpc3Qubm9kZS5jb250ZW50KVxuICAgICAgICAgICAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocGFyZW50TGlzdC5wb3MsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiAoY2hhaW4oKVxuICAgICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgIH0pXG4gICAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5ydW4oKSk7XG59O1xuXG5jb25zdCB0b2dnbGVNYXJrID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodHlwZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG5jb25zdCB0b2dnbGVOb2RlID0gKHR5cGVPck5hbWUsIHRvZ2dsZVR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgICAvLyBvbmx5IGNvcHkgYXR0cmlidXRlcyBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGF0dHJpYnV0ZXNUb0NvcHkgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnQuYXR0cnM7XG4gICAgfVxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlLCBhdHRyaWJ1dGVzVG9Db3B5KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgaXMgbm90IGFjdGl2ZSwgd2Ugd2FudCB0byBzZXQgdGhlIG5ldyBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlc1xuICAgIC8vIENvcHlpbmcgb3ZlciB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSBjdXJyZW50IG5vZGUgaWYgdGhlIHNlbGVjdGlvbiBpcyBwb2ludGluZyB0byBhIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxuICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KTtcbn07XG5cbmNvbnN0IHRvZ2dsZVdyYXAgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG5jb25zdCB1bmRvSW5wdXRSdWxlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgbGV0IHVuZG9hYmxlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCB1bnNldEFsbE1hcmtzID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB1bnNldE1hcmsgPSAodHlwZU9yTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKCFkaXNwYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGF0dHJzID0gKF9hID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzO1xuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGZyb20gPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgdG8gPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsodHlwZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB1cGRhdGVBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IG5vZGVUeXBlID0gbnVsbDtcbiAgICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSh0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3M7XG4gICAgICAgICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3M7XG4gICAgICAgICAgICBsZXQgbGFzdFBvcztcbiAgICAgICAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgICAgICAgIGxldCB0cmltbWVkRnJvbTtcbiAgICAgICAgICAgIGxldCB0cmltbWVkVG87XG4gICAgICAgICAgICBpZiAodHIuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbTIgPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvMiA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20yLCB0cmltbWVkVG8yLCBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAobGFzdFBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5sYXN0Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgJiYgbGFzdE5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB3cmFwSW4gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIHJldHVybiB3cmFwSW4kMSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3Qgd3JhcEluTGlzdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIHdyYXBJbkxpc3QkMSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxudmFyIGNvbW1hbmRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJsdXI6IGJsdXIsXG4gIGNsZWFyQ29udGVudDogY2xlYXJDb250ZW50LFxuICBjbGVhck5vZGVzOiBjbGVhck5vZGVzLFxuICBjb21tYW5kOiBjb21tYW5kLFxuICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiBjcmVhdGVQYXJhZ3JhcGhOZWFyLFxuICBjdXQ6IGN1dCxcbiAgZGVsZXRlQ3VycmVudE5vZGU6IGRlbGV0ZUN1cnJlbnROb2RlLFxuICBkZWxldGVOb2RlOiBkZWxldGVOb2RlLFxuICBkZWxldGVSYW5nZTogZGVsZXRlUmFuZ2UsXG4gIGRlbGV0ZVNlbGVjdGlvbjogZGVsZXRlU2VsZWN0aW9uLFxuICBlbnRlcjogZW50ZXIsXG4gIGV4aXRDb2RlOiBleGl0Q29kZSxcbiAgZXh0ZW5kTWFya1JhbmdlOiBleHRlbmRNYXJrUmFuZ2UsXG4gIGZpcnN0OiBmaXJzdCxcbiAgZm9jdXM6IGZvY3VzLFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBpbnNlcnRDb250ZW50OiBpbnNlcnRDb250ZW50LFxuICBpbnNlcnRDb250ZW50QXQ6IGluc2VydENvbnRlbnRBdCxcbiAgam9pbkJhY2t3YXJkOiBqb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duOiBqb2luRG93bixcbiAgam9pbkZvcndhcmQ6IGpvaW5Gb3J3YXJkLFxuICBqb2luSXRlbUJhY2t3YXJkOiBqb2luSXRlbUJhY2t3YXJkLFxuICBqb2luSXRlbUZvcndhcmQ6IGpvaW5JdGVtRm9yd2FyZCxcbiAgam9pblRleHRibG9ja0JhY2t3YXJkOiBqb2luVGV4dGJsb2NrQmFja3dhcmQsXG4gIGpvaW5UZXh0YmxvY2tGb3J3YXJkOiBqb2luVGV4dGJsb2NrRm9yd2FyZCxcbiAgam9pblVwOiBqb2luVXAsXG4gIGtleWJvYXJkU2hvcnRjdXQ6IGtleWJvYXJkU2hvcnRjdXQsXG4gIGxpZnQ6IGxpZnQsXG4gIGxpZnRFbXB0eUJsb2NrOiBsaWZ0RW1wdHlCbG9jayxcbiAgbGlmdExpc3RJdGVtOiBsaWZ0TGlzdEl0ZW0sXG4gIG5ld2xpbmVJbkNvZGU6IG5ld2xpbmVJbkNvZGUsXG4gIHJlc2V0QXR0cmlidXRlczogcmVzZXRBdHRyaWJ1dGVzLFxuICBzY3JvbGxJbnRvVmlldzogc2Nyb2xsSW50b1ZpZXcsXG4gIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxuICBzZWxlY3ROb2RlQmFja3dhcmQ6IHNlbGVjdE5vZGVCYWNrd2FyZCxcbiAgc2VsZWN0Tm9kZUZvcndhcmQ6IHNlbGVjdE5vZGVGb3J3YXJkLFxuICBzZWxlY3RQYXJlbnROb2RlOiBzZWxlY3RQYXJlbnROb2RlLFxuICBzZWxlY3RUZXh0YmxvY2tFbmQ6IHNlbGVjdFRleHRibG9ja0VuZCxcbiAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICBzZXRDb250ZW50OiBzZXRDb250ZW50LFxuICBzZXRNYXJrOiBzZXRNYXJrLFxuICBzZXRNZXRhOiBzZXRNZXRhLFxuICBzZXROb2RlOiBzZXROb2RlLFxuICBzZXROb2RlU2VsZWN0aW9uOiBzZXROb2RlU2VsZWN0aW9uLFxuICBzZXRUZXh0U2VsZWN0aW9uOiBzZXRUZXh0U2VsZWN0aW9uLFxuICBzaW5rTGlzdEl0ZW06IHNpbmtMaXN0SXRlbSxcbiAgc3BsaXRCbG9jazogc3BsaXRCbG9jayxcbiAgc3BsaXRMaXN0SXRlbTogc3BsaXRMaXN0SXRlbSxcbiAgdG9nZ2xlTGlzdDogdG9nZ2xlTGlzdCxcbiAgdG9nZ2xlTWFyazogdG9nZ2xlTWFyayxcbiAgdG9nZ2xlTm9kZTogdG9nZ2xlTm9kZSxcbiAgdG9nZ2xlV3JhcDogdG9nZ2xlV3JhcCxcbiAgdW5kb0lucHV0UnVsZTogdW5kb0lucHV0UnVsZSxcbiAgdW5zZXRBbGxNYXJrczogdW5zZXRBbGxNYXJrcyxcbiAgdW5zZXRNYXJrOiB1bnNldE1hcmssXG4gIHVwZGF0ZUF0dHJpYnV0ZXM6IHVwZGF0ZUF0dHJpYnV0ZXMsXG4gIHdyYXBJbjogd3JhcEluLFxuICB3cmFwSW5MaXN0OiB3cmFwSW5MaXN0XG59KTtcblxuY29uc3QgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnY29tbWFuZHMnLFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBEcm9wID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Ryb3AnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGlwdGFwRHJvcCcpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURyb3A6IChfLCBlLCBzbGljZSwgbW92ZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2VkaXRhYmxlJyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2VkaXRhYmxlJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgZm9jdXNFdmVudHNQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdmb2N1c0V2ZW50cycpO1xuY29uc3QgRm9jdXNFdmVudHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZm9jdXNFdmVudHMnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvY3VzRXZlbnRzUGx1Z2luS2V5LFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdmb2N1cycsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ2FkZFRvSGlzdG9yeScsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmx1cjogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdibHVyJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgS2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2tleW1hcCcsXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSxcbiAgICAgICAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zLCBwYXJlbnQgfSA9ICRhbmNob3I7XG4gICAgICAgICAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmIHBvcyA+IDAgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3I7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SXNJc29sYXRpbmcgPSAkcGFyZW50UG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBvcyA9ICRhbmNob3IucG9zIC0gJGFuY2hvci5wYXJlbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKHBhcmVudElzSXNvbGF0aW5nICYmICRwYXJlbnRQb3MucGFyZW50LmNoaWxkQ291bnQgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50UG9zID09PSAkYW5jaG9yLnBvc1xuICAgICAgICAgICAgICAgICAgICA6IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbSA9PT0gcG9zO1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlzQXRTdGFydFxuICAgICAgICAgICAgICAgICAgICB8fCAoaXNBdFN0YXJ0ICYmICRhbmNob3IucGFyZW50LnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCcpIC8vIHByZXZlbnQgY2xlYXJOb2RlcyB3aGVuIG5vIG5vZGVzIHRvIGNsZWFyLCBvdGhlcndpc2UgaGlzdG9yeSBzdGFjayBpcyBhcHBlbmRlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgICAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgICAgICAgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICAnTW9kLUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdTaGlmdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgICAgICAgICdNb2QtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgICAgICAgJ01vZC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBjS2V5bWFwID0ge1xuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICAnQWx0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgICAgICAgJ0FsdC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgICAgICAgICdDdHJsLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tFbmQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFjS2V5bWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwY0tleW1hcDtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgICAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGVhckRvY3VtZW50JyksXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuZ2V0TWV0YSgnY29tcG9zaXRpb24nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWdub3JlVHIgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50Q2xlYXJEb2N1bWVudCcpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IGlnbm9yZVRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8gfSA9IG9sZFN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRnJvbSA9IFNlbGVjdGlvbi5hdFN0YXJ0KG9sZFN0YXRlLmRvYykuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uLmF0RW5kKG9sZFN0YXRlLmRvYykudG87XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9IGlzTm9kZUVtcHR5KG5ld1N0YXRlLmRvYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgUGFzdGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAncGFzdGUnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGlwdGFwUGFzdGUnKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXN0ZTogKF92aWV3LCBlLCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdCgncGFzdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3RhYmluZGV4JyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RhYmluZGV4JyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogKCkgPT4gKHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6IENsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICBDb21tYW5kczogQ29tbWFuZHMsXG4gIERyb3A6IERyb3AsXG4gIEVkaXRhYmxlOiBFZGl0YWJsZSxcbiAgRm9jdXNFdmVudHM6IEZvY3VzRXZlbnRzLFxuICBLZXltYXA6IEtleW1hcCxcbiAgUGFzdGU6IFBhc3RlLFxuICBUYWJpbmRleDogVGFiaW5kZXgsXG4gIGZvY3VzRXZlbnRzUGx1Z2luS2V5OiBmb2N1c0V2ZW50c1BsdWdpbktleVxufSk7XG5cbmNsYXNzIE5vZGVQb3Mge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocG9zLCBlZGl0b3IsIGlzQmxvY2sgPSBmYWxzZSwgbm9kZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0dWFsRGVwdGggPSBudWxsO1xuICAgICAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuICAgICAgICB0aGlzLnJlc29sdmVkUG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLnJlc29sdmVkUG9zLm5vZGUoKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbUF0UG9zKHRoaXMucG9zKS5ub2RlO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuYWN0dWFsRGVwdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucmVzb2x2ZWRQb3MuZGVwdGg7XG4gICAgfVxuICAgIGdldCBwb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnBvcztcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuY29udGVudDtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gdGhpcy50bztcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWW91IGNhbuKAmXQgc2V0IGNvbnRlbnQgb24gYSBibG9jayBub2RlLiBUcmllZCB0byBzZXQgY29udGVudCBvbiAke3RoaXMubmFtZX0gYXQgJHt0aGlzLnBvc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gdGhpcy5mcm9tICsgMTtcbiAgICAgICAgICAgIHRvID0gdGhpcy50byAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbSwgdG8gfSwgY29udGVudCk7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmF0dHJzO1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgIH1cbiAgICBnZXQgZnJvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpO1xuICAgIH1cbiAgICBnZXQgcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHRvKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MuZW5kKHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpICsgKHRoaXMubm9kZS5pc1RleHQgPyAwIDogMSk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGggLSAxKTtcbiAgICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUocGFyZW50UG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgZ2V0IGJlZm9yZSgpIHtcbiAgICAgICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtICh0aGlzLmlzQmxvY2sgPyAxIDogMikpO1xuICAgICAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgZ2V0IGFmdGVyKCkge1xuICAgICAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArICh0aGlzLmlzQmxvY2sgPyAyIDogMSkpO1xuICAgICAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlLmNvbnRlbnQuZm9yRWFjaCgobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZS5pc0Jsb2NrICYmICFub2RlLmlzVGV4dGJsb2NrO1xuICAgICAgICAgICAgY29uc3QgaXNOb25UZXh0QXRvbSA9IG5vZGUuaXNBdG9tICYmICFub2RlLmlzVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucG9zICsgb2Zmc2V0ICsgKGlzTm9uVGV4dEF0b20gPyAwIDogMSk7XG4gICAgICAgICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0YXJnZXRQb3MpO1xuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrICYmICRwb3MuZGVwdGggPD0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZVBvcyA9IG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVQb3MuYWN0dWFsRGVwdGggPSB0aGlzLmRlcHRoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG4gICAgY2xvc2VzdChzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhbm9kZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY3VycmVudE5vZGUubm9kZS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJLZXlzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXR0cktleXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVBdHRyaWJ1dGVzW2tleV0gIT09IGF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCB0cnVlKVswXSB8fCBudWxsO1xuICAgIH1cbiAgICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30sIGZpcnN0SXRlbU9ubHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIGFsbCBjaGlsZHJlbiByZWN1cnNpdmVseSB0aGF0IG1hdGNoIHRoZSBzZWxlY3RvciBhbmQgYXR0cmlidXRlc1xuICAgICAgICAgKiBJZiBmaXJzdEl0ZW1Pbmx5IGlzIHRydWUsIGl0IHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGRQb3MgPT4ge1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgZG9udCBuZWVkIHRvIGtlZXAgZ29pbmdcbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRQb3Mubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCA9IGF0dHJLZXlzLmV2ZXJ5KGtleSA9PiBhdHRyaWJ1dGVzW2tleV0gPT09IGNoaWxkUG9zLm5vZGUuYXR0cnNba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgY2FuIHN0b3AgaGVyZSBhbmQgc2tpcCB0aGUgcmVjdXJzaW9uXG4gICAgICAgICAgICBpZiAoZmlyc3RJdGVtT25seSAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGRQb3MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcywgZmlyc3RJdGVtT25seSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCB7IHRyIH0gPSB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0aGlzLmZyb20sIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgIH1cbn1cblxuY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDAgIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAwICFpbXBvcnRhbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBub25lO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBtYXJnaW46IDA7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3I6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IC0ycHg7XG4gIHdpZHRoOiAyMHB4O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gIGFuaW1hdGlvbjogUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIDEuMXMgc3RlcHMoMiwgc3RhcnQpIGluZmluaXRlO1xufVxuXG5Aa2V5ZnJhbWVzIFByb3NlTWlycm9yLWN1cnNvci1ibGluayB7XG4gIHRvIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICoge1xuICBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1mb2N1c2VkIC5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLnRpcHB5LWJveFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPWhpZGRlbl0ge1xuICBvcGFjaXR5OiAwXG59YDtcblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGUsIG5vbmNlLCBzdWZmaXgpIHtcbiAgICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31dYCk7XG4gICAgaWYgKHRpcHRhcFN0eWxlVGFnICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZztcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgfVxuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31gLCAnJyk7XG4gICAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcbiAgICByZXR1cm4gc3R5bGVOb2RlO1xufVxuXG5jbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVkaXRvciBpcyBjb25zaWRlcmVkIGluaXRpYWxpemVkIGFmdGVyIHRoZSBgY3JlYXRlYCBldmVudCBoYXMgYmVlbiBlbWl0dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZSA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgaW5qZWN0Q1NTOiB0cnVlLFxuICAgICAgICAgICAgaW5qZWN0Tm9uY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBmYWxzZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZWRpdG9yUHJvcHM6IHt9LFxuICAgICAgICAgICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGNvcmVFeHRlbnNpb25PcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVQYXN0ZVJ1bGVzOiB0cnVlLFxuICAgICAgICAgICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDb250ZW50Q2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblRyYW5zYWN0aW9uOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Gb2N1czogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ29udGVudEVycm9yOiAoeyBlcnJvciB9KSA9PiB7IHRocm93IGVycm9yOyB9LFxuICAgICAgICAgICAgb25QYXN0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRHJvcDogKCkgPT4gbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29tbWFuZE1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTY2hlbWEoKTtcbiAgICAgICAgdGhpcy5vbignYmVmb3JlQ3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdiZWZvcmVDcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICAgICAgdGhpcy5vbignY29udGVudEVycm9yJywgdGhpcy5vcHRpb25zLm9uQ29udGVudEVycm9yKTtcbiAgICAgICAgdGhpcy5jcmVhdGVWaWV3KCk7XG4gICAgICAgIHRoaXMuaW5qZWN0Q1NTKCk7XG4gICAgICAgIHRoaXMub24oJ2NyZWF0ZScsIHRoaXMub3B0aW9ucy5vbkNyZWF0ZSk7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIHRoaXMub3B0aW9ucy5vblVwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oJ3RyYW5zYWN0aW9uJywgdGhpcy5vcHRpb25zLm9uVHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMub3B0aW9ucy5vbkZvY3VzKTtcbiAgICAgICAgdGhpcy5vbignYmx1cicsIHRoaXMub3B0aW9ucy5vbkJsdXIpO1xuICAgICAgICB0aGlzLm9uKCdkZXN0cm95JywgdGhpcy5vcHRpb25zLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMub24oJ2Ryb3AnLCAoeyBldmVudCwgc2xpY2UsIG1vdmVkIH0pID0+IHRoaXMub3B0aW9ucy5vbkRyb3AoZXZlbnQsIHNsaWNlLCBtb3ZlZCkpO1xuICAgICAgICB0aGlzLm9uKCdwYXN0ZScsICh7IGV2ZW50LCBzbGljZSB9KSA9PiB0aGlzLm9wdGlvbnMub25QYXN0ZShldmVudCwgc2xpY2UpKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmZvY3VzKHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmRzLlxuICAgICAqL1xuICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY29tbWFuZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbW1hbmQgY2hhaW4gdG8gY2FsbCBtdWx0aXBsZSBjb21tYW5kcyBhdCBvbmNlLlxuICAgICAqL1xuICAgIGNoYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAgICovXG4gICAgY2FuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jYW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5qZWN0IENTUyBzdHlsZXMuXG4gICAgICovXG4gICAgaW5qZWN0Q1NTKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluamVjdENTUyAmJiBkb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5jc3MgPSBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgdGhpcy5vcHRpb25zLmluamVjdE5vbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZWRpdG9yIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBIGxpc3Qgb2Ygb3B0aW9uc1xuICAgICAqL1xuICAgIHNldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy52aWV3IHx8ICF0aGlzLnN0YXRlIHx8IHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2V0UHJvcHModGhpcy5vcHRpb25zLmVkaXRvclByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlZGl0YWJsZSBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIHNldEVkaXRhYmxlKGVkaXRhYmxlLCBlbWl0VXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoeyBlZGl0YWJsZSB9KTtcbiAgICAgICAgaWYgKGVtaXRVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgICAqL1xuICAgIGdldCBpc0VkaXRhYmxlKCkge1xuICAgICAgICAvLyBzaW5jZSBwbHVnaW5zIGFyZSBhcHBsaWVkIGFmdGVyIGNyZWF0aW5nIHRoZSB2aWV3XG4gICAgICAgIC8vIGBlZGl0YWJsZWAgaXMgYWx3YXlzIGB0cnVlYCBmb3Igb25lIHRpY2suXG4gICAgICAgIC8vIHRoYXTigJlzIHdoeSB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgZm9yIGBvcHRpb25zLmVkaXRhYmxlYFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVkaXRhYmxlICYmIHRoaXMudmlldyAmJiB0aGlzLnZpZXcuZWRpdGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBsdWdpbiBBIFByb3NlTWlycm9yIHBsdWdpblxuICAgICAqIEBwYXJhbSBoYW5kbGVQbHVnaW5zIENvbnRyb2wgaG93IHRvIG1lcmdlIHRoZSBwbHVnaW4gaW50byB0aGUgZXhpc3RpbmcgcGx1Z2lucy5cbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGVkaXRvciBzdGF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbiwgaGFuZGxlUGx1Z2lucykge1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKVxuICAgICAgICAgICAgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pXG4gICAgICAgICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl07XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSk7XG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSBUaGUgcGx1Z2lucyBuYW1lXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGUgb3IgdW5kZWZpbmVkIGlmIHRoZSBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAgICovXG4gICAgdW5yZWdpc3RlclBsdWdpbihuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2UGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgbGV0IHBsdWdpbnMgPSBwcmV2UGx1Z2lucztcbiAgICAgICAgW10uY29uY2F0KG5hbWVPclBsdWdpbktleVRvUmVtb3ZlKS5mb3JFYWNoKG5hbWVPclBsdWdpbktleSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPclBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBgJHtuYW1lT3JQbHVnaW5LZXl9JGAgOiBuYW1lT3JQbHVnaW5LZXkua2V5O1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcGx1Z2lucyA9IHByZXZQbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldlBsdWdpbnMubGVuZ3RoID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gTm8gcGx1Z2luIHdhcyByZW1vdmVkLCBzbyB3ZSBkb27igJl0IG5lZWQgdG8gdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBleHRlbnNpb24gbWFuYWdlci5cbiAgICAgKi9cbiAgICBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjb3JlRXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA/IFtcbiAgICAgICAgICAgIEVkaXRhYmxlLFxuICAgICAgICAgICAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICBibG9ja1NlcGFyYXRvcjogKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ibG9ja1NlcGFyYXRvcixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgQ29tbWFuZHMsXG4gICAgICAgICAgICBGb2N1c0V2ZW50cyxcbiAgICAgICAgICAgIEtleW1hcCxcbiAgICAgICAgICAgIFRhYmluZGV4LFxuICAgICAgICAgICAgRHJvcCxcbiAgICAgICAgICAgIFBhc3RlLFxuICAgICAgICBdLmZpbHRlcihleHQgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9uc1tleHQubmFtZV0gIT09IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pIDogW107XG4gICAgICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbJ2V4dGVuc2lvbicsICdub2RlJywgJ21hcmsnXS5pbmNsdWRlcyhleHRlbnNpb24gPT09IG51bGwgfHwgZXh0ZW5zaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnNpb24udHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAgICovXG4gICAgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICAgKi9cbiAgICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAgICovXG4gICAgY3JlYXRlVmlldygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZG9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zLCB7IGVycm9yT25JbnZhbGlkQ29udGVudDogdGhpcy5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yKSB8fCAhWydbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnQnLCAnW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50J10uaW5jbHVkZXMoZS5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCB0aGUgY29udGVudCBlcnJvciB3ZSB3ZXJlIGV4cGVjdGluZ1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvbnRlbnRFcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5jb2xsYWJvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbi5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBzeW5jaW5nIGJhY2sgaW52YWxpZCBjb250ZW50LCByZWluaXRpYWxpemUgdGhlIGV4dGVuc2lvbnMgd2l0aG91dCB0aGUgY29sbGFib3JhdGlvbiBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lICE9PSAnY29sbGFib3JhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzIGJ5IHJlY3JlYXRpbmcgdGhlIGV4dGVuc2lvbiBtYW5hZ2VyIHdpdGggdGhlIG5ldyBzZXQgb2YgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb250ZW50IGlzIGludmFsaWQsIGJ1dCBhdHRlbXB0IHRvIGNyZWF0ZSBpdCBhbnl3YXksIHN0cmlwcGluZyBvdXQgdGhlIGludmFsaWQgcGFydHNcbiAgICAgICAgICAgIGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucywgeyBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBFZGl0b3JWaWV3KHRoaXMub3B0aW9ucy5lbGVtZW50LCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGByb2xlPVwidGV4dGJveFwiYCB0byB0aGUgZWRpdG9yIGVsZW1lbnRcbiAgICAgICAgICAgICAgICByb2xlOiAndGV4dGJveCcsXG4gICAgICAgICAgICAgICAgLi4uKF9hID0gdGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGBlZGl0b3Iudmlld2AgaXMgbm90IHlldCBhdmFpbGFibGUgYXQgdGhpcyB0aW1lLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2Ugd2lsbCBhZGQgYWxsIHBsdWdpbnMgYW5kIG5vZGUgdmlld3MgZGlyZWN0bHkgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICAgICAgdGhpcy5wcmVwZW5kQ2xhc3MoKTtcbiAgICAgICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cbiAgICAgICAgLy8gU28gd2XigJlsbCBoYXZlIGFjY2VzcyB0byBpdCBmb3IgdGVzdHMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgZG9tLmVkaXRvciA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYWxsIG5vZGUgdmlld3MuXG4gICAgICovXG4gICAgY3JlYXRlTm9kZVZpZXdzKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgICAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3cyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBlbmQgY2xhc3MgbmFtZSB0byBlbGVtZW50LlxuICAgICAqL1xuICAgIHByZXBlbmRDbGFzcygpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YDtcbiAgICB9XG4gICAgY2FwdHVyZVRyYW5zYWN0aW9uKGZuKSB7XG4gICAgICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgb3ZlciB3aGljaCB0byBzZW5kIHRyYW5zYWN0aW9ucyAoc3RhdGUgdXBkYXRlcykgcHJvZHVjZWQgYnkgdGhlIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgZGlzcGF0Y2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIC8gdGhlIHZpZXcgb2YgdGhlIGVkaXRvciB3YXMgZGVzdHJveWVkXG4gICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgbm90IGJlIGRpc3BhdGNoZWQgYXMgdGhlcmUgaXMgbm8gdmlldyBhbnltb3JlLlxuICAgICAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGVwKHN0ZXApOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuYXBwbHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlVHJhbnNhY3Rpb24nLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIG5leHRTdGF0ZTogc3RhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uJywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzZWxlY3Rpb25VcGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpO1xuICAgICAgICBjb25zdCBibHVyID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYmx1cicpO1xuICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZm9jdXMnLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBmb2N1cy5ldmVudCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibHVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2JsdXInLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRVcGRhdGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXR0cmlidXRlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyay5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKG5hbWVPclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHJpYnV0ZXModGhpcy5zdGF0ZSwgbmFtZU9yVHlwZSk7XG4gICAgfVxuICAgIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gbmFtZU9yQXR0cmlidXRlcyA6IG51bGw7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBhdHRyaWJ1dGVzT3JVbmRlZmluZWQgOiBuYW1lT3JBdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gaXNBY3RpdmUodGhpcy5zdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICAgKi9cbiAgICBnZXRKU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cbiAgICAgKi9cbiAgICBnZXRIVE1MKCkge1xuICAgICAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICAgKi9cbiAgICBnZXRUZXh0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgICAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQuXG4gICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBpc05vZGVFbXB0eSh0aGlzLnN0YXRlLmRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXRDaGFyYWN0ZXJDb3VudCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgb3VyIHJlZmVyZW5jZSB0byBwcmV2ZW50IGNpcmN1bGFyIHJlZmVyZW5jZXMgd2hpY2ggY2F1c2VkIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIGlmIChkb20gJiYgZG9tLmVkaXRvcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkb20uZWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiAhKChfYSA9IHRoaXMudmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvY1ZpZXcpO1xuICAgIH1cbiAgICAkbm9kZShzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcihzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gICAgfVxuICAgICRub2RlcyhzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gICAgfVxuICAgICRwb3MocG9zKSB7XG4gICAgICAgIGNvbnN0ICRwb3MgPSB0aGlzLnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0ICRkb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwb3MoMCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNpbnB1dC1ydWxlc1xuICovXG5mdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRTdGFydCA+IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSk7XG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGFkZHMgYSBub2RlIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgbGFzdCB0eXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhciA9IG1hdGNoWzBdW21hdGNoWzBdLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHRyLmluc2VydFRleHQobGFzdENoYXIsIHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IG5vZGUgZnJvbSBpbnB1dCBydWxlXG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uU3RhcnQgPSBjb25maWcudHlwZS5pc0lubGluZSA/IHN0YXJ0IDogc3RhcnQgLSAxO1xuICAgICAgICAgICAgICAgIHRyLmluc2VydChpbnNlcnRpb25TdGFydCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKS5kZWxldGUodHIubWFwcGluZy5tYXAoc3RhcnQpLCB0ci5tYXBwaW5nLm1hcChlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGNoYW5nZXMgdGhlIHR5cGUgb2YgYSB0ZXh0YmxvY2sgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZnVuY3Rpb24gdGV4dGJsb2NrVHlwZUlucHV0UnVsZShjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge307XG4gICAgICAgICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIC5zZXRCbG9ja1R5cGUocmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIHRleHRJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgICAgICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgYSB0ZXh0YmxvY2sgd2hlbiBhXG4gKiBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxuICogcHJvYmFibHkgd2FudCB0aGUgcmVnZXhwIHRvIHN0YXJ0IHdpdGggYF5gLCBzbyB0aGF0IHRoZSBwYXR0ZXJuIGNhblxuICogb25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gKlxuICogYHR5cGVgIGlzIHRoZSB0eXBlIG9mIG5vZGUgdG8gd3JhcCBpbi5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpZiB0aGVyZeKAmXMgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcbiAqIHdyYXBwZWQgbm9kZSwgdGhlIHJ1bGUgd2lsbCB0cnkgdG8gam9pbiB0aG9zZVxuICogdHdvIG5vZGVzLiBZb3UgY2FuIHBhc3MgYSBqb2luIHByZWRpY2F0ZSwgd2hpY2ggdGFrZXMgYSByZWd1bGFyXG4gKiBleHByZXNzaW9uIG1hdGNoIGFuZCB0aGUgbm9kZSBiZWZvcmUgdGhlIHdyYXBwZWQgbm9kZSwgYW5kIGNhblxuICogcmV0dXJuIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgam9pbiBzaG91bGQgaGFwcGVuLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZnVuY3Rpb24gd3JhcHBpbmdJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgY2hhaW4sIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIud3JhcChibG9ja1JhbmdlLCB3cmFwcGluZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gY29uZmlnLnR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCcgPyAnbGlzdEl0ZW0nIDogJ3Rhc2tMaXN0JztcbiAgICAgICAgICAgICAgICBjaGFpbigpLnVwZGF0ZUF0dHJpYnV0ZXMobm9kZVR5cGUsIGF0dHJpYnV0ZXMpLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlXG4gICAgICAgICAgICAgICAgJiYgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlXG4gICAgICAgICAgICAgICAgJiYgY2FuSm9pbih0ci5kb2MsIHJhbmdlLmZyb20gLSAxKVxuICAgICAgICAgICAgICAgICYmICghY29uZmlnLmpvaW5QcmVkaWNhdGUgfHwgY29uZmlnLmpvaW5QcmVkaWNhdGUobWF0Y2gsIGJlZm9yZSkpKSB7XG4gICAgICAgICAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhlIE5vZGUgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgY3VzdG9tIG5vZGUgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pKSB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUoY29uZmlnKTtcbiAgICB9XG4gICAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoe1xuICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgICAgICBhZGRPcHRpb25zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSB0aGUgY3VycmVudCBuYW1lXG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCB0byBiZSBvdXIgcGFyZW50XG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG4gICAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE5vZGUoZXh0ZW5kZWRDb25maWcpO1xuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICB9KSk7XG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxufVxuXG4vKipcbiAqIE5vZGUgdmlld3MgYXJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSByZW5kZXJlZCBET00gc3RydWN0dXJlIG9mIGEgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL25vZGUtdmlld3NcbiAqL1xuY2xhc3MgTm9kZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgc3RvcEV2ZW50OiBudWxsLFxuICAgICAgICAgICAgaWdub3JlTXV0YXRpb246IG51bGwsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IHByb3BzLmV4dGVuc2lvbjtcbiAgICAgICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBwcm9wcy5pbm5lckRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLnZpZXcgPSBwcm9wcy52aWV3O1xuICAgICAgICB0aGlzLkhUTUxBdHRyaWJ1dGVzID0gcHJvcHMuSFRNTEF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zO1xuICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnZXQgZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3Iudmlldy5kb207XG4gICAgfVxuICAgIGdldCBjb250ZW50RE9NKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIC8vIGdldCB0aGUgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgICAgICAvLyBgY2xvc2VzdGAgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGV4dCBub2RlcyBzbyB3ZSBtYXkgaGF2ZSB0byB1c2UgaXRzIHBhcmVudFxuICAgICAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0Lm5vZGVUeXBlID09PSAzXG4gICAgICAgICAgICA/IChfYSA9IHRhcmdldC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgICAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpO1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICgoX2IgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250YWlucyh0YXJnZXQpKSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9PSBkcmFnSGFuZGxlKSB7XG4gICAgICAgICAgICBjb25zdCBkb21Cb3ggPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBJbiBSZWFjdCwgd2UgaGF2ZSB0byBnbyB0aHJvdWdoIG5hdGl2ZUV2ZW50IHRvIHJlYWNoIG9mZnNldFgvb2Zmc2V0WS5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSAoX2MgPSBldmVudC5vZmZzZXRYKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSBldmVudC5uYXRpdmVFdmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm9mZnNldFg7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gKF9lID0gZXZlbnQub2Zmc2V0WSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5vZmZzZXRZO1xuICAgICAgICAgICAgeCA9IGhhbmRsZUJveC54IC0gZG9tQm94LnggKyBvZmZzZXRYO1xuICAgICAgICAgICAgeSA9IGhhbmRsZUJveC55IC0gZG9tQm94LnkgKyBvZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIChfZyA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnNldERyYWdJbWFnZShjbG9uZWROb2RlLCB4LCB5KTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byB0ZWxsIFByb3NlTWlycm9yIHRoYXQgd2Ugd2FudCB0byBtb3ZlIHRoZSB3aG9sZSBub2RlXG4gICAgICAgIC8vIHNvIHdlIGNyZWF0ZSBhIE5vZGVTZWxlY3Rpb25cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHBvcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50KHsgZXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCBpc0luRWxlbWVudCA9IHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkgJiYgISgoX2EgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgICAgLy8gYW55IGV2ZW50IGZyb20gY2hpbGQgbm9kZXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgUHJvc2VNaXJyb3JcbiAgICAgICAgaWYgKCFpc0luRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRHJhZ0V2ZW50ID0gZXZlbnQudHlwZS5zdGFydHNXaXRoKCdkcmFnJyk7XG4gICAgICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnO1xuICAgICAgICBjb25zdCBpc0lucHV0ID0gWydJTlBVVCcsICdCVVRUT04nLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ10uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgLy8gYW55IGlucHV0IGV2ZW50IHdpdGhpbiBub2RlIHZpZXdzIHNob3VsZCBiZSBpZ25vcmVkIGJ5IFByb3NlTWlycm9yXG4gICAgICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgaXNEcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xuICAgICAgICBjb25zdCBpc0NvcHlFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjb3B5JztcbiAgICAgICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ3Bhc3RlJztcbiAgICAgICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnO1xuICAgICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBldmVudC50eXBlID09PSAnbW91c2Vkb3duJztcbiAgICAgICAgLy8gUHJvc2VNaXJyb3IgdHJpZXMgdG8gZHJhZyBzZWxlY3RhYmxlIG5vZGVzXG4gICAgICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcbiAgICAgICAgLy8gdGhpcyBmaXggcHJldmVudHMgdGhhdFxuICAgICAgICBpZiAoIWlzRHJhZ2dhYmxlICYmIGlzU2VsZWN0YWJsZSAmJiBpc0RyYWdFdmVudCAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0RyYWdFdmVudCAmJiAhaXNEcmFnZ2luZyAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gc3RvcmUgdGhhdCBkcmFnZ2luZyBzdGFydGVkXG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0VkaXRhYmxlICYmICFpc0RyYWdnaW5nICYmIGlzQ2xpY2tFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWREcmFnSGFuZGxlID0gZHJhZ0hhbmRsZSAmJiAodGhpcy5kb20gPT09IGRyYWdIYW5kbGUgfHwgdGhpcy5kb20uY29udGFpbnMoZHJhZ0hhbmRsZSkpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREcmFnSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBldmVudHMgYXJlIGhhbmRsZWQgYnkgcHJvc2VtaXJyb3JcbiAgICAgICAgaWYgKGlzRHJhZ2dpbmdcbiAgICAgICAgICAgIHx8IGlzRHJvcEV2ZW50XG4gICAgICAgICAgICB8fCBpc0NvcHlFdmVudFxuICAgICAgICAgICAgfHwgaXNQYXN0ZUV2ZW50XG4gICAgICAgICAgICB8fCBpc0N1dEV2ZW50XG4gICAgICAgICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBET00gW211dGF0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25PYnNlcnZlcikgb3IgYSBzZWxlY3Rpb24gY2hhbmdlIGhhcHBlbnMgd2l0aGluIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm4gYGZhbHNlYCBpZiB0aGUgZWRpdG9yIHNob3VsZCByZS1yZWFkIHRoZSBzZWxlY3Rpb24gb3IgcmUtcGFyc2UgdGhlIHJhbmdlIGFyb3VuZCB0aGUgbXV0YXRpb25cbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiBpdCBjYW4gc2FmZWx5IGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgbGVhZi9hdG9tIG5vZGUgaXMgbGlrZSBhIGJsYWNrIGJveCBmb3IgUHJvc2VNaXJyb3JcbiAgICAgICAgLy8gYW5kIHNob3VsZCBiZSBmdWxseSBoYW5kbGVkIGJ5IHRoZSBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc0xlYWYgfHwgdGhpcy5ub2RlLmlzQXRvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgc2VsZWN0aW9uc1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcbiAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIFByb3NlTWlycm9yIGNhbuKAmXQgcHJldmVudERpc3BhdGNoIG9uIGVudGVyXG4gICAgICAgIC8vIHRoaXMgd2lsbCBsZWFkIHRvIGEgcmUtcmVuZGVyIG9mIHRoZSBub2RlIHZpZXcgb24gZW50ZXJcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI1MzRcbiAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldClcbiAgICAgICAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXG4gICAgICAgICAgICAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSlcbiAgICAgICAgICAgICYmIHRoaXMuZWRpdG9yLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xuICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIHdl4oCZbGwgY2hlY2sgaWYgZXZlcnkgY2hhbmdlZCBub2RlIGlzIGNvbnRlbnRFZGl0YWJsZVxuICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGl04oCZcyBwcm9iYWJseSBtdXRhdGVkIGJ5IFByb3NlTWlycm9yXG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2lsbCBhbGxvdyBtdXRhdGlvbiBjb250ZW50RE9NIHdpdGggYXR0cmlidXRlc1xuICAgICAgICAvLyBzbyB3ZSBjYW4gZm9yIGV4YW1wbGUgYWRkaW5nIGNsYXNzZXMgd2l0aGluIG91ciBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgY2hhbmdlcyB3aXRoaW4gY29udGVudERPTVxuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBwcm9zZW1pcnJvciBub2RlLlxuICAgICAqL1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGRlbGV0ZU5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmdldFBvcygpO1xuICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb20sIHRvIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgcGFzdGVFdmVudCwgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50bztcbiAgICAgICAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2XG5mdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQsIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNhbGxPclJldHVybihjb25maWcuZ2V0Q29udGVudCwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0geyB0eXBlOiBjb25maWcudHlwZS5uYW1lLCBhdHRyczogYXR0cmlidXRlcyB9O1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgY2hhaW4oKS5kZWxldGVSYW5nZShyYW5nZSkuaW5zZXJ0Q29udGVudEF0KHJhbmdlLmZyb20sIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNwYXN0ZS1ydWxlc1xuICovXG5mdW5jdGlvbiB0ZXh0UGFzdGVSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuY2xhc3MgVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGg7XG4gICAgfVxuICAgIG1hcChwb3NpdGlvbikge1xuICAgICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHNcbiAgICAgICAgICAgIC5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKVxuICAgICAgICAgICAgLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcFJlc3VsdCA9IHN0ZXAuZ2V0TWFwKCkubWFwUmVzdWx0KG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChtYXBSZXN1bHQuZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3M7XG4gICAgICAgIH0sIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcbiAgICAgICAgICAgIGRlbGV0ZWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21tYW5kTWFuYWdlciwgRWRpdG9yLCBFeHRlbnNpb24sIElucHV0UnVsZSwgTWFyaywgTm9kZSwgTm9kZVBvcywgTm9kZVZpZXcsIFBhc3RlUnVsZSwgVHJhY2tlciwgY2FsbE9yUmV0dXJuLCBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcywgY3JlYXRlQ2hhaW5hYmxlU3RhdGUsIGNyZWF0ZURvY3VtZW50LCBjcmVhdGVOb2RlRnJvbUNvbnRlbnQsIGNyZWF0ZVN0eWxlVGFnLCBkZWZhdWx0QmxvY2tBdCwgZGVsZXRlUHJvcHMsIGVsZW1lbnRGcm9tU3RyaW5nLCBlc2NhcGVGb3JSZWdFeCwgaW5kZXggYXMgZXh0ZW5zaW9ucywgZmluZENoaWxkcmVuLCBmaW5kQ2hpbGRyZW5JblJhbmdlLCBmaW5kRHVwbGljYXRlcywgZmluZFBhcmVudE5vZGUsIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLCBmcm9tU3RyaW5nLCBnZW5lcmF0ZUhUTUwsIGdlbmVyYXRlSlNPTiwgZ2VuZXJhdGVUZXh0LCBnZXRBdHRyaWJ1dGVzLCBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMsIGdldENoYW5nZWRSYW5nZXMsIGdldERlYnVnSlNPTiwgZ2V0RXh0ZW5zaW9uRmllbGQsIGdldEhUTUxGcm9tRnJhZ21lbnQsIGdldE1hcmtBdHRyaWJ1dGVzLCBnZXRNYXJrUmFuZ2UsIGdldE1hcmtUeXBlLCBnZXRNYXJrc0JldHdlZW4sIGdldE5vZGVBdFBvc2l0aW9uLCBnZXROb2RlQXR0cmlidXRlcywgZ2V0Tm9kZVR5cGUsIGdldFJlbmRlcmVkQXR0cmlidXRlcywgZ2V0U2NoZW1hLCBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucywgZ2V0U2NoZW1hVHlwZUJ5TmFtZSwgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUsIGdldFNwbGl0dGVkQXR0cmlidXRlcywgZ2V0VGV4dCwgZ2V0VGV4dEJldHdlZW4sIGdldFRleHRDb250ZW50RnJvbU5vZGVzLCBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLCBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUsIGlucHV0UnVsZXNQbHVnaW4sIGlzQWN0aXZlLCBpc0F0RW5kT2ZOb2RlLCBpc0F0U3RhcnRPZk5vZGUsIGlzRW1wdHlPYmplY3QsIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLCBpc0Z1bmN0aW9uLCBpc0xpc3QsIGlzTWFjT1MsIGlzTWFya0FjdGl2ZSwgaXNOb2RlQWN0aXZlLCBpc05vZGVFbXB0eSwgaXNOb2RlU2VsZWN0aW9uLCBpc051bWJlciwgaXNQbGFpbk9iamVjdCwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1RleHRTZWxlY3Rpb24sIGlzaU9TLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMsIG1lcmdlRGVlcCwgbWluTWF4LCBub2RlSW5wdXRSdWxlLCBub2RlUGFzdGVSdWxlLCBvYmplY3RJbmNsdWRlcywgcGFzdGVSdWxlc1BsdWdpbiwgcG9zVG9ET01SZWN0LCByZW1vdmVEdXBsaWNhdGVzLCByZXNvbHZlRm9jdXNQb3NpdGlvbiwgcmV3cml0ZVVua25vd25Db250ZW50LCBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCwgc3BsaXRFeHRlbnNpb25zLCB0ZXh0SW5wdXRSdWxlLCB0ZXh0UGFzdGVSdWxlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCB3cmFwcGluZ0lucHV0UnVsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ Bold),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Matches bold text via `**` as input.\n */\nconst starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\n/**\n * Matches bold text via `**` while pasting.\n */\nconst starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\n/**\n * Matches bold text via `__` as input.\n */\nconst underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\n/**\n * Matches bold text via `__` while pasting.\n */\nconst underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nconst Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'bold',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'strong',\n            },\n            {\n                tag: 'b',\n                getAttrs: node => node.style.fontWeight !== 'normal' && null,\n            },\n            {\n                style: 'font-weight=400',\n                clearMark: mark => mark.type.name === this.name,\n            },\n            {\n                style: 'font-weight',\n                getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null,\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['strong', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setBold: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleBold: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetBold: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-b': () => this.editor.commands.toggleBold(),\n            'Mod-B': () => this.editor.commands.toggleBold(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ib2xkL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdEQUF3RCxHQUFHO0FBQzNELGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLDBCQUEwQiw2REFBZTtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFNEc7QUFDN0ciLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxleHRlbnNpb24tYm9sZFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYCoqYCBhcyBpbnB1dC5cbiAqL1xuY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkkLztcbi8qKlxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGAqKmAgd2hpbGUgcGFzdGluZy5cbiAqL1xuY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkvZztcbi8qKlxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGBfX2AgYXMgaW5wdXQuXG4gKi9cbmNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfXyg/IVxccytfXykoKD86W15fXSspKV9fKD8hXFxzK19fKSkkLztcbi8qKlxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGBfX2Agd2hpbGUgcGFzdGluZy5cbiAqL1xuY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKS9nO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIG1hcmsgdGV4dCBhcyBib2xkLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL21hcmtzL2JvbGRcbiAqL1xuY29uc3QgQm9sZCA9IE1hcmsuY3JlYXRlKHtcbiAgICBuYW1lOiAnYm9sZCcsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdzdHJvbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdiJyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogbm9kZSA9PiBub2RlLnN0eWxlLmZvbnRXZWlnaHQgIT09ICdub3JtYWwnICYmIG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC13ZWlnaHQ9NDAwJyxcbiAgICAgICAgICAgICAgICBjbGVhck1hcms6IG1hcmsgPT4gbWFyay50eXBlLm5hbWUgPT09IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICdmb250LXdlaWdodCcsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IHZhbHVlID0+IC9eKGJvbGQoZXIpP3xbNS05XVxcZHsyLH0pJC8udGVzdCh2YWx1ZSkgJiYgbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydzdHJvbmcnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgICAgICAgICAnTW9kLUInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQm9sZCwgQm9sZCBhcyBkZWZhdWx0LCBzdGFySW5wdXRSZWdleCwgc3RhclBhc3RlUmVnZXgsIHVuZGVyc2NvcmVJbnB1dFJlZ2V4LCB1bmRlcnNjb3JlUGFzdGVSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-bold/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bubble-menu/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   BubbleMenuPlugin: () => (/* binding */ BubbleMenuPlugin),\n/* harmony export */   BubbleMenuView: () => (/* binding */ BubbleMenuView),\n/* harmony export */   \"default\": () => (/* binding */ BubbleMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(app-pages-browser)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\n\nclass BubbleMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow, }) {\n        this.preventHide = false;\n        this.shouldShow = ({ view, state, from, to, }) => {\n            const { doc, selection } = state;\n            const { empty } = selection;\n            // Sometime check for `empty` is not enough.\n            // Doubleclick an empty paragraph returns a node size of 2.\n            // So we check also for an empty text size.\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isTextSelection)(state.selection);\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\n            // is called and the bubble menu item is focussed. In this case we should\n            // consider the menu as part of the editor and keep showing the menu\n            const isChildOfMenu = this.element.contains(document.activeElement);\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = () => {\n            this.preventHide = true;\n        };\n        this.dragstartHandler = () => {\n            this.hide();\n        };\n        this.focusHandler = () => {\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(() => this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event }) => {\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event) => {\n            this.blurHandler({ event });\n        };\n        this.handleDebouncedUpdate = (view, oldState) => {\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n            if (!selectionChanged && !docChanged) {\n                return;\n            }\n            if (this.updateDebounceTimer) {\n                clearTimeout(this.updateDebounceTimer);\n            }\n            this.updateDebounceTimer = window.setTimeout(() => {\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\n            }, this.updateDelay);\n        };\n        this.updateHandler = (view, selectionChanged, docChanged, oldState) => {\n            var _a, _b, _c;\n            const { state, composing } = view;\n            const { selection } = state;\n            const isSame = !selectionChanged && !docChanged;\n            if (composing || isSame) {\n                return;\n            }\n            this.createTooltip();\n            // support for CellSelections\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map(range => range.$from.pos));\n            const to = Math.max(...ranges.map(range => range.$to.pos));\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n                editor: this.editor,\n                element: this.element,\n                view,\n                state,\n                oldState,\n                from,\n                to,\n            });\n            if (!shouldShow) {\n                this.hide();\n                return;\n            }\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect)\n                    || (() => {\n                        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection)) {\n                            let node = view.nodeDOM(from);\n                            if (node) {\n                                const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]');\n                                if (nodeViewWrapper) {\n                                    node = nodeViewWrapper.firstChild;\n                                }\n                                if (node) {\n                                    return node.getBoundingClientRect();\n                                }\n                            }\n                        }\n                        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to);\n                    }),\n            });\n            this.show();\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        this.updateDelay = updateDelay;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n        this.editor.on('focus', this.focusHandler);\n        this.editor.on('blur', this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = 'visible';\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: 'manual',\n            placement: 'top',\n            hideOnClick: 'toggle',\n            ...this.tippyOptions,\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        const { state } = view;\n        const hasValidSelection = state.selection.from !== state.selection.to;\n        if (this.updateDelay > 0 && hasValidSelection) {\n            this.handleDebouncedUpdate(view, oldState);\n            return;\n        }\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n        this.editor.off('focus', this.focusHandler);\n        this.editor.off('blur', this.blurHandler);\n    }\n}\nconst BubbleMenuPlugin = (options) => {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === 'string' ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: view => new BubbleMenuView({ view, ...options }),\n    });\n};\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nconst BubbleMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'bubbleMenu',\n    addOptions() {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: 'bubbleMenu',\n            updateDelay: undefined,\n            shouldShow: null,\n        };\n    },\n    addProseMirrorPlugins() {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            BubbleMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                updateDelay: this.options.updateDelay,\n                shouldShow: this.options.shouldShow,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBeUY7QUFDcEM7QUFDeEI7O0FBRTdCO0FBQ0Esa0JBQWtCLHdDQUF3QyxrQ0FBa0M7QUFDNUY7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JELG9CQUFvQixpQkFBaUI7QUFDckMsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDZEQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwREFBWTtBQUMzQyxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvREFBTTtBQUNyQix5REFBeUQsdURBQVM7QUFDbEUsMkNBQTJDLGtCQUFrQjtBQUM3RCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRThFO0FBQy9FIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxcZXh0ZW5zaW9uLWJ1YmJsZS1tZW51XFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24sIGlzTm9kZVNlbGVjdGlvbiwgcG9zVG9ET01SZWN0LCBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB0aXBweSBmcm9tICd0aXBweS5qcyc7XG5cbmNsYXNzIEJ1YmJsZU1lbnVWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVkaXRvciwgZWxlbWVudCwgdmlldywgdGlwcHlPcHRpb25zID0ge30sIHVwZGF0ZURlbGF5ID0gMjUwLCBzaG91bGRTaG93LCB9KSB7XG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gKHsgdmlldywgc3RhdGUsIGZyb20sIHRvLCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lIGNoZWNrIGZvciBgZW1wdHlgIGlzIG5vdCBlbm91Z2guXG4gICAgICAgICAgICAvLyBEb3VibGVjbGljayBhbiBlbXB0eSBwYXJhZ3JhcGggcmV0dXJucyBhIG5vZGUgc2l6ZSBvZiAyLlxuICAgICAgICAgICAgLy8gU28gd2UgY2hlY2sgYWxzbyBmb3IgYW4gZW1wdHkgdGV4dCBzaXplLlxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9ICFkb2MudGV4dEJldHdlZW4oZnJvbSwgdG8pLmxlbmd0aCAmJiBpc1RleHRTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb24gYSBlbGVtZW50IGluc2lkZSB0aGUgYnViYmxlIG1lbnUgdGhlIGVkaXRvciBcImJsdXJcIiBldmVudFxuICAgICAgICAgICAgLy8gaXMgY2FsbGVkIGFuZCB0aGUgYnViYmxlIG1lbnUgaXRlbSBpcyBmb2N1c3NlZC4gSW4gdGhpcyBjYXNlIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG1lbnUgYXMgcGFydCBvZiB0aGUgZWRpdG9yIGFuZCBrZWVwIHNob3dpbmcgdGhlIG1lbnVcbiAgICAgICAgICAgIGNvbnN0IGlzQ2hpbGRPZk1lbnUgPSB0aGlzLmVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBoYXNFZGl0b3JGb2N1cyA9IHZpZXcuaGFzRm9jdXMoKSB8fCBpc0NoaWxkT2ZNZW51O1xuICAgICAgICAgICAgaWYgKCFoYXNFZGl0b3JGb2N1cyB8fCBlbXB0eSB8fCBpc0VtcHR5VGV4dEJsb2NrIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudEhpZGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyYWdzdGFydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mb2N1c0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgYHNldFRpbWVvdXRgIHRvIG1ha2Ugc3VyZSBgc2VsZWN0aW9uYCBpcyBhbHJlYWR5IHVwZGF0ZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGUodGhpcy5lZGl0b3IudmlldykpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJsdXJIYW5kbGVyID0gKHsgZXZlbnQgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldmVudEhpZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgKChfYSA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQucmVsYXRlZFRhcmdldCkgPT09IHRoaXMuZWRpdG9yLnZpZXcuZG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGlwcHlCbHVySGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibHVySGFuZGxlcih7IGV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSA9ICh2aWV3LCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpO1xuICAgICAgICAgICAgY29uc3QgZG9jQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLmRvYy5lcSh2aWV3LnN0YXRlLmRvYykpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSk7XG4gICAgICAgICAgICB9LCB0aGlzLnVwZGF0ZURlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVyID0gKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIGNvbXBvc2luZyB9ID0gdmlldztcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2FtZSA9ICFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2luZyB8fCBpc1NhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIENlbGxTZWxlY3Rpb25zXG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSk7XG4gICAgICAgICAgICBjb25zdCB0byA9IE1hdGgubWF4KC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJHRvLnBvcykpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2hvdyA9IChfYSA9IHRoaXMuc2hvdWxkU2hvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTaG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKF9jID0gdGhpcy50aXBweU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0KVxuICAgICAgICAgICAgICAgICAgICB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aWV3Lm5vZGVET00oZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZpZXdXcmFwcGVyID0gbm9kZS5kYXRhc2V0Lm5vZGVWaWV3V3JhcHBlciA/IG5vZGUgOiBub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5vZGUtdmlldy13cmFwcGVyXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVZpZXdXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVZpZXdXcmFwcGVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudXBkYXRlRGVsYXkgPSB1cGRhdGVEZWxheTtcbiAgICAgICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3c7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnM7XG4gICAgICAgIC8vIERldGFjaGVzIG1lbnUgY29udGVudCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudFxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVkaXRvcklzQXR0YWNoZWQgPSAhIWVkaXRvckVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMudGlwcHkgfHwgIWVkaXRvcklzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpcHB5ID0gdGlwcHkoZWRpdG9yRWxlbWVudCwge1xuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICAgICAgICBoaWRlT25DbGljazogJ3RvZ2dsZScsXG4gICAgICAgICAgICAuLi50aGlzLnRpcHB5T3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG1heWJlIHdlIGhhdmUgdG8gaGlkZSB0aXBweSBvbiBpdHMgb3duIGJsdXIgZXZlbnQgYXMgd2VsbFxuICAgICAgICBpZiAodGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy50aXBweUJsdXJIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodmlldywgb2xkU3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAgICAgY29uc3QgaGFzVmFsaWRTZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24uZnJvbSAhPT0gc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVEZWxheSA+IDAgJiYgaGFzVmFsaWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVib3VuY2VkVXBkYXRlKHZpZXcsIG9sZFN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIShvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvdygpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgIH1cbn1cbmNvbnN0IEJ1YmJsZU1lbnVQbHVnaW4gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgdmlldzogdmlldyA9PiBuZXcgQnViYmxlTWVudVZpZXcoeyB2aWV3LCAuLi5vcHRpb25zIH0pLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhIGJ1YmJsZSBtZW51LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvYnViYmxlLW1lbnVcbiAqL1xuY29uc3QgQnViYmxlTWVudSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdidWJibGVNZW51JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIHRpcHB5T3B0aW9uczoge30sXG4gICAgICAgICAgICBwbHVnaW5LZXk6ICdidWJibGVNZW51JyxcbiAgICAgICAgICAgIHVwZGF0ZURlbGF5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaG91bGRTaG93OiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEJ1YmJsZU1lbnVQbHVnaW4oe1xuICAgICAgICAgICAgICAgIHBsdWdpbktleTogdGhpcy5vcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy5vcHRpb25zLnRpcHB5T3B0aW9ucyxcbiAgICAgICAgICAgICAgICB1cGRhdGVEZWxheTogdGhpcy5vcHRpb25zLnVwZGF0ZURlbGF5LFxuICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMub3B0aW9ucy5zaG91bGRTaG93LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBCdWJibGVNZW51LCBCdWJibGVNZW51UGx1Z2luLCBCdWJibGVNZW51VmlldywgQnViYmxlTWVudSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ Code),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */\nconst inputRegex = /(^|[^`])`([^`]+)`(?!`)/;\n/**\n * Matches inline code while pasting.\n */\nconst pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nconst Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'code',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    excludes: '_',\n    code: true,\n    exitable: true,\n    parseHTML() {\n        return [\n            { tag: 'code' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['code', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setCode: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleCode: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetCode: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-e': () => this.editor.commands.toggleCode(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUY7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyx3QkFBd0IsNkRBQWU7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLGFBQWE7QUFDYixpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGFBQWE7QUFDYixnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFd0Q7QUFDekQiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxleHRlbnNpb24tY29kZVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb25zIHRvIG1hdGNoIGlubGluZSBjb2RlIGJsb2NrcyBlbmNsb3NlZCBpbiBiYWNrdGlja3MuXG4gKiAgSXQgbWF0Y2hlczpcbiAqICAgICAtIEFuIG9wZW5pbmcgYmFja3RpY2ssIGZvbGxvd2VkIGJ5XG4gKiAgICAgLSBBbnkgdGV4dCB0aGF0IGRvZXNuJ3QgaW5jbHVkZSBhIGJhY2t0aWNrIChjYXB0dXJlZCBmb3IgbWFya2luZyksIGZvbGxvd2VkIGJ5XG4gKiAgICAgLSBBIGNsb3NpbmcgYmFja3RpY2suXG4gKiAgVGhpcyBlbnN1cmVzIHRoYXQgYW55IHRleHQgYmV0d2VlbiBiYWNrdGlja3MgaXMgZm9ybWF0dGVkIGFzIGNvZGUsXG4gKiAgcmVnYXJkbGVzcyBvZiB0aGUgc3Vycm91bmRpbmcgY2hhcmFjdGVycyAoZXhjZXB0aW9uIGJlaW5nIGFub3RoZXIgYmFja3RpY2spLlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkvO1xuLyoqXG4gKiBNYXRjaGVzIGlubGluZSBjb2RlIHdoaWxlIHBhc3RpbmcuXG4gKi9cbmNvbnN0IHBhc3RlUmVnZXggPSAvKF58W15gXSlgKFteYF0rKWAoPyFgKS9nO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIG1hcmsgdGV4dCBhcyBpbmxpbmUgY29kZS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9tYXJrcy9jb2RlXG4gKi9cbmNvbnN0IENvZGUgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NvZGUnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBleGNsdWRlczogJ18nLFxuICAgIGNvZGU6IHRydWUsXG4gICAgZXhpdGFibGU6IHRydWUsXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0YWc6ICdjb2RlJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnY29kZScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUNvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGUoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBDb2RlLCBDb2RlIGFzIGRlZmF1bHQsIGlucHV0UmVnZXgsIHBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-code/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollaborationCursor: () => (/* binding */ CollaborationCursor),\n/* harmony export */   \"default\": () => (/* binding */ CollaborationCursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\");\n\n\n\nconst awarenessStatesToArray = (states) => {\n    return Array.from(states.entries()).map(([key, value]) => {\n        return {\n            clientId: key,\n            ...value.user,\n        };\n    });\n};\nconst defaultOnUpdate = () => null;\n/**\n * This extension allows you to add collaboration cursors to your editor.\n * @see https://tiptap.dev/api/extensions/collaboration-cursor\n */\nconst CollaborationCursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n    name: 'collaborationCursor',\n    priority: 999,\n    addOptions() {\n        return {\n            provider: null,\n            user: {\n                name: null,\n                color: null,\n            },\n            render: user => {\n                const cursor = document.createElement('span');\n                cursor.classList.add('collaboration-cursor__caret');\n                cursor.setAttribute('style', `border-color: ${user.color}`);\n                const label = document.createElement('div');\n                label.classList.add('collaboration-cursor__label');\n                label.setAttribute('style', `background-color: ${user.color}`);\n                label.insertBefore(document.createTextNode(user.name), null);\n                cursor.insertBefore(label, null);\n                return cursor;\n            },\n            selectionRender: y_prosemirror__WEBPACK_IMPORTED_MODULE_1__.defaultSelectionBuilder,\n            onUpdate: defaultOnUpdate,\n        };\n    },\n    onCreate() {\n        if (this.options.onUpdate !== defaultOnUpdate) {\n            console.warn('[tiptap warn]: DEPRECATED: The \"onUpdate\" option is deprecated. Please use `editor.storage.collaborationCursor.users` instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor');\n        }\n        if (!this.options.provider) {\n            throw new Error('The \"provider\" option is required for the CollaborationCursor extension');\n        }\n    },\n    addStorage() {\n        return {\n            users: [],\n        };\n    },\n    addCommands() {\n        return {\n            updateUser: attributes => () => {\n                this.options.user = attributes;\n                this.options.provider.awareness.setLocalStateField('user', this.options.user);\n                return true;\n            },\n            user: attributes => ({ editor }) => {\n                console.warn('[tiptap warn]: DEPRECATED: The \"user\" command is deprecated. Please use \"updateUser\" instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor');\n                return editor.commands.updateUser(attributes);\n            },\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_1__.yCursorPlugin)((() => {\n                this.options.provider.awareness.setLocalStateField('user', this.options.user);\n                this.storage.users = awarenessStatesToArray(this.options.provider.awareness.states);\n                this.options.provider.awareness.on('update', () => {\n                    this.storage.users = awarenessStatesToArray(this.options.provider.awareness.states);\n                });\n                return this.options.provider.awareness;\n            })(), \n            // @ts-ignore\n            {\n                cursorBuilder: this.options.render,\n                selectionBuilder: this.options.selectionRender,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uLWN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDOEI7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZCQUE2QixrRUFBdUI7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSw0REFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUU4RDtBQUMvRCIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXGV4dGVuc2lvbi1jb2xsYWJvcmF0aW9uLWN1cnNvclxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IGRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyLCB5Q3Vyc29yUGx1Z2luIH0gZnJvbSAneS1wcm9zZW1pcnJvcic7XG5cbmNvbnN0IGF3YXJlbmVzc1N0YXRlc1RvQXJyYXkgPSAoc3RhdGVzKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmVudHJpZXMoKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudElkOiBrZXksXG4gICAgICAgICAgICAuLi52YWx1ZS51c2VyLFxuICAgICAgICB9O1xuICAgIH0pO1xufTtcbmNvbnN0IGRlZmF1bHRPblVwZGF0ZSA9ICgpID0+IG51bGw7XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGNvbGxhYm9yYXRpb24gY3Vyc29ycyB0byB5b3VyIGVkaXRvci5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2NvbGxhYm9yYXRpb24tY3Vyc29yXG4gKi9cbmNvbnN0IENvbGxhYm9yYXRpb25DdXJzb3IgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnY29sbGFib3JhdGlvbkN1cnNvcicsXG4gICAgcHJpb3JpdHk6IDk5OSxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdmlkZXI6IG51bGwsXG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2xvcjogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXI6IHVzZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IuY2xhc3NMaXN0LmFkZCgnY29sbGFib3JhdGlvbi1jdXJzb3JfX2NhcmV0Jyk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgYm9yZGVyLWNvbG9yOiAke3VzZXIuY29sb3J9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdjb2xsYWJvcmF0aW9uLWN1cnNvcl9fbGFiZWwnKTtcbiAgICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn1gKTtcbiAgICAgICAgICAgICAgICBsYWJlbC5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodXNlci5uYW1lKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLmluc2VydEJlZm9yZShsYWJlbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Rpb25SZW5kZXI6IGRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyLFxuICAgICAgICAgICAgb25VcGRhdGU6IGRlZmF1bHRPblVwZGF0ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9uQ3JlYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uVXBkYXRlICE9PSBkZWZhdWx0T25VcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogREVQUkVDQVRFRDogVGhlIFwib25VcGRhdGVcIiBvcHRpb24gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbkN1cnNvci51c2Vyc2AgaW5zdGVhZC4gUmVhZCBtb3JlOiBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvY29sbGFib3JhdGlvbi1jdXJzb3InKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJwcm92aWRlclwiIG9wdGlvbiBpcyByZXF1aXJlZCBmb3IgdGhlIENvbGxhYm9yYXRpb25DdXJzb3IgZXh0ZW5zaW9uJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyczogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVwZGF0ZVVzZXI6IGF0dHJpYnV0ZXMgPT4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy51c2VyID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJvdmlkZXIuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgndXNlcicsIHRoaXMub3B0aW9ucy51c2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1c2VyOiBhdHRyaWJ1dGVzID0+ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBERVBSRUNBVEVEOiBUaGUgXCJ1c2VyXCIgY29tbWFuZCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwidXBkYXRlVXNlclwiIGluc3RlYWQuIFJlYWQgbW9yZTogaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2NvbGxhYm9yYXRpb24tY3Vyc29yJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy51cGRhdGVVc2VyKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHlDdXJzb3JQbHVnaW4oKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJvdmlkZXIuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgndXNlcicsIHRoaXMub3B0aW9ucy51c2VyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UudXNlcnMgPSBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5KHRoaXMub3B0aW9ucy5wcm92aWRlci5hd2FyZW5lc3Muc3RhdGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJvdmlkZXIuYXdhcmVuZXNzLm9uKCd1cGRhdGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS51c2VycyA9IGF3YXJlbmVzc1N0YXRlc1RvQXJyYXkodGhpcy5vcHRpb25zLnByb3ZpZGVyLmF3YXJlbmVzcy5zdGF0ZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucHJvdmlkZXIuYXdhcmVuZXNzO1xuICAgICAgICAgICAgfSkoKSwgXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3Vyc29yQnVpbGRlcjogdGhpcy5vcHRpb25zLnJlbmRlcixcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25CdWlsZGVyOiB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uUmVuZGVyLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBDb2xsYWJvcmF0aW9uQ3Vyc29yLCBDb2xsYWJvcmF0aW9uQ3Vyc29yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-collaboration/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-collaboration/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collaboration: () => (/* binding */ Collaboration),\n/* harmony export */   \"default\": () => (/* binding */ Collaboration),\n/* harmony export */   isChangeOrigin: () => (/* binding */ isChangeOrigin)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! y-prosemirror */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/lib.js\");\n\n\n\n\n/**\n * This extension allows you to collaborate with others in real-time.\n * @see https://tiptap.dev/api/extensions/collaboration\n */\nconst Collaboration = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'collaboration',\n    priority: 1000,\n    addOptions() {\n        return {\n            document: null,\n            field: 'default',\n            fragment: null,\n        };\n    },\n    addStorage() {\n        return {\n            isDisabled: false,\n        };\n    },\n    onCreate() {\n        if (this.editor.extensionManager.extensions.find(extension => extension.name === 'history')) {\n            console.warn('[tiptap warn]: \"@tiptap/extension-collaboration\" comes with its own history support and is not compatible with \"@tiptap/extension-history\".');\n        }\n    },\n    addCommands() {\n        return {\n            undo: () => ({ tr, state, dispatch }) => {\n                tr.setMeta('preventDispatch', true);\n                const undoManager = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.yUndoPluginKey.getState(state).undoManager;\n                if (undoManager.undoStack.length === 0) {\n                    return false;\n                }\n                if (!dispatch) {\n                    return true;\n                }\n                return (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.undo)(state);\n            },\n            redo: () => ({ tr, state, dispatch }) => {\n                tr.setMeta('preventDispatch', true);\n                const undoManager = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.yUndoPluginKey.getState(state).undoManager;\n                if (undoManager.redoStack.length === 0) {\n                    return false;\n                }\n                if (!dispatch) {\n                    return true;\n                }\n                return (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.redo)(state);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-z': () => this.editor.commands.undo(),\n            'Mod-y': () => this.editor.commands.redo(),\n            'Shift-Mod-z': () => this.editor.commands.redo(),\n        };\n    },\n    addProseMirrorPlugins() {\n        var _a;\n        const fragment = this.options.fragment\n            ? this.options.fragment\n            : this.options.document.getXmlFragment(this.options.field);\n        // Quick fix until there is an official implementation (thanks to @hamflx).\n        // See https://github.com/yjs/y-prosemirror/issues/114 and https://github.com/yjs/y-prosemirror/issues/102\n        const yUndoPluginInstance = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.yUndoPlugin)(this.options.yUndoOptions);\n        const originalUndoPluginView = yUndoPluginInstance.spec.view;\n        yUndoPluginInstance.spec.view = (view) => {\n            const { undoManager } = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.yUndoPluginKey.getState(view.state);\n            if (undoManager.restore) {\n                undoManager.restore();\n                undoManager.restore = () => {\n                    // noop\n                };\n            }\n            const viewRet = originalUndoPluginView ? originalUndoPluginView(view) : undefined;\n            return {\n                destroy: () => {\n                    const hasUndoManSelf = undoManager.trackedOrigins.has(undoManager);\n                    // eslint-disable-next-line no-underscore-dangle\n                    const observers = undoManager._observers;\n                    undoManager.restore = () => {\n                        if (hasUndoManSelf) {\n                            undoManager.trackedOrigins.add(undoManager);\n                        }\n                        undoManager.doc.on('afterTransaction', undoManager.afterTransactionHandler);\n                        // eslint-disable-next-line no-underscore-dangle\n                        undoManager._observers = observers;\n                    };\n                    if (viewRet === null || viewRet === void 0 ? void 0 : viewRet.destroy) {\n                        viewRet.destroy();\n                    }\n                },\n            };\n        };\n        const ySyncPluginOptions = {\n            ...this.options.ySyncOptions,\n            onFirstRender: this.options.onFirstRender,\n        };\n        const ySyncPluginInstance = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_4__.ySyncPlugin)(fragment, ySyncPluginOptions);\n        if (this.editor.options.enableContentCheck) {\n            (_a = fragment.doc) === null || _a === void 0 ? void 0 : _a.on('beforeTransaction', () => {\n                try {\n                    const jsonContent = ((0,y_prosemirror__WEBPACK_IMPORTED_MODULE_5__.yXmlFragmentToProsemirrorJSON)(fragment));\n                    if (jsonContent.content.length === 0) {\n                        return;\n                    }\n                    this.editor.schema.nodeFromJSON(jsonContent).check();\n                }\n                catch (error) {\n                    this.editor.emit('contentError', {\n                        error: error,\n                        editor: this.editor,\n                        disableCollaboration: () => {\n                            var _a;\n                            (_a = fragment.doc) === null || _a === void 0 ? void 0 : _a.destroy();\n                            this.storage.isDisabled = true;\n                        },\n                    });\n                    // If the content is invalid, return false to prevent the transaction from being applied\n                    return false;\n                }\n            });\n        }\n        return [\n            ySyncPluginInstance,\n            yUndoPluginInstance,\n            // Only add the filterInvalidContent plugin if content checking is enabled\n            this.editor.options.enableContentCheck\n                && new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('filterInvalidContent'),\n                    filterTransaction: () => {\n                        var _a;\n                        // When collaboration is disabled, prevent any sync transactions from being applied\n                        if (this.storage.isDisabled) {\n                            // Destroy the Yjs document to prevent any further sync transactions\n                            (_a = fragment.doc) === null || _a === void 0 ? void 0 : _a.destroy();\n                            return true;\n                        }\n                        return true;\n                    },\n                }),\n        ].filter(Boolean);\n    },\n});\n\n/**\n * Checks if a transaction was originated from a Yjs change.\n * @param {Transaction} transaction - The transaction to check.\n * @returns {boolean} - True if the transaction was originated from a Yjs change, false otherwise.\n * @example\n * const transaction = new Transaction(doc)\n * const isOrigin = isChangeOrigin(transaction) // returns false\n */\nfunction isChangeOrigin(transaction) {\n    return !!transaction.getMeta(y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.ySyncPluginKey);\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ1k7QUFDK0U7O0FBRXBJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQSxvQ0FBb0MseURBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFJO0FBQzNCLGFBQWE7QUFDYiwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0Esb0NBQW9DLHlEQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtREFBSTtBQUMzQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFXO0FBQy9DO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxFQUFFLHlEQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0RUFBNkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQU07QUFDN0IsNkJBQTZCLHVEQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlEQUFjO0FBQy9DOztBQUVtRTtBQUNuRSIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXGV4dGVuc2lvbi1jb2xsYWJvcmF0aW9uXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IHlVbmRvUGx1Z2luS2V5LCB1bmRvLCByZWRvLCB5VW5kb1BsdWdpbiwgeVN5bmNQbHVnaW4sIHlYbWxGcmFnbWVudFRvUHJvc2VtaXJyb3JKU09OLCB5U3luY1BsdWdpbktleSB9IGZyb20gJ3ktcHJvc2VtaXJyb3InO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY29sbGFib3JhdGUgd2l0aCBvdGhlcnMgaW4gcmVhbC10aW1lLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvY29sbGFib3JhdGlvblxuICovXG5jb25zdCBDb2xsYWJvcmF0aW9uID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NvbGxhYm9yYXRpb24nLFxuICAgIHByaW9yaXR5OiAxMDAwLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb2N1bWVudDogbnVsbCxcbiAgICAgICAgICAgIGZpZWxkOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9uQ3JlYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5leHRlbnNpb25zLmZpbmQoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lID09PSAnaGlzdG9yeScpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwiQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvblwiIGNvbWVzIHdpdGggaXRzIG93biBoaXN0b3J5IHN1cHBvcnQgYW5kIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggXCJAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5XCIuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5kbzogKCkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgncHJldmVudERpc3BhdGNoJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkudW5kb01hbmFnZXI7XG4gICAgICAgICAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kbyhzdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkbzogKCkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgncHJldmVudERpc3BhdGNoJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkudW5kb01hbmFnZXI7XG4gICAgICAgICAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAgICAgICAnTW9kLXknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgICAgICAnU2hpZnQtTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLm9wdGlvbnMuZnJhZ21lbnRcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmZyYWdtZW50XG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5kb2N1bWVudC5nZXRYbWxGcmFnbWVudCh0aGlzLm9wdGlvbnMuZmllbGQpO1xuICAgICAgICAvLyBRdWljayBmaXggdW50aWwgdGhlcmUgaXMgYW4gb2ZmaWNpYWwgaW1wbGVtZW50YXRpb24gKHRoYW5rcyB0byBAaGFtZmx4KS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveS1wcm9zZW1pcnJvci9pc3N1ZXMvMTE0IGFuZCBodHRwczovL2dpdGh1Yi5jb20veWpzL3ktcHJvc2VtaXJyb3IvaXNzdWVzLzEwMlxuICAgICAgICBjb25zdCB5VW5kb1BsdWdpbkluc3RhbmNlID0geVVuZG9QbHVnaW4odGhpcy5vcHRpb25zLnlVbmRvT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVW5kb1BsdWdpblZpZXcgPSB5VW5kb1BsdWdpbkluc3RhbmNlLnNwZWMudmlldztcbiAgICAgICAgeVVuZG9QbHVnaW5JbnN0YW5jZS5zcGVjLnZpZXcgPSAodmlldykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1bmRvTWFuYWdlciB9ID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAodW5kb01hbmFnZXIucmVzdG9yZSkge1xuICAgICAgICAgICAgICAgIHVuZG9NYW5hZ2VyLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB1bmRvTWFuYWdlci5yZXN0b3JlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpZXdSZXQgPSBvcmlnaW5hbFVuZG9QbHVnaW5WaWV3ID8gb3JpZ2luYWxVbmRvUGx1Z2luVmlldyh2aWV3KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNVbmRvTWFuU2VsZiA9IHVuZG9NYW5hZ2VyLnRyYWNrZWRPcmlnaW5zLmhhcyh1bmRvTWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlcnMgPSB1bmRvTWFuYWdlci5fb2JzZXJ2ZXJzO1xuICAgICAgICAgICAgICAgICAgICB1bmRvTWFuYWdlci5yZXN0b3JlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1VuZG9NYW5TZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kb01hbmFnZXIudHJhY2tlZE9yaWdpbnMuYWRkKHVuZG9NYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZG9NYW5hZ2VyLmRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIHVuZG9NYW5hZ2VyLmFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kb01hbmFnZXIuX29ic2VydmVycyA9IG9ic2VydmVycztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdSZXQgPT09IG51bGwgfHwgdmlld1JldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld1JldC5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3UmV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB5U3luY1BsdWdpbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMueVN5bmNPcHRpb25zLFxuICAgICAgICAgICAgb25GaXJzdFJlbmRlcjogdGhpcy5vcHRpb25zLm9uRmlyc3RSZW5kZXIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHlTeW5jUGx1Z2luSW5zdGFuY2UgPSB5U3luY1BsdWdpbihmcmFnbWVudCwgeVN5bmNQbHVnaW5PcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrKSB7XG4gICAgICAgICAgICAoX2EgPSBmcmFnbWVudC5kb2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbignYmVmb3JlVHJhbnNhY3Rpb24nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbkNvbnRlbnQgPSAoeVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oZnJhZ21lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25Db250ZW50LmNvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2NoZW1hLm5vZGVGcm9tSlNPTihqc29uQ29udGVudCkuY2hlY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoJ2NvbnRlbnRFcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ29sbGFib3JhdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBmcmFnbWVudC5kb2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb250ZW50IGlzIGludmFsaWQsIHJldHVybiBmYWxzZSB0byBwcmV2ZW50IHRoZSB0cmFuc2FjdGlvbiBmcm9tIGJlaW5nIGFwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB5U3luY1BsdWdpbkluc3RhbmNlLFxuICAgICAgICAgICAgeVVuZG9QbHVnaW5JbnN0YW5jZSxcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBmaWx0ZXJJbnZhbGlkQ29udGVudCBwbHVnaW4gaWYgY29udGVudCBjaGVja2luZyBpcyBlbmFibGVkXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICAgICAgICAgICAgICAgICYmIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2ZpbHRlckludmFsaWRDb250ZW50JyksXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRyYW5zYWN0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGNvbGxhYm9yYXRpb24gaXMgZGlzYWJsZWQsIHByZXZlbnQgYW55IHN5bmMgdHJhbnNhY3Rpb25zIGZyb20gYmVpbmcgYXBwbGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJveSB0aGUgWWpzIGRvY3VtZW50IHRvIHByZXZlbnQgYW55IGZ1cnRoZXIgc3luYyB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBmcmFnbWVudC5kb2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSxcbn0pO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHRyYW5zYWN0aW9uIHdhcyBvcmlnaW5hdGVkIGZyb20gYSBZanMgY2hhbmdlLlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgb3JpZ2luYXRlZCBmcm9tIGEgWWpzIGNoYW5nZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYylcbiAqIGNvbnN0IGlzT3JpZ2luID0gaXNDaGFuZ2VPcmlnaW4odHJhbnNhY3Rpb24pIC8vIHJldHVybnMgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNDaGFuZ2VPcmlnaW4odHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gISF0cmFuc2FjdGlvbi5nZXRNZXRhKHlTeW5jUGx1Z2luS2V5KTtcbn1cblxuZXhwb3J0IHsgQ29sbGFib3JhdGlvbiwgQ29sbGFib3JhdGlvbiBhcyBkZWZhdWx0LCBpc0NoYW5nZU9yaWdpbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-collaboration/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-floating-menu/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-floating-menu/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   FloatingMenuPlugin: () => (/* binding */ FloatingMenuPlugin),\n/* harmony export */   FloatingMenuView: () => (/* binding */ FloatingMenuView),\n/* harmony export */   \"default\": () => (/* binding */ FloatingMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(app-pages-browser)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\n\nclass FloatingMenuView {\n    getTextContent(node) {\n        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getText)(node, { textSerializers: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getTextSerializersFromSchema)(this.editor.schema) });\n    }\n    constructor({ editor, element, view, tippyOptions = {}, shouldShow, }) {\n        this.preventHide = false;\n        this.shouldShow = ({ view, state }) => {\n            const { selection } = state;\n            const { $anchor, empty } = selection;\n            const isRootDepth = $anchor.depth === 1;\n            const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent && $anchor.parent.childCount === 0 && !this.getTextContent($anchor.parent);\n            if (!view.hasFocus()\n                || !empty\n                || !isRootDepth\n                || !isEmptyTextBlock\n                || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = () => {\n            this.preventHide = true;\n        };\n        this.focusHandler = () => {\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(() => this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event }) => {\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event) => {\n            this.blurHandler({ event });\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.editor.on('focus', this.focusHandler);\n        this.editor.on('blur', this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = 'visible';\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: 'manual',\n            placement: 'right',\n            hideOnClick: 'toggle',\n            ...this.tippyOptions,\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        var _a, _b, _c;\n        const { state } = view;\n        const { doc, selection } = state;\n        const { from, to } = selection;\n        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n        if (isSame) {\n            return;\n        }\n        this.createTooltip();\n        const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n            editor: this.editor,\n            view,\n            state,\n            oldState,\n        });\n        if (!shouldShow) {\n            this.hide();\n            return;\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n            getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to)),\n        });\n        this.show();\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.editor.off('focus', this.focusHandler);\n        this.editor.off('blur', this.blurHandler);\n    }\n}\nconst FloatingMenuPlugin = (options) => {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === 'string' ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: view => new FloatingMenuView({ view, ...options }),\n    });\n};\n\n/**\n * This extension allows you to create a floating menu.\n * @see https://tiptap.dev/api/extensions/floating-menu\n */\nconst FloatingMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'floatingMenu',\n    addOptions() {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: 'floatingMenu',\n            shouldShow: null,\n        };\n    },\n    addProseMirrorPlugins() {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            FloatingMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                shouldShow: this.options.shouldShow,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1mbG9hdGluZy1tZW51L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4RjtBQUN6QztBQUN4Qjs7QUFFN0I7QUFDQTtBQUNBLGVBQWUscURBQU8sU0FBUyxpQkFBaUIsMEVBQTRCLHNCQUFzQjtBQUNsRztBQUNBLGtCQUFrQix3Q0FBd0MsZUFBZTtBQUN6RTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDLG9CQUFvQixZQUFZO0FBQ2hDLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSwwREFBWTtBQUNwSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvREFBTTtBQUNyQix5REFBeUQsdURBQVM7QUFDbEUsNkNBQTZDLGtCQUFrQjtBQUMvRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFc0Y7QUFDdkYiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxleHRlbnNpb24tZmxvYXRpbmctbWVudVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VGV4dCwgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSwgcG9zVG9ET01SZWN0LCBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB0aXBweSBmcm9tICd0aXBweS5qcyc7XG5cbmNsYXNzIEZsb2F0aW5nTWVudVZpZXcge1xuICAgIGdldFRleHRDb250ZW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGdldFRleHQobm9kZSwgeyB0ZXh0U2VyaWFsaXplcnM6IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5lZGl0b3Iuc2NoZW1hKSB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBlZGl0b3IsIGVsZW1lbnQsIHZpZXcsIHRpcHB5T3B0aW9ucyA9IHt9LCBzaG91bGRTaG93LCB9KSB7XG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gKHsgdmlldywgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyAkYW5jaG9yLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgaXNSb290RGVwdGggPSAkYW5jaG9yLmRlcHRoID09PSAxO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmICEkYW5jaG9yLnBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQgJiYgJGFuY2hvci5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMCAmJiAhdGhpcy5nZXRUZXh0Q29udGVudCgkYW5jaG9yLnBhcmVudCk7XG4gICAgICAgICAgICBpZiAoIXZpZXcuaGFzRm9jdXMoKVxuICAgICAgICAgICAgICAgIHx8ICFlbXB0eVxuICAgICAgICAgICAgICAgIHx8ICFpc1Jvb3REZXB0aFxuICAgICAgICAgICAgICAgIHx8ICFpc0VtcHR5VGV4dEJsb2NrXG4gICAgICAgICAgICAgICAgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd25IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmICgoX2EgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpID09PSB0aGlzLmVkaXRvci52aWV3LmRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBzaG91bGRTaG93O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgICAgICB0aGlzLnRpcHB5T3B0aW9ucyA9IHRpcHB5T3B0aW9ucztcbiAgICAgICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudDogZWRpdG9yRWxlbWVudCB9ID0gdGhpcy5lZGl0b3Iub3B0aW9ucztcbiAgICAgICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAodGhpcy50aXBweSB8fCAhZWRpdG9ySXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwcHkgPSB0aXBweShlZGl0b3JFbGVtZW50LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxuICAgICAgICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBpc1NhbWUgPSBvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5kb2MuZXEoZG9jKSAmJiBvbGRTdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGlzU2FtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCgpO1xuICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gKF9hID0gdGhpcy5zaG91bGRTaG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZFNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRQcm9wcyh7XG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKF9jID0gdGhpcy50aXBweU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0KSB8fCAoKCkgPT4gcG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvdygpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICB9XG59XG5jb25zdCBGbG9hdGluZ01lbnVQbHVnaW4gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgdmlldzogdmlldyA9PiBuZXcgRmxvYXRpbmdNZW51Vmlldyh7IHZpZXcsIC4uLm9wdGlvbnMgfSksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGEgZmxvYXRpbmcgbWVudS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2Zsb2F0aW5nLW1lbnVcbiAqL1xuY29uc3QgRmxvYXRpbmdNZW51ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Zsb2F0aW5nTWVudScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICB0aXBweU9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgcGx1Z2luS2V5OiAnZmxvYXRpbmdNZW51JyxcbiAgICAgICAgICAgIHNob3VsZFNob3c6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRmxvYXRpbmdNZW51UGx1Z2luKHtcbiAgICAgICAgICAgICAgICBwbHVnaW5LZXk6IHRoaXMub3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHRoaXMub3B0aW9ucy50aXBweU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2hvdWxkU2hvdzogdGhpcy5vcHRpb25zLnNob3VsZFNob3csXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEZsb2F0aW5nTWVudSwgRmxvYXRpbmdNZW51UGx1Z2luLCBGbG9hdGluZ01lbnVWaWV3LCBGbG9hdGluZ01lbnUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-gapcursor/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   \"default\": () => (/* binding */ Gapcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(app-pages-browser)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\");\n\n\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */\nconst Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'gapCursor',\n    addProseMirrorPlugins() {\n        return [\n            (0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)(),\n        ];\n    },\n    extendNodeSchema(extension) {\n        var _a;\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        return {\n            allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null,\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBFO0FBQ3pCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbURBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBUztBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFZLENBQUMsK0RBQWlCO0FBQ2hFO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRTBDO0FBQzNDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxcZXh0ZW5zaW9uLWdhcGN1cnNvclxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uLCBjYWxsT3JSZXR1cm4sIGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IGdhcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZ2FwY3Vyc29yJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGFkZCBhIGdhcCBjdXJzb3IgdG8geW91ciBlZGl0b3IuXG4gKiBBIGdhcCBjdXJzb3IgaXMgYSBjdXJzb3IgdGhhdCBhcHBlYXJzIHdoZW4geW91IGNsaWNrIG9uIGEgcGxhY2VcbiAqIHdoZXJlIG5vIGNvbnRlbnQgaXMgcHJlc2VudCwgZm9yIGV4YW1wbGUgaW5iZXR3ZWVuIG5vZGVzLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvZ2FwY3Vyc29yXG4gKi9cbmNvbnN0IEdhcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdnYXBDdXJzb3InLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGdhcEN1cnNvcigpLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dHYXBDdXJzb3I6IChfYSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhbGxvd0dhcEN1cnNvcicsIGNvbnRleHQpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEdhcGN1cnNvciwgR2FwY3Vyc29yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-history/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   History: () => (/* binding */ History),\n/* harmony export */   \"default\": () => (/* binding */ History)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/history */ \"(app-pages-browser)/./node_modules/@tiptap/pm/history/dist/index.js\");\n\n\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nconst History = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'history',\n    addOptions() {\n        return {\n            depth: 100,\n            newGroupDelay: 500,\n        };\n    },\n    addCommands() {\n        return {\n            undo: () => ({ state, dispatch }) => {\n                return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.undo)(state, dispatch);\n            },\n            redo: () => ({ state, dispatch }) => {\n                return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.redo)(state, dispatch);\n            },\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.history)(this.options),\n        ];\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-z': () => this.editor.commands.undo(),\n            'Shift-Mod-z': () => this.editor.commands.redo(),\n            'Mod-y': () => this.editor.commands.redo(),\n            // Russian keyboard layouts\n            'Mod-я': () => this.editor.commands.undo(),\n            'Shift-Mod-я': () => this.editor.commands.redo(),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QztBQUNnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1Qyx1QkFBdUIsd0RBQUk7QUFDM0IsYUFBYTtBQUNiLDJCQUEyQixpQkFBaUI7QUFDNUMsdUJBQXVCLHdEQUFJO0FBQzNCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBTztBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFc0M7QUFDdkMiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxleHRlbnNpb24taGlzdG9yeVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IHVuZG8sIHJlZG8sIGhpc3RvcnkgfSBmcm9tICdAdGlwdGFwL3BtL2hpc3RvcnknO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gdW5kbyBhbmQgcmVkbyByZWNlbnQgY2hhbmdlcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9oaXN0b3J5XG4gKlxuICogKipJbXBvcnRhbnQqKjogSWYgdGhlIGBAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uYCBwYWNrYWdlIGlzIHVzZWQsIG1ha2Ugc3VyZSB0byByZW1vdmVcbiAqIHRoZSBgaGlzdG9yeWAgZXh0ZW5zaW9uLCBhcyBpdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBgY29sbGFib3JhdGlvbmAgZXh0ZW5zaW9uLlxuICpcbiAqIGBAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uYCB1c2VzIGl0cyBvd24gaGlzdG9yeSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY29uc3QgSGlzdG9yeSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdoaXN0b3J5JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5kbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kbyhzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZG8oc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoaXN0b3J5KHRoaXMub3B0aW9ucyksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICAgICAgICdTaGlmdC1Nb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgICAgICAgICdNb2QteSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgICAgICAgIC8vIFJ1c3NpYW4ga2V5Ym9hcmQgbGF5b3V0c1xuICAgICAgICAgICAgJ01vZC3Rjyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICAgICAgICdTaGlmdC1Nb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBIaXN0b3J5LCBIaXN0b3J5IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-history/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ Italic),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Matches an italic to a *italic* on input.\n */\nconst starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\n/**\n * Matches an italic to a *italic* on paste.\n */\nconst starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\n/**\n * Matches an italic to a _italic_ on input.\n */\nconst underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\n/**\n * Matches an italic to a _italic_ on paste.\n */\nconst underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nconst Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'italic',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'em',\n            },\n            {\n                tag: 'i',\n                getAttrs: node => node.style.fontStyle !== 'normal' && null,\n            },\n            {\n                style: 'font-style=normal',\n                clearMark: mark => mark.type.name === this.name,\n            },\n            {\n                style: 'font-style=italic',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['em', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setItalic: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleItalic: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetItalic: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-i': () => this.editor.commands.toggleItalic(),\n            'Mod-I': () => this.editor.commands.toggleItalic(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1GOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMsc0JBQXNCLDZEQUFlO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQSxhQUFhO0FBQ2Isa0NBQWtDLFVBQVU7QUFDNUM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVnSDtBQUNqSCIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXGV4dGVuc2lvbi1pdGFsaWNcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSAqaXRhbGljKiBvbiBpbnB1dC5cbiAqL1xuY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkkLztcbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSAqaXRhbGljKiBvbiBwYXN0ZS5cbiAqL1xuY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkvZztcbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSBfaXRhbGljXyBvbiBpbnB1dC5cbiAqL1xuY29uc3QgdW5kZXJzY29yZUlucHV0UmVnZXggPSAvKD86XnxcXHMpKF8oPyFcXHMrXykoKD86W15fXSspKV8oPyFcXHMrXykpJC87XG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgX2l0YWxpY18gb24gcGFzdGUuXG4gKi9cbmNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKS9nO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBpdGFsaWMgdGV4dC5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3MvaXRhbGljXG4gKi9cbmNvbnN0IEl0YWxpYyA9IE1hcmsuY3JlYXRlKHtcbiAgICBuYW1lOiAnaXRhbGljJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ2VtJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnaScsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gbm9kZS5zdHlsZS5mb250U3R5bGUgIT09ICdub3JtYWwnICYmIG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC1zdHlsZT1ub3JtYWwnLFxuICAgICAgICAgICAgICAgIGNsZWFyTWFyazogbWFyayA9PiBtYXJrLnR5cGUubmFtZSA9PT0gdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtc3R5bGU9aXRhbGljJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydlbScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtaSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgICAgICAgJ01vZC1JJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgSXRhbGljLCBJdGFsaWMgYXMgZGVmYXVsdCwgc3RhcklucHV0UmVnZXgsIHN0YXJQYXN0ZVJlZ2V4LCB1bmRlcnNjb3JlSW5wdXRSZWdleCwgdW5kZXJzY29yZVBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-italic/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-link/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-link/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   \"default\": () => (/* binding */ Link),\n/* harmony export */   isAllowedUri: () => (/* binding */ isAllowedUri),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var linkifyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! linkifyjs */ \"(app-pages-browser)/./node_modules/linkifyjs/dist/linkify.es.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens) {\n    if (tokens.length === 1) {\n        return tokens[0].isLink;\n    }\n    if (tokens.length === 3 && tokens[1].isLink) {\n        return ['()', '[]'].includes(tokens[0].value + tokens[2].value);\n    }\n    return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nfunction autolink(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey('autolink'),\n        appendTransaction: (transactions, oldState, newState) => {\n            /**\n             * Does the transaction change the document?\n             */\n            const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n            /**\n             * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n             */\n            const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n            /**\n             * Prevent autolink if the transaction is not a document change\n             * or if the transaction has the meta `preventAutolink`.\n             */\n            if (!docChanges || preventAutolink) {\n                return;\n            }\n            const { tr } = newState;\n            const transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps)(oldState.doc, [...transactions]);\n            const changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges)(transform);\n            changes.forEach(({ newRange }) => {\n                // Now let’s see if we can add new links.\n                const nodesInChangedRanges = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange)(newState.doc, newRange, node => node.isTextblock);\n                let textBlock;\n                let textBeforeWhitespace;\n                if (nodesInChangedRanges.length > 1) {\n                    // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n                }\n                else if (nodesInChangedRanges.length\n                    // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n                    && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n                }\n                if (textBlock && textBeforeWhitespace) {\n                    const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '');\n                    if (wordsBeforeWhitespace.length <= 0) {\n                        return false;\n                    }\n                    const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n                    const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n                    if (!lastWordBeforeSpace) {\n                        return false;\n                    }\n                    const linksBeforeSpace = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.tokenize)(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n                    if (!isValidLinkStructure(linksBeforeSpace)) {\n                        return false;\n                    }\n                    linksBeforeSpace\n                        .filter(link => link.isLink)\n                        // Calculate link position.\n                        .map(link => ({\n                        ...link,\n                        from: lastWordAndBlockOffset + link.start + 1,\n                        to: lastWordAndBlockOffset + link.end + 1,\n                    }))\n                        // ignore link inside code mark\n                        .filter(link => {\n                        if (!newState.schema.marks.code) {\n                            return true;\n                        }\n                        return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n                    })\n                        // validate link\n                        .filter(link => options.validate(link.value))\n                        // check whether should autolink\n                        .filter(link => options.shouldAutoLink(link.value))\n                        // Add link mark.\n                        .forEach(link => {\n                        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween)(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                            return;\n                        }\n                        tr.addMark(link.from, link.to, options.type.create({\n                            href: link.href,\n                        }));\n                    });\n                }\n            });\n            if (!tr.steps.length) {\n                return;\n            }\n            return tr;\n        },\n    });\n}\n\nfunction clickHandler(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey('handleClickLink'),\n        props: {\n            handleClick: (view, pos, event) => {\n                var _a, _b;\n                if (event.button !== 0) {\n                    return false;\n                }\n                if (!view.editable) {\n                    return false;\n                }\n                let a = event.target;\n                const els = [];\n                while (a.nodeName !== 'DIV') {\n                    els.push(a);\n                    a = a.parentNode;\n                }\n                if (!els.find(value => value.nodeName === 'A')) {\n                    return false;\n                }\n                const attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes)(view.state, options.type.name);\n                const link = event.target;\n                const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n                const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n                if (link && href) {\n                    window.open(href, target);\n                    return true;\n                }\n                return false;\n            },\n        },\n    });\n}\n\nfunction pasteHandler(options) {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey('handlePasteLink'),\n        props: {\n            handlePaste: (view, event, slice) => {\n                const { state } = view;\n                const { selection } = state;\n                const { empty } = selection;\n                if (empty) {\n                    return false;\n                }\n                let textContent = '';\n                slice.content.forEach(node => {\n                    textContent += node.textContent;\n                });\n                const link = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(textContent, { defaultProtocol: options.defaultProtocol }).find(item => item.isLink && item.value === textContent);\n                if (!textContent || !link) {\n                    return false;\n                }\n                return options.editor.commands.setMark(options.type, {\n                    href: link.href,\n                });\n            },\n        },\n    });\n}\n\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\nfunction isAllowedUri(uri, protocols) {\n    const allowedProtocols = [\n        'http',\n        'https',\n        'ftp',\n        'ftps',\n        'mailto',\n        'tel',\n        'callto',\n        'sms',\n        'cid',\n        'xmpp',\n    ];\n    if (protocols) {\n        protocols.forEach(protocol => {\n            const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme;\n            if (nextProtocol) {\n                allowedProtocols.push(nextProtocol);\n            }\n        });\n    }\n    return (!uri\n        || uri\n            .replace(ATTR_WHITESPACE, '')\n            .match(new RegExp(\n        // eslint-disable-next-line no-useless-escape\n        `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i')));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nconst Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({\n    name: 'link',\n    priority: 1000,\n    keepOnSplit: false,\n    exitable: true,\n    onCreate() {\n        if (this.options.validate && !this.options.shouldAutoLink) {\n            // Copy the validate function to the shouldAutoLink option\n            this.options.shouldAutoLink = this.options.validate;\n            console.warn('The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.');\n        }\n        this.options.protocols.forEach(protocol => {\n            if (typeof protocol === 'string') {\n                (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol);\n                return;\n            }\n            (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);\n        });\n    },\n    onDestroy() {\n        (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.reset)();\n    },\n    inclusive() {\n        return this.options.autolink;\n    },\n    addOptions() {\n        return {\n            openOnClick: true,\n            linkOnPaste: true,\n            autolink: true,\n            protocols: [],\n            defaultProtocol: 'http',\n            HTMLAttributes: {\n                target: '_blank',\n                rel: 'noopener noreferrer nofollow',\n                class: null,\n            },\n            isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n            validate: url => !!url,\n            shouldAutoLink: url => !!url,\n        };\n    },\n    addAttributes() {\n        return {\n            href: {\n                default: null,\n                parseHTML(element) {\n                    return element.getAttribute('href');\n                },\n            },\n            target: {\n                default: this.options.HTMLAttributes.target,\n            },\n            rel: {\n                default: this.options.HTMLAttributes.rel,\n            },\n            class: {\n                default: this.options.HTMLAttributes.class,\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'a[href]',\n                getAttrs: dom => {\n                    const href = dom.getAttribute('href');\n                    // prevent XSS attacks\n                    if (!href\n                        || !this.options.isAllowedUri(href, {\n                            defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n                            protocols: this.options.protocols,\n                            defaultProtocol: this.options.defaultProtocol,\n                        })) {\n                        return false;\n                    }\n                    return null;\n                },\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        // prevent XSS attacks\n        if (!this.options.isAllowedUri(HTMLAttributes.href, {\n            defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol,\n        })) {\n            // strip out the href\n            return [\n                'a',\n                (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }),\n                0,\n            ];\n        }\n        return ['a', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setLink: attributes => ({ chain }) => {\n                const { href } = attributes;\n                if (!this.options.isAllowedUri(href, {\n                    defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n                    protocols: this.options.protocols,\n                    defaultProtocol: this.options.defaultProtocol,\n                })) {\n                    return false;\n                }\n                return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n            },\n            toggleLink: attributes => ({ chain }) => {\n                const { href } = attributes;\n                if (!this.options.isAllowedUri(href, {\n                    defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n                    protocols: this.options.protocols,\n                    defaultProtocol: this.options.defaultProtocol,\n                })) {\n                    return false;\n                }\n                return chain()\n                    .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n            unsetLink: () => ({ chain }) => {\n                return chain()\n                    .unsetMark(this.name, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n        };\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule)({\n                find: text => {\n                    const foundLinks = [];\n                    if (text) {\n                        const { protocols, defaultProtocol } = this.options;\n                        const links = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(text).filter(item => item.isLink\n                            && this.options.isAllowedUri(item.value, {\n                                defaultValidate: href => !!isAllowedUri(href, protocols),\n                                protocols,\n                                defaultProtocol,\n                            }));\n                        if (links.length) {\n                            links.forEach(link => foundLinks.push({\n                                text: link.value,\n                                data: {\n                                    href: link.href,\n                                },\n                                index: link.start,\n                            }));\n                        }\n                    }\n                    return foundLinks;\n                },\n                type: this.type,\n                getAttributes: match => {\n                    var _a;\n                    return {\n                        href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href,\n                    };\n                },\n            }),\n        ];\n    },\n    addProseMirrorPlugins() {\n        const plugins = [];\n        const { protocols, defaultProtocol } = this.options;\n        if (this.options.autolink) {\n            plugins.push(autolink({\n                type: this.type,\n                defaultProtocol: this.options.defaultProtocol,\n                validate: url => this.options.isAllowedUri(url, {\n                    defaultValidate: href => !!isAllowedUri(href, protocols),\n                    protocols,\n                    defaultProtocol,\n                }),\n                shouldAutoLink: this.options.shouldAutoLink,\n            }));\n        }\n        if (this.options.openOnClick === true) {\n            plugins.push(clickHandler({\n                type: this.type,\n            }));\n        }\n        if (this.options.linkOnPaste) {\n            plugins.push(pasteHandler({\n                editor: this.editor,\n                defaultProtocol: this.options.defaultProtocol,\n                type: this.type,\n            }));\n        }\n        return plugins;\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saW5rL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvSztBQUMxRjtBQUNyQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFNO0FBQ3JCLGlCQUFpQix1REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCLDhCQUE4QixxRUFBdUI7QUFDckQsNEJBQTRCLDhEQUFnQjtBQUM1QywrQkFBK0IsVUFBVTtBQUN6QztBQUNBLDZDQUE2QyxpRUFBbUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtREFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxlQUFlLG9EQUFNO0FBQ3JC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRTBEO0FBQzNEIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxcZXh0ZW5zaW9uLWxpbmtcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLCBnZXRDaGFuZ2VkUmFuZ2VzLCBmaW5kQ2hpbGRyZW5JblJhbmdlLCBnZXRNYXJrc0JldHdlZW4sIGdldEF0dHJpYnV0ZXMsIE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyB0b2tlbml6ZSwgZmluZCwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVzZXQgfSBmcm9tICdsaW5raWZ5anMnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcHJvdmlkZWQgdG9rZW5zIGZvcm0gYSB2YWxpZCBsaW5rIHN0cnVjdHVyZSwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIHNpbmdsZSBsaW5rIHRva2VuXG4gKiBvciBhIGxpbmsgdG9rZW4gc3Vycm91bmRlZCBieSBwYXJlbnRoZXNlcyBvciBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgb25seSBjb21wbGV0ZSBhbmQgdmFsaWQgdGV4dCBpcyBoeXBlcmxpbmtlZCwgcHJldmVudGluZyBjYXNlcyB3aGVyZSBhIHZhbGlkXG4gKiB0b3AtbGV2ZWwgZG9tYWluIChUTEQpIGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIGludmFsaWQgY2hhcmFjdGVyLCBsaWtlIGEgbnVtYmVyLiBGb3JcbiAqIGV4YW1wbGUsIHdpdGggdGhlIGBmaW5kYCBtZXRob2QgZnJvbSBMaW5raWZ5LCBlbnRlcmluZyBgZXhhbXBsZS5jb20xYCB3b3VsZCByZXN1bHQgaW5cbiAqIGBleGFtcGxlLmNvbWAgYmVpbmcgbGlua2VkIGFuZCB0aGUgdHJhaWxpbmcgYDFgIGxlZnQgYXMgcGxhaW4gdGV4dC4gQnkgdXNpbmcgdGhlIGB0b2tlbml6ZWBcbiAqIG1ldGhvZCwgd2UgY2FuIHBlcmZvcm0gbW9yZSBjb21wcmVoZW5zaXZlIHZhbGlkYXRpb24gb24gdGhlIGlucHV0IHRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRMaW5rU3RydWN0dXJlKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnNbMF0uaXNMaW5rO1xuICAgIH1cbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMyAmJiB0b2tlbnNbMV0uaXNMaW5rKSB7XG4gICAgICAgIHJldHVybiBbJygpJywgJ1tdJ10uaW5jbHVkZXModG9rZW5zWzBdLnZhbHVlICsgdG9rZW5zWzJdLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBUaGlzIHBsdWdpbiBhbGxvd3MgeW91IHRvIGF1dG9tYXRpY2FsbHkgYWRkIGxpbmtzIHRvIHlvdXIgZWRpdG9yLlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIHBsdWdpbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgcGx1Z2luIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGF1dG9saW5rKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnYXV0b2xpbmsnKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEb2VzIHRoZSB0cmFuc2FjdGlvbiBjaGFuZ2UgdGhlIGRvY3VtZW50P1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcmV2ZW50IGF1dG9saW5rIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBub3QgYSBkb2N1bWVudCBjaGFuZ2Ugb3IgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyB0aGUgbWV0YSBgcHJldmVudEF1dG9saW5rYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJldmVudEF1dG9saW5rID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudEF1dG9saW5rJykpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcmV2ZW50IGF1dG9saW5rIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBub3QgYSBkb2N1bWVudCBjaGFuZ2VcbiAgICAgICAgICAgICAqIG9yIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgdGhlIG1ldGEgYHByZXZlbnRBdXRvbGlua2AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghZG9jQ2hhbmdlcyB8fCBwcmV2ZW50QXV0b2xpbmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRyIH0gPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZFN0YXRlLmRvYywgWy4uLnRyYW5zYWN0aW9uc10pO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaCgoeyBuZXdSYW5nZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm93IGxldOKAmXMgc2VlIGlmIHdlIGNhbiBhZGQgbmV3IGxpbmtzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzID0gZmluZENoaWxkcmVuSW5SYW5nZShuZXdTdGF0ZS5kb2MsIG5ld1JhbmdlLCBub2RlID0+IG5vZGUuaXNUZXh0YmxvY2spO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0QmxvY2s7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRCZWZvcmVXaGl0ZXNwYWNlO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgdGhlIGZpcnN0IG5vZGUgd2l0aGluIHRoZSBjaGFuZ2VkIHJhbmdlcyAoZXguIHRoZSBmaXJzdCBvZiB0d28gcGFyYWdyYXBocyB3aGVuIGhpdHRpbmcgZW50ZXIpLlxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmxvY2sgPSBub2Rlc0luQ2hhbmdlZFJhbmdlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJlZm9yZVdoaXRlc3BhY2UgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4odGV4dEJsb2NrLnBvcywgdGV4dEJsb2NrLnBvcyArIHRleHRCbG9jay5ub2RlLm5vZGVTaXplLCB1bmRlZmluZWQsICcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVzSW5DaGFuZ2VkUmFuZ2VzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHRoZSBibG9jayBzZXBlcmF0b3IgYXJndW1lbnQgdG8gdHJlYXQgaGFyZCBicmVha3MgbGlrZSBzcGFjZXMuXG4gICAgICAgICAgICAgICAgICAgICYmIG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbihuZXdSYW5nZS5mcm9tLCBuZXdSYW5nZS50bywgJyAnLCAnICcpLmVuZHNXaXRoKCcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJsb2NrID0gbm9kZXNJbkNoYW5nZWRSYW5nZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKHRleHRCbG9jay5wb3MsIG5ld1JhbmdlLnRvLCB1bmRlZmluZWQsICcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0QmxvY2sgJiYgdGV4dEJlZm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29yZHNCZWZvcmVXaGl0ZXNwYWNlID0gdGV4dEJlZm9yZVdoaXRlc3BhY2Uuc3BsaXQoJyAnKS5maWx0ZXIocyA9PiBzICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3Jkc0JlZm9yZVdoaXRlc3BhY2UubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0V29yZEJlZm9yZVNwYWNlID0gd29yZHNCZWZvcmVXaGl0ZXNwYWNlW3dvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFdvcmRBbmRCbG9ja09mZnNldCA9IHRleHRCbG9jay5wb3MgKyB0ZXh0QmVmb3JlV2hpdGVzcGFjZS5sYXN0SW5kZXhPZihsYXN0V29yZEJlZm9yZVNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXN0V29yZEJlZm9yZVNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua3NCZWZvcmVTcGFjZSA9IHRva2VuaXplKGxhc3RXb3JkQmVmb3JlU3BhY2UpLm1hcCh0ID0+IHQudG9PYmplY3Qob3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkTGlua1N0cnVjdHVyZShsaW5rc0JlZm9yZVNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzQmVmb3JlU3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBsaW5rLmlzTGluaylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsaW5rIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChsaW5rID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuc3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgKyBsaW5rLmVuZCArIDEsXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGxpbmsgaW5zaWRlIGNvZGUgbWFya1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihsaW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhbmV3U3RhdGUuZG9jLnJhbmdlSGFzTWFyayhsaW5rLmZyb20sIGxpbmsudG8sIG5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRlIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBvcHRpb25zLnZhbGlkYXRlKGxpbmsudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBzaG91bGQgYXV0b2xpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBvcHRpb25zLnNob3VsZEF1dG9MaW5rKGxpbmsudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGxpbmsgbWFyay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldE1hcmtzQmV0d2VlbihsaW5rLmZyb20sIGxpbmsudG8sIG5ld1N0YXRlLmRvYykuc29tZShpdGVtID0+IGl0ZW0ubWFyay50eXBlID09PSBvcHRpb25zLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhsaW5rLmZyb20sIGxpbmsudG8sIG9wdGlvbnMudHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnaGFuZGxlQ2xpY2tMaW5rJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVDbGljazogKHZpZXcsIHBvcywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbHMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYS5ub2RlTmFtZSAhPT0gJ0RJVicpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBhLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZWxzLmZpbmQodmFsdWUgPT4gdmFsdWUubm9kZU5hbWUgPT09ICdBJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IGdldEF0dHJpYnV0ZXModmlldy5zdGF0ZSwgb3B0aW9ucy50eXBlLm5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IChfYSA9IGxpbmsgPT09IG51bGwgfHwgbGluayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGluay5ocmVmKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhdHRycy5ocmVmO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChfYiA9IGxpbmsgPT09IG51bGwgfHwgbGluayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGluay50YXJnZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGF0dHJzLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAobGluayAmJiBocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXN0ZUhhbmRsZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdoYW5kbGVQYXN0ZUxpbmsnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZVBhc3RlOiAodmlldywgZXZlbnQsIHNsaWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgIHNsaWNlLmNvbnRlbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gZmluZCh0ZXh0Q29udGVudCwgeyBkZWZhdWx0UHJvdG9jb2w6IG9wdGlvbnMuZGVmYXVsdFByb3RvY29sIH0pLmZpbmQoaXRlbSA9PiBpdGVtLmlzTGluayAmJiBpdGVtLnZhbHVlID09PSB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCAhbGluaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVkaXRvci5jb21tYW5kcy5zZXRNYXJrKG9wdGlvbnMudHlwZSwge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBsaW5rLmhyZWYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5jb25zdCBwYXN0ZVJlZ2V4ID0gL2h0dHBzPzpcXC9cXC8oPzp3d3dcXC4pP1stYS16QS1aMC05QDolLl8rfiM9XXsxLDI1Nn1cXC5bYS16QS1aXXsyLH1cXGIoPzpbLWEtekEtWjAtOUA6JS5fK34jPT8hJi9dKikoPzpbLWEtekEtWjAtOUA6JS5fK34jPT8hJi9dKikvZ2k7XG4vLyBGcm9tIERPTVB1cmlmeVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi9tYWluL3NyYy9yZWdleHAuanNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCBBVFRSX1dISVRFU1BBQ0UgPSAvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nO1xuZnVuY3Rpb24gaXNBbGxvd2VkVXJpKHVyaSwgcHJvdG9jb2xzKSB7XG4gICAgY29uc3QgYWxsb3dlZFByb3RvY29scyA9IFtcbiAgICAgICAgJ2h0dHAnLFxuICAgICAgICAnaHR0cHMnLFxuICAgICAgICAnZnRwJyxcbiAgICAgICAgJ2Z0cHMnLFxuICAgICAgICAnbWFpbHRvJyxcbiAgICAgICAgJ3RlbCcsXG4gICAgICAgICdjYWxsdG8nLFxuICAgICAgICAnc21zJyxcbiAgICAgICAgJ2NpZCcsXG4gICAgICAgICd4bXBwJyxcbiAgICBdO1xuICAgIGlmIChwcm90b2NvbHMpIHtcbiAgICAgICAgcHJvdG9jb2xzLmZvckVhY2gocHJvdG9jb2wgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dFByb3RvY29sID0gdHlwZW9mIHByb3RvY29sID09PSAnc3RyaW5nJyA/IHByb3RvY29sIDogcHJvdG9jb2wuc2NoZW1lO1xuICAgICAgICAgICAgaWYgKG5leHRQcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRQcm90b2NvbHMucHVzaChuZXh0UHJvdG9jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICghdXJpXG4gICAgICAgIHx8IHVyaVxuICAgICAgICAgICAgLnJlcGxhY2UoQVRUUl9XSElURVNQQUNFLCAnJylcbiAgICAgICAgICAgIC5tYXRjaChuZXcgUmVnRXhwKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgICAgYF4oPzooPzoke2FsbG93ZWRQcm90b2NvbHMuam9pbignfCcpfSk6fFteYS16XXxbYS16MC05Ky5cXC1dKyg/OlteYS16Ky5cXC06XXwkKSlgLCAnaScpKSk7XG59XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGxpbmtzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9tYXJrcy9saW5rXG4gKi9cbmNvbnN0IExpbmsgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2xpbmsnLFxuICAgIHByaW9yaXR5OiAxMDAwLFxuICAgIGtlZXBPblNwbGl0OiBmYWxzZSxcbiAgICBleGl0YWJsZTogdHJ1ZSxcbiAgICBvbkNyZWF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWxpZGF0ZSAmJiAhdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rKSB7XG4gICAgICAgICAgICAvLyBDb3B5IHRoZSB2YWxpZGF0ZSBmdW5jdGlvbiB0byB0aGUgc2hvdWxkQXV0b0xpbmsgb3B0aW9uXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmsgPSB0aGlzLm9wdGlvbnMudmFsaWRhdGU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBgdmFsaWRhdGVgIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBSZW5hbWUgdG8gdGhlIGBzaG91bGRBdXRvTGlua2Agb3B0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnByb3RvY29scy5mb3JFYWNoKHByb3RvY29sID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbC5zY2hlbWUsIHByb3RvY29sLm9wdGlvbmFsU2xhc2hlcyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgb25EZXN0cm95KCkge1xuICAgICAgICByZXNldCgpO1xuICAgIH0sXG4gICAgaW5jbHVzaXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmF1dG9saW5rO1xuICAgIH0sXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZW5PbkNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgbGlua09uUGFzdGU6IHRydWUsXG4gICAgICAgICAgICBhdXRvbGluazogdHJ1ZSxcbiAgICAgICAgICAgIHByb3RvY29sczogW10sXG4gICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6ICdodHRwJyxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJyxcbiAgICAgICAgICAgICAgICByZWw6ICdub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93JyxcbiAgICAgICAgICAgICAgICBjbGFzczogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0FsbG93ZWRVcmk6ICh1cmwsIGN0eCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCBjdHgucHJvdG9jb2xzKSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB1cmwgPT4gISF1cmwsXG4gICAgICAgICAgICBzaG91bGRBdXRvTGluazogdXJsID0+ICEhdXJsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnRhcmdldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWw6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMucmVsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLmNsYXNzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdhW2hyZWZdJyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogZG9tID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBYU1MgYXR0YWNrc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhyZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IHVybCA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgLy8gcHJldmVudCBYU1MgYXR0YWNrc1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoSFRNTEF0dHJpYnV0ZXMuaHJlZiwge1xuICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiBocmVmID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgLy8gc3RyaXAgb3V0IHRoZSBocmVmXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCB7IC4uLkhUTUxBdHRyaWJ1dGVzLCBocmVmOiAnJyB9KSxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydhJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0TGluazogYXR0cmlidXRlcyA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBocmVmIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogdXJsID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgdGhpcy5vcHRpb25zLnByb3RvY29scyksXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKCkuc2V0TWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpLnJ1bigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUxpbms6IGF0dHJpYnV0ZXMgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IHVybCA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgICAgICAgIC50b2dnbGVNYXJrKHRoaXMubmFtZSwgYXR0cmlidXRlcywgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgncHJldmVudEF1dG9saW5rJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0TGluazogKCkgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgICAgICAgIC51bnNldE1hcmsodGhpcy5uYW1lLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAucnVuKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZExpbmtzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHByb3RvY29scywgZGVmYXVsdFByb3RvY29sIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rcyA9IGZpbmQodGV4dCkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pc0xpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGl0ZW0udmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiBocmVmID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHByb3RvY29scyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGxpbmsgPT4gZm91bmRMaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGluay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbGluay5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kTGlua3M7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoX2EgPSBtYXRjaC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBwcm90b2NvbHMsIGRlZmF1bHRQcm90b2NvbCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9saW5rKSB7XG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goYXV0b2xpbmsoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGU6IHVybCA9PiB0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKHVybCwge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IGhyZWYgPT4gISFpc0FsbG93ZWRVcmkoaHJlZiwgcHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgc2hvdWxkQXV0b0xpbms6IHRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGluayxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9wZW5PbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goY2xpY2tIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5rT25QYXN0ZSkge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBhc3RlSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgTGluaywgTGluayBhcyBkZWZhdWx0LCBpc0FsbG93ZWRVcmksIHBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-link/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ Strike),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nconst inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nconst pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nconst Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'strike',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 's',\n            },\n            {\n                tag: 'del',\n            },\n            {\n                tag: 'strike',\n            },\n            {\n                style: 'text-decoration',\n                consuming: false,\n                getAttrs: style => (style.includes('line-through') ? {} : false),\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['s', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setStrike: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleStrike: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetStrike: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxxQkFBcUIsNkRBQWU7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLGFBQWE7QUFDYixtQ0FBbUMsVUFBVTtBQUM3QztBQUNBLGFBQWE7QUFDYixrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFNEQ7QUFDN0QiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxleHRlbnNpb24tc3RyaWtlXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIE1hdGNoZXMgYSBzdHJpa2UgdG8gYSB+fnN0cmlrZX5+IG9uIGlucHV0LlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSh+fig/IVxccyt+fikoKD86W15+XSspKX5+KD8hXFxzK35+KSkkLztcbi8qKlxuICogTWF0Y2hlcyBhIHN0cmlrZSB0byBhIH5+c3RyaWtlfn4gb24gcGFzdGUuXG4gKi9cbmNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKS9nO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBzdHJpa2UgdGV4dC5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3Mvc3RyaWtlXG4gKi9cbmNvbnN0IFN0cmlrZSA9IE1hcmsuY3JlYXRlKHtcbiAgICBuYW1lOiAnc3RyaWtlJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdkZWwnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdzdHJpa2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3RleHQtZGVjb3JhdGlvbicsXG4gICAgICAgICAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogc3R5bGUgPT4gKHN0eWxlLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKSA/IHt9IDogZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3MnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLVNoaWZ0LXMnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdHJpa2UoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBTdHJpa2UsIFN0cmlrZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4LCBwYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-strike/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-table-cell/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-table-cell/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableCell: () => (/* binding */ TableCell),\n/* harmony export */   \"default\": () => (/* binding */ TableCell)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create table cells.\n * @see https://www.tiptap.dev/api/nodes/table-cell\n */\nconst TableCell = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'tableCell',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: 'block+',\n    addAttributes() {\n        return {\n            colspan: {\n                default: 1,\n            },\n            rowspan: {\n                default: 1,\n            },\n            colwidth: {\n                default: null,\n                parseHTML: element => {\n                    const colwidth = element.getAttribute('colwidth');\n                    const value = colwidth\n                        ? colwidth.split(',').map(width => parseInt(width, 10))\n                        : null;\n                    return value;\n                },\n            },\n        };\n    },\n    tableRole: 'cell',\n    isolating: true,\n    parseHTML() {\n        return [\n            { tag: 'td' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['td', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS1jZWxsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMsc0JBQXNCLDZEQUFlO0FBQ3JDLEtBQUs7QUFDTCxDQUFDOztBQUUwQztBQUMzQyIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXGV4dGVuc2lvbi10YWJsZS1jZWxsXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRhYmxlIGNlbGxzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy90YWJsZS1jZWxsXG4gKi9cbmNvbnN0IFRhYmxlQ2VsbCA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAndGFibGVDZWxsJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHNwYW46IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvd3NwYW46IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbHdpZHRoOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2x3aWR0aCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb2x3aWR0aCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbHdpZHRoLnNwbGl0KCcsJykubWFwKHdpZHRoID0+IHBhcnNlSW50KHdpZHRoLCAxMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlUm9sZTogJ2NlbGwnLFxuICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHRhZzogJ3RkJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsndGQnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgVGFibGVDZWxsLCBUYWJsZUNlbGwgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-table-cell/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-table-header/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-table-header/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableHeader: () => (/* binding */ TableHeader),\n/* harmony export */   \"default\": () => (/* binding */ TableHeader)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create table headers.\n * @see https://www.tiptap.dev/api/nodes/table-header\n */\nconst TableHeader = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'tableHeader',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: 'block+',\n    addAttributes() {\n        return {\n            colspan: {\n                default: 1,\n            },\n            rowspan: {\n                default: 1,\n            },\n            colwidth: {\n                default: null,\n                parseHTML: element => {\n                    const colwidth = element.getAttribute('colwidth');\n                    const value = colwidth\n                        ? colwidth.split(',').map(width => parseInt(width, 10))\n                        : null;\n                    return value;\n                },\n            },\n        };\n    },\n    tableRole: 'header_cell',\n    isolating: true,\n    parseHTML() {\n        return [\n            { tag: 'th' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['th', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS1oZWFkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMLENBQUM7O0FBRThDO0FBQy9DIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxcZXh0ZW5zaW9uLXRhYmxlLWhlYWRlclxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0YWJsZSBoZWFkZXJzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy90YWJsZS1oZWFkZXJcbiAqL1xuY29uc3QgVGFibGVIZWFkZXIgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3RhYmxlSGVhZGVyJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHNwYW46IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvd3NwYW46IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbHdpZHRoOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2x3aWR0aCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb2x3aWR0aCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbHdpZHRoLnNwbGl0KCcsJykubWFwKHdpZHRoID0+IHBhcnNlSW50KHdpZHRoLCAxMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlUm9sZTogJ2hlYWRlcl9jZWxsJyxcbiAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0YWc6ICd0aCcgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3RoJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFRhYmxlSGVhZGVyLCBUYWJsZUhlYWRlciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-table-header/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-table-row/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-table-row/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TableRow: () => (/* binding */ TableRow),\n/* harmony export */   \"default\": () => (/* binding */ TableRow)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create table rows.\n * @see https://www.tiptap.dev/api/nodes/table-row\n */\nconst TableRow = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'tableRow',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: '(tableCell | tableHeader)*',\n    tableRole: 'row',\n    parseHTML() {\n        return [\n            { tag: 'tr' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['tr', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS1yb3cvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLHNCQUFzQiw2REFBZTtBQUNyQyxLQUFLO0FBQ0wsQ0FBQzs7QUFFd0M7QUFDekMiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxleHRlbnNpb24tdGFibGUtcm93XFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRhYmxlIHJvd3MuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RhYmxlLXJvd1xuICovXG5jb25zdCBUYWJsZVJvdyA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAndGFibGVSb3cnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb250ZW50OiAnKHRhYmxlQ2VsbCB8IHRhYmxlSGVhZGVyKSonLFxuICAgIHRhYmxlUm9sZTogJ3JvdycsXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0YWc6ICd0cicgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3RyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFRhYmxlUm93LCBUYWJsZVJvdyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-table-row/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nconst Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'text',\n    group: 'inline',\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQUk7QUFDakI7QUFDQTtBQUNBLENBQUM7O0FBRWdDO0FBQ2pDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxcZXh0ZW5zaW9uLXRleHRcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRleHQgbm9kZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RleHRcbiAqL1xuY29uc3QgVGV4dCA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAndGV4dCcsXG4gICAgZ3JvdXA6ICdpbmxpbmUnLFxufSk7XG5cbmV4cG9ydCB7IFRleHQsIFRleHQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-text/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-underline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-underline/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Underline: () => (/* binding */ Underline),\n/* harmony export */   \"default\": () => (/* binding */ Underline)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */\nconst Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'underline',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'u',\n            },\n            {\n                style: 'text-decoration',\n                consuming: false,\n                getAttrs: style => (style.includes('underline') ? {} : false),\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['u', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setUnderline: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleUnderline: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetUnderline: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-u': () => this.editor.commands.toggleUnderline(),\n            'Mod-U': () => this.editor.commands.toggleUnderline(),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMscUJBQXFCLDZEQUFlO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQSxhQUFhO0FBQ2Isc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQSxhQUFhO0FBQ2IscUNBQXFDLFVBQVU7QUFDL0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUUwQztBQUMzQyIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXGV4dGVuc2lvbi11bmRlcmxpbmVcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgdW5kZXJsaW5lIHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3VuZGVybGluZVxuICovXG5jb25zdCBVbmRlcmxpbmUgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3VuZGVybGluZScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICd1JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAgICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IHN0eWxlID0+IChzdHlsZS5pbmNsdWRlcygndW5kZXJsaW5lJykgPyB7fSA6IGZhbHNlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWyd1JywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC11JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKCksXG4gICAgICAgICAgICAnTW9kLVUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFVuZGVybGluZSwgVW5kZXJsaW5lIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-underline/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/commands/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/commands/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(app-pages-browser)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2NvbW1hbmRzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDcUMiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxAdGlwdGFwXFxwbVxcY29tbWFuZHNcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbW1hbmRzL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/commands/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/gapcursor/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/gapcursor/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(app-pages-browser)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2dhcGN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3NDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxccG1cXGdhcGN1cnNvclxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2FwY3Vyc29yL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItZ2FwY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/history/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/history/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(app-pages-browser)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2hpc3RvcnkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNvQyIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXHBtXFxoaXN0b3J5XFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBoaXN0b3J5L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItaGlzdG9yeVwiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/history/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/keymap/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/keymap/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2tleW1hcC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ21DIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxccG1cXGtleW1hcFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8ga2V5bWFwL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/keymap/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/model/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/model/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL21vZGVsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNrQyIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXHBtXFxtb2RlbFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9kZWwvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/model/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/schema-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/schema-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(app-pages-browser)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3NjaGVtYS1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QyIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXHBtXFxzY2hlbWEtbGlzdFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2NoZW1hLWxpc3QvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1zY2hlbWEtbGlzdFwiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/schema-list/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/state/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3N0YXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2tDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxccG1cXHN0YXRlXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/transform/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/transform/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3RyYW5zZm9ybS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxccG1cXHRyYW5zZm9ybVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNmb3JtL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/transform/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/view/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/view/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3ZpZXcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNpQyIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXEB0aXB0YXBcXHBtXFx2aWV3XFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aWV3L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/view/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.CommandManager),\n/* harmony export */   Editor: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension),\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.InputRule),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactNodeView: () => (/* binding */ ReactNodeView),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createDocument),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isActive),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textblockTypeInputRule),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorState: () => (/* binding */ useEditorState),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-bubble-menu */ \"(app-pages-browser)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-floating-menu */ \"(app-pages-browser)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\");\n\n\n\n\n\n\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar shim = {exports: {}};\n\nvar useSyncExternalStoreShim_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_production_min;\n\nfunction requireUseSyncExternalStoreShim_production_min () {\n\tif (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;\n\thasRequiredUseSyncExternalStoreShim_production_min = 1;\nvar e=react__WEBPACK_IMPORTED_MODULE_0__;function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c});},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c});})},[a]);p(d);return d}\n\tfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return !k(a,d)}catch(f){return !0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;useSyncExternalStoreShim_production_min.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n\treturn useSyncExternalStoreShim_production_min;\n}\n\nvar useSyncExternalStoreShim_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_development;\n\nfunction requireUseSyncExternalStoreShim_development () {\n\tif (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;\n\thasRequiredUseSyncExternalStoreShim_development = 1;\n\n\tif (true) {\n\t  (function() {\n\n\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t}\n\t          var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n\n\tvar ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n\tfunction error(format) {\n\t  {\n\t    {\n\t      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t        args[_key2 - 1] = arguments[_key2];\n\t      }\n\n\t      printWarning('error', format, args);\n\t    }\n\t  }\n\t}\n\n\tfunction printWarning(level, format, args) {\n\t  // When changing this logic, you might want to also\n\t  // update consoleWithStackDev.www.js as well.\n\t  {\n\t    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\t    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n\t    if (stack !== '') {\n\t      format += '%s';\n\t      args = args.concat([stack]);\n\t    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n\t    var argsWithFormat = args.map(function (item) {\n\t      return String(item);\n\t    }); // Careful: RN currently depends on this prefix\n\n\t    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n\t    // breaks IE9: https://github.com/facebook/react/issues/13610\n\t    // eslint-disable-next-line react-internal/no-production-logging\n\n\t    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\t  }\n\t}\n\n\t/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */\n\tfunction is(x, y) {\n\t  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n\t  ;\n\t}\n\n\tvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n\t// dispatch for CommonJS interop named imports.\n\n\tvar useState = React$1.useState,\n\t    useEffect = React$1.useEffect,\n\t    useLayoutEffect = React$1.useLayoutEffect,\n\t    useDebugValue = React$1.useDebugValue;\n\tvar didWarnOld18Alpha = false;\n\tvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n\t// because of a very particular set of implementation details and assumptions\n\t// -- change any one of them and it will break. The most important assumption\n\t// is that updates are always synchronous, because concurrent rendering is\n\t// only available in versions of React that also have a built-in\n\t// useSyncExternalStore API. And we only use this shim when the built-in API\n\t// does not exist.\n\t//\n\t// Do not assume that the clever hacks used by this hook also work in general.\n\t// The point of this shim is to replace the need for hacks by other libraries.\n\n\tfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n\t// React do not expose a way to check if we're hydrating. So users of the shim\n\t// will need to track that themselves and return the correct value\n\t// from `getSnapshot`.\n\tgetServerSnapshot) {\n\t  {\n\t    if (!didWarnOld18Alpha) {\n\t      if (React$1.startTransition !== undefined) {\n\t        didWarnOld18Alpha = true;\n\n\t        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n\t      }\n\t    }\n\t  } // Read the current snapshot from the store on every render. Again, this\n\t  // breaks the rules of React, and only works here because of specific\n\t  // implementation details, most importantly that updates are\n\t  // always synchronous.\n\n\n\t  var value = getSnapshot();\n\n\t  {\n\t    if (!didWarnUncachedGetSnapshot) {\n\t      var cachedValue = getSnapshot();\n\n\t      if (!objectIs(value, cachedValue)) {\n\t        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n\t        didWarnUncachedGetSnapshot = true;\n\t      }\n\t    }\n\t  } // Because updates are synchronous, we don't queue them. Instead we force a\n\t  // re-render whenever the subscribed state changes by updating an some\n\t  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n\t  // the current value.\n\t  //\n\t  // Because we don't actually use the state returned by the useState hook, we\n\t  // can save a bit of memory by storing other stuff in that slot.\n\t  //\n\t  // To implement the early bailout, we need to track some things on a mutable\n\t  // object. Usually, we would put that in a useRef hook, but we can stash it in\n\t  // our useState hook instead.\n\t  //\n\t  // To force a re-render, we call forceUpdate({inst}). That works because the\n\t  // new object always fails an equality check.\n\n\n\t  var _useState = useState({\n\t    inst: {\n\t      value: value,\n\t      getSnapshot: getSnapshot\n\t    }\n\t  }),\n\t      inst = _useState[0].inst,\n\t      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n\t  // in the layout phase so we can access it during the tearing check that\n\t  // happens on subscribe.\n\n\n\t  useLayoutEffect(function () {\n\t    inst.value = value;\n\t    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n\t    // commit phase if there was an interleaved mutation. In concurrent mode\n\t    // this can happen all the time, but even in synchronous mode, an earlier\n\t    // effect may have mutated the store.\n\n\t    if (checkIfSnapshotChanged(inst)) {\n\t      // Force a re-render.\n\t      forceUpdate({\n\t        inst: inst\n\t      });\n\t    }\n\t  }, [subscribe, value, getSnapshot]);\n\t  useEffect(function () {\n\t    // Check for changes right before subscribing. Subsequent changes will be\n\t    // detected in the subscription handler.\n\t    if (checkIfSnapshotChanged(inst)) {\n\t      // Force a re-render.\n\t      forceUpdate({\n\t        inst: inst\n\t      });\n\t    }\n\n\t    var handleStoreChange = function () {\n\t      // TODO: Because there is no cross-renderer API for batching updates, it's\n\t      // up to the consumer of this library to wrap their subscription event\n\t      // with unstable_batchedUpdates. Should we try to detect when this isn't\n\t      // the case and print a warning in development?\n\t      // The store changed. Check if the snapshot changed since the last time we\n\t      // read from the store.\n\t      if (checkIfSnapshotChanged(inst)) {\n\t        // Force a re-render.\n\t        forceUpdate({\n\t          inst: inst\n\t        });\n\t      }\n\t    }; // Subscribe to the store and return a clean-up function.\n\n\n\t    return subscribe(handleStoreChange);\n\t  }, [subscribe]);\n\t  useDebugValue(value);\n\t  return value;\n\t}\n\n\tfunction checkIfSnapshotChanged(inst) {\n\t  var latestGetSnapshot = inst.getSnapshot;\n\t  var prevValue = inst.value;\n\n\t  try {\n\t    var nextValue = latestGetSnapshot();\n\t    return !objectIs(prevValue, nextValue);\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t}\n\n\tfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n\t  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n\t  // React do not expose a way to check if we're hydrating. So users of the shim\n\t  // will need to track that themselves and return the correct value\n\t  // from `getSnapshot`.\n\t  return getSnapshot();\n\t}\n\n\tvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\n\tvar isServerEnvironment = !canUseDOM;\n\n\tvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n\tvar useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;\n\n\tuseSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;\n\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t}\n\t        \n\t  })();\n\t}\n\treturn useSyncExternalStoreShim_development;\n}\n\nif (false) {} else {\n  shim.exports = requireUseSyncExternalStoreShim_development();\n}\n\nvar shimExports = shim.exports;\n\nconst mergeRefs = (...refs) => {\n    return (node) => {\n        refs.forEach(ref => {\n            if (typeof ref === 'function') {\n                ref(node);\n            }\n            else if (ref) {\n                ref.current = node;\n            }\n        });\n    };\n};\n/**\n * This component renders all of the editor's node views.\n */\nconst Portals = ({ contentComponent, }) => {\n    // For performance reasons, we render the node view portals on state changes only\n    const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n    // This allows us to directly render the portals without any additional wrapper\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Object.values(renderers)));\n};\nfunction getInstance() {\n    const subscribers = new Set();\n    let renderers = {};\n    return {\n        /**\n         * Subscribe to the editor instance's changes.\n         */\n        subscribe(callback) {\n            subscribers.add(callback);\n            return () => {\n                subscribers.delete(callback);\n            };\n        },\n        getSnapshot() {\n            return renderers;\n        },\n        getServerSnapshot() {\n            return renderers;\n        },\n        /**\n         * Adds a new NodeView Renderer to the editor.\n         */\n        setRenderer(id, renderer) {\n            renderers = {\n                ...renderers,\n                [id]: react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id),\n            };\n            subscribers.forEach(subscriber => subscriber());\n        },\n        /**\n         * Removes a NodeView Renderer from the editor.\n         */\n        removeRenderer(id) {\n            const nextRenderers = { ...renderers };\n            delete nextRenderers[id];\n            renderers = nextRenderers;\n            subscribers.forEach(subscriber => subscriber());\n        },\n    };\n}\nclass PureEditorContent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props) {\n        var _a;\n        super(props);\n        this.editorContentRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.initialized = false;\n        this.state = {\n            hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent),\n        };\n    }\n    componentDidMount() {\n        this.init();\n    }\n    componentDidUpdate() {\n        this.init();\n    }\n    init() {\n        const editor = this.props.editor;\n        if (editor && !editor.isDestroyed && editor.options.element) {\n            if (editor.contentComponent) {\n                return;\n            }\n            const element = this.editorContentRef.current;\n            element.append(...editor.options.element.childNodes);\n            editor.setOptions({\n                element,\n            });\n            editor.contentComponent = getInstance();\n            // Has the content component been initialized?\n            if (!this.state.hasContentComponentInitialized) {\n                // Subscribe to the content component\n                this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n                    this.setState(prevState => {\n                        if (!prevState.hasContentComponentInitialized) {\n                            return {\n                                hasContentComponentInitialized: true,\n                            };\n                        }\n                        return prevState;\n                    });\n                    // Unsubscribe to previous content component\n                    if (this.unsubscribeToContentComponent) {\n                        this.unsubscribeToContentComponent();\n                    }\n                });\n            }\n            editor.createNodeViews();\n            this.initialized = true;\n        }\n    }\n    componentWillUnmount() {\n        const editor = this.props.editor;\n        if (!editor) {\n            return;\n        }\n        this.initialized = false;\n        if (!editor.isDestroyed) {\n            editor.view.setProps({\n                nodeViews: {},\n            });\n        }\n        if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n        }\n        editor.contentComponent = null;\n        if (!editor.options.element.firstChild) {\n            return;\n        }\n        const newElement = document.createElement('div');\n        newElement.append(...editor.options.element.childNodes);\n        editor.setOptions({\n            element: newElement,\n        });\n    }\n    render() {\n        const { editor, innerRef, ...rest } = this.props;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),\n            (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portals, { contentComponent: editor.contentComponent })));\n    }\n}\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return Math.floor(Math.random() * 0xffffffff).toString();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.editor]);\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n        key,\n        innerRef: ref,\n        ...props,\n    });\n});\nconst EditorContent = react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\n\nvar react = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (key === '_owner' && a.$$typeof) {\n        // React-specific: avoid traversing React elements' _owner.\n        //  _owner contains circular references\n        // and is not needed when comparing the actual elements (and not their owners)\n        continue;\n      }\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\nvar deepEqual = /*@__PURE__*/getDefaultExportFromCjs(react);\n\nvar withSelector = {exports: {}};\n\nvar withSelector_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_production_min;\n\nfunction requireWithSelector_production_min () {\n\tif (hasRequiredWithSelector_production_min) return withSelector_production_min;\n\thasRequiredWithSelector_production_min = 1;\nvar h=react__WEBPACK_IMPORTED_MODULE_0__,n=shimExports;function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\n\twithSelector_production_min.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f;}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return [function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\n\tu(function(){f.hasValue=!0;f.value=d;},[d]);w(d);return d};\n\treturn withSelector_production_min;\n}\n\nvar withSelector_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_development;\n\nfunction requireWithSelector_development () {\n\tif (hasRequiredWithSelector_development) return withSelector_development;\n\thasRequiredWithSelector_development = 1;\n\n\tif (true) {\n\t  (function() {\n\n\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t}\n\t          var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n\tvar shim = shimExports;\n\n\t/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */\n\tfunction is(x, y) {\n\t  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n\t  ;\n\t}\n\n\tvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n\tvar useSyncExternalStore = shim.useSyncExternalStore;\n\n\t// for CommonJS interop.\n\n\tvar useRef = React$1.useRef,\n\t    useEffect = React$1.useEffect,\n\t    useMemo = React$1.useMemo,\n\t    useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\n\tfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n\t  // Use this to track the rendered snapshot.\n\t  var instRef = useRef(null);\n\t  var inst;\n\n\t  if (instRef.current === null) {\n\t    inst = {\n\t      hasValue: false,\n\t      value: null\n\t    };\n\t    instRef.current = inst;\n\t  } else {\n\t    inst = instRef.current;\n\t  }\n\n\t  var _useMemo = useMemo(function () {\n\t    // Track the memoized state using closure variables that are local to this\n\t    // memoized instance of a getSnapshot function. Intentionally not using a\n\t    // useRef hook, because that state would be shared across all concurrent\n\t    // copies of the hook/component.\n\t    var hasMemo = false;\n\t    var memoizedSnapshot;\n\t    var memoizedSelection;\n\n\t    var memoizedSelector = function (nextSnapshot) {\n\t      if (!hasMemo) {\n\t        // The first time the hook is called, there is no memoized result.\n\t        hasMemo = true;\n\t        memoizedSnapshot = nextSnapshot;\n\n\t        var _nextSelection = selector(nextSnapshot);\n\n\t        if (isEqual !== undefined) {\n\t          // Even if the selector has changed, the currently rendered selection\n\t          // may be equal to the new selection. We should attempt to reuse the\n\t          // current value if possible, to preserve downstream memoizations.\n\t          if (inst.hasValue) {\n\t            var currentSelection = inst.value;\n\n\t            if (isEqual(currentSelection, _nextSelection)) {\n\t              memoizedSelection = currentSelection;\n\t              return currentSelection;\n\t            }\n\t          }\n\t        }\n\n\t        memoizedSelection = _nextSelection;\n\t        return _nextSelection;\n\t      } // We may be able to reuse the previous invocation's result.\n\n\n\t      // We may be able to reuse the previous invocation's result.\n\t      var prevSnapshot = memoizedSnapshot;\n\t      var prevSelection = memoizedSelection;\n\n\t      if (objectIs(prevSnapshot, nextSnapshot)) {\n\t        // The snapshot is the same as last time. Reuse the previous selection.\n\t        return prevSelection;\n\t      } // The snapshot has changed, so we need to compute a new selection.\n\n\n\t      // The snapshot has changed, so we need to compute a new selection.\n\t      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n\t      // has changed. If it hasn't, return the previous selection. That signals\n\t      // to React that the selections are conceptually equal, and we can bail\n\t      // out of rendering.\n\n\t      // If a custom isEqual function is provided, use that to check if the data\n\t      // has changed. If it hasn't, return the previous selection. That signals\n\t      // to React that the selections are conceptually equal, and we can bail\n\t      // out of rendering.\n\t      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n\t        return prevSelection;\n\t      }\n\n\t      memoizedSnapshot = nextSnapshot;\n\t      memoizedSelection = nextSelection;\n\t      return nextSelection;\n\t    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n\t    // Assigning this to a constant so that Flow knows it can't change.\n\t    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n\t    var getSnapshotWithSelector = function () {\n\t      return memoizedSelector(getSnapshot());\n\t    };\n\n\t    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n\t      return memoizedSelector(maybeGetServerSnapshot());\n\t    };\n\t    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n\t  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n\t      getSelection = _useMemo[0],\n\t      getServerSelection = _useMemo[1];\n\n\t  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n\t  useEffect(function () {\n\t    inst.hasValue = true;\n\t    inst.value = value;\n\t  }, [value]);\n\t  useDebugValue(value);\n\t  return value;\n\t}\n\n\twithSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t}\n\t        \n\t  })();\n\t}\n\treturn withSelector_development;\n}\n\nif (false) {} else {\n  withSelector.exports = requireWithSelector_development();\n}\n\nvar withSelectorExports = withSelector.exports;\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager {\n    constructor(initialEditor) {\n        this.transactionNumber = 0;\n        this.lastTransactionNumber = 0;\n        this.subscribers = new Set();\n        this.editor = initialEditor;\n        this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };\n        this.getSnapshot = this.getSnapshot.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.watch = this.watch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n    }\n    /**\n     * Get the current editor instance.\n     */\n    getSnapshot() {\n        if (this.transactionNumber === this.lastTransactionNumber) {\n            return this.lastSnapshot;\n        }\n        this.lastTransactionNumber = this.transactionNumber;\n        this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };\n        return this.lastSnapshot;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */\n    getServerSnapshot() {\n        return { editor: null, transactionNumber: 0 };\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n        this.subscribers.add(callback);\n        return () => {\n            this.subscribers.delete(callback);\n        };\n    }\n    /**\n     * Watch the editor instance for changes.\n     */\n    watch(nextEditor) {\n        this.editor = nextEditor;\n        if (this.editor) {\n            /**\n             * This will force a re-render when the editor state changes.\n             * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n             * This could be more efficient, but it's a good trade-off for now.\n             */\n            const fn = () => {\n                this.transactionNumber += 1;\n                this.subscribers.forEach(callback => callback());\n            };\n            const currentEditor = this.editor;\n            currentEditor.on('transaction', fn);\n            return () => {\n                currentEditor.off('transaction', fn);\n            };\n        }\n        return undefined;\n    }\n}\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nfunction useEditorState(options) {\n    var _a;\n    const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorStateManager(options.editor));\n    // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);\n    useIsomorphicLayoutEffect(() => {\n        return editorStateManager.watch(options.editor);\n    }, [options.editor, editorStateManager]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n    return selectedState;\n}\n\nconst isDev = \"development\" !== 'production';\nconst isSSR = typeof window === 'undefined';\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && window.next);\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n    constructor(options) {\n        /**\n         * The current editor instance.\n         */\n        this.editor = null;\n        /**\n         * The subscriptions to notify when the editor instance\n         * has been created or destroyed.\n         */\n        this.subscriptions = new Set();\n        /**\n         * Whether the editor has been mounted.\n         */\n        this.isComponentMounted = false;\n        /**\n         * The most recent dependencies array.\n         */\n        this.previousDeps = null;\n        /**\n         * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n         */\n        this.instanceId = '';\n        this.options = options;\n        this.subscriptions = new Set();\n        this.setEditor(this.getInitialEditor());\n        this.scheduleDestroy();\n        this.getEditor = this.getEditor.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n        this.scheduleDestroy = this.scheduleDestroy.bind(this);\n        this.onRender = this.onRender.bind(this);\n        this.createEditor = this.createEditor.bind(this);\n    }\n    setEditor(editor) {\n        this.editor = editor;\n        this.instanceId = Math.random().toString(36).slice(2, 9);\n        // Notify all subscribers that the editor instance has been created\n        this.subscriptions.forEach(cb => cb());\n    }\n    getInitialEditor() {\n        if (this.options.current.immediatelyRender === undefined) {\n            if (isSSR || isNext) {\n                // TODO in the next major release, we should throw an error here\n                if (isDev) {\n                    /**\n                     * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n                     * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n                     */\n                    console.warn('Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.');\n                }\n                // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n                return null;\n            }\n            // Default to immediately rendering when client-side rendering\n            return this.createEditor();\n        }\n        if (this.options.current.immediatelyRender && isSSR && isDev) {\n            // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n            throw new Error('Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.');\n        }\n        if (this.options.current.immediatelyRender) {\n            return this.createEditor();\n        }\n        return null;\n    }\n    /**\n     * Create a new editor instance. And attach event listeners.\n     */\n    createEditor() {\n        const optionsToApply = {\n            ...this.options.current,\n            // Always call the most recent version of the callback function by default\n            onBeforeCreate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onBlur: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onCreate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onDestroy: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onFocus: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onSelectionUpdate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onTransaction: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onUpdate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onContentError: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onDrop: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onPaste: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n        };\n        const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor(optionsToApply);\n        // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n        return editor;\n    }\n    /**\n     * Get the current editor instance.\n     */\n    getEditor() {\n        return this.editor;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */\n    getServerSnapshot() {\n        return null;\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(onStoreChange) {\n        this.subscriptions.add(onStoreChange);\n        return () => {\n            this.subscriptions.delete(onStoreChange);\n        };\n    }\n    static compareOptions(a, b) {\n        return Object.keys(a).every(key => {\n            if (['onCreate', 'onBeforeCreate', 'onDestroy', 'onUpdate', 'onTransaction', 'onFocus', 'onBlur', 'onSelectionUpdate', 'onContentError', 'onDrop', 'onPaste'].includes(key)) {\n                // we don't want to compare callbacks, they are always different and only registered once\n                return true;\n            }\n            // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n            if (key === 'extensions' && a.extensions && b.extensions) {\n                if (a.extensions.length !== b.extensions.length) {\n                    return false;\n                }\n                return a.extensions.every((extension, index) => {\n                    var _a;\n                    if (extension !== ((_a = b.extensions) === null || _a === void 0 ? void 0 : _a[index])) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            if (a[key] !== b[key]) {\n                // if any of the options have changed, we should update the editor options\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * On each render, we will create, update, or destroy the editor instance.\n     * @param deps The dependencies to watch for changes\n     * @returns A cleanup function\n     */\n    onRender(deps) {\n        // The returned callback will run on each render\n        return () => {\n            this.isComponentMounted = true;\n            // Cleanup any scheduled destructions, since we are currently rendering\n            clearTimeout(this.scheduledDestructionTimeout);\n            if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n                // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n                if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n                    // But, the options are different, so we need to update the editor options\n                    // Still, this is faster than re-creating the editor\n                    this.editor.setOptions({\n                        ...this.options.current,\n                        editable: this.editor.isEditable,\n                    });\n                }\n            }\n            else {\n                // When the editor:\n                // - does not yet exist\n                // - is destroyed\n                // - the deps array changes\n                // We need to destroy the editor instance and re-initialize it\n                this.refreshEditorInstance(deps);\n            }\n            return () => {\n                this.isComponentMounted = false;\n                this.scheduleDestroy();\n            };\n        };\n    }\n    /**\n     * Recreate the editor instance if the dependencies have changed.\n     */\n    refreshEditorInstance(deps) {\n        if (this.editor && !this.editor.isDestroyed) {\n            // Editor instance already exists\n            if (this.previousDeps === null) {\n                // If lastDeps has not yet been initialized, reuse the current editor instance\n                this.previousDeps = deps;\n                return;\n            }\n            const depsAreEqual = this.previousDeps.length === deps.length\n                && this.previousDeps.every((dep, index) => dep === deps[index]);\n            if (depsAreEqual) {\n                // deps exist and are equal, no need to recreate\n                return;\n            }\n        }\n        if (this.editor && !this.editor.isDestroyed) {\n            // Destroy the editor instance if it exists\n            this.editor.destroy();\n        }\n        this.setEditor(this.createEditor());\n        // Update the lastDeps to the current deps\n        this.previousDeps = deps;\n    }\n    /**\n     * Schedule the destruction of the editor instance.\n     * This will only destroy the editor if it was not mounted on the next tick.\n     * This is to avoid destroying the editor instance when it's actually still mounted.\n     */\n    scheduleDestroy() {\n        const currentInstanceId = this.instanceId;\n        const currentEditor = this.editor;\n        // Wait two ticks to see if the component is still mounted\n        this.scheduledDestructionTimeout = setTimeout(() => {\n            if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n                // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n                if (currentEditor) {\n                    // just re-apply options as they might have changed\n                    currentEditor.setOptions(this.options.current);\n                }\n                return;\n            }\n            if (currentEditor && !currentEditor.isDestroyed) {\n                currentEditor.destroy();\n                if (this.instanceId === currentInstanceId) {\n                    this.setEditor(null);\n                }\n            }\n            // This allows the effect to run again between ticks\n            // which may save us from having to re-create the editor\n        }, 1);\n    }\n}\nfunction useEditor(options = {}, deps = []) {\n    const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    mostRecentOptions.current = options;\n    const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorInstanceManager(mostRecentOptions));\n    const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n    // This effect will handle creating/updating the editor instance\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n    // The default behavior is to re-render on each transaction\n    // This is legacy behavior that will be removed in future versions\n    useEditorState({\n        editor,\n        selector: ({ transactionNumber }) => {\n            if (options.shouldRerenderOnTransaction === false) {\n                // This will prevent the editor from re-rendering on each transaction\n                return null;\n            }\n            // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n            if (options.immediatelyRender && transactionNumber === 0) {\n                return 0;\n            }\n            return transactionNumber + 1;\n        },\n    });\n    return editor;\n}\n\nconst EditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    editor: null,\n});\nconst EditorConsumer = EditorContext.Consumer;\n/**\n * A hook to get the current editor instance.\n */\nconst useCurrentEditor = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nfunction EditorProvider({ children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions }) {\n    const editor = useEditor(editorOptions);\n    if (!editor) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContext.Provider, { value: { editor } },\n        slotBefore,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorConsumer, null, ({ editor: currentEditor }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContent, { editor: currentEditor, ...editorContainerProps }))),\n        children,\n        slotAfter));\n}\n\nconst BubbleMenu = (props) => {\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = 'bubbleMenu', editor, tippyOptions = {}, updateDelay, shouldShow = null, } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.');\n            return;\n        }\n        const plugin = (0,_tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__.BubbleMenuPlugin)({\n            updateDelay,\n            editor: menuEditor,\n            element,\n            pluginKey,\n            shouldShow,\n            tippyOptions,\n        });\n        menuEditor.registerPlugin(plugin);\n        return () => { menuEditor.unregisterPlugin(pluginKey); };\n    }, [props.editor, currentEditor, element]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));\n};\n\nconst FloatingMenu = (props) => {\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = 'floatingMenu', editor, tippyOptions = {}, shouldShow = null, } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn('FloatingMenu component is not rendered inside of an editor component or does not have editor prop.');\n            return;\n        }\n        const plugin = (0,_tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__.FloatingMenuPlugin)({\n            pluginKey,\n            editor: menuEditor,\n            element,\n            tippyOptions,\n            shouldShow,\n        });\n        menuEditor.registerPlugin(plugin);\n        return () => { menuEditor.unregisterPlugin(pluginKey); };\n    }, [\n        props.editor,\n        currentEditor,\n        element,\n    ]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));\n};\n\nconst ReactNodeViewContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    onDragStart: undefined,\n});\nconst useReactNodeView = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\n\nconst NodeViewContent = props => {\n    const Tag = props.as || 'div';\n    const { nodeViewContentRef } = useReactNodeView();\n    return (\n    // @ts-ignore\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, { ...props, ref: nodeViewContentRef, \"data-node-view-content\": \"\", style: {\n            whiteSpace: 'pre-wrap',\n            ...props.style,\n        } }));\n};\n\nconst NodeViewWrapper = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const { onDragStart } = useReactNodeView();\n    const Tag = props.as || 'div';\n    return (\n    // @ts-ignore\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, { ...props, ref: ref, \"data-node-view-wrapper\": \"\", onDragStart: onDragStart, style: {\n            whiteSpace: 'normal',\n            ...props.style,\n        } }));\n});\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component) {\n    return !!(typeof Component === 'function'\n        && Component.prototype\n        && Component.prototype.isReactComponent);\n}\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component) {\n    var _a;\n    return !!(typeof Component === 'object'\n        && ((_a = Component.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === 'Symbol(react.forward_ref)');\n}\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n*/\nclass ReactRenderer {\n    /**\n     * Immediately creates element and renders the provided React component.\n     */\n    constructor(component, { editor, props = {}, as = 'div', className = '', }) {\n        this.ref = null;\n        this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n        this.component = component;\n        this.editor = editor;\n        this.props = props;\n        this.element = document.createElement(as);\n        this.element.classList.add('react-renderer');\n        if (className) {\n            this.element.classList.add(...className.split(' '));\n        }\n        if (this.editor.isInitialized) {\n            // On first render, we need to flush the render synchronously\n            // Renders afterwards can be async, but this fixes a cursor positioning issue\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n                this.render();\n            });\n        }\n        else {\n            this.render();\n        }\n    }\n    /**\n     * Render the React component.\n     */\n    render() {\n        var _a;\n        const Component = this.component;\n        const props = this.props;\n        const editor = this.editor;\n        if (isClassComponent(Component) || isForwardRefComponent(Component)) {\n            // @ts-ignore This is a hack to make the ref work\n            props.ref = (ref) => {\n                this.ref = ref;\n            };\n        }\n        this.reactElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { ...props });\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);\n    }\n    /**\n     * Re-renders the React component with new props.\n     */\n    updateProps(props = {}) {\n        this.props = {\n            ...this.props,\n            ...props,\n        };\n        this.render();\n    }\n    /**\n     * Destroy the React component.\n     */\n    destroy() {\n        var _a;\n        const editor = this.editor;\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);\n    }\n    /**\n     * Update the attributes of the element that holds the React component.\n     */\n    updateAttributes(attributes) {\n        Object.keys(attributes).forEach(key => {\n            this.element.setAttribute(key, attributes[key]);\n        });\n    }\n}\n\nclass ReactNodeView extends _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView {\n    /**\n     * Setup the React component.\n     * Called on initialization.\n     */\n    mount() {\n        const props = {\n            editor: this.editor,\n            node: this.node,\n            decorations: this.decorations,\n            innerDecorations: this.innerDecorations,\n            view: this.view,\n            selected: false,\n            extension: this.extension,\n            HTMLAttributes: this.HTMLAttributes,\n            getPos: () => this.getPos(),\n            updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n            deleteNode: () => this.deleteNode(),\n        };\n        if (!this.component.displayName) {\n            const capitalizeFirstChar = (string) => {\n                return string.charAt(0).toUpperCase() + string.substring(1);\n            };\n            this.component.displayName = capitalizeFirstChar(this.extension.name);\n        }\n        const onDragStart = this.onDragStart.bind(this);\n        const nodeViewContentRef = element => {\n            if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n                element.appendChild(this.contentDOMElement);\n            }\n        };\n        const context = { onDragStart, nodeViewContentRef };\n        const Component = this.component;\n        // For performance reasons, we memoize the provider component\n        // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n        const ReactNodeViewProvider = react__WEBPACK_IMPORTED_MODULE_0__.memo(componentProps => {\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactNodeViewContext.Provider, { value: context }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, componentProps)));\n        });\n        ReactNodeViewProvider.displayName = 'ReactNodeView';\n        if (this.node.isLeaf) {\n            this.contentDOMElement = null;\n        }\n        else if (this.options.contentDOMElementTag) {\n            this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n        }\n        else {\n            this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div');\n        }\n        if (this.contentDOMElement) {\n            this.contentDOMElement.dataset.nodeViewContentReact = '';\n            // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n            // With this fix it seems to work fine\n            // See: https://github.com/ueberdosis/tiptap/issues/1197\n            this.contentDOMElement.style.whiteSpace = 'inherit';\n        }\n        let as = this.node.isInline ? 'span' : 'div';\n        if (this.options.as) {\n            as = this.options.as;\n        }\n        const { className = '' } = this.options;\n        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n        this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n            editor: this.editor,\n            props,\n            as,\n            className: `node-${this.node.type.name} ${className}`.trim(),\n        });\n        this.editor.on('selectionUpdate', this.handleSelectionUpdate);\n        this.updateElementAttributes();\n    }\n    /**\n     * Return the DOM element.\n     * This is the element that will be used to display the node view.\n     */\n    get dom() {\n        var _a;\n        if (this.renderer.element.firstElementChild\n            && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-node-view-wrapper'))) {\n            throw Error('Please use the NodeViewWrapper component for your node view.');\n        }\n        return this.renderer.element;\n    }\n    /**\n     * Return the content DOM element.\n     * This is the element that will be used to display the rich-text content of the node.\n     */\n    get contentDOM() {\n        if (this.node.isLeaf) {\n            return null;\n        }\n        return this.contentDOMElement;\n    }\n    /**\n     * On editor selection update, check if the node is selected.\n     * If it is, call `selectNode`, otherwise call `deselectNode`.\n     */\n    handleSelectionUpdate() {\n        const { from, to } = this.editor.state.selection;\n        const pos = this.getPos();\n        if (typeof pos !== 'number') {\n            return;\n        }\n        if (from <= pos && to >= pos + this.node.nodeSize) {\n            if (this.renderer.props.selected) {\n                return;\n            }\n            this.selectNode();\n        }\n        else {\n            if (!this.renderer.props.selected) {\n                return;\n            }\n            this.deselectNode();\n        }\n    }\n    /**\n     * On update, update the React component.\n     * To prevent unnecessary updates, the `update` option can be used.\n     */\n    update(node, decorations, innerDecorations) {\n        const rerenderComponent = (props) => {\n            this.renderer.updateProps(props);\n            if (typeof this.options.attrs === 'function') {\n                this.updateElementAttributes();\n            }\n        };\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        if (typeof this.options.update === 'function') {\n            const oldNode = this.node;\n            const oldDecorations = this.decorations;\n            const oldInnerDecorations = this.innerDecorations;\n            this.node = node;\n            this.decorations = decorations;\n            this.innerDecorations = innerDecorations;\n            return this.options.update({\n                oldNode,\n                oldDecorations,\n                newNode: node,\n                newDecorations: decorations,\n                oldInnerDecorations,\n                innerDecorations,\n                updateProps: () => rerenderComponent({ node, decorations, innerDecorations }),\n            });\n        }\n        if (node === this.node\n            && this.decorations === decorations\n            && this.innerDecorations === innerDecorations) {\n            return true;\n        }\n        this.node = node;\n        this.decorations = decorations;\n        this.innerDecorations = innerDecorations;\n        rerenderComponent({ node, decorations, innerDecorations });\n        return true;\n    }\n    /**\n     * Select the node.\n     * Add the `selected` prop and the `ProseMirror-selectednode` class.\n     */\n    selectNode() {\n        this.renderer.updateProps({\n            selected: true,\n        });\n        this.renderer.element.classList.add('ProseMirror-selectednode');\n    }\n    /**\n     * Deselect the node.\n     * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n     */\n    deselectNode() {\n        this.renderer.updateProps({\n            selected: false,\n        });\n        this.renderer.element.classList.remove('ProseMirror-selectednode');\n    }\n    /**\n     * Destroy the React component instance.\n     */\n    destroy() {\n        this.renderer.destroy();\n        this.editor.off('selectionUpdate', this.handleSelectionUpdate);\n        this.contentDOMElement = null;\n    }\n    /**\n     * Update the attributes of the top-level element that holds the React component.\n     * Applying the attributes defined in the `attrs` option.\n     */\n    updateElementAttributes() {\n        if (this.options.attrs) {\n            let attrsObj = {};\n            if (typeof this.options.attrs === 'function') {\n                const extensionAttributes = this.editor.extensionManager.attributes;\n                const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes)(this.node, extensionAttributes);\n                attrsObj = this.options.attrs({ node: this.node, HTMLAttributes });\n            }\n            else {\n                attrsObj = this.options.attrs;\n            }\n            this.renderer.updateAttributes(attrsObj);\n        }\n    }\n}\n/**\n * Create a React node view renderer.\n */\nfunction ReactNodeViewRenderer(component, options) {\n    return props => {\n        // try to get the parent component\n        // this is important for vue devtools to show the component hierarchy correctly\n        // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n        if (!props.editor.contentComponent) {\n            return {};\n        }\n        return new ReactNodeView(component, props, options);\n    };\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3JlYWN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ2lFO0FBQ2xGO0FBQ3VCO0FBQzFDO0FBQ3dDOztBQUVyRTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrQ0FBSyxDQUFDLGdCQUFnQiwrQ0FBK0MsaUhBQWlILGdCQUFnQixlQUFlLE1BQU0sdUJBQXVCLHFCQUFxQixhQUFhLFVBQVUsZ0JBQWdCLFNBQVMsT0FBTyxHQUFHLFVBQVUsYUFBYSxTQUFTLE9BQU8sRUFBRSxvQkFBb0IsU0FBUyxPQUFPLEdBQUcsRUFBRSxNQUFNLEtBQUs7QUFDcGEsZUFBZSxvQkFBb0IsVUFBVSxJQUFJLFVBQVUsZUFBZSxTQUFTLFdBQVcsZ0JBQWdCLFdBQVcsZ0lBQWdJO0FBQ3pQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQXFDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQUs7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxlQUFlO0FBQ2pIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQSxNQUFNLEdBQUc7O0FBRVQsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUNBQXFDO0FBQzVGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUVBQXFCO0FBQzVELGdEQUFnRCxpQ0FBaUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlTO0FBQ2pTIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xcQHRpcHRhcFxccmVhY3RcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1YmJsZU1lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudSc7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZURlYnVnVmFsdWUsIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00sIHsgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IEVkaXRvciwgTm9kZVZpZXcsIGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgRmxvYXRpbmdNZW51UGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZmxvYXRpbmctbWVudSc7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBzaGltID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbiA9IHt9O1xuXG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluO1xuXG5mdW5jdGlvbiByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluKSByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluO1xuXHRoYXNSZXF1aXJlZFVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbiA9IDE7XG52YXIgZT1SZWFjdDtmdW5jdGlvbiBoKGEsYil7cmV0dXJuIGE9PT1iJiYoMCE9PWF8fDEvYT09PTEvYil8fGEhPT1hJiZiIT09Yn12YXIgaz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpoLGw9ZS51c2VTdGF0ZSxtPWUudXNlRWZmZWN0LG49ZS51c2VMYXlvdXRFZmZlY3QscD1lLnVzZURlYnVnVmFsdWU7ZnVuY3Rpb24gcShhLGIpe3ZhciBkPWIoKSxmPWwoe2luc3Q6e3ZhbHVlOmQsZ2V0U25hcHNob3Q6Yn19KSxjPWZbMF0uaW5zdCxnPWZbMV07bihmdW5jdGlvbigpe2MudmFsdWU9ZDtjLmdldFNuYXBzaG90PWI7cihjKSYmZyh7aW5zdDpjfSk7fSxbYSxkLGJdKTttKGZ1bmN0aW9uKCl7cihjKSYmZyh7aW5zdDpjfSk7cmV0dXJuIGEoZnVuY3Rpb24oKXtyKGMpJiZnKHtpbnN0OmN9KTt9KX0sW2FdKTtwKGQpO3JldHVybiBkfVxuXHRmdW5jdGlvbiByKGEpe3ZhciBiPWEuZ2V0U25hcHNob3Q7YT1hLnZhbHVlO3RyeXt2YXIgZD1iKCk7cmV0dXJuICFrKGEsZCl9Y2F0Y2goZil7cmV0dXJuICEwfX1mdW5jdGlvbiB0KGEsYil7cmV0dXJuIGIoKX12YXIgdT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3cuZG9jdW1lbnR8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ/dDpxO3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbi51c2VTeW5jRXh0ZXJuYWxTdG9yZT12b2lkIDAhPT1lLnVzZVN5bmNFeHRlcm5hbFN0b3JlP2UudXNlU3luY0V4dGVybmFsU3RvcmU6dTtcblx0cmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbjtcbn1cblxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9kZXZlbG9wbWVudCA9IHt9O1xuXG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50KSByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50O1xuXHRoYXNSZXF1aXJlZFVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9kZXZlbG9wbWVudCA9IDE7XG5cblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHQgIChmdW5jdGlvbigpIHtcblxuXHQvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5cdGlmIChcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuXHQgICAgJ2Z1bmN0aW9uJ1xuXHQpIHtcblx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgICAgdmFyIFJlYWN0JDEgPSBSZWFjdDtcblxuXHR2YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdCQxLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5cdGZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuXHQgIHtcblx0ICAgIHtcblx0ICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcblx0ICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcblx0ICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cblx0ICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cblx0ICB7XG5cdCAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cdCAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuXHQgICAgaWYgKHN0YWNrICE9PSAnJykge1xuXHQgICAgICBmb3JtYXQgKz0gJyVzJztcblx0ICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuXHQgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG5cdCAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuXHQgICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cblx0ICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuXHQgICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG5cdCAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG5cdCAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuXHQgKi9cblx0ZnVuY3Rpb24gaXMoeCwgeSkge1xuXHQgIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdCAgO1xuXHR9XG5cblx0dmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG5cdC8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cblx0dmFyIHVzZVN0YXRlID0gUmVhY3QkMS51c2VTdGF0ZSxcblx0ICAgIHVzZUVmZmVjdCA9IFJlYWN0JDEudXNlRWZmZWN0LFxuXHQgICAgdXNlTGF5b3V0RWZmZWN0ID0gUmVhY3QkMS51c2VMYXlvdXRFZmZlY3QsXG5cdCAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QkMS51c2VEZWJ1Z1ZhbHVlO1xuXHR2YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcblx0dmFyIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gZmFsc2U7IC8vIERpc2NsYWltZXI6IFRoaXMgc2hpbSBicmVha3MgbWFueSBvZiB0aGUgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzXG5cdC8vIGJlY2F1c2Ugb2YgYSB2ZXJ5IHBhcnRpY3VsYXIgc2V0IG9mIGltcGxlbWVudGF0aW9uIGRldGFpbHMgYW5kIGFzc3VtcHRpb25zXG5cdC8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG5cdC8vIGlzIHRoYXQgdXBkYXRlcyBhcmUgYWx3YXlzIHN5bmNocm9ub3VzLCBiZWNhdXNlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIGlzXG5cdC8vIG9ubHkgYXZhaWxhYmxlIGluIHZlcnNpb25zIG9mIFJlYWN0IHRoYXQgYWxzbyBoYXZlIGEgYnVpbHQtaW5cblx0Ly8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuXHQvLyBkb2VzIG5vdCBleGlzdC5cblx0Ly9cblx0Ly8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG5cdC8vIFRoZSBwb2ludCBvZiB0aGlzIHNoaW0gaXMgdG8gcmVwbGFjZSB0aGUgbmVlZCBmb3IgaGFja3MgYnkgb3RoZXIgbGlicmFyaWVzLlxuXG5cdGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2Zcblx0Ly8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG5cdC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuXHQvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG5cdGdldFNlcnZlclNuYXBzaG90KSB7XG5cdCAge1xuXHQgICAgaWYgKCFkaWRXYXJuT2xkMThBbHBoYSkge1xuXHQgICAgICBpZiAoUmVhY3QkMS5zdGFydFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGRpZFdhcm5PbGQxOEFscGhhID0gdHJ1ZTtcblxuXHQgICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuXHQgIC8vIGJyZWFrcyB0aGUgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGhlcmUgYmVjYXVzZSBvZiBzcGVjaWZpY1xuXHQgIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMsIG1vc3QgaW1wb3J0YW50bHkgdGhhdCB1cGRhdGVzIGFyZVxuXHQgIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG5cdCAgdmFyIHZhbHVlID0gZ2V0U25hcHNob3QoKTtcblxuXHQgIHtcblx0ICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcblx0ICAgICAgdmFyIGNhY2hlZFZhbHVlID0gZ2V0U25hcHNob3QoKTtcblxuXHQgICAgICBpZiAoIW9iamVjdElzKHZhbHVlLCBjYWNoZWRWYWx1ZSkpIHtcblx0ICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuXHQgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gLy8gQmVjYXVzZSB1cGRhdGVzIGFyZSBzeW5jaHJvbm91cywgd2UgZG9uJ3QgcXVldWUgdGhlbS4gSW5zdGVhZCB3ZSBmb3JjZSBhXG5cdCAgLy8gcmUtcmVuZGVyIHdoZW5ldmVyIHRoZSBzdWJzY3JpYmVkIHN0YXRlIGNoYW5nZXMgYnkgdXBkYXRpbmcgYW4gc29tZVxuXHQgIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcblx0ICAvLyB0aGUgY3VycmVudCB2YWx1ZS5cblx0ICAvL1xuXHQgIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2Vcblx0ICAvLyBjYW4gc2F2ZSBhIGJpdCBvZiBtZW1vcnkgYnkgc3RvcmluZyBvdGhlciBzdHVmZiBpbiB0aGF0IHNsb3QuXG5cdCAgLy9cblx0ICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG5cdCAgLy8gb2JqZWN0LiBVc3VhbGx5LCB3ZSB3b3VsZCBwdXQgdGhhdCBpbiBhIHVzZVJlZiBob29rLCBidXQgd2UgY2FuIHN0YXNoIGl0IGluXG5cdCAgLy8gb3VyIHVzZVN0YXRlIGhvb2sgaW5zdGVhZC5cblx0ICAvL1xuXHQgIC8vIFRvIGZvcmNlIGEgcmUtcmVuZGVyLCB3ZSBjYWxsIGZvcmNlVXBkYXRlKHtpbnN0fSkuIFRoYXQgd29ya3MgYmVjYXVzZSB0aGVcblx0ICAvLyBuZXcgb2JqZWN0IGFsd2F5cyBmYWlscyBhbiBlcXVhbGl0eSBjaGVjay5cblxuXG5cdCAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcblx0ICAgIGluc3Q6IHtcblx0ICAgICAgdmFsdWU6IHZhbHVlLFxuXHQgICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3Rcblx0ICAgIH1cblx0ICB9KSxcblx0ICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuXHQgICAgICBmb3JjZVVwZGF0ZSA9IF91c2VTdGF0ZVsxXTsgLy8gVHJhY2sgdGhlIGxhdGVzdCBnZXRTbmFwc2hvdCBmdW5jdGlvbiB3aXRoIGEgcmVmLiBUaGlzIG5lZWRzIHRvIGJlIHVwZGF0ZWRcblx0ICAvLyBpbiB0aGUgbGF5b3V0IHBoYXNlIHNvIHdlIGNhbiBhY2Nlc3MgaXQgZHVyaW5nIHRoZSB0ZWFyaW5nIGNoZWNrIHRoYXRcblx0ICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG5cdCAgdXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcblx0ICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG5cdCAgICAvLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcblx0ICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcblx0ICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuXHQgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcblx0ICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG5cdCAgICAgIGZvcmNlVXBkYXRlKHtcblx0ICAgICAgICBpbnN0OiBpbnN0XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF0pO1xuXHQgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG5cdCAgICAvLyBkZXRlY3RlZCBpbiB0aGUgc3Vic2NyaXB0aW9uIGhhbmRsZXIuXG5cdCAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cblx0ICAgICAgZm9yY2VVcGRhdGUoe1xuXHQgICAgICAgIGluc3Q6IGluc3Rcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBoYW5kbGVTdG9yZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3Ncblx0ICAgICAgLy8gdXAgdG8gdGhlIGNvbnN1bWVyIG9mIHRoaXMgbGlicmFyeSB0byB3cmFwIHRoZWlyIHN1YnNjcmlwdGlvbiBldmVudFxuXHQgICAgICAvLyB3aXRoIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLiBTaG91bGQgd2UgdHJ5IHRvIGRldGVjdCB3aGVuIHRoaXMgaXNuJ3Rcblx0ICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cblx0ICAgICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Vcblx0ICAgICAgLy8gcmVhZCBmcm9tIHRoZSBzdG9yZS5cblx0ICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcblx0ICAgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cblx0ICAgICAgICBmb3JjZVVwZGF0ZSh7XG5cdCAgICAgICAgICBpbnN0OiBpbnN0XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cblx0ICAgIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xuXHQgIH0sIFtzdWJzY3JpYmVdKTtcblx0ICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcblx0ICByZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcblx0ICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuXHQgIHZhciBwcmV2VmFsdWUgPSBpbnN0LnZhbHVlO1xuXG5cdCAgdHJ5IHtcblx0ICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuXHQgICAgcmV0dXJuICFvYmplY3RJcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcblx0ICAvLyBOb3RlOiBUaGUgc2hpbSBkb2VzIG5vdCB1c2UgZ2V0U2VydmVyU25hcHNob3QsIGJlY2F1c2UgcHJlLTE4IHZlcnNpb25zIG9mXG5cdCAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG5cdCAgLy8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG5cdCAgLy8gZnJvbSBgZ2V0U25hcHNob3RgLlxuXHQgIHJldHVybiBnZXRTbmFwc2hvdCgpO1xuXHR9XG5cblx0dmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5cdHZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxuXHR2YXIgc2hpbSA9IGlzU2VydmVyRW52aXJvbm1lbnQgPyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxIDogdXNlU3luY0V4dGVybmFsU3RvcmU7XG5cdHZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyID0gUmVhY3QkMS51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QkMS51c2VTeW5jRXh0ZXJuYWxTdG9yZSA6IHNoaW07XG5cblx0dXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcblx0ICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0aWYgKFxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cblx0ICAgICdmdW5jdGlvbidcblx0KSB7XG5cdCAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgIFxuXHQgIH0pKCk7XG5cdH1cblx0cmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9kZXZlbG9wbWVudDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgc2hpbS5leHBvcnRzID0gcmVxdWlyZVVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbigpO1xufSBlbHNlIHtcbiAgc2hpbS5leHBvcnRzID0gcmVxdWlyZVVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9kZXZlbG9wbWVudCgpO1xufVxuXG52YXIgc2hpbUV4cG9ydHMgPSBzaGltLmV4cG9ydHM7XG5cbmNvbnN0IG1lcmdlUmVmcyA9ICguLi5yZWZzKSA9PiB7XG4gICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgIHJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZWYobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGFsbCBvZiB0aGUgZWRpdG9yJ3Mgbm9kZSB2aWV3cy5cbiAqL1xuY29uc3QgUG9ydGFscyA9ICh7IGNvbnRlbnRDb21wb25lbnQsIH0pID0+IHtcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgcmVuZGVyIHRoZSBub2RlIHZpZXcgcG9ydGFscyBvbiBzdGF0ZSBjaGFuZ2VzIG9ubHlcbiAgICBjb25zdCByZW5kZXJlcnMgPSBzaGltRXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZShjb250ZW50Q29tcG9uZW50LnN1YnNjcmliZSwgY29udGVudENvbXBvbmVudC5nZXRTbmFwc2hvdCwgY29udGVudENvbXBvbmVudC5nZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gZGlyZWN0bHkgcmVuZGVyIHRoZSBwb3J0YWxzIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgd3JhcHBlclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgT2JqZWN0LnZhbHVlcyhyZW5kZXJlcnMpKSk7XG59O1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG4gICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHJlbmRlcmVycyA9IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBnZXRTbmFwc2hvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBuZXcgTm9kZVZpZXcgUmVuZGVyZXIgdG8gdGhlIGVkaXRvci5cbiAgICAgICAgICovXG4gICAgICAgIHNldFJlbmRlcmVyKGlkLCByZW5kZXJlcikge1xuICAgICAgICAgICAgcmVuZGVyZXJzID0ge1xuICAgICAgICAgICAgICAgIC4uLnJlbmRlcmVycyxcbiAgICAgICAgICAgICAgICBbaWRdOiBSZWFjdERPTS5jcmVhdGVQb3J0YWwocmVuZGVyZXIucmVhY3RFbGVtZW50LCByZW5kZXJlci5lbGVtZW50LCBpZCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgTm9kZVZpZXcgUmVuZGVyZXIgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlUmVuZGVyZXIoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRSZW5kZXJlcnMgPSB7IC4uLnJlbmRlcmVycyB9O1xuICAgICAgICAgICAgZGVsZXRlIG5leHRSZW5kZXJlcnNbaWRdO1xuICAgICAgICAgICAgcmVuZGVyZXJzID0gbmV4dFJlbmRlcmVycztcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5jbGFzcyBQdXJlRWRpdG9yQ29udGVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udGVudFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQ6IEJvb2xlYW4oKF9hID0gcHJvcHMuZWRpdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudENvbXBvbmVudCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3I7XG4gICAgICAgIGlmIChlZGl0b3IgJiYgIWVkaXRvci5pc0Rlc3Ryb3llZCAmJiBlZGl0b3Iub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lZGl0b3JDb250ZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZCguLi5lZGl0b3Iub3B0aW9ucy5lbGVtZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVkaXRvci5jb250ZW50Q29tcG9uZW50ID0gZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIC8vIEhhcyB0aGUgY29udGVudCBjb21wb25lbnQgYmVlbiBpbml0aWFsaXplZD9cbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5oYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGNvbnRlbnQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCA9IGVkaXRvci5jb250ZW50Q29tcG9uZW50LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUocHJldlN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJldlN0YXRlLmhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc3Vic2NyaWJlIHRvIHByZXZpb3VzIGNvbnRlbnQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICBlZGl0b3Iudmlldy5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgICAgbm9kZVZpZXdzOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmNvbnRlbnRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICBpZiAoIWVkaXRvci5vcHRpb25zLmVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbmV3RWxlbWVudC5hcHBlbmQoLi4uZWRpdG9yLm9wdGlvbnMuZWxlbWVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgZWxlbWVudDogbmV3RWxlbWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBlZGl0b3IsIGlubmVyUmVmLCAuLi5yZXN0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBtZXJnZVJlZnMoaW5uZXJSZWYsIHRoaXMuZWRpdG9yQ29udGVudFJlZiksIC4uLnJlc3QgfSksXG4gICAgICAgICAgICAoZWRpdG9yID09PSBudWxsIHx8IGVkaXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9ydGFscywgeyBjb250ZW50Q29tcG9uZW50OiBlZGl0b3IuY29udGVudENvbXBvbmVudCB9KSkpO1xuICAgIH1cbn1cbi8vIEVkaXRvckNvbnRlbnQgc2hvdWxkIGJlIHJlLWNyZWF0ZWQgd2hlbmV2ZXIgdGhlIEVkaXRvciBpbnN0YW5jZSBjaGFuZ2VzXG5jb25zdCBFZGl0b3JDb250ZW50V2l0aEtleSA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCBrZXkgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYpLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbcHJvcHMuZWRpdG9yXSk7XG4gICAgLy8gQ2FuJ3QgdXNlIEpTWCBoZXJlIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGggdGhlIHR5cGUgZGVmaW5pdGlvbiBvZiBWdWUncyBKU1gsIHNvIHVzZSBjcmVhdGVFbGVtZW50XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHVyZUVkaXRvckNvbnRlbnQsIHtcbiAgICAgICAga2V5LFxuICAgICAgICBpbm5lclJlZjogcmVmLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbn0pO1xuY29uc3QgRWRpdG9yQ29udGVudCA9IFJlYWN0Lm1lbW8oRWRpdG9yQ29udGVudFdpdGhLZXkpO1xuXG52YXIgcmVhY3QgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIGlmICgoYSBpbnN0YW5jZW9mIE1hcCkgJiYgKGIgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSBvZiBhLmVudHJpZXMoKSlcbiAgICAgICAgaWYgKCFiLmhhcyhpWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpIG9mIGEuZW50cmllcygpKVxuICAgICAgICBpZiAoIWVxdWFsKGlbMV0sIGIuZ2V0KGlbMF0pKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKChhIGluc3RhbmNlb2YgU2V0KSAmJiAoYiBpbnN0YW5jZW9mIFNldCkpIHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpIG9mIGEuZW50cmllcygpKVxuICAgICAgICBpZiAoIWIuaGFzKGlbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIC8vIFJlYWN0LXNwZWNpZmljOiBhdm9pZCB0cmF2ZXJzaW5nIFJlYWN0IGVsZW1lbnRzJyBfb3duZXIuXG4gICAgICAgIC8vICBfb3duZXIgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAvLyBhbmQgaXMgbm90IG5lZWRlZCB3aGVuIGNvbXBhcmluZyB0aGUgYWN0dWFsIGVsZW1lbnRzIChhbmQgbm90IHRoZWlyIG93bmVycylcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxudmFyIGRlZXBFcXVhbCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhyZWFjdCk7XG5cbnZhciB3aXRoU2VsZWN0b3IgPSB7ZXhwb3J0czoge319O1xuXG52YXIgd2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbjtcblxuZnVuY3Rpb24gcmVxdWlyZVdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbikgcmV0dXJuIHdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbjtcblx0aGFzUmVxdWlyZWRXaXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW4gPSAxO1xudmFyIGg9UmVhY3Qsbj1zaGltRXhwb3J0cztmdW5jdGlvbiBwKGEsYil7cmV0dXJuIGE9PT1iJiYoMCE9PWF8fDEvYT09PTEvYil8fGEhPT1hJiZiIT09Yn12YXIgcT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpwLHI9bi51c2VTeW5jRXh0ZXJuYWxTdG9yZSx0PWgudXNlUmVmLHU9aC51c2VFZmZlY3Qsdj1oLnVzZU1lbW8sdz1oLnVzZURlYnVnVmFsdWU7XG5cdHdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbi51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3Rvcj1mdW5jdGlvbihhLGIsZSxsLGcpe3ZhciBjPXQobnVsbCk7aWYobnVsbD09PWMuY3VycmVudCl7dmFyIGY9e2hhc1ZhbHVlOiExLHZhbHVlOm51bGx9O2MuY3VycmVudD1mO31lbHNlIGY9Yy5jdXJyZW50O2M9dihmdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7aWYoIWMpe2M9ITA7ZD1hO2E9bChhKTtpZih2b2lkIDAhPT1nJiZmLmhhc1ZhbHVlKXt2YXIgYj1mLnZhbHVlO2lmKGcoYixhKSlyZXR1cm4gaz1ifXJldHVybiBrPWF9Yj1rO2lmKHEoZCxhKSlyZXR1cm4gYjt2YXIgZT1sKGEpO2lmKHZvaWQgMCE9PWcmJmcoYixlKSlyZXR1cm4gYjtkPWE7cmV0dXJuIGs9ZX12YXIgYz0hMSxkLGssbT12b2lkIDA9PT1lP251bGw6ZTtyZXR1cm4gW2Z1bmN0aW9uKCl7cmV0dXJuIGEoYigpKX0sbnVsbD09PW0/dm9pZCAwOmZ1bmN0aW9uKCl7cmV0dXJuIGEobSgpKX1dfSxbYixlLGwsZ10pO3ZhciBkPXIoYSxjWzBdLGNbMV0pO1xuXHR1KGZ1bmN0aW9uKCl7Zi5oYXNWYWx1ZT0hMDtmLnZhbHVlPWQ7fSxbZF0pO3coZCk7cmV0dXJuIGR9O1xuXHRyZXR1cm4gd2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xufVxuXG52YXIgd2l0aFNlbGVjdG9yX2RldmVsb3BtZW50ID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudDtcblxuZnVuY3Rpb24gcmVxdWlyZVdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudCkgcmV0dXJuIHdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudDtcblx0aGFzUmVxdWlyZWRXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQgPSAxO1xuXG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcblx0ICAoZnVuY3Rpb24oKSB7XG5cblx0LyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuXHRpZiAoXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cblx0ICAgICdmdW5jdGlvbidcblx0KSB7XG5cdCAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG5cdH1cblx0ICAgICAgICAgIHZhciBSZWFjdCQxID0gUmVhY3Q7XG5cdHZhciBzaGltID0gc2hpbUV4cG9ydHM7XG5cblx0LyoqXG5cdCAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG5cdCAqL1xuXHRmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdCAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICA7XG5cdH1cblxuXHR2YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cblx0dmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gc2hpbS51c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblxuXHQvLyBmb3IgQ29tbW9uSlMgaW50ZXJvcC5cblxuXHR2YXIgdXNlUmVmID0gUmVhY3QkMS51c2VSZWYsXG5cdCAgICB1c2VFZmZlY3QgPSBSZWFjdCQxLnVzZUVmZmVjdCxcblx0ICAgIHVzZU1lbW8gPSBSZWFjdCQxLnVzZU1lbW8sXG5cdCAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QkMS51c2VEZWJ1Z1ZhbHVlOyAvLyBTYW1lIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCBidXQgc3VwcG9ydHMgc2VsZWN0b3IgYW5kIGlzRXF1YWwgYXJndW1lbnRzLlxuXG5cdGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbCkge1xuXHQgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHRoZSByZW5kZXJlZCBzbmFwc2hvdC5cblx0ICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcblx0ICB2YXIgaW5zdDtcblxuXHQgIGlmIChpbnN0UmVmLmN1cnJlbnQgPT09IG51bGwpIHtcblx0ICAgIGluc3QgPSB7XG5cdCAgICAgIGhhc1ZhbHVlOiBmYWxzZSxcblx0ICAgICAgdmFsdWU6IG51bGxcblx0ICAgIH07XG5cdCAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuXHQgIH1cblxuXHQgIHZhciBfdXNlTWVtbyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gVHJhY2sgdGhlIG1lbW9pemVkIHN0YXRlIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzIHRoYXQgYXJlIGxvY2FsIHRvIHRoaXNcblx0ICAgIC8vIG1lbW9pemVkIGluc3RhbmNlIG9mIGEgZ2V0U25hcHNob3QgZnVuY3Rpb24uIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGFcblx0ICAgIC8vIHVzZVJlZiBob29rLCBiZWNhdXNlIHRoYXQgc3RhdGUgd291bGQgYmUgc2hhcmVkIGFjcm9zcyBhbGwgY29uY3VycmVudFxuXHQgICAgLy8gY29waWVzIG9mIHRoZSBob29rL2NvbXBvbmVudC5cblx0ICAgIHZhciBoYXNNZW1vID0gZmFsc2U7XG5cdCAgICB2YXIgbWVtb2l6ZWRTbmFwc2hvdDtcblx0ICAgIHZhciBtZW1vaXplZFNlbGVjdGlvbjtcblxuXHQgICAgdmFyIG1lbW9pemVkU2VsZWN0b3IgPSBmdW5jdGlvbiAobmV4dFNuYXBzaG90KSB7XG5cdCAgICAgIGlmICghaGFzTWVtbykge1xuXHQgICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHRoZSBob29rIGlzIGNhbGxlZCwgdGhlcmUgaXMgbm8gbWVtb2l6ZWQgcmVzdWx0LlxuXHQgICAgICAgIGhhc01lbW8gPSB0cnVlO1xuXHQgICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG5cblx0ICAgICAgICB2YXIgX25leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuXG5cdCAgICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgc2VsZWN0b3IgaGFzIGNoYW5nZWQsIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgc2VsZWN0aW9uXG5cdCAgICAgICAgICAvLyBtYXkgYmUgZXF1YWwgdG8gdGhlIG5ldyBzZWxlY3Rpb24uIFdlIHNob3VsZCBhdHRlbXB0IHRvIHJldXNlIHRoZVxuXHQgICAgICAgICAgLy8gY3VycmVudCB2YWx1ZSBpZiBwb3NzaWJsZSwgdG8gcHJlc2VydmUgZG93bnN0cmVhbSBtZW1vaXphdGlvbnMuXG5cdCAgICAgICAgICBpZiAoaW5zdC5oYXNWYWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG5cblx0ICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgX25leHRTZWxlY3Rpb24pKSB7XG5cdCAgICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXHQgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBfbmV4dFNlbGVjdGlvbjtcblx0ICAgICAgICByZXR1cm4gX25leHRTZWxlY3Rpb247XG5cdCAgICAgIH0gLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG5cblxuXHQgICAgICAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cblx0ICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IG1lbW9pemVkU25hcHNob3Q7XG5cdCAgICAgIHZhciBwcmV2U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG5cblx0ICAgICAgaWYgKG9iamVjdElzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KSkge1xuXHQgICAgICAgIC8vIFRoZSBzbmFwc2hvdCBpcyB0aGUgc2FtZSBhcyBsYXN0IHRpbWUuIFJldXNlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uXG5cdCAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG5cdCAgICAgIH0gLy8gVGhlIHNuYXBzaG90IGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgc2VsZWN0aW9uLlxuXG5cblx0ICAgICAgLy8gVGhlIHNuYXBzaG90IGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgc2VsZWN0aW9uLlxuXHQgICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7IC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG5cdCAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcblx0ICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcblx0ICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblxuXHQgICAgICAvLyBJZiBhIGN1c3RvbSBpc0VxdWFsIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgdGhhdCB0byBjaGVjayBpZiB0aGUgZGF0YVxuXHQgICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG5cdCAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG5cdCAgICAgIC8vIG91dCBvZiByZW5kZXJpbmcuXG5cdCAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQgJiYgaXNFcXVhbChwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSkge1xuXHQgICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuXHQgICAgICB9XG5cblx0ICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblx0ICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuXHQgICAgICByZXR1cm4gbmV4dFNlbGVjdGlvbjtcblx0ICAgIH07IC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cblxuXG5cdCAgICAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG5cdCAgICB2YXIgbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQgPyBudWxsIDogZ2V0U2VydmVyU25hcHNob3Q7XG5cblx0ICAgIHZhciBnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IgPSBtYXliZUdldFNlcnZlclNuYXBzaG90ID09PSBudWxsID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBbZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IsIGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yXTtcblx0ICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF0pLFxuXHQgICAgICBnZXRTZWxlY3Rpb24gPSBfdXNlTWVtb1swXSxcblx0ICAgICAgZ2V0U2VydmVyU2VsZWN0aW9uID0gX3VzZU1lbW9bMV07XG5cblx0ICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNlbGVjdGlvbiwgZ2V0U2VydmVyU2VsZWN0aW9uKTtcblx0ICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuXHQgICAgaW5zdC5oYXNWYWx1ZSA9IHRydWU7XG5cdCAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG5cdCAgfSwgW3ZhbHVlXSk7XG5cdCAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0d2l0aFNlbGVjdG9yX2RldmVsb3BtZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3I7XG5cdCAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5cdGlmIChcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG5cdCAgICAnZnVuY3Rpb24nXG5cdCkge1xuXHQgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG5cdH1cblx0ICAgICAgICBcblx0ICB9KSgpO1xuXHR9XG5cdHJldHVybiB3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQ7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdpdGhTZWxlY3Rvci5leHBvcnRzID0gcmVxdWlyZVdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbigpO1xufSBlbHNlIHtcbiAgd2l0aFNlbGVjdG9yLmV4cG9ydHMgPSByZXF1aXJlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50KCk7XG59XG5cbnZhciB3aXRoU2VsZWN0b3JFeHBvcnRzID0gd2l0aFNlbGVjdG9yLmV4cG9ydHM7XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbi8qKlxuICogVG8gc3luY2hyb25pemUgdGhlIGVkaXRvciBpbnN0YW5jZSB3aXRoIHRoZSBjb21wb25lbnQgc3RhdGUsXG4gKiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGluc3RhbmNlIHRoYXQgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSBjb21wb25lbnQgcmUtcmVuZGVycy5cbiAqL1xuY2xhc3MgRWRpdG9yU3RhdGVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsRWRpdG9yKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25OdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlciA9IDA7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gaW5pdGlhbEVkaXRvcjtcbiAgICAgICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogaW5pdGlhbEVkaXRvciwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgICAgICAgdGhpcy5nZXRTbmFwc2hvdCA9IHRoaXMuZ2V0U25hcHNob3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdCA9IHRoaXMuZ2V0U2VydmVyU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy53YXRjaCA9IHRoaXMud2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldFNuYXBzaG90KCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbk51bWJlciA9PT0gdGhpcy5sYXN0VHJhbnNhY3Rpb25OdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RTbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlciA9IHRoaXMudHJhbnNhY3Rpb25OdW1iZXI7XG4gICAgICAgIHRoaXMubGFzdFNuYXBzaG90ID0geyBlZGl0b3I6IHRoaXMuZWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogdGhpcy50cmFuc2FjdGlvbk51bWJlciB9O1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0U25hcHNob3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsd2F5cyBkaXNhYmxlIHRoZSBlZGl0b3Igb24gdGhlIHNlcnZlci1zaWRlLlxuICAgICAqL1xuICAgIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgICAgICByZXR1cm4geyBlZGl0b3I6IG51bGwsIHRyYW5zYWN0aW9uTnVtYmVyOiAwIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byB0aGUgZWRpdG9yIGluc3RhbmNlJ3MgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYXRjaCB0aGUgZWRpdG9yIGluc3RhbmNlIGZvciBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHdhdGNoKG5leHRFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBuZXh0RWRpdG9yO1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGZvcmNlIGEgcmUtcmVuZGVyIHdoZW4gdGhlIGVkaXRvciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAgICAgICAgICogVGhpcyBpcyB0byBzdXBwb3J0IHRoaW5ncyBsaWtlIGBlZGl0b3IuY2FuKCkudG9nZ2xlQm9sZCgpYCBpbiBjb21wb25lbnRzIHRoYXQgYHVzZUVkaXRvcmAuXG4gICAgICAgICAgICAgKiBUaGlzIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50LCBidXQgaXQncyBhIGdvb2QgdHJhZGUtb2ZmIGZvciBub3cuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGZuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25OdW1iZXIgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICAgICAgY3VycmVudEVkaXRvci5vbigndHJhbnNhY3Rpb24nLCBmbik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFZGl0b3Iub2ZmKCd0cmFuc2FjdGlvbicsIGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgaG9vayBhbGxvd3MgeW91IHRvIHdhdGNoIGZvciBjaGFuZ2VzIG9uIHRoZSBlZGl0b3IgaW5zdGFuY2UuXG4gKiBJdCB3aWxsIGFsbG93IHlvdSB0byBzZWxlY3QgYSBwYXJ0IG9mIHRoZSBlZGl0b3Igc3RhdGUgYW5kIHJlLXJlbmRlciB0aGUgY29tcG9uZW50IHdoZW4gaXQgY2hhbmdlcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcih7Li4ub3B0aW9uc30pXG4gKiBjb25zdCB7IGN1cnJlbnRTZWxlY3Rpb24gfSA9IHVzZUVkaXRvclN0YXRlKHtcbiAqICBlZGl0b3IsXG4gKiAgc2VsZWN0b3I6IHNuYXBzaG90ID0+ICh7IGN1cnJlbnRTZWxlY3Rpb246IHNuYXBzaG90LmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24gfSksXG4gKiB9KVxuICovXG5mdW5jdGlvbiB1c2VFZGl0b3JTdGF0ZShvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IFtlZGl0b3JTdGF0ZU1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVkaXRvclN0YXRlTWFuYWdlcihvcHRpb25zLmVkaXRvcikpO1xuICAgIC8vIFVzaW5nIHRoZSBgdXNlU3luY0V4dGVybmFsU3RvcmVgIGhvb2sgdG8gc3luYyB0aGUgZWRpdG9yIGluc3RhbmNlIHdpdGggdGhlIGNvbXBvbmVudCBzdGF0ZVxuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB3aXRoU2VsZWN0b3JFeHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKGVkaXRvclN0YXRlTWFuYWdlci5zdWJzY3JpYmUsIGVkaXRvclN0YXRlTWFuYWdlci5nZXRTbmFwc2hvdCwgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNlcnZlclNuYXBzaG90LCBvcHRpb25zLnNlbGVjdG9yLCAoX2EgPSBvcHRpb25zLmVxdWFsaXR5Rm4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZXBFcXVhbCk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiBlZGl0b3JTdGF0ZU1hbmFnZXIud2F0Y2gob3B0aW9ucy5lZGl0b3IpO1xuICAgIH0sIFtvcHRpb25zLmVkaXRvciwgZWRpdG9yU3RhdGVNYW5hZ2VyXSk7XG4gICAgdXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbn1cblxuY29uc3QgaXNEZXYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3QgaXNTU1IgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzTmV4dCA9IGlzU1NSIHx8IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5leHQpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGhhbmRsZXMgdGhlIGNyZWF0aW9uLCBkZXN0cnVjdGlvbiwgYW5kIHJlLWNyZWF0aW9uIG9mIHRoZSBlZGl0b3IgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIEVkaXRvckluc3RhbmNlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0b3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN1YnNjcmlwdGlvbnMgdG8gbm90aWZ5IHdoZW4gdGhlIGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgKiBoYXMgYmVlbiBjcmVhdGVkIG9yIGRlc3Ryb3llZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGVkaXRvciBoYXMgYmVlbiBtb3VudGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCBkZXBlbmRlbmNpZXMgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIGluc3RhbmNlIElELiBUaGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGVkaXRvciBpbnN0YW5jZS4gQW5kIHdpbGwgYmUgcmUtZ2VuZXJhdGVkIGZvciBlYWNoIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5zdGFuY2VJZCA9ICcnO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc2V0RWRpdG9yKHRoaXMuZ2V0SW5pdGlhbEVkaXRvcigpKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZURlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5nZXRFZGl0b3IgPSB0aGlzLmdldEVkaXRvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFNlcnZlclNuYXBzaG90ID0gdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmcmVzaEVkaXRvckluc3RhbmNlID0gdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZURlc3Ryb3kgPSB0aGlzLnNjaGVkdWxlRGVzdHJveS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVuZGVyID0gdGhpcy5vblJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUVkaXRvciA9IHRoaXMuY3JlYXRlRWRpdG9yLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHNldEVkaXRvcihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpO1xuICAgICAgICAvLyBOb3RpZnkgYWxsIHN1YnNjcmliZXJzIHRoYXQgdGhlIGVkaXRvciBpbnN0YW5jZSBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGNiID0+IGNiKCkpO1xuICAgIH1cbiAgICBnZXRJbml0aWFsRWRpdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlzU1NSIHx8IGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSwgd2Ugc2hvdWxkIHRocm93IGFuIGVycm9yIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoaXNEZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRocm93IGFuIGVycm9yIGluIGRldmVsb3BtZW50LCB0byBtYWtlIHN1cmUgdGhlIGRldmVsb3BlciBpcyBhd2FyZSB0aGF0IHRpcHRhcCBjYW5ub3QgYmUgU1NSJ2RcbiAgICAgICAgICAgICAgICAgICAgICogYW5kIHRoYXQgdGhleSBuZWVkIHRvIHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RpcHRhcCBFcnJvcjogU1NSIGhhcyBiZWVuIGRldGVjdGVkLCBwbGVhc2Ugc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgZXhwbGljaXRseSB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCZXN0IGZhaXRoIGVmZm9ydCBpbiBwcm9kdWN0aW9uLCBydW4gdGhlIGNvZGUgaW4gdGhlIGxlZ2FjeSBtb2RlIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzIGFuZCBlcnJvcnMgaW4gcHJvZHVjdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBpbW1lZGlhdGVseSByZW5kZXJpbmcgd2hlbiBjbGllbnQtc2lkZSByZW5kZXJpbmdcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVkaXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VycmVudC5pbW1lZGlhdGVseVJlbmRlciAmJiBpc1NTUiAmJiBpc0Rldikge1xuICAgICAgICAgICAgLy8gV2FybiBpbiBkZXZlbG9wbWVudCwgdG8gbWFrZSBzdXJlIHRoZSBkZXZlbG9wZXIgaXMgYXdhcmUgdGhhdCB0aXB0YXAgY2Fubm90IGJlIFNTUidkLCBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaXB0YXAgRXJyb3I6IFNTUiBoYXMgYmVlbiBkZXRlY3RlZCwgYW5kIGBpbW1lZGlhdGVseVJlbmRlcmAgaGFzIGJlZW4gc2V0IHRvIGB0cnVlYCB0aGlzIGlzIGFuIHVuc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb24gdGhhdCBtYXkgcmVzdWx0IGluIGVycm9ycywgZXhwbGljaXRseSBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VycmVudC5pbW1lZGlhdGVseVJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlZGl0b3IgaW5zdGFuY2UuIEFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGNyZWF0ZUVkaXRvcigpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uc1RvQXBwbHkgPSB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuY3VycmVudCxcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBieSBkZWZhdWx0XG4gICAgICAgICAgICBvbkJlZm9yZUNyZWF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkJlZm9yZUNyZWF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25CbHVyOiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uQmx1cikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25DcmVhdGU6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25DcmVhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uRGVzdHJveTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkRlc3Ryb3kpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uRm9jdXM6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Gb2N1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25TZWxlY3Rpb25VcGRhdGU6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25TZWxlY3Rpb25VcGRhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uVHJhbnNhY3Rpb246ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25UcmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25VcGRhdGU6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25VcGRhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uQ29udGVudEVycm9yOiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uQ29udGVudEVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvbkRyb3A6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Ecm9wKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvblBhc3RlOiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uUGFzdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gbmV3IEVkaXRvcihvcHRpb25zVG9BcHBseSk7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgYmUgcmVtb3ZlZCB3aGVuIHRoZSBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0RWRpdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsd2F5cyBkaXNhYmxlIHRoZSBlZGl0b3Igb24gdGhlIHNlcnZlci1zaWRlLlxuICAgICAqL1xuICAgIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShvblN0b3JlQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQob25TdG9yZUNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKG9uU3RvcmVDaGFuZ2UpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZU9wdGlvbnMoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYSkuZXZlcnkoa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChbJ29uQ3JlYXRlJywgJ29uQmVmb3JlQ3JlYXRlJywgJ29uRGVzdHJveScsICdvblVwZGF0ZScsICdvblRyYW5zYWN0aW9uJywgJ29uRm9jdXMnLCAnb25CbHVyJywgJ29uU2VsZWN0aW9uVXBkYXRlJywgJ29uQ29udGVudEVycm9yJywgJ29uRHJvcCcsICdvblBhc3RlJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gY29tcGFyZSBjYWxsYmFja3MsIHRoZXkgYXJlIGFsd2F5cyBkaWZmZXJlbnQgYW5kIG9ubHkgcmVnaXN0ZXJlZCBvbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBvZnRlbiBlbmNvdXJhZ2UgcHV0dGluZyBleHRlbnNpb25zIGlubGluZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LCBzbyB3ZSB3aWxsIGRvIGEgc2xpZ2h0bHkgZGVlcGVyIGNvbXBhcmlzb24gaGVyZVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2V4dGVuc2lvbnMnICYmIGEuZXh0ZW5zaW9ucyAmJiBiLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5leHRlbnNpb25zLmxlbmd0aCAhPT0gYi5leHRlbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLmV4dGVuc2lvbnMuZXZlcnkoKGV4dGVuc2lvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uICE9PSAoKF9hID0gYi5leHRlbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYW55IG9mIHRoZSBvcHRpb25zIGhhdmUgY2hhbmdlZCwgd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgZWRpdG9yIG9wdGlvbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIGVhY2ggcmVuZGVyLCB3ZSB3aWxsIGNyZWF0ZSwgdXBkYXRlLCBvciBkZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIGRlcHMgVGhlIGRlcGVuZGVuY2llcyB0byB3YXRjaCBmb3IgY2hhbmdlc1xuICAgICAqIEByZXR1cm5zIEEgY2xlYW51cCBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uUmVuZGVyKGRlcHMpIHtcbiAgICAgICAgLy8gVGhlIHJldHVybmVkIGNhbGxiYWNrIHdpbGwgcnVuIG9uIGVhY2ggcmVuZGVyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIGFueSBzY2hlZHVsZWQgZGVzdHJ1Y3Rpb25zLCBzaW5jZSB3ZSBhcmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQgJiYgZGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIGRvZXMgZXhpc3QgJiBkZXBzIGFyZSBlbXB0eSwgd2UgZG9uJ3QgbmVlZCB0byByZS1pbml0aWFsaXplIHRoZSBlZGl0b3IgZ2VuZXJhbGx5XG4gICAgICAgICAgICAgICAgaWYgKCFFZGl0b3JJbnN0YW5jZU1hbmFnZXIuY29tcGFyZU9wdGlvbnModGhpcy5vcHRpb25zLmN1cnJlbnQsIHRoaXMuZWRpdG9yLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCwgdGhlIG9wdGlvbnMgYXJlIGRpZmZlcmVudCwgc28gd2UgbmVlZCB0byB1cGRhdGUgdGhlIGVkaXRvciBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0aWxsLCB0aGlzIGlzIGZhc3RlciB0aGFuIHJlLWNyZWF0aW5nIHRoZSBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlOiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBlZGl0b3I6XG4gICAgICAgICAgICAgICAgLy8gLSBkb2VzIG5vdCB5ZXQgZXhpc3RcbiAgICAgICAgICAgICAgICAvLyAtIGlzIGRlc3Ryb3llZFxuICAgICAgICAgICAgICAgIC8vIC0gdGhlIGRlcHMgYXJyYXkgY2hhbmdlc1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVzdHJveSB0aGUgZWRpdG9yIGluc3RhbmNlIGFuZCByZS1pbml0aWFsaXplIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZURlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY3JlYXRlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaWYgdGhlIGRlcGVuZGVuY2llcyBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgcmVmcmVzaEVkaXRvckluc3RhbmNlKGRlcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yICYmICF0aGlzLmVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgLy8gRWRpdG9yIGluc3RhbmNlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c0RlcHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBsYXN0RGVwcyBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLCByZXVzZSB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IGRlcHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVwc0FyZUVxdWFsID0gdGhpcy5wcmV2aW91c0RlcHMubGVuZ3RoID09PSBkZXBzLmxlbmd0aFxuICAgICAgICAgICAgICAgICYmIHRoaXMucHJldmlvdXNEZXBzLmV2ZXJ5KChkZXAsIGluZGV4KSA9PiBkZXAgPT09IGRlcHNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChkZXBzQXJlRXF1YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBkZXBzIGV4aXN0IGFuZCBhcmUgZXF1YWwsIG5vIG5lZWQgdG8gcmVjcmVhdGVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yICYmICF0aGlzLmVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgLy8gRGVzdHJveSB0aGUgZWRpdG9yIGluc3RhbmNlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RWRpdG9yKHRoaXMuY3JlYXRlRWRpdG9yKCkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3REZXBzIHRvIHRoZSBjdXJyZW50IGRlcHNcbiAgICAgICAgdGhpcy5wcmV2aW91c0RlcHMgPSBkZXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSB0aGUgZGVzdHJ1Y3Rpb24gb2YgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKiBUaGlzIHdpbGwgb25seSBkZXN0cm95IHRoZSBlZGl0b3IgaWYgaXQgd2FzIG5vdCBtb3VudGVkIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgICogVGhpcyBpcyB0byBhdm9pZCBkZXN0cm95aW5nIHRoZSBlZGl0b3IgaW5zdGFuY2Ugd2hlbiBpdCdzIGFjdHVhbGx5IHN0aWxsIG1vdW50ZWQuXG4gICAgICovXG4gICAgc2NoZWR1bGVEZXN0cm95KCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SW5zdGFuY2VJZCA9IHRoaXMuaW5zdGFuY2VJZDtcbiAgICAgICAgY29uc3QgY3VycmVudEVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICAvLyBXYWl0IHR3byB0aWNrcyB0byBzZWUgaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkXG4gICAgICAgIHRoaXMuc2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgJiYgdGhpcy5pbnN0YW5jZUlkID09PSBjdXJyZW50SW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHN0aWxsIG1vdW50ZWQgb24gdGhlIGZvbGxvd2luZyB0aWNrLCB3aXRoIHRoZSBzYW1lIGluc3RhbmNlSWQsIGRvIG5vdCBkZXN0cm95IHRoZSBlZGl0b3JcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJlLWFwcGx5IG9wdGlvbnMgYXMgdGhleSBtaWdodCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVkaXRvci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFZGl0b3IgJiYgIWN1cnJlbnRFZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUlkID09PSBjdXJyZW50SW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEVkaXRvcihudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgZWZmZWN0IHRvIHJ1biBhZ2FpbiBiZXR3ZWVuIHRpY2tzXG4gICAgICAgICAgICAvLyB3aGljaCBtYXkgc2F2ZSB1cyBmcm9tIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIGVkaXRvclxuICAgICAgICB9LCAxKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1c2VFZGl0b3Iob3B0aW9ucyA9IHt9LCBkZXBzID0gW10pIHtcbiAgICBjb25zdCBtb3N0UmVjZW50T3B0aW9ucyA9IHVzZVJlZihvcHRpb25zKTtcbiAgICBtb3N0UmVjZW50T3B0aW9ucy5jdXJyZW50ID0gb3B0aW9ucztcbiAgICBjb25zdCBbaW5zdGFuY2VNYW5hZ2VyXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBFZGl0b3JJbnN0YW5jZU1hbmFnZXIobW9zdFJlY2VudE9wdGlvbnMpKTtcbiAgICBjb25zdCBlZGl0b3IgPSBzaGltRXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZShpbnN0YW5jZU1hbmFnZXIuc3Vic2NyaWJlLCBpbnN0YW5jZU1hbmFnZXIuZ2V0RWRpdG9yLCBpbnN0YW5jZU1hbmFnZXIuZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIHVzZURlYnVnVmFsdWUoZWRpdG9yKTtcbiAgICAvLyBUaGlzIGVmZmVjdCB3aWxsIGhhbmRsZSBjcmVhdGluZy91cGRhdGluZyB0aGUgZWRpdG9yIGluc3RhbmNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHVzZUVmZmVjdChpbnN0YW5jZU1hbmFnZXIub25SZW5kZXIoZGVwcykpO1xuICAgIC8vIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJlLXJlbmRlciBvbiBlYWNoIHRyYW5zYWN0aW9uXG4gICAgLy8gVGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgdGhhdCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zXG4gICAgdXNlRWRpdG9yU3RhdGUoe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHNlbGVjdG9yOiAoeyB0cmFuc2FjdGlvbk51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRSZXJlbmRlck9uVHJhbnNhY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHByZXZlbnQgdGhlIGVkaXRvciBmcm9tIHJlLXJlbmRlcmluZyBvbiBlYWNoIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgYXZvaWQgcmUtcmVuZGVyaW5nIG9uIHRoZSBmaXJzdCB0cmFuc2FjdGlvbiB3aGVuIGBpbW1lZGlhdGVseVJlbmRlcmAgaXMgc2V0IHRvIGB0cnVlYFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlbHlSZW5kZXIgJiYgdHJhbnNhY3Rpb25OdW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk51bWJlciArIDE7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbn1cblxuY29uc3QgRWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGVkaXRvcjogbnVsbCxcbn0pO1xuY29uc3QgRWRpdG9yQ29uc3VtZXIgPSBFZGl0b3JDb250ZXh0LkNvbnN1bWVyO1xuLyoqXG4gKiBBIGhvb2sgdG8gZ2V0IHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZS5cbiAqL1xuY29uc3QgdXNlQ3VycmVudEVkaXRvciA9ICgpID0+IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIHByb3ZpZGVyIGNvbXBvbmVudCBmb3IgdGhlIGVkaXRvci5cbiAqIEl0IGFsbG93cyB0aGUgZWRpdG9yIHRvIGJlIGFjY2Vzc2libGUgYWNyb3NzIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWVcbiAqIHdpdGggYHVzZUN1cnJlbnRFZGl0b3JgLlxuICovXG5mdW5jdGlvbiBFZGl0b3JQcm92aWRlcih7IGNoaWxkcmVuLCBzbG90QWZ0ZXIsIHNsb3RCZWZvcmUsIGVkaXRvckNvbnRhaW5lclByb3BzID0ge30sIC4uLmVkaXRvck9wdGlvbnMgfSkge1xuICAgIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcihlZGl0b3JPcHRpb25zKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgZWRpdG9yIH0gfSxcbiAgICAgICAgc2xvdEJlZm9yZSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0b3JDb25zdW1lciwgbnVsbCwgKHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0pID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRlbnQsIHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yLCAuLi5lZGl0b3JDb250YWluZXJQcm9wcyB9KSkpLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2xvdEFmdGVyKSk7XG59XG5cbmNvbnN0IEJ1YmJsZU1lbnUgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBbZWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCB7IGVkaXRvcjogY3VycmVudEVkaXRvciB9ID0gdXNlQ3VycmVudEVkaXRvcigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSBwcm9wcy5lZGl0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rlc3Ryb3llZCkgfHwgKGN1cnJlbnRFZGl0b3IgPT09IG51bGwgfHwgY3VycmVudEVkaXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBsdWdpbktleSA9ICdidWJibGVNZW51JywgZWRpdG9yLCB0aXBweU9wdGlvbnMgPSB7fSwgdXBkYXRlRGVsYXksIHNob3VsZFNob3cgPSBudWxsLCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IG1lbnVFZGl0b3IgPSBlZGl0b3IgfHwgY3VycmVudEVkaXRvcjtcbiAgICAgICAgaWYgKCFtZW51RWRpdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0J1YmJsZU1lbnUgY29tcG9uZW50IGlzIG5vdCByZW5kZXJlZCBpbnNpZGUgb2YgYW4gZWRpdG9yIGNvbXBvbmVudCBvciBkb2VzIG5vdCBoYXZlIGVkaXRvciBwcm9wLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IEJ1YmJsZU1lbnVQbHVnaW4oe1xuICAgICAgICAgICAgdXBkYXRlRGVsYXksXG4gICAgICAgICAgICBlZGl0b3I6IG1lbnVFZGl0b3IsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgcGx1Z2luS2V5LFxuICAgICAgICAgICAgc2hvdWxkU2hvdyxcbiAgICAgICAgICAgIHRpcHB5T3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIG1lbnVFZGl0b3IucmVnaXN0ZXJQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHsgbWVudUVkaXRvci51bnJlZ2lzdGVyUGx1Z2luKHBsdWdpbktleSk7IH07XG4gICAgfSwgW3Byb3BzLmVkaXRvciwgY3VycmVudEVkaXRvciwgZWxlbWVudF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogc2V0RWxlbWVudCwgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsIHN0eWxlOiB7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn07XG5cbmNvbnN0IEZsb2F0aW5nTWVudSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IFtlbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0gPSB1c2VDdXJyZW50RWRpdG9yKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHByb3BzLmVkaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRGVzdHJveWVkKSB8fCAoY3VycmVudEVkaXRvciA9PT0gbnVsbCB8fCBjdXJyZW50RWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RWRpdG9yLmlzRGVzdHJveWVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGx1Z2luS2V5ID0gJ2Zsb2F0aW5nTWVudScsIGVkaXRvciwgdGlwcHlPcHRpb25zID0ge30sIHNob3VsZFNob3cgPSBudWxsLCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IG1lbnVFZGl0b3IgPSBlZGl0b3IgfHwgY3VycmVudEVkaXRvcjtcbiAgICAgICAgaWYgKCFtZW51RWRpdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Zsb2F0aW5nTWVudSBjb21wb25lbnQgaXMgbm90IHJlbmRlcmVkIGluc2lkZSBvZiBhbiBlZGl0b3IgY29tcG9uZW50IG9yIGRvZXMgbm90IGhhdmUgZWRpdG9yIHByb3AuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGx1Z2luID0gRmxvYXRpbmdNZW51UGx1Z2luKHtcbiAgICAgICAgICAgIHBsdWdpbktleSxcbiAgICAgICAgICAgIGVkaXRvcjogbWVudUVkaXRvcixcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICB0aXBweU9wdGlvbnMsXG4gICAgICAgICAgICBzaG91bGRTaG93LFxuICAgICAgICB9KTtcbiAgICAgICAgbWVudUVkaXRvci5yZWdpc3RlclBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBtZW51RWRpdG9yLnVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luS2V5KTsgfTtcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLmVkaXRvcixcbiAgICAgICAgY3VycmVudEVkaXRvcixcbiAgICAgICAgZWxlbWVudCxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHNldEVsZW1lbnQsIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG59O1xuXG5jb25zdCBSZWFjdE5vZGVWaWV3Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIG9uRHJhZ1N0YXJ0OiB1bmRlZmluZWQsXG59KTtcbmNvbnN0IHVzZVJlYWN0Tm9kZVZpZXcgPSAoKSA9PiB1c2VDb250ZXh0KFJlYWN0Tm9kZVZpZXdDb250ZXh0KTtcblxuY29uc3QgTm9kZVZpZXdDb250ZW50ID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IFRhZyA9IHByb3BzLmFzIHx8ICdkaXYnO1xuICAgIGNvbnN0IHsgbm9kZVZpZXdDb250ZW50UmVmIH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XG4gICAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHsgLi4ucHJvcHMsIHJlZjogbm9kZVZpZXdDb250ZW50UmVmLCBcImRhdGEtbm9kZS12aWV3LWNvbnRlbnRcIjogXCJcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgICAgICAuLi5wcm9wcy5zdHlsZSxcbiAgICAgICAgfSB9KSk7XG59O1xuXG5jb25zdCBOb2RlVmlld1dyYXBwZXIgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgeyBvbkRyYWdTdGFydCB9ID0gdXNlUmVhY3ROb2RlVmlldygpO1xuICAgIGNvbnN0IFRhZyA9IHByb3BzLmFzIHx8ICdkaXYnO1xuICAgIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCB7IC4uLnByb3BzLCByZWY6IHJlZiwgXCJkYXRhLW5vZGUtdmlldy13cmFwcGVyXCI6IFwiXCIsIG9uRHJhZ1N0YXJ0OiBvbkRyYWdTdGFydCwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnLFxuICAgICAgICAgICAgLi4ucHJvcHMuc3R5bGUsXG4gICAgICAgIH0gfSkpO1xufSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb25lbnQgaXMgYSBjbGFzcyBjb21wb25lbnQuXG4gKiBAcGFyYW0gQ29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAmJiBDb21wb25lbnQucHJvdG90eXBlXG4gICAgICAgICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9uZW50IGlzIGEgZm9yd2FyZCByZWYgY29tcG9uZW50LlxuICogQHBhcmFtIENvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICYmICgoX2EgPSBDb21wb25lbnQuJCR0eXBlb2YpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSA9PT0gJ1N5bWJvbChyZWFjdC5mb3J3YXJkX3JlZiknKTtcbn1cbi8qKlxuICogVGhlIFJlYWN0UmVuZGVyZXIgY2xhc3MuIEl0J3MgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIGluc2lkZSB0aGUgZWRpdG9yLlxuICogQGV4YW1wbGVcbiAqIG5ldyBSZWFjdFJlbmRlcmVyKE15Q29tcG9uZW50LCB7XG4gKiAgIGVkaXRvcixcbiAqICAgcHJvcHM6IHtcbiAqICAgICBmb286ICdiYXInLFxuICogICB9LFxuICogICBhczogJ3NwYW4nLFxuICogfSlcbiovXG5jbGFzcyBSZWFjdFJlbmRlcmVyIHtcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBjcmVhdGVzIGVsZW1lbnQgYW5kIHJlbmRlcnMgdGhlIHByb3ZpZGVkIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHsgZWRpdG9yLCBwcm9wcyA9IHt9LCBhcyA9ICdkaXYnLCBjbGFzc05hbWUgPSAnJywgfSkge1xuICAgICAgICB0aGlzLnJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRkZGKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhcyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdyZWFjdC1yZW5kZXJlcicpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWUuc3BsaXQoJyAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIE9uIGZpcnN0IHJlbmRlciwgd2UgbmVlZCB0byBmbHVzaCB0aGUgcmVuZGVyIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIC8vIFJlbmRlcnMgYWZ0ZXJ3YXJkcyBjYW4gYmUgYXN5bmMsIGJ1dCB0aGlzIGZpeGVzIGEgY3Vyc29yIHBvc2l0aW9uaW5nIGlzc3VlXG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBpZiAoaXNDbGFzc0NvbXBvbmVudChDb21wb25lbnQpIHx8IGlzRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2UgdGhlIHJlZiB3b3JrXG4gICAgICAgICAgICBwcm9wcy5yZWYgPSAocmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhY3RFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHsgLi4ucHJvcHMgfSk7XG4gICAgICAgIChfYSA9IGVkaXRvciA9PT0gbnVsbCB8fCBlZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRvci5jb250ZW50Q29tcG9uZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0UmVuZGVyZXIodGhpcy5pZCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlLXJlbmRlcnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIG5ldyBwcm9wcy5cbiAgICAgKi9cbiAgICB1cGRhdGVQcm9wcyhwcm9wcyA9IHt9KSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICAoX2EgPSBlZGl0b3IgPT09IG51bGwgfHwgZWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVJlbmRlcmVyKHRoaXMuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQgdGhhdCBob2xkcyB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBSZWFjdE5vZGVWaWV3IGV4dGVuZHMgTm9kZVZpZXcge1xuICAgIC8qKlxuICAgICAqIFNldHVwIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICogQ2FsbGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBub2RlOiB0aGlzLm5vZGUsXG4gICAgICAgICAgICBkZWNvcmF0aW9uczogdGhpcy5kZWNvcmF0aW9ucyxcbiAgICAgICAgICAgIGlubmVyRGVjb3JhdGlvbnM6IHRoaXMuaW5uZXJEZWNvcmF0aW9ucyxcbiAgICAgICAgICAgIHZpZXc6IHRoaXMudmlldyxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbjogdGhpcy5leHRlbnNpb24sXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogdGhpcy5IVE1MQXR0cmlidXRlcyxcbiAgICAgICAgICAgIGdldFBvczogKCkgPT4gdGhpcy5nZXRQb3MoKSxcbiAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IChhdHRyaWJ1dGVzID0ge30pID0+IHRoaXMudXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgIGRlbGV0ZU5vZGU6ICgpID0+IHRoaXMuZGVsZXRlTm9kZSgpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjYXBpdGFsaXplRmlyc3RDaGFyID0gKHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmRpc3BsYXlOYW1lID0gY2FwaXRhbGl6ZUZpcnN0Q2hhcih0aGlzLmV4dGVuc2lvbi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkRyYWdTdGFydCA9IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgbm9kZVZpZXdDb250ZW50UmVmID0gZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmNvbnRlbnRET01FbGVtZW50ICYmIGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gdGhpcy5jb250ZW50RE9NRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IG9uRHJhZ1N0YXJ0LCBub2RlVmlld0NvbnRlbnRSZWYgfTtcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBtZW1vaXplIHRoZSBwcm92aWRlciBjb21wb25lbnRcbiAgICAgICAgLy8gQW5kIGFsbCBvZiB0aGUgdGhpbmdzIGl0IHJlcXVpcmVzIGFyZSBkZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQsIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byByZS1yZW5kZXJcbiAgICAgICAgY29uc3QgUmVhY3ROb2RlVmlld1Byb3ZpZGVyID0gUmVhY3QubWVtbyhjb21wb25lbnRQcm9wcyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3ROb2RlVmlld0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIGNvbXBvbmVudFByb3BzKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgUmVhY3ROb2RlVmlld1Byb3ZpZGVyLmRpc3BsYXlOYW1lID0gJ1JlYWN0Tm9kZVZpZXcnO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRET01FbGVtZW50VGFnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMuY29udGVudERPTUVsZW1lbnRUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlLmlzSW5saW5lID8gJ3NwYW4nIDogJ2RpdicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LmRhdGFzZXQubm9kZVZpZXdDb250ZW50UmVhY3QgPSAnJztcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiB0aGUgd2hpdGVTcGFjZSBwcm9wIGlzIG5vdCBpbmhlcml0ZWQgcHJvcGVybHkgaW4gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIC8vIFdpdGggdGhpcyBmaXggaXQgc2VlbXMgdG8gd29yayBmaW5lXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTE5N1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gJ2luaGVyaXQnO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcyA9IHRoaXMubm9kZS5pc0lubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFzKSB7XG4gICAgICAgICAgICBhcyA9IHRoaXMub3B0aW9ucy5hcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSA9ICcnIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlID0gdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZWFjdFJlbmRlcmVyKFJlYWN0Tm9kZVZpZXdQcm92aWRlciwge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGBub2RlLSR7dGhpcy5ub2RlLnR5cGUubmFtZX0gJHtjbGFzc05hbWV9YC50cmltKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRBdHRyaWJ1dGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgRE9NIGVsZW1lbnQuXG4gICAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSBub2RlIHZpZXcuXG4gICAgICovXG4gICAgZ2V0IGRvbSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkXG4gICAgICAgICAgICAmJiAhKChfYSA9IHRoaXMucmVuZGVyZXIuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc0F0dHJpYnV0ZSgnZGF0YS1ub2RlLXZpZXctd3JhcHBlcicpKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIE5vZGVWaWV3V3JhcHBlciBjb21wb25lbnQgZm9yIHlvdXIgbm9kZSB2aWV3LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY29udGVudCBET00gZWxlbWVudC5cbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIHJpY2gtdGV4dCBjb250ZW50IG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGdldCBjb250ZW50RE9NKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIGVkaXRvciBzZWxlY3Rpb24gdXBkYXRlLCBjaGVjayBpZiB0aGUgbm9kZSBpcyBzZWxlY3RlZC5cbiAgICAgKiBJZiBpdCBpcywgY2FsbCBgc2VsZWN0Tm9kZWAsIG90aGVyd2lzZSBjYWxsIGBkZXNlbGVjdE5vZGVgLlxuICAgICAqL1xuICAgIGhhbmRsZVNlbGVjdGlvblVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpO1xuICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA8PSBwb3MgJiYgdG8gPj0gcG9zICsgdGhpcy5ub2RlLm5vZGVTaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiB1cGRhdGUsIHVwZGF0ZSB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgICAqIFRvIHByZXZlbnQgdW5uZWNlc3NhcnkgdXBkYXRlcywgdGhlIGB1cGRhdGVgIG9wdGlvbiBjYW4gYmUgdXNlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUobm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVyZW5kZXJDb21wb25lbnQgPSAocHJvcHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMocHJvcHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYXR0cnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IHRoaXMubm9kZS50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBvbGROb2RlID0gdGhpcy5ub2RlO1xuICAgICAgICAgICAgY29uc3Qgb2xkRGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zO1xuICAgICAgICAgICAgY29uc3Qgb2xkSW5uZXJEZWNvcmF0aW9ucyA9IHRoaXMuaW5uZXJEZWNvcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBpbm5lckRlY29yYXRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIG9sZE5vZGUsXG4gICAgICAgICAgICAgICAgb2xkRGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgICAgbmV3Tm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBuZXdEZWNvcmF0aW9uczogZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgICAgb2xkSW5uZXJEZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVByb3BzOiAoKSA9PiByZXJlbmRlckNvbXBvbmVudCh7IG5vZGUsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubm9kZVxuICAgICAgICAgICAgJiYgdGhpcy5kZWNvcmF0aW9ucyA9PT0gZGVjb3JhdGlvbnNcbiAgICAgICAgICAgICYmIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9PT0gaW5uZXJEZWNvcmF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBpbm5lckRlY29yYXRpb25zO1xuICAgICAgICByZXJlbmRlckNvbXBvbmVudCh7IG5vZGUsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBub2RlLlxuICAgICAqIEFkZCB0aGUgYHNlbGVjdGVkYCBwcm9wIGFuZCB0aGUgYFByb3NlTWlycm9yLXNlbGVjdGVkbm9kZWAgY2xhc3MuXG4gICAgICovXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7XG4gICAgICAgICAgICBzZWxlY3RlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZWxlY3QgdGhlIG5vZGUuXG4gICAgICogUmVtb3ZlIHRoZSBgc2VsZWN0ZWRgIHByb3AgYW5kIHRoZSBgUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlYCBjbGFzcy5cbiAgICAgKi9cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ1Byb3NlTWlycm9yLXNlbGVjdGVkbm9kZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCB0aGF0IGhvbGRzIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICogQXBwbHlpbmcgdGhlIGF0dHJpYnV0ZXMgZGVmaW5lZCBpbiB0aGUgYGF0dHJzYCBvcHRpb24uXG4gICAgICovXG4gICAgdXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCBhdHRyc09iaiA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYXR0cnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKHRoaXMubm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgYXR0cnNPYmogPSB0aGlzLm9wdGlvbnMuYXR0cnMoeyBub2RlOiB0aGlzLm5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cnNPYmogPSB0aGlzLm9wdGlvbnMuYXR0cnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnNPYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBSZWFjdCBub2RlIHZpZXcgcmVuZGVyZXIuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Tm9kZVZpZXdSZW5kZXJlcihjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJvcHMgPT4ge1xuICAgICAgICAvLyB0cnkgdG8gZ2V0IHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IGZvciB2dWUgZGV2dG9vbHMgdG8gc2hvdyB0aGUgY29tcG9uZW50IGhpZXJhcmNoeSBjb3JyZWN0bHlcbiAgICAgICAgLy8gbWF5YmUgaXTigJlzIGB1bmRlZmluZWRgIGJlY2F1c2UgPGVkaXRvci1jb250ZW50PiBpc27igJl0IHJlbmRlcmVkIHlldFxuICAgICAgICBpZiAoIXByb3BzLmVkaXRvci5jb250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZWFjdE5vZGVWaWV3KGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IEJ1YmJsZU1lbnUsIEVkaXRvckNvbnN1bWVyLCBFZGl0b3JDb250ZW50LCBFZGl0b3JDb250ZXh0LCBFZGl0b3JQcm92aWRlciwgRmxvYXRpbmdNZW51LCBOb2RlVmlld0NvbnRlbnQsIE5vZGVWaWV3V3JhcHBlciwgUHVyZUVkaXRvckNvbnRlbnQsIFJlYWN0Tm9kZVZpZXcsIFJlYWN0Tm9kZVZpZXdDb250ZXh0LCBSZWFjdE5vZGVWaWV3UmVuZGVyZXIsIFJlYWN0UmVuZGVyZXIsIHVzZUN1cnJlbnRFZGl0b3IsIHVzZUVkaXRvciwgdXNlRWRpdG9yU3RhdGUsIHVzZVJlYWN0Tm9kZVZpZXcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/react/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* binding */ autoJoin),\n/* harmony export */   baseKeymap: () => (/* binding */ baseKeymap),\n/* harmony export */   chainCommands: () => (/* binding */ chainCommands),\n/* harmony export */   createParagraphNear: () => (/* binding */ createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* binding */ deleteSelection),\n/* harmony export */   exitCode: () => (/* binding */ exitCode),\n/* harmony export */   joinBackward: () => (/* binding */ joinBackward),\n/* harmony export */   joinDown: () => (/* binding */ joinDown),\n/* harmony export */   joinForward: () => (/* binding */ joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* binding */ joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* binding */ joinTextblockForward),\n/* harmony export */   joinUp: () => (/* binding */ joinUp),\n/* harmony export */   lift: () => (/* binding */ lift),\n/* harmony export */   liftEmptyBlock: () => (/* binding */ liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* binding */ macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* binding */ newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* binding */ pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectNodeBackward: () => (/* binding */ selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* binding */ selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* binding */ selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* binding */ selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* binding */ selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* binding */ setBlockType),\n/* harmony export */   splitBlock: () => (/* binding */ splitBlock),\n/* harmony export */   splitBlockAs: () => (/* binding */ splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* binding */ splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* binding */ toggleMark),\n/* harmony export */   wrapIn: () => (/* binding */ wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\n/**\nDelete the selection, if there is one.\n*/\nconst deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n        : $cursor.parentOffset > 0))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before it—if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/\nconst joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, -1))\n        return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        for (let depth = $cursor.depth;; depth--) {\n            let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(depth), $cursor.after(depth), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n            if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n                if (dispatch) {\n                    let tr = state.tr.step(delStep);\n                    tr.setSelection(textblockAt(before, \"end\")\n                        ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                    dispatch(tr.scrollIntoView());\n                }\n                return true;\n            }\n            if (depth == 1 || $cursor.node(depth - 1).childCount > 1)\n                break;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/\nconst joinTextblockBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/\nconst joinTextblockForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for (; !beforeText.isTextblock; beforePos--) {\n        if (beforeText.type.spec.isolating)\n            return false;\n        let child = beforeText.lastChild;\n        if (!child)\n            return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for (; !afterText.isTextblock; afterPos++) {\n        if (afterText.type.spec.isolating)\n            return false;\n        let child = afterText.firstChild;\n        if (!child)\n            return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos ||\n        step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos)\n        return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = (side == \"start\" ? scan.firstChild : scan.lastChild)) {\n        if (scan.isTextblock)\n            return true;\n        if (only && scan.childCount != 1)\n            return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/\nconst selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n            return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            if ($pos.index(i) > 0)\n                return $pos.doc.resolve($pos.before(i + 1));\n            if ($pos.node(i).type.spec.isolating)\n                break;\n        }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n        : $cursor.parentOffset < $cursor.parent.content.size))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/\nconst joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut)\n        return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, 1))\n        return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                    : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/\nconst selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n            return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            let parent = $pos.node(i);\n            if ($pos.index(i) + 1 < parent.childCount)\n                return $pos.doc.resolve($pos.after(i + 1));\n            if (parent.type.spec.isolating)\n                break;\n        }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/\nconst joinUp = (state, dispatch) => {\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from))\n            return false;\n        point = sel.from;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel)\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/\nconst joinDown = (state, dispatch) => {\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to))\n            return false;\n        point = sel.to;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch)\n        dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/\nconst lift = (state, dispatch) => {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/\nconst newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs())\n            return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/\nconst exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n        return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/\nconst createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n        return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n        return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/\nconst liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n        return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch)\n                dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/\nfunction splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos))\n                return false;\n            if (dispatch)\n                dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.depth)\n            return false;\n        let types = [];\n        let splitDepth, deflt, atEnd = false, atStart = false;\n        for (let d = $from.depth;; d--) {\n            let node = $from.node(d);\n            if (node.isBlock) {\n                atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n                atStart = $from.start(d) == $from.pos - ($from.depth - d);\n                deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n                let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n                types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));\n                splitDepth = d;\n                break;\n            }\n            else {\n                if (d == 1)\n                    return false;\n                types.unshift(null);\n            }\n        }\n        let tr = state.tr;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection)\n            tr.deleteSelection();\n        let splitPos = tr.mapping.map($from.pos);\n        let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, types.length, types);\n        if (!can) {\n            types[0] = deflt ? { type: deflt } : null;\n            can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, types.length, types);\n        }\n        tr.split(splitPos, types.length, types);\n        if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n            let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);\n            if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n                tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n        }\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/\nconst splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/\nconst splitBlockKeepMarks = (state, dispatch) => {\n    return splitBlock(state, dispatch && (tr => {\n        let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n        if (marks)\n            tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/\nconst selectParentNode = (state, dispatch) => {\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0)\n        return false;\n    pos = $from.before(same);\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/\nconst selectAll = (state, dispatch) => {\n    if (dispatch)\n        dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n        return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch)\n            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.join($pos.pos).scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    let isolated = before.type.spec.isolating || after.type.spec.isolating;\n    if (!isolated && joinMaybeClear(state, $cut, dispatch))\n        return true;\n    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter &&\n        (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n        match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for (let i = conn.length - 1; i >= 0; i--)\n                wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let $joinAt = tr.doc.resolve(end + 2 * conn.length);\n            if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type &&\n                (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, $joinAt.pos))\n                tr.join($joinAt.pos);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = after.type.spec.isolating || (dir > 0 && isolated) ? null : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for (;;) {\n            wrap.push(at);\n            if (at.isTextblock)\n                break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for (; !afterText.isTextblock; afterText = afterText.firstChild)\n            afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for (let i = wrap.length - 1; i >= 0; i--)\n                    end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function (state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while ($pos.node(depth).isInline) {\n            if (!depth)\n                return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/\nconst selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/\nconst selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/\nfunction wrapIn(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/\nfunction setBlockType(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let applicable = false;\n        for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos) => {\n                if (applicable)\n                    return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs))\n                    return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                }\n                else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable)\n            return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for (let i = 0; i < state.selection.ranges.length; i++) {\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type, enterAtoms) {\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos)\n                return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can)\n            return true;\n    }\n    return false;\n}\nfunction removeInlineAtoms(ranges) {\n    let result = [];\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        $from.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {\n                if (pos + 1 > $from.pos)\n                    result.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.SelectionRange($from, $from.doc.resolve(pos + 1)));\n                $from = $from.doc.resolve(pos + 1 + node.content.size);\n                return false;\n            }\n        });\n        if ($from.pos < $to.pos)\n            result.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.SelectionRange($from, $to));\n    }\n    return result;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/\nfunction toggleMark(markType, attrs = null, options) {\n    let removeWhenPresent = (options && options.removeWhenPresent) !== false;\n    let enterAtoms = (options && options.enterInlineAtoms) !== false;\n    let dropSpace = !(options && options.includeWhitespace);\n    return function (state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType, enterAtoms))\n            return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks()))\n                    dispatch(state.tr.removeStoredMark(markType));\n                else\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            }\n            else {\n                let add, tr = state.tr;\n                if (!enterAtoms)\n                    ranges = removeInlineAtoms(ranges);\n                if (removeWhenPresent) {\n                    add = !ranges.some(r => state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType));\n                }\n                else {\n                    add = !ranges.every(r => {\n                        let missing = false;\n                        tr.doc.nodesBetween(r.$from.pos, r.$to.pos, (node, pos, parent) => {\n                            if (missing)\n                                return false;\n                            missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) &&\n                                !(node.isText && /^\\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));\n                        });\n                        return !missing;\n                    });\n                }\n                for (let i = 0; i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    if (!add) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    }\n                    else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = dropSpace && start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = dropSpace && end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr) => {\n        if (!tr.isGeneric)\n            return dispatch(tr);\n        let ranges = [];\n        for (let i = 0; i < tr.mapping.maps.length; i++) {\n            let map = tr.mapping.maps[i];\n            for (let j = 0; j < ranges.length; j++)\n                ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to) => ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for (let i = 0; i < ranges.length; i += 2) {\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n                let after = parent.maybeChild(index);\n                if (!after)\n                    break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after))\n                        joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b) => a - b);\n        for (let i = joinable.length - 1; i >= 0; i--) {\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i]))\n                tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/\nfunction autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1\n        : isJoinable;\n    return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/\nfunction chainCommands(...commands) {\n    return function (state, dispatch, view) {\n        for (let i = 0; i < commands.length; i++)\n            if (commands[i](state, dispatch, view))\n                return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/\nconst pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/\nconst macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n    // @ts-ignore\n    : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRJO0FBQ3hGO0FBQ3NEOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpRUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0REFBYTtBQUNwRCx5Q0FBeUM7QUFDekMsMEJBQTBCLGtFQUFXLHlEQUF5RCxvREFBSztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBUztBQUNuQywwQkFBMEIsNERBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRUFBVyxpQ0FBaUMsb0RBQUs7QUFDaEU7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwYiIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXHByb3NlbWlycm9yLWNvbW1hbmRzXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCwgUmVwbGFjZVN0ZXAsIGNhbkpvaW4sIGpvaW5Qb2ludCwgY2FuU3BsaXQsIFJlcGxhY2VBcm91bmRTdGVwLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4qL1xuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0ID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xucmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl04oCUaWZcbnRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG5JZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG50aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG5pbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4oYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSB0aGlzLCB0cnkgdG8gbGlmdFxuICAgIGlmICghJGN1dCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgLy8gQXBwbHkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoLCAtMSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGJlbG93IGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBhYm92ZSBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gJGN1cnNvci5kZXB0aDs7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZShkZXB0aCksICRjdXJzb3IuYWZ0ZXIoZGVwdGgpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlcHRoID09IDEgfHwgJGN1cnNvci5ub2RlKGRlcHRoIC0gMSkuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVmb3JlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChiZWZvcmUuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkY3V0LnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkJhY2t3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5CYWNrd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZVxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5Gb3J3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXJcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBiZWZvcmVUZXh0ID0gYmVmb3JlLCBiZWZvcmVQb3MgPSAkY3V0LnBvcyAtIDE7XG4gICAgZm9yICg7ICFiZWZvcmVUZXh0LmlzVGV4dGJsb2NrOyBiZWZvcmVQb3MtLSkge1xuICAgICAgICBpZiAoYmVmb3JlVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBiZWZvcmVUZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyUG9zID0gJGN1dC5wb3MgKyAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgICAgIGlmIChhZnRlclRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGFmdGVyVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgYmVmb3JlUG9zLCBhZnRlclBvcywgU2xpY2UuZW1wdHkpO1xuICAgIGlmICghc3RlcCB8fCBzdGVwLmZyb20gIT0gYmVmb3JlUG9zIHx8XG4gICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCAmJiBzdGVwLnNsaWNlLnNpemUgPj0gYWZ0ZXJQb3MgLSBiZWZvcmVQb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChzdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUsIG9ubHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gKHNpZGUgPT0gXCJzdGFydFwiID8gc2Nhbi5maXJzdENoaWxkIDogc2Nhbi5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGJlZm9yZSB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbmJvdW5kIHRvIGtleXMgbGlrZSBiYWNrc3BhY2UsIGFmdGVyXG5bYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpIG9yIG90aGVyIGRlbGV0aW5nXG5jb21tYW5kcywgYXMgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3QgYWxsb3dcbmRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQmVmb3JlO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zIC0gbm9kZS5ub2RlU2l6ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhXG50ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2tcbmFuZCB0aGUgb25lIGFmdGVyIGl0LCBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXJcbmJsb2NrIGNsb3NlciB0byB0aGlzIG9uZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFdpbGwgdXNlIHRoZSB2aWV3XG5mb3IgYWNjdXJhdGUgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEkY3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gICAgLy8gVHJ5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCwgMSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBhYm92ZSBhbmQgc2VsZWN0IHRoZSBvbmUgYmVsb3cuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBjb21pbmcgYWZ0ZXIgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkXG50byBiZSBib3VuZCB0byBrZXlzIGxpa2UgZGVsZXRlLCBhZnRlclxuW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZCkgYW5kIHNpbWlsYXIgZGVsZXRpbmdcbmNvbW1hbmRzLCB0byBwcm92aWRlIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0XG5hbGxvdyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2sgb3IsIGlmIHRoZXJlIGlzIGEgdGV4dCBzZWxlY3Rpb24sIHRoZVxuY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aFxudGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4qL1xuY29uc3Qgam9pblVwID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAobm9kZVNlbCkge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLmZyb207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgICAgIGlmIChub2RlU2VsKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxudGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGpvaW5Eb3duID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLnRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkxpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbnNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG4qL1xuY29uc3QgbGlmdCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiovXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aXRoIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGNyZWF0ZSBhXG5kZWZhdWx0IGJsb2NrIGFmdGVyIHRoZSBjb2RlIGJsb2NrLCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRoZXJlLlxuKi9cbmNvbnN0IGV4aXRDb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWJvdmUgPSAkaGVhZC5ub2RlKC0xKSwgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSwgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG5pdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KCR0by5wYXJlbnQuY29udGVudE1hdGNoQXQoJHRvLmluZGV4QWZ0ZXIoKSkpO1xuICAgIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2lkZSA9ICghJGZyb20ucGFyZW50T2Zmc2V0ICYmICR0by5pbmRleCgpIDwgJHRvLnBhcmVudC5jaGlsZENvdW50ID8gJGZyb20gOiAkdG8pLnBvcztcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZVxuYmxvY2suXG4qL1xuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGN1cnNvci5kZXB0aCA+IDEgJiYgJGN1cnNvci5hZnRlcigpICE9ICRjdXJzb3IuZW5kKC0xKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ3JlYXRlIGEgdmFyaWFudCBvZiBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jaykgdGhhdCB1c2VzXG5hIGN1c3RvbSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG5ld2x5IHNwbGl0IG9mZiBibG9jay5cbiovXG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkZnJvbS5kZXB0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGVzID0gW107XG4gICAgICAgIGxldCBzcGxpdERlcHRoLCBkZWZsdCwgYXRFbmQgPSBmYWxzZSwgYXRTdGFydCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJGZyb20ubm9kZShkKTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBhdEVuZCA9ICRmcm9tLmVuZChkKSA9PSAkZnJvbS5wb3MgKyAoJGZyb20uZGVwdGggLSBkKTtcbiAgICAgICAgICAgICAgICBhdFN0YXJ0ID0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCk7XG4gICAgICAgICAgICAgICAgZGVmbHQgPSBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKGQgLSAxKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGQgLSAxKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzcGxpdFR5cGUgPSBzcGxpdE5vZGUgJiYgc3BsaXROb2RlKCR0by5wYXJlbnQsIGF0RW5kLCAkZnJvbSk7XG4gICAgICAgICAgICAgICAgdHlwZXMudW5zaGlmdChzcGxpdFR5cGUgfHwgKGF0RW5kICYmIGRlZmx0ID8geyB0eXBlOiBkZWZsdCB9IDogbnVsbCkpO1xuICAgICAgICAgICAgICAgIHNwbGl0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGQgPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHR5cGVzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uIHx8IHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICBsZXQgc3BsaXRQb3MgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpO1xuICAgICAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgdHlwZXMubGVuZ3RoLCB0eXBlcyk7XG4gICAgICAgIGlmICghY2FuKSB7XG4gICAgICAgICAgICB0eXBlc1swXSA9IGRlZmx0ID8geyB0eXBlOiBkZWZsdCB9IDogbnVsbDtcbiAgICAgICAgICAgIGNhbiA9IGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHR5cGVzLmxlbmd0aCwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRyLnNwbGl0KHNwbGl0UG9zLCB0eXBlcy5sZW5ndGgsIHR5cGVzKTtcbiAgICAgICAgaWYgKCFhdEVuZCAmJiBhdFN0YXJ0ICYmICRmcm9tLm5vZGUoc3BsaXREZXB0aCkudHlwZSAhPSBkZWZsdCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKHNwbGl0RGVwdGgpKSwgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgaWYgKGRlZmx0ICYmICRmcm9tLm5vZGUoc3BsaXREZXB0aCAtIDEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSlcbiAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZShzcGxpdERlcHRoKSksIGRlZmx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuU3BsaXQgdGhlIHBhcmVudCBibG9jayBvZiB0aGUgc2VsZWN0aW9uLiBJZiB0aGUgc2VsZWN0aW9uIGlzIGEgdGV4dFxuc2VsZWN0aW9uLCBhbHNvIGRlbGV0ZSBpdHMgY29udGVudC5cbiovXG5jb25zdCBzcGxpdEJsb2NrID0gc3BsaXRCbG9ja0FzKCk7XG4vKipcbkFjdHMgbGlrZSBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jayksIGJ1dCB3aXRob3V0XG5yZXNldHRpbmcgdGhlIHNldCBvZiBhY3RpdmUgbWFya3MgYXQgdGhlIGN1cnNvci5cbiovXG5jb25zdCBzcGxpdEJsb2NrS2VlcE1hcmtzID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCAmJiAodHIgPT4ge1xuICAgICAgICBsZXQgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9KSk7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5vZGUgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBpZlxuYW55LiAoV2lsbCBub3Qgc2VsZWN0IHRoZSBkb2N1bWVudCBub2RlLilcbiovXG5jb25zdCBzZWxlY3RQYXJlbnROb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLCBwb3M7XG4gICAgbGV0IHNhbWUgPSAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgaWYgKHNhbWUgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyA9ICRmcm9tLmJlZm9yZShzYW1lKTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgd2hvbGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBBbGxTZWxlY3Rpb24oc3RhdGUuZG9jKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkcG9zLCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCAhYmVmb3JlLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYWZ0ZXIudHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWJlZm9yZS5jb250ZW50LnNpemUgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCAtIDEsIGluZGV4KSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJHBvcy5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSB8fCAhKGFmdGVyLmlzVGV4dGJsb2NrIHx8IGNhbkpvaW4oc3RhdGUuZG9jLCAkcG9zLnBvcykpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKCRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoLCBkaXIpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBjb25uLCBtYXRjaDtcbiAgICBsZXQgaXNvbGF0ZWQgPSBiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nO1xuICAgIGlmICghaXNvbGF0ZWQgJiYgam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGNhbkRlbEFmdGVyID0gIWlzb2xhdGVkICYmICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiZcbiAgICAgICAgKGNvbm4gPSAobWF0Y2ggPSBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKS5maW5kV3JhcHBpbmcoYWZ0ZXIudHlwZSkpICYmXG4gICAgICAgIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9ICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsIHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGNvbm5baV0uY3JlYXRlKG51bGwsIHdyYXApKTtcbiAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGJlZm9yZS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gMSwgZW5kLCAkY3V0LnBvcywgZW5kLCBuZXcgU2xpY2Uod3JhcCwgMSwgMCksIGNvbm4ubGVuZ3RoLCB0cnVlKSk7XG4gICAgICAgICAgICBsZXQgJGpvaW5BdCA9IHRyLmRvYy5yZXNvbHZlKGVuZCArIDIgKiBjb25uLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoJGpvaW5BdC5ub2RlQWZ0ZXIgJiYgJGpvaW5BdC5ub2RlQWZ0ZXIudHlwZSA9PSBiZWZvcmUudHlwZSAmJlxuICAgICAgICAgICAgICAgIGNhbkpvaW4odHIuZG9jLCAkam9pbkF0LnBvcykpXG4gICAgICAgICAgICAgICAgdHIuam9pbigkam9pbkF0LnBvcyk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNlbEFmdGVyID0gYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAoZGlyID4gMCAmJiBpc29sYXRlZCkgPyBudWxsIDogU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICAgIGxldCByYW5nZSA9IHNlbEFmdGVyICYmIHNlbEFmdGVyLiRmcm9tLmJsb2NrUmFuZ2Uoc2VsQWZ0ZXIuJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldCA+PSAkY3V0LmRlcHRoKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgICAgICBsZXQgYXQgPSBiZWZvcmUsIHdyYXAgPSBbXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgd3JhcC5wdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdC5pc1RleHRibG9jaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGF0ID0gYXQubGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJEZXB0aCA9IDE7XG4gICAgICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIGFmdGVyRGVwdGgrKztcbiAgICAgICAgaWYgKGF0LmNhblJlcGxhY2UoYXQuY2hpbGRDb3VudCwgYXQuY2hpbGRDb3VudCwgYWZ0ZXJUZXh0LmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IEZyYWdtZW50LmZyb20od3JhcFtpXS5jb3B5KGVuZCkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gd3JhcC5sZW5ndGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsICRjdXQucG9zICsgYWZ0ZXJEZXB0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSAtIGFmdGVyRGVwdGgsIG5ldyBTbGljZShlbmQsIHdyYXAubGVuZ3RoLCAwKSwgMCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0VGV4dGJsb2NrU2lkZShzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgJHBvcyA9IHNpZGUgPCAwID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICAgICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aDtcbiAgICAgICAgd2hpbGUgKCRwb3Mubm9kZShkZXB0aCkuaXNJbmxpbmUpIHtcbiAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRwb3Mubm9kZShkZXB0aCkuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHNpZGUgPCAwID8gJHBvcy5zdGFydChkZXB0aCkgOiAkcG9zLmVuZChkZXB0aCkpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0IG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1NpZGUoLTEpO1xuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja1NpZGUoMSk7XG4vLyBQYXJhbWV0ZXJpemVkIGNvbW1hbmRzXG4vKipcbldyYXAgdGhlIHNlbGVjdGlvbiBpbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd2l0aCB0aGUgZ2l2ZW5cbmF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gd3JhcEluKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgd3JhcHBpbmcgPSByYW5nZSAmJiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgIGlmICghd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLndyYXAocmFuZ2UsIHdyYXBwaW5nKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCB0cmllcyB0byBzZXQgdGhlIHNlbGVjdGVkIHRleHRibG9ja3MgdG8gdGhlXG5naXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBhcHBsaWNhYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggJiYgIWFwcGxpY2FibGU7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpY2FibGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIGF0dHJzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gbm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgbm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXBwbGljYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHRyLnNldEJsb2NrVHlwZShmcm9tLCB0bywgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2MsIHJhbmdlcywgdHlwZSwgZW50ZXJBdG9tcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbGV0IGNhbiA9ICRmcm9tLmRlcHRoID09IDAgPyBkb2MuaW5saW5lQ29udGVudCAmJiBkb2MudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKSA6IGZhbHNlO1xuICAgICAgICBkb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbiB8fCAhZW50ZXJBdG9tcyAmJiBub2RlLmlzQXRvbSAmJiBub2RlLmlzSW5saW5lICYmIHBvcyA+PSAkZnJvbS5wb3MgJiYgcG9zICsgbm9kZS5ub2RlU2l6ZSA8PSAkdG8ucG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhbiA9IG5vZGUuaW5saW5lQ29udGVudCAmJiBub2RlLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUlubGluZUF0b21zKHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICRmcm9tLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0F0b20gJiYgbm9kZS5jb250ZW50LnNpemUgJiYgbm9kZS5pc0lubGluZSAmJiBwb3MgPj0gJGZyb20ucG9zICYmIHBvcyArIG5vZGUubm9kZVNpemUgPD0gJHRvLnBvcykge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyAxID4gJGZyb20ucG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU2VsZWN0aW9uUmFuZ2UoJGZyb20sICRmcm9tLmRvYy5yZXNvbHZlKHBvcyArIDEpKSk7XG4gICAgICAgICAgICAgICAgJGZyb20gPSAkZnJvbS5kb2MucmVzb2x2ZShwb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgkZnJvbS5wb3MgPCAkdG8ucG9zKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFNlbGVjdGlvblJhbmdlKCRmcm9tLCAkdG8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHRvZ2dsZXMgdGhlIGdpdmVuIG1hcmsgd2l0aCB0aGVcbmdpdmVuIGF0dHJpYnV0ZXMuIFdpbGwgcmV0dXJuIGBmYWxzZWAgd2hlbiB0aGUgY3VycmVudCBzZWxlY3Rpb25cbmRvZXNuJ3Qgc3VwcG9ydCB0aGF0IG1hcmsuIFRoaXMgd2lsbCByZW1vdmUgdGhlIG1hcmsgaWYgYW55IG1hcmtzXG5vZiB0aGF0IHR5cGUgZXhpc3QgaW4gdGhlIHNlbGVjdGlvbiwgb3IgYWRkIGl0IG90aGVyd2lzZS4gSWYgdGhlXG5zZWxlY3Rpb24gaXMgZW1wdHksIHRoaXMgYXBwbGllcyB0byB0aGUgW3N0b3JlZFxubWFya3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykgaW5zdGVhZCBvZiBhIHJhbmdlIG9mIHRoZVxuZG9jdW1lbnQuXG4qL1xuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSwgYXR0cnMgPSBudWxsLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlbW92ZVdoZW5QcmVzZW50ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5yZW1vdmVXaGVuUHJlc2VudCkgIT09IGZhbHNlO1xuICAgIGxldCBlbnRlckF0b21zID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5lbnRlcklubGluZUF0b21zKSAhPT0gZmFsc2U7XG4gICAgbGV0IGRyb3BTcGFjZSA9ICEob3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVXaGl0ZXNwYWNlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyBlbXB0eSwgJGN1cnNvciwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgoZW1wdHkgJiYgISRjdXJzb3IpIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUsIGVudGVyQXRvbXMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGN1cnNvci5tYXJrcygpKSlcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIGlmICghZW50ZXJBdG9tcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gcmVtb3ZlSW5saW5lQXRvbXMocmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlV2hlblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gIXJhbmdlcy5zb21lKHIgPT4gc3RhdGUuZG9jLnJhbmdlSGFzTWFyayhyLiRmcm9tLnBvcywgci4kdG8ucG9zLCBtYXJrVHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gIXJhbmdlcy5ldmVyeShyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHIuJGZyb20ucG9zLCByLiR0by5wb3MsIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZyA9ICFtYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpICYmICEhcGFyZW50ICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKG5vZGUuaXNUZXh0ICYmIC9eXFxzKiQvLnRlc3Qobm9kZS50ZXh0QmV0d2VlbihNYXRoLm1heCgwLCByLiRmcm9tLnBvcyAtIHBvcyksIE1hdGgubWluKG5vZGUubm9kZVNpemUsIHIuJHRvLnBvcyAtIHBvcykpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhbWlzc2luZztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9ICRmcm9tLnBvcywgdG8gPSAkdG8ucG9zLCBzdGFydCA9ICRmcm9tLm5vZGVBZnRlciwgZW5kID0gJHRvLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VTdGFydCA9IGRyb3BTcGFjZSAmJiBzdGFydCAmJiBzdGFydC5pc1RleHQgPyAvXlxccyovLmV4ZWMoc3RhcnQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUVuZCA9IGRyb3BTcGFjZSAmJiBlbmQgJiYgZW5kLmlzVGV4dCA/IC9cXHMqJC8uZXhlYyhlbmQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICsgc3BhY2VTdGFydCA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSBzcGFjZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIC09IHNwYWNlRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgbWFya1R5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGlzSm9pbmFibGUpIHtcbiAgICByZXR1cm4gKHRyKSA9PiB7XG4gICAgICAgIGlmICghdHIuaXNHZW5lcmljKVxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFuZ2VzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IG1hcC5tYXAocmFuZ2VzW2pdKTtcbiAgICAgICAgICAgIG1hcC5mb3JFYWNoKChfcywgX2UsIGZyb20sIHRvKSA9PiByYW5nZXMucHVzaChmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggam9pbmFibGUgcG9pbnRzIGV4aXN0IGluc2lkZSB0aG9zZSByYW5nZXMsXG4gICAgICAgIC8vIGJ5IGNoZWNraW5nIGFsbCBub2RlIGJvdW5kYXJpZXMgaW4gdGhlaXIgcGFyZW50IG5vZGVzLlxuICAgICAgICBsZXQgam9pbmFibGUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2ldLCB0byA9IHJhbmdlc1tpICsgMV07XG4gICAgICAgICAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgZGVwdGggPSAkZnJvbS5zaGFyZWREZXB0aCh0byksIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAmJiBqb2luYWJsZS5pbmRleE9mKHBvcykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLnR5cGUgPT0gYWZ0ZXIudHlwZSAmJiBpc0pvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmFibGUucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gYWZ0ZXIubm9kZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiB0aGUgam9pbmFibGUgcG9pbnRzXG4gICAgICAgIGpvaW5hYmxlLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5hYmxlW2ldKSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5hYmxlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCBhIGNvbW1hbmQgc28gdGhhdCwgd2hlbiBpdCBwcm9kdWNlcyBhIHRyYW5zZm9ybSB0aGF0IGNhdXNlc1xudHdvIGpvaW5hYmxlIG5vZGVzIHRvIGVuZCB1cCBuZXh0IHRvIGVhY2ggb3RoZXIsIHRob3NlIGFyZSBqb2luZWQuXG5Ob2RlcyBhcmUgY29uc2lkZXJlZCBqb2luYWJsZSB3aGVuIHRoZXkgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kXG53aGVuIHRoZSBgaXNKb2luYWJsZWAgcHJlZGljYXRlIHJldHVybnMgdHJ1ZSBmb3IgdGhlbSBvciwgaWYgYW5cbmFycmF5IG9mIHN0cmluZ3Mgd2FzIHBhc3NlZCwgaWYgdGhlaXIgbm9kZSB0eXBlIG5hbWUgaXMgaW4gdGhhdFxuYXJyYXkuXG4qL1xuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICAgIGxldCBjYW5Kb2luID0gQXJyYXkuaXNBcnJheShpc0pvaW5hYmxlKSA/IChub2RlKSA9PiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTFcbiAgICAgICAgOiBpc0pvaW5hYmxlO1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG59XG4vKipcbkNvbWJpbmUgYSBudW1iZXIgb2YgY29tbWFuZCBmdW5jdGlvbnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiAod2hpY2hcbmNhbGxzIHRoZW0gb25lIGJ5IG9uZSB1bnRpbCBvbmUgcmV0dXJucyB0cnVlKS5cbiovXG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKC4uLmNvbW1hbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tYW5kc1tpXShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmxldCBiYWNrc3BhY2UgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkJhY2t3YXJkLCBzZWxlY3ROb2RlQmFja3dhcmQpO1xubGV0IGRlbCA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luRm9yd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQpO1xuLyoqXG5BIGJhc2ljIGtleW1hcCBjb250YWluaW5nIGJpbmRpbmdzIG5vdCBzcGVjaWZpYyB0byBhbnkgc2NoZW1hLlxuQmluZHMgdGhlIGZvbGxvd2luZyBrZXlzICh3aGVuIG11bHRpcGxlIGNvbW1hbmRzIGFyZSBsaXN0ZWQsIHRoZXlcbmFyZSBjaGFpbmVkIHdpdGggW2BjaGFpbkNvbW1hbmRzYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmNoYWluQ29tbWFuZHMpKTpcblxuKiAqKkVudGVyKiogdG8gYG5ld2xpbmVJbkNvZGVgLCBgY3JlYXRlUGFyYWdyYXBoTmVhcmAsIGBsaWZ0RW1wdHlCbG9ja2AsIGBzcGxpdEJsb2NrYFxuKiAqKk1vZC1FbnRlcioqIHRvIGBleGl0Q29kZWBcbiogKipCYWNrc3BhY2UqKiBhbmQgKipNb2QtQmFja3NwYWNlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luQmFja3dhcmRgLCBgc2VsZWN0Tm9kZUJhY2t3YXJkYFxuKiAqKkRlbGV0ZSoqIGFuZCAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1hKiogdG8gYHNlbGVjdEFsbGBcbiovXG5jb25zdCBwY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJFbnRlclwiOiBjaGFpbkNvbW1hbmRzKG5ld2xpbmVJbkNvZGUsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGxpZnRFbXB0eUJsb2NrLCBzcGxpdEJsb2NrKSxcbiAgICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgICBcIkJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJNb2QtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJEZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLURlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG4vKipcbkEgY29weSBvZiBgcGNCYXNlS2V5bWFwYCB0aGF0IGFsc28gYmluZHMgKipDdHJsLWgqKiBsaWtlIEJhY2tzcGFjZSxcbioqQ3RybC1kKiogbGlrZSBEZWxldGUsICoqQWx0LUJhY2tzcGFjZSoqIGxpa2UgQ3RybC1CYWNrc3BhY2UsIGFuZFxuKipDdHJsLUFsdC1CYWNrc3BhY2UqKiwgKipBbHQtRGVsZXRlKiosIGFuZCAqKkFsdC1kKiogbGlrZVxuQ3RybC1EZWxldGUuXG4qL1xuY29uc3QgbWFjQmFzZUtleW1hcCA9IHtcbiAgICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gICAgXCJBbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1CYWNrc3BhY2VcIl0sXG4gICAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtRGVsZXRlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1hXCI6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICAgIFwiQ3RybC1lXCI6IHNlbGVjdFRleHRibG9ja0VuZFxufTtcbmZvciAobGV0IGtleSBpbiBwY0Jhc2VLZXltYXApXG4gICAgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcy5wbGF0Zm9ybSA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xuLyoqXG5EZXBlbmRpbmcgb24gdGhlIGRldGVjdGVkIHBsYXRmb3JtLCB0aGlzIHdpbGwgaG9sZFxuW2BwY0Jhc2VrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMucGNCYXNlS2V5bWFwKSBvclxuW2BtYWNCYXNlS2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLm1hY0Jhc2VLZXltYXApLlxuKi9cbmNvbnN0IGJhc2VLZXltYXAgPSBtYWMgPyBtYWNCYXNlS2V5bWFwIDogcGNCYXNlS2V5bWFwO1xuXG5leHBvcnQgeyBhdXRvSm9pbiwgYmFzZUtleW1hcCwgY2hhaW5Db21tYW5kcywgY3JlYXRlUGFyYWdyYXBoTmVhciwgZGVsZXRlU2VsZWN0aW9uLCBleGl0Q29kZSwgam9pbkJhY2t3YXJkLCBqb2luRG93biwgam9pbkZvcndhcmQsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCwgam9pblRleHRibG9ja0ZvcndhcmQsIGpvaW5VcCwgbGlmdCwgbGlmdEVtcHR5QmxvY2ssIG1hY0Jhc2VLZXltYXAsIG5ld2xpbmVJbkNvZGUsIHBjQmFzZUtleW1hcCwgc2VsZWN0QWxsLCBzZWxlY3ROb2RlQmFja3dhcmQsIHNlbGVjdE5vZGVGb3J3YXJkLCBzZWxlY3RQYXJlbnROb2RlLCBzZWxlY3RUZXh0YmxvY2tFbmQsIHNlbGVjdFRleHRibG9ja1N0YXJ0LCBzZXRCbG9ja1R5cGUsIHNwbGl0QmxvY2ssIHNwbGl0QmxvY2tBcywgc3BsaXRCbG9ja0tlZXBNYXJrcywgdG9nZ2xlTWFyaywgd3JhcEluIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-commands/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-dropcursor/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\n/**\nCreate a plugin that, when added to a ProseMirror instance,\ncauses a decoration to show up at the drop position when something\nis dragged over the editor.\n\nNodes may add a `disableDropCursor` property to their spec to\ncontrol the showing of a drop cursor inside them. This may be a\nboolean or a function, which will be called with a view and a\nposition, and should return a boolean.\n*/\nfunction dropCursor(options = {}) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view(editorView) { return new DropCursorView(editorView, options); }\n    });\n}\nclass DropCursorView {\n    constructor(editorView, options) {\n        var _a;\n        this.editorView = editorView;\n        this.cursorPos = null;\n        this.element = null;\n        this.timeout = -1;\n        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;\n        this.color = options.color === false ? undefined : (options.color || \"black\");\n        this.class = options.class;\n        this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n            let handler = (e) => { this[name](e); };\n            editorView.dom.addEventListener(name, handler);\n            return { name, handler };\n        });\n    }\n    destroy() {\n        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));\n    }\n    update(editorView, prevState) {\n        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n            if (this.cursorPos > editorView.state.doc.content.size)\n                this.setCursor(null);\n            else\n                this.updateOverlay();\n        }\n    }\n    setCursor(pos) {\n        if (pos == this.cursorPos)\n            return;\n        this.cursorPos = pos;\n        if (pos == null) {\n            this.element.parentNode.removeChild(this.element);\n            this.element = null;\n        }\n        else {\n            this.updateOverlay();\n        }\n    }\n    updateOverlay() {\n        let $pos = this.editorView.state.doc.resolve(this.cursorPos);\n        let isBlock = !$pos.parent.inlineContent, rect;\n        if (isBlock) {\n            let before = $pos.nodeBefore, after = $pos.nodeAfter;\n            if (before || after) {\n                let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));\n                if (node) {\n                    let nodeRect = node.getBoundingClientRect();\n                    let top = before ? nodeRect.bottom : nodeRect.top;\n                    if (before && after)\n                        top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n                    rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };\n                }\n            }\n        }\n        if (!rect) {\n            let coords = this.editorView.coordsAtPos(this.cursorPos);\n            rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };\n        }\n        let parent = this.editorView.dom.offsetParent;\n        if (!this.element) {\n            this.element = parent.appendChild(document.createElement(\"div\"));\n            if (this.class)\n                this.element.className = this.class;\n            this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none;\";\n            if (this.color) {\n                this.element.style.backgroundColor = this.color;\n            }\n        }\n        this.element.classList.toggle(\"prosemirror-dropcursor-block\", isBlock);\n        this.element.classList.toggle(\"prosemirror-dropcursor-inline\", !isBlock);\n        let parentLeft, parentTop;\n        if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n            parentLeft = -pageXOffset;\n            parentTop = -pageYOffset;\n        }\n        else {\n            let rect = parent.getBoundingClientRect();\n            parentLeft = rect.left - parent.scrollLeft;\n            parentTop = rect.top - parent.scrollTop;\n        }\n        this.element.style.left = (rect.left - parentLeft) + \"px\";\n        this.element.style.top = (rect.top - parentTop) + \"px\";\n        this.element.style.width = (rect.right - rect.left) + \"px\";\n        this.element.style.height = (rect.bottom - rect.top) + \"px\";\n    }\n    scheduleRemoval(timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => this.setCursor(null), timeout);\n    }\n    dragover(event) {\n        if (!this.editorView.editable)\n            return;\n        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });\n        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n        let disableDropCursor = node && node.type.spec.disableDropCursor;\n        let disabled = typeof disableDropCursor == \"function\" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;\n        if (pos && !disabled) {\n            let target = pos.pos;\n            if (this.editorView.dragging && this.editorView.dragging.slice) {\n                let point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.dropPoint)(this.editorView.state.doc, target, this.editorView.dragging.slice);\n                if (point != null)\n                    target = point;\n            }\n            this.setCursor(target);\n            this.scheduleRemoval(5000);\n        }\n    }\n    dragend() {\n        this.scheduleRemoval(20);\n    }\n    drop() {\n        this.scheduleRemoval(20);\n    }\n    dragleave(event) {\n        if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n            this.setCursor(null);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJDO0FBQ087O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZUFBZSxxREFBTTtBQUNyQiwyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0IiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxwcm9zZW1pcnJvci1kcm9wY3Vyc29yXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG4vKipcbkNyZWF0ZSBhIHBsdWdpbiB0aGF0LCB3aGVuIGFkZGVkIHRvIGEgUHJvc2VNaXJyb3IgaW5zdGFuY2UsXG5jYXVzZXMgYSBkZWNvcmF0aW9uIHRvIHNob3cgdXAgYXQgdGhlIGRyb3AgcG9zaXRpb24gd2hlbiBzb21ldGhpbmdcbmlzIGRyYWdnZWQgb3ZlciB0aGUgZWRpdG9yLlxuXG5Ob2RlcyBtYXkgYWRkIGEgYGRpc2FibGVEcm9wQ3Vyc29yYCBwcm9wZXJ0eSB0byB0aGVpciBzcGVjIHRvXG5jb250cm9sIHRoZSBzaG93aW5nIG9mIGEgZHJvcCBjdXJzb3IgaW5zaWRlIHRoZW0uIFRoaXMgbWF5IGJlIGFcbmJvb2xlYW4gb3IgYSBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHZpZXcgYW5kIGFcbnBvc2l0aW9uLCBhbmQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHZpZXcoZWRpdG9yVmlldykgeyByZXR1cm4gbmV3IERyb3BDdXJzb3JWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpOyB9XG4gICAgfSk7XG59XG5jbGFzcyBEcm9wQ3Vyc29yVmlldyB7XG4gICAgY29uc3RydWN0b3IoZWRpdG9yVmlldywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldyA9IGVkaXRvclZpZXc7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMud2lkdGggPSAoX2EgPSBvcHRpb25zLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvciA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiAob3B0aW9ucy5jb2xvciB8fCBcImJsYWNrXCIpO1xuICAgICAgICB0aGlzLmNsYXNzID0gb3B0aW9ucy5jbGFzcztcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtcImRyYWdvdmVyXCIsIFwiZHJhZ2VuZFwiLCBcImRyb3BcIiwgXCJkcmFnbGVhdmVcIl0ubWFwKG5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSAoZSkgPT4geyB0aGlzW25hbWVdKGUpOyB9O1xuICAgICAgICAgICAgZWRpdG9yVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIGhhbmRsZXIgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaCgoeyBuYW1lLCBoYW5kbGVyIH0pID0+IHRoaXMuZWRpdG9yVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSk7XG4gICAgfVxuICAgIHVwZGF0ZShlZGl0b3JWaWV3LCBwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zICE9IG51bGwgJiYgcHJldlN0YXRlLmRvYyAhPSBlZGl0b3JWaWV3LnN0YXRlLmRvYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zID4gZWRpdG9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEN1cnNvcihwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVPdmVybGF5KCkge1xuICAgICAgICBsZXQgJHBvcyA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0aGlzLmN1cnNvclBvcyk7XG4gICAgICAgIGxldCBpc0Jsb2NrID0gISRwb3MucGFyZW50LmlubGluZUNvbnRlbnQsIHJlY3Q7XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSB8fCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MgLSAoYmVmb3JlID8gYmVmb3JlLm5vZGVTaXplIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBiZWZvcmUgPyBub2RlUmVjdC5ib3R0b20gOiBub2RlUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSAodG9wICsgdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBub2RlUmVjdC5sZWZ0LCByaWdodDogbm9kZVJlY3QucmlnaHQsIHRvcDogdG9wIC0gdGhpcy53aWR0aCAvIDIsIGJvdHRvbTogdG9wICsgdGhpcy53aWR0aCAvIDIgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gdGhpcy5lZGl0b3JWaWV3LmNvb3Jkc0F0UG9zKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IGNvb3Jkcy5sZWZ0IC0gdGhpcy53aWR0aCAvIDIsIHJpZ2h0OiBjb29yZHMubGVmdCArIHRoaXMud2lkdGggLyAyLCB0b3A6IGNvb3Jkcy50b3AsIGJvdHRvbTogY29vcmRzLmJvdHRvbSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVkaXRvclZpZXcuZG9tLm9mZnNldFBhcmVudDtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzKVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgei1pbmRleDogNTA7IHBvaW50ZXItZXZlbnRzOiBub25lO1wiO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItYmxvY2tcIiwgaXNCbG9jayk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwicHJvc2VtaXJyb3ItZHJvcGN1cnNvci1pbmxpbmVcIiwgIWlzQmxvY2spO1xuICAgICAgICBsZXQgcGFyZW50TGVmdCwgcGFyZW50VG9wO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQuYm9keSAmJiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24gPT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgcGFyZW50TGVmdCA9IC1wYWdlWE9mZnNldDtcbiAgICAgICAgICAgIHBhcmVudFRvcCA9IC1wYWdlWU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcGFyZW50TGVmdCA9IHJlY3QubGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgcGFyZW50VG9wID0gcmVjdC50b3AgLSBwYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gKHJlY3QubGVmdCAtIHBhcmVudExlZnQpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gKHJlY3QudG9wIC0gcGFyZW50VG9wKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApICsgXCJweFwiO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbW92YWwodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNldEN1cnNvcihudWxsKSwgdGltZW91dCk7XG4gICAgfVxuICAgIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3JWaWV3LmVkaXRhYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5lZGl0b3JWaWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgICBsZXQgbm9kZSA9IHBvcyAmJiBwb3MuaW5zaWRlID49IDAgJiYgdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgIGxldCBkaXNhYmxlRHJvcEN1cnNvciA9IG5vZGUgJiYgbm9kZS50eXBlLnNwZWMuZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IHR5cGVvZiBkaXNhYmxlRHJvcEN1cnNvciA9PSBcImZ1bmN0aW9uXCIgPyBkaXNhYmxlRHJvcEN1cnNvcih0aGlzLmVkaXRvclZpZXcsIHBvcywgZXZlbnQpIDogZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICAgIGlmIChwb3MgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcG9zLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcgJiYgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ID0gZHJvcFBvaW50KHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MsIHRhcmdldCwgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcih0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoNTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgICBkcm9wKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICAgIGRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMuZWRpdG9yVmlldy5kb20gfHwgIXRoaXMuZWRpdG9yVmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihudWxsKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGRyb3BDdXJzb3IgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-dropcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-gapcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* binding */ GapCursor),\n/* harmony export */   gapCursor: () => (/* binding */ gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ \"(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\");\n\n\n\n\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n    content() { return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFDZ0M7QUFDaEM7QUFDUzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3REFBUztBQUN0RTtBQUNBLGdCQUFnQixPQUFPLG9EQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdEQUF3RCw0REFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3REFBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0Isa0VBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5Q0FBeUM7QUFDL0UsNENBQTRDLDREQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUTtBQUN2QixvQ0FBb0MsUUFBUTtBQUM1QyxlQUFlLHVEQUFRO0FBQ3ZCLDZEQUE2RCxvREFBSztBQUNsRSxvQkFBb0IsNERBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQWEsb0JBQW9CLHdEQUFVLHNDQUFzQyxrQkFBa0I7QUFDOUc7O0FBRWdDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xccHJvc2VtaXJyb3ItZ2FwY3Vyc29yXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZXlkb3duSGFuZGxlciB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24gfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcblxuLyoqXG5HYXAgY3Vyc29yIHNlbGVjdGlvbnMgYXJlIHJlcHJlc2VudGVkIHVzaW5nIHRoaXMgY2xhc3MuIEl0c1xuYCRhbmNob3JgIGFuZCBgJGhlYWRgIHByb3BlcnRpZXMgYm90aCBwb2ludCBhdCB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuKi9cbmNsYXNzIEdhcEN1cnNvciBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZ2FwIGN1cnNvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgc3VwZXIoJHBvcywgJHBvcyk7XG4gICAgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG4gICAgY29udGVudCgpIHsgcmV0dXJuIFNsaWNlLmVtcHR5OyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgR2FwQ3Vyc29yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZ2FwY3Vyc29yXCIsIHBvczogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEdhcEN1cnNvci5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXBDdXJzb3IoZG9jLnJlc29sdmUoanNvbi5wb3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIG5ldyBHYXBCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyB2YWxpZCgkcG9zKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudC5pc1RleHRibG9jayB8fCAhY2xvc2VkQmVmb3JlKCRwb3MpIHx8ICFjbG9zZWRBZnRlcigkcG9zKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gcGFyZW50LnR5cGUuc3BlYy5hbGxvd0dhcEN1cnNvcjtcbiAgICAgICAgaWYgKG92ZXJyaWRlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgICAgIGxldCBkZWZsdCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkcG9zLmluZGV4KCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICByZXR1cm4gZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmRHYXBDdXJzb3JGcm9tKCRwb3MsIGRpciwgbXVzdE1vdmUgPSBmYWxzZSkge1xuICAgICAgICBzZWFyY2g6IGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghbXVzdE1vdmUgJiYgR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zO1xuICAgICAgICAgICAgbGV0IHBvcyA9ICRwb3MucG9zLCBuZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFNjYW4gdXAgZnJvbSB0aGlzIHBvc2l0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgPCBwYXJlbnQuY2hpbGRDb3VudCA6ICRwb3MuaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwYXJlbnQuY2hpbGQoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA6ICRwb3MuaW5kZXgoZCkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFuZCB0aGVuIGRvd24gaW50byB0aGUgbmV4dCBub2RlXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc2lkZSA9IGRpciA+IDAgPyBuZXh0LmZpcnN0Q2hpbGQgOiBuZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAoIWluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5pc0F0b20gJiYgIW5leHQuaXNUZXh0ICYmICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHBvcyA9ICRwb3MuZG9jLnJlc29sdmUocG9zICsgbmV4dC5ub2RlU2l6ZSAqIGRpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gaW5zaWRlO1xuICAgICAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgICAgICAgbGV0ICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkdhcEN1cnNvci5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuR2FwQ3Vyc29yLmZpbmRGcm9tID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tO1xuU2VsZWN0aW9uLmpzb25JRChcImdhcGN1cnNvclwiLCBHYXBDdXJzb3IpO1xuY2xhc3MgR2FwQm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKHBvcykge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXBCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLnBvcykpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZWRCZWZvcmUoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIC8vIEF0IHRoZSBzdGFydCBvZiB0aGlzIHBhcmVudCwgbG9vayBhdCBuZXh0IG9uZVxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGlmIHRoZSBub2RlIGJlZm9yZSAob3IgaXRzIGZpcnN0IGFuY2VzdG9yKSBpcyBjbG9zZWRcbiAgICAgICAgZm9yIChsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7OyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50KSB8fCBiZWZvcmUuaXNBdG9tIHx8IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgc3RhcnQgb2YgZG9jdW1lbnRcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlZEFmdGVyKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSBwYXJlbnQuY2hpbGQoaW5kZXgpOzsgYWZ0ZXIgPSBhZnRlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGFmdGVyLmNoaWxkQ291bnQgPT0gMCAmJiAhYWZ0ZXIuaW5saW5lQ29udGVudCkgfHwgYWZ0ZXIuaXNBdG9tIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQ3JlYXRlIGEgZ2FwIGN1cnNvciBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgdGhpcyB3aWxsIGNhcHR1cmUgY2xpY2tzXG5uZWFyIGFuZCBhcnJvdy1rZXktbW90aW9uIHBhc3QgcGxhY2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIG5vcm1hbGx5XG5zZWxlY3RhYmxlIHBvc2l0aW9uIG5lYXJieSwgYW5kIGNyZWF0ZSBhIGdhcCBjdXJzb3Igc2VsZWN0aW9uIGZvclxudGhlbS4gVGhlIGN1cnNvciBpcyBkcmF3biBhcyBhbiBlbGVtZW50IHdpdGggY2xhc3NcbmBQcm9zZU1pcnJvci1nYXBjdXJzb3JgLiBZb3UgY2FuIGVpdGhlciBpbmNsdWRlXG5gc3R5bGUvZ2FwY3Vyc29yLmNzc2AgZnJvbSB0aGUgcGFja2FnZSdzIGRpcmVjdG9yeSBvciBhZGQgeW91ciBvd25cbnN0eWxlcyB0byBtYWtlIGl0IHZpc2libGUuXG4qL1xuZnVuY3Rpb24gZ2FwQ3Vyc29yKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBkcmF3R2FwQ3Vyc29yLFxuICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2VlbihfdmlldywgJGFuY2hvciwgJGhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkgPyBuZXcgR2FwQ3Vyc29yKCRoZWFkKSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7IGJlZm9yZWlucHV0OiBiZWZvcmVpbnB1dCB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGhhbmRsZUtleURvd24gPSBrZXlkb3duSGFuZGxlcih7XG4gICAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gICAgXCJBcnJvd1JpZ2h0XCI6IGFycm93KFwiaG9yaXpcIiwgMSksXG4gICAgXCJBcnJvd1VwXCI6IGFycm93KFwidmVydFwiLCAtMSksXG4gICAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcbmZ1bmN0aW9uIGFycm93KGF4aXMsIGRpcikge1xuICAgIGNvbnN0IGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyAoZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiKSA6IChkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCAkc3RhcnQgPSBkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSwgbXVzdE1vdmUgPSBzZWwuZW1wdHk7XG4gICAgICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyU3RyKSB8fCAkc3RhcnQuZGVwdGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzdGFydC5hZnRlcigpIDogJHN0YXJ0LmJlZm9yZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgICAgIGlmICghJGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkZm91bmQpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3IHx8ICF2aWV3LmVkaXRhYmxlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2xpY2tQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgIGlmIChjbGlja1BvcyAmJiBjbGlja1Bvcy5pbnNpZGUgPiAtMSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh2aWV3LnN0YXRlLmRvYy5ub2RlQXQoY2xpY2tQb3MuaW5zaWRlKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFRoaXMgaXMgYSBoYWNrIHRoYXQsIHdoZW4gYSBjb21wb3NpdGlvbiBzdGFydHMgd2hpbGUgYSBnYXAgY3Vyc29yXG4vLyBpcyBhY3RpdmUsIHF1aWNrbHkgY3JlYXRlcyBhbiBpbmxpbmUgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvXG4vLyBoYXBwZW4gaW4sIHRvIGF2b2lkIGl0IGJlaW5nIGFib3J0ZWQgYnkgdGhlIERPTSBzZWxlY3Rpb24gYmVpbmdcbi8vIG1vdmVkIGludG8gYSB2YWxpZCBwb3NpdGlvbi5cbmZ1bmN0aW9uIGJlZm9yZWlucHV0KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSAhPSBcImluc2VydENvbXBvc2l0aW9uVGV4dFwiIHx8ICEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBpbnNlcnQgPSAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSkuZmluZFdyYXBwaW5nKHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLnRleHQpO1xuICAgIGlmICghaW5zZXJ0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGZyYWcgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gaW5zZXJ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBmcmFnID0gRnJhZ21lbnQuZnJvbShpbnNlcnRbaV0uY3JlYXRlQW5kRmlsbChudWxsLCBmcmFnKSk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKCRmcm9tLnBvcywgJGZyb20ucG9zLCBuZXcgU2xpY2UoZnJhZywgMCwgMCkpO1xuICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgMSkpKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3R2FwQ3Vyc29yKHN0YXRlKSB7XG4gICAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1nYXBjdXJzb3JcIjtcbiAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbRGVjb3JhdGlvbi53aWRnZXQoc3RhdGUuc2VsZWN0aW9uLmhlYWQsIG5vZGUsIHsga2V5OiBcImdhcGN1cnNvclwiIH0pXSk7XG59XG5cbmV4cG9ydCB7IEdhcEN1cnNvciwgZ2FwQ3Vyc29yIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-gapcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* binding */ closeHistory),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoNoScroll: () => (/* binding */ redoNoScroll),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoNoScroll: () => (/* binding */ undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ \"(app-pages-browser)/./node_modules/rope-sequence/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"history\");\nconst closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDTztBQUNNOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLHFEQUFZO0FBQ3RDO0FBQ0E7QUFDQSwwQkFBMEIscURBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkJBQTZCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBUztBQUNoQyw0QkFBNEIsd0RBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStGIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xccHJvc2VtaXJyb3ItaGlzdG9yeVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJvcGVTZXF1ZW5jZSBmcm9tICdyb3BlLXNlcXVlbmNlJztcbmltcG9ydCB7IE1hcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgUGx1Z2luS2V5LCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8vIFByb3NlTWlycm9yJ3MgaGlzdG9yeSBpc24ndCBzaW1wbHkgYSB3YXkgdG8gcm9sbCBiYWNrIHRvIGEgcHJldmlvdXNcbi8vIHN0YXRlLCBiZWNhdXNlIFByb3NlTWlycm9yIHN1cHBvcnRzIGFwcGx5aW5nIGNoYW5nZXMgd2l0aG91dCBhZGRpbmdcbi8vIHRoZW0gdG8gdGhlIGhpc3RvcnkgKGZvciBleGFtcGxlIGR1cmluZyBjb2xsYWJvcmF0aW9uKS5cbi8vXG4vLyBUbyB0aGlzIGVuZCwgZWFjaCAnQnJhbmNoJyAob25lIGZvciB0aGUgdW5kbyBoaXN0b3J5IGFuZCBvbmUgZm9yXG4vLyB0aGUgcmVkbyBoaXN0b3J5KSBrZWVwcyBhbiBhcnJheSBvZiAnSXRlbXMnLCB3aGljaCBjYW4gb3B0aW9uYWxseVxuLy8gaG9sZCBhIHN0ZXAgKGFuIGFjdHVhbCB1bmRvYWJsZSBjaGFuZ2UpLCBhbmQgYWx3YXlzIGhvbGQgYSBwb3NpdGlvblxuLy8gbWFwICh3aGljaCBpcyBuZWVkZWQgdG8gbW92ZSBjaGFuZ2VzIGJlbG93IHRoZW0gdG8gYXBwbHkgdG8gdGhlXG4vLyBjdXJyZW50IGRvY3VtZW50KS5cbi8vXG4vLyBBbiBpdGVtIHRoYXQgaGFzIGJvdGggYSBzdGVwIGFuZCBhIHNlbGVjdGlvbiBib29rbWFyayBpcyB0aGUgc3RhcnRcbi8vIG9mIGFuICdldmVudCcg4oCUIGEgZ3JvdXAgb2YgY2hhbmdlcyB0aGF0IHdpbGwgYmUgdW5kb25lIG9yIHJlZG9uZSBhdFxuLy8gb25jZS4gKEl0IHN0b3JlcyBvbmx5IHRoZSBib29rbWFyaywgc2luY2UgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSB0b1xuLy8gcHJvdmlkZSBhIGRvY3VtZW50IHVudGlsIHRoZSBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgYXBwbGllZCwgd2hpY2hcbi8vIGlzIHVzZWZ1bCB3aGVuIGNvbXByZXNzaW5nLilcbi8vIFVzZWQgdG8gc2NoZWR1bGUgaGlzdG9yeSBjb21wcmVzc2lvblxuY29uc3QgbWF4X2VtcHR5X2l0ZW1zID0gNTAwO1xuY2xhc3MgQnJhbmNoIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgZXZlbnRDb3VudCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZXZlbnRDb3VudCA9IGV2ZW50Q291bnQ7XG4gICAgfVxuICAgIC8vIFBvcCB0aGUgbGF0ZXN0IGV2ZW50IG9mZiB0aGUgYnJhbmNoJ3MgaGlzdG9yeSBhbmQgYXBwbHkgaXRcbiAgICAvLyB0byBhIGRvY3VtZW50IHRyYW5zZm9ybS5cbiAgICBwb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcykge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDs7IGVuZC0tKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaXRlbXMuZ2V0KGVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKG5leHQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLS1lbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbWFwLCBtYXBGcm9tO1xuICAgICAgICBpZiAocHJlc2VydmVJdGVtcykge1xuICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gc3RhdGUudHI7XG4gICAgICAgIGxldCBzZWxlY3Rpb24sIHJlbWFpbmluZztcbiAgICAgICAgbGV0IGFkZEFmdGVyID0gW10sIGFkZEJlZm9yZSA9IFtdO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZW1hcCA9IHRoaXMucmVtYXBwaW5nKGVuZCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYXApIHtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChuZXcgSXRlbShpdGVtLm1hcCkpO1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcDtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCAmJiB0cmFuc2Zvcm0ubWF5YmVTdGVwKHN0ZXApLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW3RyYW5zZm9ybS5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGFkZEFmdGVyLnB1c2gobmV3IEl0ZW0obWFwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYWRkQWZ0ZXIubGVuZ3RoICsgYWRkQmVmb3JlLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ubWF5YmVTdGVwKGl0ZW0uc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSByZW1hcCA/IGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSkgOiBpdGVtLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuc2xpY2UoMCwgZW5kKS5hcHBlbmQoYWRkQmVmb3JlLnJldmVyc2UoKS5jb25jYXQoYWRkQWZ0ZXIpKSwgdGhpcy5ldmVudENvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiB7IHJlbWFpbmluZzogcmVtYWluaW5nLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbjogc2VsZWN0aW9uIH07XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIG5ldyBicmFuY2ggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtIGFkZGVkLlxuICAgIGFkZFRyYW5zZm9ybSh0cmFuc2Zvcm0sIHNlbGVjdGlvbiwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgbGV0IG5ld0l0ZW1zID0gW10sIGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIGxldCBvbGRJdGVtcyA9IHRoaXMuaXRlbXMsIGxhc3RJdGVtID0gIXByZXNlcnZlSXRlbXMgJiYgb2xkSXRlbXMubGVuZ3RoID8gb2xkSXRlbXMuZ2V0KG9sZEl0ZW1zLmxlbmd0aCAtIDEpIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm0uc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGVwID0gdHJhbnNmb3JtLnN0ZXBzW2ldLmludmVydCh0cmFuc2Zvcm0uZG9jc1tpXSk7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJdGVtKHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbaV0sIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZDtcbiAgICAgICAgICAgIGlmIChtZXJnZWQgPSBsYXN0SXRlbSAmJiBsYXN0SXRlbS5tZXJnZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZXJnZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2xkSXRlbXMgPSBvbGRJdGVtcy5zbGljZSgwLCBvbGRJdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlc2VydmVJdGVtcylcbiAgICAgICAgICAgICAgICBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG92ZXJmbG93ID0gZXZlbnRDb3VudCAtIGhpc3RPcHRpb25zLmRlcHRoO1xuICAgICAgICBpZiAob3ZlcmZsb3cgPiBERVBUSF9PVkVSRkxPVykge1xuICAgICAgICAgICAgb2xkSXRlbXMgPSBjdXRPZmZFdmVudHMob2xkSXRlbXMsIG92ZXJmbG93KTtcbiAgICAgICAgICAgIGV2ZW50Q291bnQgLT0gb3ZlcmZsb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2gob2xkSXRlbXMuYXBwZW5kKG5ld0l0ZW1zKSwgZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIHJlbWFwcGluZyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgbWFwcyA9IG5ldyBNYXBwaW5nO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBtaXJyb3JQb3MgPSBpdGVtLm1pcnJvck9mZnNldCAhPSBudWxsICYmIGkgLSBpdGVtLm1pcnJvck9mZnNldCA+PSBmcm9tXG4gICAgICAgICAgICAgICAgPyBtYXBzLm1hcHMubGVuZ3RoIC0gaXRlbS5taXJyb3JPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBtYXBzLmFwcGVuZE1hcChpdGVtLm1hcCwgbWlycm9yUG9zKTtcbiAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gbWFwcztcbiAgICB9XG4gICAgYWRkTWFwcyhhcnJheSkge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2godGhpcy5pdGVtcy5hcHBlbmQoYXJyYXkubWFwKG1hcCA9PiBuZXcgSXRlbShtYXApKSksIHRoaXMuZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhlIGNvbGxhYiBtb2R1bGUgcmVjZWl2ZXMgcmVtb3RlIGNoYW5nZXMsIHRoZSBoaXN0b3J5IGhhc1xuICAgIC8vIHRvIGtub3cgYWJvdXQgdGhvc2UsIHNvIHRoYXQgaXQgY2FuIGFkanVzdCB0aGUgc3RlcHMgdGhhdCB3ZXJlXG4gICAgLy8gcmViYXNlZCBvbiB0b3Agb2YgdGhlIHJlbW90ZSBjaGFuZ2VzLCBhbmQgaW5jbHVkZSB0aGUgcG9zaXRpb25cbiAgICAvLyBtYXBzIGZvciB0aGUgcmVtb3RlIGNoYW5nZXMgaW4gaXRzIGFycmF5IG9mIGl0ZW1zLlxuICAgIHJlYmFzZWQocmViYXNlZFRyYW5zZm9ybSwgcmViYXNlZENvdW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZWJhc2VkSXRlbXMgPSBbXSwgc3RhcnQgPSBNYXRoLm1heCgwLCB0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRDb3VudCk7XG4gICAgICAgIGxldCBtYXBwaW5nID0gcmViYXNlZFRyYW5zZm9ybS5tYXBwaW5nO1xuICAgICAgICBsZXQgbmV3VW50aWwgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHsgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgZXZlbnRDb3VudC0tOyB9LCBzdGFydCk7XG4gICAgICAgIGxldCBpUmViYXNlZCA9IHJlYmFzZWRDb3VudDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcuZ2V0TWlycm9yKC0taVJlYmFzZWQpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5ld1VudGlsID0gTWF0aC5taW4obmV3VW50aWwsIHBvcyk7XG4gICAgICAgICAgICBsZXQgbWFwID0gbWFwcGluZy5tYXBzW3Bvc107XG4gICAgICAgICAgICBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzW3Bvc10uaW52ZXJ0KHJlYmFzZWRUcmFuc2Zvcm0uZG9jc1twb3NdKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKG1hcHBpbmcuc2xpY2UoaVJlYmFzZWQgKyAxLCBwb3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwLCBzdGVwLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgIGxldCBuZXdNYXBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSByZWJhc2VkQ291bnQ7IGkgPCBuZXdVbnRpbDsgaSsrKVxuICAgICAgICAgICAgbmV3TWFwcy5wdXNoKG5ldyBJdGVtKG1hcHBpbmcubWFwc1tpXSkpO1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDAsIHN0YXJ0KS5hcHBlbmQobmV3TWFwcykuYXBwZW5kKHJlYmFzZWRJdGVtcyk7XG4gICAgICAgIGxldCBicmFuY2ggPSBuZXcgQnJhbmNoKGl0ZW1zLCBldmVudENvdW50KTtcbiAgICAgICAgaWYgKGJyYW5jaC5lbXB0eUl0ZW1Db3VudCgpID4gbWF4X2VtcHR5X2l0ZW1zKVxuICAgICAgICAgICAgYnJhbmNoID0gYnJhbmNoLmNvbXByZXNzKHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZEl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgfVxuICAgIGVtcHR5SXRlbUNvdW50KCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmICghaXRlbS5zdGVwKVxuICAgICAgICAgICAgY291bnQrKzsgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLy8gQ29tcHJlc3NpbmcgYSBicmFuY2ggbWVhbnMgcmV3cml0aW5nIGl0IHRvIHB1c2ggdGhlIGFpciAobWFwLW9ubHlcbiAgICAvLyBpdGVtcykgb3V0LiBEdXJpbmcgY29sbGFib3JhdGlvbiwgdGhlc2UgbmF0dXJhbGx5IGFjY3VtdWxhdGVcbiAgICAvLyBiZWNhdXNlIGVhY2ggcmVtb3RlIGNoYW5nZSBhZGRzIG9uZS4gVGhlIGB1cHRvYCBhcmd1bWVudCBpcyB1c2VkXG4gICAgLy8gdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgaXRlbXMgYmVsb3cgYSBnaXZlbiBsZXZlbCBhcmUgY29tcHJlc3NlZCxcbiAgICAvLyBiZWNhdXNlIGByZWJhc2VkYCByZWxpZXMgb24gYSBjbGVhbiwgdW50b3VjaGVkIHNldCBvZiBpdGVtcyBpblxuICAgIC8vIG9yZGVyIHRvIGFzc29jaWF0ZSBvbGQgaXRlbXMgd2l0aCByZWJhc2VkIHN0ZXBzLlxuICAgIGNvbXByZXNzKHVwdG8gPSB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICBsZXQgcmVtYXAgPSB0aGlzLnJlbWFwcGluZygwLCB1cHRvKSwgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaXRlbXMgPSBbXSwgZXZlbnRzID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA+PSB1cHRvKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBpdGVtLnN0ZXAubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSwgbWFwID0gc3RlcCAmJiBzdGVwLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBpZiAobWFwKVxuICAgICAgICAgICAgICAgICAgICByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SXRlbSA9IG5ldyBJdGVtKG1hcC5pbnZlcnQoKSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkLCBsYXN0ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZCA9IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsYXN0XS5tZXJnZShuZXdJdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2xhc3RdID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ubWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5mcm9tKGl0ZW1zLnJldmVyc2UoKSksIGV2ZW50cyk7XG4gICAgfVxufVxuQnJhbmNoLmVtcHR5ID0gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZW1wdHksIDApO1xuZnVuY3Rpb24gY3V0T2ZmRXZlbnRzKGl0ZW1zLCBuKSB7XG4gICAgbGV0IGN1dFBvaW50O1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uICYmIChuLS0gPT0gMCkpIHtcbiAgICAgICAgICAgIGN1dFBvaW50ID0gaTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVtcy5zbGljZShjdXRQb2ludCk7XG59XG5jbGFzcyBJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgKGZvcndhcmQpIHN0ZXAgbWFwIGZvciB0aGlzIGl0ZW0uXG4gICAgbWFwLCBcbiAgICAvLyBUaGUgaW52ZXJ0ZWQgc3RlcFxuICAgIHN0ZXAsIFxuICAgIC8vIElmIHRoaXMgaXMgbm9uLW51bGwsIHRoaXMgaXRlbSBpcyB0aGUgc3RhcnQgb2YgYSBncm91cCwgYW5kXG4gICAgLy8gdGhpcyBzZWxlY3Rpb24gaXMgdGhlIHN0YXJ0aW5nIHNlbGVjdGlvbiBmb3IgdGhlIGdyb3VwICh0aGUgb25lXG4gICAgLy8gdGhhdCB3YXMgYWN0aXZlIGJlZm9yZSB0aGUgZmlyc3Qgc3RlcCB3YXMgYXBwbGllZClcbiAgICBzZWxlY3Rpb24sIFxuICAgIC8vIElmIHRoaXMgaXRlbSBpcyB0aGUgaW52ZXJzZSBvZiBhIHByZXZpb3VzIG1hcHBpbmcgb24gdGhlIHN0YWNrLFxuICAgIC8vIHRoaXMgcG9pbnRzIGF0IHRoZSBpbnZlcnNlJ3Mgb2Zmc2V0XG4gICAgbWlycm9yT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5taXJyb3JPZmZzZXQgPSBtaXJyb3JPZmZzZXQ7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0ZXAgJiYgb3RoZXIuc3RlcCAmJiAhb3RoZXIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IG90aGVyLnN0ZXAubWVyZ2UodGhpcy5zdGVwKTtcbiAgICAgICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlbShzdGVwLmdldE1hcCgpLmludmVydCgpLCBzdGVwLCB0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBUaGUgdmFsdWUgb2YgdGhlIHN0YXRlIGZpZWxkIHRoYXQgdHJhY2tzIHVuZG8vcmVkbyBoaXN0b3J5IGZvciB0aGF0XG4vLyBzdGF0ZS4gV2lsbCBiZSBzdG9yZWQgaW4gdGhlIHBsdWdpbiBzdGF0ZSB3aGVuIHRoZSBoaXN0b3J5IHBsdWdpblxuLy8gaXMgYWN0aXZlLlxuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZSYW5nZXMsIHByZXZUaW1lLCBwcmV2Q29tcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlJhbmdlcyA9IHByZXZSYW5nZXM7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2Q29tcG9zaXRpb24gPSBwcmV2Q29tcG9zaXRpb247XG4gICAgfVxufVxuY29uc3QgREVQVEhfT1ZFUkZMT1cgPSAyMDtcbi8vIFJlY29yZCBhIHRyYW5zZm9ybWF0aW9uIGluIHVuZG8gaGlzdG9yeS5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNhY3Rpb24oaGlzdG9yeSwgc3RhdGUsIHRyLCBvcHRpb25zKSB7XG4gICAgbGV0IGhpc3RvcnlUciA9IHRyLmdldE1ldGEoaGlzdG9yeUtleSksIHJlYmFzZWQ7XG4gICAgaWYgKGhpc3RvcnlUcilcbiAgICAgICAgcmV0dXJuIGhpc3RvcnlUci5oaXN0b3J5U3RhdGU7XG4gICAgaWYgKHRyLmdldE1ldGEoY2xvc2VIaXN0b3J5S2V5KSlcbiAgICAgICAgaGlzdG9yeSA9IG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZSwgbnVsbCwgMCwgLTEpO1xuICAgIGxldCBhcHBlbmRlZCA9IHRyLmdldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIpO1xuICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KSkge1xuICAgICAgICBpZiAoYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KS5yZWRvKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBoaXN0b3J5LnVuZG9uZSwgcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgbnVsbCwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ci5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpICE9PSBmYWxzZSAmJiAhKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgPT09IGZhbHNlKSkge1xuICAgICAgICAvLyBHcm91cCB0cmFuc2Zvcm1zIHRoYXQgb2NjdXIgaW4gcXVpY2sgc3VjY2Vzc2lvbiBpbnRvIG9uZSBldmVudC5cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gdHIuZ2V0TWV0YShcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgbmV3R3JvdXAgPSBoaXN0b3J5LnByZXZUaW1lID09IDAgfHxcbiAgICAgICAgICAgICghYXBwZW5kZWQgJiYgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24gIT0gY29tcG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAoaGlzdG9yeS5wcmV2VGltZSA8ICh0ci50aW1lIHx8IDApIC0gb3B0aW9ucy5uZXdHcm91cERlbGF5IHx8ICFpc0FkamFjZW50VG8odHIsIGhpc3RvcnkucHJldlJhbmdlcykpKTtcbiAgICAgICAgbGV0IHByZXZSYW5nZXMgPSBhcHBlbmRlZCA/IG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpIDogcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwcyk7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIG5ld0dyb3VwID8gc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCkgOiB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIEJyYW5jaC5lbXB0eSwgcHJldlJhbmdlcywgdHIudGltZSwgY29tcG9zaXRpb24gPT0gbnVsbCA/IGhpc3RvcnkucHJldkNvbXBvc2l0aW9uIDogY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWJhc2VkID0gdHIuZ2V0TWV0YShcInJlYmFzZWRcIikpIHtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgY29sbGFiIG1vZHVsZSB0byB0ZWxsIHRoZSBoaXN0b3J5IHRoYXQgc29tZSBvZiBpdHNcbiAgICAgICAgLy8gY29udGVudCBoYXMgYmVlbiByZWJhc2VkLlxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksIGhpc3RvcnkudW5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgaGlzdG9yeS51bmRvbmUuYWRkTWFwcyh0ci5tYXBwaW5nLm1hcHMpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnRUbyh0cmFuc2Zvcm0sIHByZXZSYW5nZXMpIHtcbiAgICBpZiAoIXByZXZSYW5nZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXRyYW5zZm9ybS5kb2NDaGFuZ2VkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYWRqYWNlbnQgPSBmYWxzZTtcbiAgICB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzWzBdLmZvckVhY2goKHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2UmFuZ2VzLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHN0YXJ0IDw9IHByZXZSYW5nZXNbaSArIDFdICYmIGVuZCA+PSBwcmV2UmFuZ2VzW2ldKVxuICAgICAgICAgICAgICAgIGFkamFjZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWRqYWNlbnQ7XG59XG5mdW5jdGlvbiByYW5nZXNGb3IobWFwcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gbWFwcy5sZW5ndGggLSAxOyBpID49IDAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAwOyBpLS0pXG4gICAgICAgIG1hcHNbaV0uZm9yRWFjaCgoX2Zyb20sIF90bywgZnJvbSwgdG8pID0+IHJlc3VsdC5wdXNoKGZyb20sIHRvKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlcyhyYW5nZXMsIG1hcHBpbmcpIHtcbiAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAocmFuZ2VzW2ldLCAxKSwgdG8gPSBtYXBwaW5nLm1hcChyYW5nZXNbaSArIDFdLCAtMSk7XG4gICAgICAgIGlmIChmcm9tIDw9IHRvKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQXBwbHkgdGhlIGxhdGVzdCBldmVudCBmcm9tIG9uZSBicmFuY2ggdG8gdGhlIGRvY3VtZW50IGFuZCBzaGlmdCB0aGUgZXZlbnRcbi8vIG9udG8gdGhlIG90aGVyIGJyYW5jaC5cbmZ1bmN0aW9uIGhpc3RUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgcmVkbykge1xuICAgIGxldCBwcmVzZXJ2ZUl0ZW1zID0gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpO1xuICAgIGxldCBoaXN0T3B0aW9ucyA9IGhpc3RvcnlLZXkuZ2V0KHN0YXRlKS5zcGVjLmNvbmZpZztcbiAgICBsZXQgcG9wID0gKHJlZG8gPyBoaXN0b3J5LnVuZG9uZSA6IGhpc3RvcnkuZG9uZSkucG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpO1xuICAgIGlmICghcG9wKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2VsZWN0aW9uID0gcG9wLnNlbGVjdGlvbi5yZXNvbHZlKHBvcC50cmFuc2Zvcm0uZG9jKTtcbiAgICBsZXQgYWRkZWQgPSAocmVkbyA/IGhpc3RvcnkuZG9uZSA6IGhpc3RvcnkudW5kb25lKS5hZGRUcmFuc2Zvcm0ocG9wLnRyYW5zZm9ybSwgc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCksIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBsZXQgbmV3SGlzdCA9IG5ldyBIaXN0b3J5U3RhdGUocmVkbyA/IGFkZGVkIDogcG9wLnJlbWFpbmluZywgcmVkbyA/IHBvcC5yZW1haW5pbmcgOiBhZGRlZCwgbnVsbCwgMCwgLTEpO1xuICAgIHJldHVybiBwb3AudHJhbnNmb3JtLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNldE1ldGEoaGlzdG9yeUtleSwgeyByZWRvLCBoaXN0b3J5U3RhdGU6IG5ld0hpc3QgfSk7XG59XG5sZXQgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlLCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IG51bGw7XG4vLyBDaGVjayB3aGV0aGVyIGFueSBwbHVnaW4gaW4gdGhlIGdpdmVuIHN0YXRlIGhhcyBhXG4vLyBgaGlzdG9yeVByZXNlcnZlSXRlbXNgIHByb3BlcnR5IGluIGl0cyBzcGVjLCBpbiB3aGljaCBjYXNlIHdlIG11c3Rcbi8vIHByZXNlcnZlIHN0ZXBzIGV4YWN0bHkgYXMgdGhleSBjYW1lIGluLCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4vLyByZWJhc2VkLlxuZnVuY3Rpb24gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpIHtcbiAgICBsZXQgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gICAgaWYgKGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zICE9IHBsdWdpbnMpIHtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwbHVnaW5zW2ldLnNwZWMuaGlzdG9yeVByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFByZXNlcnZlSXRlbXM7XG59XG4vKipcblNldCBhIGZsYWcgb24gdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IGZ1cnRoZXIgc3RlcHNcbmZyb20gYmVpbmcgYXBwZW5kZWQgdG8gYW4gZXhpc3RpbmcgaGlzdG9yeSBldmVudCAoc28gdGhhdCB0aGV5XG5yZXF1aXJlIGEgc2VwYXJhdGUgdW5kbyBjb21tYW5kIHRvIHVuZG8pLlxuKi9cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICAgIHJldHVybiB0ci5zZXRNZXRhKGNsb3NlSGlzdG9yeUtleSwgdHJ1ZSk7XG59XG5jb25zdCBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG5jb25zdCBjbG9zZUhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiY2xvc2VIaXN0b3J5XCIpO1xuLyoqXG5SZXR1cm5zIGEgcGx1Z2luIHRoYXQgZW5hYmxlcyB0aGUgdW5kbyBoaXN0b3J5IGZvciBhbiBlZGl0b3IuIFRoZVxucGx1Z2luIHdpbGwgdHJhY2sgdW5kbyBhbmQgcmVkbyBzdGFja3MsIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggdGhlXG5bYHVuZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS51bmRvKSBhbmQgW2ByZWRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkucmVkbykgY29tbWFuZHMuXG5cbllvdSBjYW4gc2V0IGFuIGBcImFkZFRvSGlzdG9yeVwiYCBbbWV0YWRhdGFcbnByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0TWV0YSkgb2YgYGZhbHNlYCBvbiBhIHRyYW5zYWN0aW9uXG50byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcm9sbGVkIGJhY2sgYnkgdW5kby5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgY29uZmlnID0geyBkZXB0aDogY29uZmlnLmRlcHRoIHx8IDEwMCxcbiAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnLm5ld0dyb3VwRGVsYXkgfHwgNTAwIH07XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IGhpc3RvcnlLZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKEJyYW5jaC5lbXB0eSwgQnJhbmNoLmVtcHR5LCBudWxsLCAwLCAtMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIGhpc3QsIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHRyLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dFR5cGUgPSBlLmlucHV0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRDb21tYW5kKHJlZG8sIHNjcm9sbCkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIGlmICghaGlzdCB8fCAocmVkbyA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lKS5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCByZWRvKTtcbiAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzY3JvbGwgPyB0ci5zY3JvbGxJbnRvVmlldygpIDogdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHVuZG9lcyB0aGUgbGFzdCBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCB1bmRvID0gYnVpbGRDb21tYW5kKGZhbHNlLCB0cnVlKTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVkb2VzIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCByZWRvID0gYnVpbGRDb21tYW5kKHRydWUsIHRydWUpO1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB1bmRvZXMgdGhlIGxhc3QgY2hhbmdlLiBEb24ndCBzY3JvbGwgdGhlXG5zZWxlY3Rpb24gaW50byB2aWV3LlxuKi9cbmNvbnN0IHVuZG9Ob1Njcm9sbCA9IGJ1aWxkQ29tbWFuZChmYWxzZSwgZmFsc2UpO1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCByZWRvZXMgdGhlIGxhc3QgdW5kb25lIGNoYW5nZS4gRG9uJ3RcbnNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlldy5cbiovXG5jb25zdCByZWRvTm9TY3JvbGwgPSBidWlsZENvbW1hbmQodHJ1ZSwgZmFsc2UpO1xuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiB1bmRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QudW5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5leHBvcnQgeyBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgcmVkb05vU2Nyb2xsLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9Ob1Njcm9sbCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-history/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* binding */ keydownHandler),\n/* harmony export */   keymap: () => (/* binding */ keymap)\n/* harmony export */ });\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ \"(app-pages-browser)/./node_modules/w3c-keyname/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n        let mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction normalize(map) {\n    let copy = Object.create(null);\n    for (let prop in map)\n        copy[normalizeKeyName(prop)] = map[prop];\n    return copy;\n}\nfunction modifiers(name, event, shift = true) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/**\nCreate a keymap plugin for the given set of bindings.\n\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\nfunctions, which will be called with `(EditorState, dispatch,\nEditorView)` arguments, and should return true when they've handled\nthe key. Note that the view argument isn't part of the command\nprotocol, but can be used as an escape hatch if a binding needs to\ndirectly interact with the UI.\n\nKey names may be strings like `\"Shift-Ctrl-Enter\"`—a key\nidentifier prefixed with zero or more modifiers. Key identifiers\nare based on the strings that can appear in\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\nUse lowercase letters to refer to letter keys (or uppercase letters\nif you want shift to be held). You may use `\"Space\"` as an alias\nfor the `\" \"` name.\n\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n`Meta-`) are recognized. For characters that are created by holding\nshift, the `Shift-` prefix is implied, and should not be added\nexplicitly.\n\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\nother platforms.\n\nYou can add multiple keymap plugins to an editor. The order in\nwhich they appear determines their precedence (the ones early in\nthe array get to dispatch first).\n*/\nfunction keymap(bindings) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n    let map = normalize(bindings);\n    return function (view, event) {\n        let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), baseName, direct = map[modifiers(name, event)];\n        if (direct && direct(view.state, view.dispatch, view))\n            return true;\n        // A character key\n        if (name.length == 1 && name != \" \") {\n            if (event.shiftKey) {\n                // In case the name was already modified by shift, try looking\n                // it up without its shift modifier\n                let noShift = map[modifiers(name, event, false)];\n                if (noShift && noShift(view.state, view.dispatch, view))\n                    return true;\n            }\n            if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n                (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {\n                // Try falling back to the keyCode when there's a modifier\n                // active or the character produced isn't ASCII, and our table\n                // produces a different name from the the keyCode. See #668,\n                // #1060\n                let fromCode = map[modifiers(baseName, event)];\n                if (fromCode && fromCode(view.state, view.dispatch, view))\n                    return true;\n            }\n        }\n        return false;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1rZXltYXAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ0Q7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFNLEdBQUcsU0FBUywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xccHJvc2VtaXJyb3Ita2V5bWFwXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZXlOYW1lLCBiYXNlIH0gZnJvbSAndzNjLWtleW5hbWUnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICAgIGxldCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKG1hYylcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICBjb3B5W25vcm1hbGl6ZUtleU5hbWUocHJvcCldID0gbWFwW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCA9IHRydWUpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbkNyZWF0ZSBhIGtleW1hcCBwbHVnaW4gZm9yIHRoZSBnaXZlbiBzZXQgb2YgYmluZGluZ3MuXG5cbkJpbmRpbmdzIHNob3VsZCBtYXAga2V5IG5hbWVzIHRvIFtjb21tYW5kXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMpLXN0eWxlXG5mdW5jdGlvbnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYChFZGl0b3JTdGF0ZSwgZGlzcGF0Y2gsXG5FZGl0b3JWaWV3KWAgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhleSd2ZSBoYW5kbGVkXG50aGUga2V5LiBOb3RlIHRoYXQgdGhlIHZpZXcgYXJndW1lbnQgaXNuJ3QgcGFydCBvZiB0aGUgY29tbWFuZFxucHJvdG9jb2wsIGJ1dCBjYW4gYmUgdXNlZCBhcyBhbiBlc2NhcGUgaGF0Y2ggaWYgYSBiaW5kaW5nIG5lZWRzIHRvXG5kaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBVSS5cblxuS2V5IG5hbWVzIG1heSBiZSBzdHJpbmdzIGxpa2UgYFwiU2hpZnQtQ3RybC1FbnRlclwiYOKAlGEga2V5XG5pZGVudGlmaWVyIHByZWZpeGVkIHdpdGggemVybyBvciBtb3JlIG1vZGlmaWVycy4gS2V5IGlkZW50aWZpZXJzXG5hcmUgYmFzZWQgb24gdGhlIHN0cmluZ3MgdGhhdCBjYW4gYXBwZWFyIGluXG5bYEtleUV2ZW50LmtleWBdKGh0dHBzOmRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpLlxuVXNlIGxvd2VyY2FzZSBsZXR0ZXJzIHRvIHJlZmVyIHRvIGxldHRlciBrZXlzIChvciB1cHBlcmNhc2UgbGV0dGVyc1xuaWYgeW91IHdhbnQgc2hpZnQgdG8gYmUgaGVsZCkuIFlvdSBtYXkgdXNlIGBcIlNwYWNlXCJgIGFzIGFuIGFsaWFzXG5mb3IgdGhlIGBcIiBcImAgbmFtZS5cblxuTW9kaWZpZXJzIGNhbiBiZSBnaXZlbiBpbiBhbnkgb3JkZXIuIGBTaGlmdC1gIChvciBgcy1gKSwgYEFsdC1gIChvclxuYGEtYCksIGBDdHJsLWAgKG9yIGBjLWAgb3IgYENvbnRyb2wtYCkgYW5kIGBDbWQtYCAob3IgYG0tYCBvclxuYE1ldGEtYCkgYXJlIHJlY29nbml6ZWQuIEZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgaG9sZGluZ1xuc2hpZnQsIHRoZSBgU2hpZnQtYCBwcmVmaXggaXMgaW1wbGllZCwgYW5kIHNob3VsZCBub3QgYmUgYWRkZWRcbmV4cGxpY2l0bHkuXG5cbllvdSBjYW4gdXNlIGBNb2QtYCBhcyBhIHNob3J0aGFuZCBmb3IgYENtZC1gIG9uIE1hYyBhbmQgYEN0cmwtYCBvblxub3RoZXIgcGxhdGZvcm1zLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXAgcGx1Z2lucyB0byBhbiBlZGl0b3IuIFRoZSBvcmRlciBpblxud2hpY2ggdGhleSBhcHBlYXIgZGV0ZXJtaW5lcyB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBlYXJseSBpblxudGhlIGFycmF5IGdldCB0byBkaXNwYXRjaCBmaXJzdCkuXG4qL1xuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oeyBwcm9wczogeyBoYW5kbGVLZXlEb3duOiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykgfSB9KTtcbn1cbi8qKlxuR2l2ZW4gYSBzZXQgb2YgYmluZGluZ3MgKHVzaW5nIHRoZSBzYW1lIGZvcm1hdCBhc1xuW2BrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8ja2V5bWFwLmtleW1hcCkpLCByZXR1cm4gYSBba2V5ZG93blxuaGFuZGxlcl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlS2V5RG93bikgdGhhdCBoYW5kbGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIHtcbiAgICBsZXQgbWFwID0gbm9ybWFsaXplKGJpbmRpbmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCksIGJhc2VOYW1lLCBkaXJlY3QgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50KV07XG4gICAgICAgIGlmIChkaXJlY3QgJiYgZGlyZWN0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEEgY2hhcmFjdGVyIGtleVxuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMSAmJiBuYW1lICE9IFwiIFwiKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBuYW1lIHdhcyBhbHJlYWR5IG1vZGlmaWVkIGJ5IHNoaWZ0LCB0cnkgbG9va2luZ1xuICAgICAgICAgICAgICAgIC8vIGl0IHVwIHdpdGhvdXQgaXRzIHNoaWZ0IG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgbGV0IG5vU2hpZnQgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBmYWxzZSldO1xuICAgICAgICAgICAgICAgIGlmIChub1NoaWZ0ICYmIG5vU2hpZnQodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBuYW1lLmNoYXJDb2RlQXQoMCkgPiAxMjcpICYmXG4gICAgICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBmYWxsaW5nIGJhY2sgdG8gdGhlIGtleUNvZGUgd2hlbiB0aGVyZSdzIGEgbW9kaWZpZXJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmUgb3IgdGhlIGNoYXJhY3RlciBwcm9kdWNlZCBpc24ndCBBU0NJSSwgYW5kIG91ciB0YWJsZVxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y2VzIGEgZGlmZmVyZW50IG5hbWUgZnJvbSB0aGUgdGhlIGtleUNvZGUuIFNlZSAjNjY4LFxuICAgICAgICAgICAgICAgIC8vICMxMDYwXG4gICAgICAgICAgICAgICAgbGV0IGZyb21Db2RlID0gbWFwW21vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQpXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUNvZGUgJiYgZnJvbUNvZGUodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBrZXlkb3duSGFuZGxlciwga2V5bWFwIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-schema-list/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* binding */ addListNodes),\n/* harmony export */   bulletList: () => (/* binding */ bulletList),\n/* harmony export */   liftListItem: () => (/* binding */ liftListItem),\n/* harmony export */   listItem: () => (/* binding */ listItem),\n/* harmony export */   orderedList: () => (/* binding */ orderedList),\n/* harmony export */   sinkListItem: () => (/* binding */ sinkListItem),\n/* harmony export */   splitListItem: () => (/* binding */ splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* binding */ splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* binding */ wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* binding */ wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to);\n        if (!range)\n            return false;\n        let tr = dispatch ? state.tr : null;\n        if (!wrapRangeInList(tr, range, listType, attrs))\n            return false;\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nTry to wrap the given node range in a list of the given type.\nReturn `true` when this is possible, `false` otherwise. When `tr`\nis non-null, the wrapping is added to that transaction. When it is\n`null`, the function only queries whether the wrapping is\npossible.\n*/\nfunction wrapRangeInList(tr, range, listType, attrs = null) {\n    let doJoin = false, outerRange = range, doc = range.$from.doc;\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n        // Don't do anything if this is the top of the list\n        if (range.$from.index(range.depth - 1) == 0)\n            return false;\n        let $insert = doc.resolve(range.start - 2);\n        outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($insert, $insert, range.depth);\n        if (range.endIndex < range.parent.childCount)\n            range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n        doJoin = true;\n    }\n    let wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(outerRange, listType, attrs, range);\n    if (!wrap)\n        return false;\n    if (tr)\n        doWrapInList(tr, range, wrap, doJoin, listType);\n    return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : undefined;\n        if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nActs like [`splitListItem`](https://prosemirror.net/docs/ref/#schema-list.splitListItem), but\nwithout resetting the set of active marks at the cursor.\n*/\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n    let split = splitListItem(itemType, itemAttrs);\n    return (state, dispatch) => {\n        return split(state, dispatch && (tr => {\n            let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n            if (marks)\n                tr.ensureMarks(marks);\n            dispatch(tr);\n        }));\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.liftTarget)(range);\n    if (target == null)\n        return false;\n    tr.lift(range, target);\n    let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)\n        tr.join($after.pos);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty)))\n        .append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUc7QUFDeEM7QUFDakI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsa0NBQWtDO0FBQ3hELGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekIsZUFBZTtBQUNmO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUNBQXlDO0FBQ2xGLHVDQUF1Qyx5Q0FBeUM7QUFDaEYsbUNBQW1DLHNCQUFzQjtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQVM7QUFDbEM7QUFDQSx3QkFBd0Isd0RBQVM7QUFDakM7QUFDQTtBQUNBLGVBQWUsbUVBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdURBQVE7QUFDMUIsc0NBQXNDLFFBQVE7QUFDOUMsa0JBQWtCLHVEQUFRO0FBQzFCLGdCQUFnQixvRUFBaUIsNEVBQTRFLG9EQUFLO0FBQ2xIO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxPQUFPO0FBQzVFLHNCQUFzQiwrREFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxzQkFBc0I7QUFDOUUsMkJBQTJCLHVEQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBUTtBQUMzQztBQUNBLCtFQUErRSxvREFBSztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQ0FBb0Msd0RBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1DQUFtQyxVQUFVLGdCQUFnQjtBQUMzRyxhQUFhLCtEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9FQUFpQix5Q0FBeUMsb0RBQUssQ0FBQyx1REFBUTtBQUM1RixvQkFBb0Isd0RBQVM7QUFDN0I7QUFDQSxtQkFBbUIsaUVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsT0FBTztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHVEQUFRLFNBQVMsdURBQVE7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBaUIsMkVBQTJFLG9EQUFLLFlBQVksdURBQVEsU0FBUyx1REFBUSxnQkFBZ0IsdURBQVE7QUFDOUssd0JBQXdCLHVEQUFRLFNBQVMsdURBQVEsZ0JBQWdCLHVEQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFRO0FBQ2hDLDRCQUE0QixvREFBSyxDQUFDLHVEQUFRLDRCQUE0Qix1REFBUTtBQUM5RTtBQUNBLHVDQUF1QyxvRUFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkoiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFxwcm9zZW1pcnJvci1zY2hlbWEtbGlzdFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmluZFdyYXBwaW5nLCBSZXBsYWNlQXJvdW5kU3RlcCwgY2FuU3BsaXQsIGxpZnRUYXJnZXQsIGNhbkpvaW4gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgTm9kZVJhbmdlLCBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG9sRE9NID0gW1wib2xcIiwgMF0sIHVsRE9NID0gW1widWxcIiwgMF0sIGxpRE9NID0gW1wibGlcIiwgMF07XG4vKipcbkFuIG9yZGVyZWQgbGlzdCBbbm9kZSBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMpLiBIYXMgYSBzaW5nbGVcbmF0dHJpYnV0ZSwgYG9yZGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIGF0IHdoaWNoIHRoZSBsaXN0XG5zdGFydHMgY291bnRpbmcsIGFuZCBkZWZhdWx0cyB0byAxLiBSZXByZXNlbnRlZCBhcyBhbiBgPG9sPmBcbmVsZW1lbnQuXG4qL1xuY29uc3Qgb3JkZXJlZExpc3QgPSB7XG4gICAgYXR0cnM6IHsgb3JkZXI6IHsgZGVmYXVsdDogMSwgdmFsaWRhdGU6IFwibnVtYmVyXCIgfSB9LFxuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwib2xcIiwgZ2V0QXR0cnMoZG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/ICtkb20uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgOiAxIH07XG4gICAgICAgICAgICB9IH1dLFxuICAgIHRvRE9NKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXR0cnMub3JkZXIgPT0gMSA/IG9sRE9NIDogW1wib2xcIiwgeyBzdGFydDogbm9kZS5hdHRycy5vcmRlciB9LCAwXTtcbiAgICB9XG59O1xuLyoqXG5BIGJ1bGxldCBsaXN0IG5vZGUgc3BlYywgcmVwcmVzZW50ZWQgaW4gdGhlIERPTSBhcyBgPHVsPmAuXG4qL1xuY29uc3QgYnVsbGV0TGlzdCA9IHtcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcInVsXCIgfV0sXG4gICAgdG9ET00oKSB7IHJldHVybiB1bERPTTsgfVxufTtcbi8qKlxuQSBsaXN0IGl0ZW0gKGA8bGk+YCkgc3BlYy5cbiovXG5jb25zdCBsaXN0SXRlbSA9IHtcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcImxpXCIgfV0sXG4gICAgdG9ET00oKSB7IHJldHVybiBsaURPTTsgfSxcbiAgICBkZWZpbmluZzogdHJ1ZVxufTtcbmZ1bmN0aW9uIGFkZChvYmosIHByb3BzKSB7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKVxuICAgICAgICBjb3B5W3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vKipcbkNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBhZGRpbmcgbGlzdC1yZWxhdGVkIG5vZGUgdHlwZXMgdG8gYSBtYXBcbnNwZWNpZnlpbmcgdGhlIG5vZGVzIGZvciBhIHNjaGVtYS4gQWRkc1xuW2BvcmRlcmVkTGlzdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5vcmRlcmVkTGlzdCkgYXMgYFwib3JkZXJlZF9saXN0XCJgLFxuW2BidWxsZXRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0LmJ1bGxldExpc3QpIGFzIGBcImJ1bGxldF9saXN0XCJgLCBhbmRcbltgbGlzdEl0ZW1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QubGlzdEl0ZW0pIGFzIGBcImxpc3RfaXRlbVwiYC5cblxuYGl0ZW1Db250ZW50YCBkZXRlcm1pbmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24gZm9yIHRoZSBsaXN0IGl0ZW1zLlxuSWYgeW91IHdhbnQgdGhlIGNvbW1hbmRzIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUgdG8gYXBwbHkgdG8geW91clxubGlzdCBzdHJ1Y3R1cmUsIGl0IHNob3VsZCBoYXZlIGEgc2hhcGUgbGlrZSBgXCJwYXJhZ3JhcGggYmxvY2sqXCJgIG9yXG5gXCJwYXJhZ3JhcGggKG9yZGVyZWRfbGlzdCB8IGJ1bGxldF9saXN0KSpcImAuIGBsaXN0R3JvdXBgIGNhbiBiZVxuZ2l2ZW4gdG8gYXNzaWduIGEgZ3JvdXAgbmFtZSB0byB0aGUgbGlzdCBub2RlIHR5cGVzLCBmb3IgZXhhbXBsZVxuYFwiYmxvY2tcImAuXG4qL1xuZnVuY3Rpb24gYWRkTGlzdE5vZGVzKG5vZGVzLCBpdGVtQ29udGVudCwgbGlzdEdyb3VwKSB7XG4gICAgcmV0dXJuIG5vZGVzLmFwcGVuZCh7XG4gICAgICAgIG9yZGVyZWRfbGlzdDogYWRkKG9yZGVyZWRMaXN0LCB7IGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwIH0pLFxuICAgICAgICBidWxsZXRfbGlzdDogYWRkKGJ1bGxldExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGxpc3RfaXRlbTogYWRkKGxpc3RJdGVtLCB7IGNvbnRlbnQ6IGl0ZW1Db250ZW50IH0pXG4gICAgfSk7XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIHNlbGVjdGlvbiBpbiBhIGxpc3Qgd2l0aFxudGhlIGdpdmVuIHR5cGUgYW4gYXR0cmlidXRlcy4gSWYgYGRpc3BhdGNoYCBpcyBudWxsLCBvbmx5IHJldHVybiBhXG52YWx1ZSB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgaXMgcG9zc2libGUsIGJ1dCBkb24ndCBhY3R1YWxseVxucGVyZm9ybSB0aGUgY2hhbmdlLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBkaXNwYXRjaCA/IHN0YXRlLnRyIDogbnVsbDtcbiAgICAgICAgaWYgKCF3cmFwUmFuZ2VJbkxpc3QodHIsIHJhbmdlLCBsaXN0VHlwZSwgYXR0cnMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuVHJ5IHRvIHdyYXAgdGhlIGdpdmVuIG5vZGUgcmFuZ2UgaW4gYSBsaXN0IG9mIHRoZSBnaXZlbiB0eXBlLlxuUmV0dXJuIGB0cnVlYCB3aGVuIHRoaXMgaXMgcG9zc2libGUsIGBmYWxzZWAgb3RoZXJ3aXNlLiBXaGVuIGB0cmBcbmlzIG5vbi1udWxsLCB0aGUgd3JhcHBpbmcgaXMgYWRkZWQgdG8gdGhhdCB0cmFuc2FjdGlvbi4gV2hlbiBpdCBpc1xuYG51bGxgLCB0aGUgZnVuY3Rpb24gb25seSBxdWVyaWVzIHdoZXRoZXIgdGhlIHdyYXBwaW5nIGlzXG5wb3NzaWJsZS5cbiovXG5mdW5jdGlvbiB3cmFwUmFuZ2VJbkxpc3QodHIsIHJhbmdlLCBsaXN0VHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgbGV0IGRvSm9pbiA9IGZhbHNlLCBvdXRlclJhbmdlID0gcmFuZ2UsIGRvYyA9IHJhbmdlLiRmcm9tLmRvYztcbiAgICAvLyBUaGlzIGlzIGF0IHRoZSB0b3Agb2YgYW4gZXhpc3RpbmcgbGlzdCBpdGVtXG4gICAgaWYgKHJhbmdlLmRlcHRoID49IDIgJiYgcmFuZ2UuJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdFR5cGUpICYmIHJhbmdlLnN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGlzIHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgICAgaWYgKHJhbmdlLiRmcm9tLmluZGV4KHJhbmdlLmRlcHRoIC0gMSkgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0ICRpbnNlcnQgPSBkb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgICAgICBvdXRlclJhbmdlID0gbmV3IE5vZGVSYW5nZSgkaW5zZXJ0LCAkaW5zZXJ0LCByYW5nZS5kZXB0aCk7XG4gICAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHJhbmdlLiRmcm9tLCBkb2MucmVzb2x2ZShyYW5nZS4kdG8uZW5kKHJhbmdlLmRlcHRoKSksIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgZG9Kb2luID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHdyYXAgPSBmaW5kV3JhcHBpbmcob3V0ZXJSYW5nZSwgbGlzdFR5cGUsIGF0dHJzLCByYW5nZSk7XG4gICAgaWYgKCF3cmFwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRyKVxuICAgICAgICBkb1dyYXBJbkxpc3QodHIsIHJhbmdlLCB3cmFwLCBkb0pvaW4sIGxpc3RUeXBlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRvV3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXBwZXJzLCBqb2luQmVmb3JlLCBsaXN0VHlwZSkge1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHJhbmdlLnN0YXJ0IC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHJhbmdlLmVuZCwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbiAgICBsZXQgZm91bmQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcHBlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh3cmFwcGVyc1tpXS50eXBlID09IGxpc3RUeXBlKVxuICAgICAgICAgICAgZm91bmQgPSBpICsgMTtcbiAgICBsZXQgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kO1xuICAgIGxldCBzcGxpdFBvcyA9IHJhbmdlLnN0YXJ0ICsgd3JhcHBlcnMubGVuZ3RoIC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBmb3IgKGxldCBpID0gcmFuZ2Uuc3RhcnRJbmRleCwgZSA9IHJhbmdlLmVuZEluZGV4LCBmaXJzdCA9IHRydWU7IGkgPCBlOyBpKyssIGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFmaXJzdCAmJiBjYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCBzcGxpdERlcHRoKSkge1xuICAgICAgICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHNwbGl0RGVwdGgpO1xuICAgICAgICAgICAgc3BsaXRQb3MgKz0gMiAqIHNwbGl0RGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXRQb3MgKz0gcGFyZW50LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG4vKipcbkJ1aWxkIGEgY29tbWFuZCB0aGF0IHNwbGl0cyBhIG5vbi1lbXB0eSB0ZXh0YmxvY2sgYXQgdGhlIHRvcCBsZXZlbFxub2YgYSBsaXN0IGl0ZW0gYnkgYWxzbyBzcGxpdHRpbmcgdGhhdCBsaXN0IGl0ZW0uXG4qL1xuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbShpdGVtVHlwZSwgaXRlbUF0dHJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0bywgbm9kZSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAgICAgICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xuICAgICAgICAgICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAgICAgICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgICAgICAgICBpZiAoJGZyb20uZGVwdGggPT0gMyB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9IGl0ZW1UeXBlIHx8XG4gICAgICAgICAgICAgICAgJGZyb20uaW5kZXgoLTIpICE9ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoQmVmb3JlID0gJGZyb20uaW5kZXgoLTEpID8gMSA6ICRmcm9tLmluZGV4KC0yKSA/IDIgOiAzO1xuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkLS0pXG4gICAgICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxXG4gICAgICAgICAgICAgICAgICAgIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgICAgICAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gLTE7XG4gICAgICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSwgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmIG5vZGUuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0VHlwZSA9ICR0by5wb3MgPT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpO1xuICAgICAgICBsZXQgdHlwZXMgPSBuZXh0VHlwZSA/IFtpdGVtQXR0cnMgPyB7IHR5cGU6IGl0ZW1UeXBlLCBhdHRyczogaXRlbUF0dHJzIH0gOiBudWxsLCB7IHR5cGU6IG5leHRUeXBlIH1dIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyLCB0eXBlcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdExpc3RJdGVtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0LnNwbGl0TGlzdEl0ZW0pLCBidXRcbndpdGhvdXQgcmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbUtlZXBNYXJrcyhpdGVtVHlwZSwgaXRlbUF0dHJzKSB7XG4gICAgbGV0IHNwbGl0ID0gc3BsaXRMaXN0SXRlbShpdGVtVHlwZSwgaXRlbUF0dHJzKTtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgICAgICByZXR1cm4gc3BsaXQoc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgICAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gbGlmdCB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIHVwIGludG9cbmEgd3JhcHBpbmcgbGlzdC5cbiovXG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRpc3BhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgLy8gSW5zaWRlIGEgcGFyZW50IGxpc3RcbiAgICAgICAgICAgIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO1xuICAgICAgICBlbHNlIC8vIE91dGVyIGxpc3Qgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkge1xuICAgIGxldCB0ciA9IHN0YXRlLnRyLCBlbmQgPSByYW5nZS5lbmQsIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHJhbmdlLnBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHIubGlmdChyYW5nZSwgdGFyZ2V0KTtcbiAgICBsZXQgJGFmdGVyID0gdHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoZW5kLCAtMSkgLSAxKTtcbiAgICBpZiAoY2FuSm9pbih0ci5kb2MsICRhZnRlci5wb3MpICYmICRhZnRlci5ub2RlQmVmb3JlLnR5cGUgPT0gJGFmdGVyLm5vZGVBZnRlci50eXBlKVxuICAgICAgICB0ci5qb2luKCRhZnRlci5wb3MpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmVuZCwgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgZSA9IHJhbmdlLnN0YXJ0SW5kZXg7IGkgPiBlOyBpLS0pIHtcbiAgICAgICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgbGV0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KSwgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gICAgaWYgKHRyLm1hcHBpbmcubWFwKHJhbmdlLmVuZCkgIT0gcmFuZ2Uuc3RhcnQgKyAkc3RhcnQubm9kZUFmdGVyLm5vZGVTaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICAgIGxldCBwYXJlbnQgPSAkc3RhcnQubm9kZSgtMSksIGluZGV4QmVmb3JlID0gJHN0YXJ0LmluZGV4KC0xKTtcbiAgICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgaXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0KSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXJ0ID0gJHN0YXJ0LnBvcywgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIGl0IGlzIG92ZXJ3cml0dGVuIHRvIGl0cyBlbmQuXG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSlcbiAgICAgICAgLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIHRvIHNpbmsgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiBkb3duXG5pbnRvIGFuIGlubmVyIGxpc3QuXG4qL1xuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgbm9kZSA9PiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlKTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBub2RlQmVmb3JlID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IEZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSByYW5nZS5zdGFydCwgYWZ0ZXIgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChiZWZvcmUgLSAobmVzdGVkQmVmb3JlID8gMyA6IDEpLCBhZnRlciwgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKVxuICAgICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhZGRMaXN0Tm9kZXMsIGJ1bGxldExpc3QsIGxpZnRMaXN0SXRlbSwgbGlzdEl0ZW0sIG9yZGVyZWRMaXN0LCBzaW5rTGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW1LZWVwTWFya3MsIHdyYXBJbkxpc3QsIHdyYXBSYW5nZUluTGlzdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-schema-list/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-tables/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-tables/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellBookmark: () => (/* binding */ CellBookmark),\n/* harmony export */   CellSelection: () => (/* binding */ CellSelection),\n/* harmony export */   ResizeState: () => (/* binding */ ResizeState),\n/* harmony export */   TableMap: () => (/* binding */ TableMap),\n/* harmony export */   TableView: () => (/* binding */ TableView),\n/* harmony export */   __clipCells: () => (/* binding */ clipCells),\n/* harmony export */   __insertCells: () => (/* binding */ insertCells),\n/* harmony export */   __pastedCells: () => (/* binding */ pastedCells),\n/* harmony export */   addColSpan: () => (/* binding */ addColSpan),\n/* harmony export */   addColumn: () => (/* binding */ addColumn),\n/* harmony export */   addColumnAfter: () => (/* binding */ addColumnAfter),\n/* harmony export */   addColumnBefore: () => (/* binding */ addColumnBefore),\n/* harmony export */   addRow: () => (/* binding */ addRow),\n/* harmony export */   addRowAfter: () => (/* binding */ addRowAfter),\n/* harmony export */   addRowBefore: () => (/* binding */ addRowBefore),\n/* harmony export */   cellAround: () => (/* binding */ cellAround),\n/* harmony export */   cellNear: () => (/* binding */ cellNear),\n/* harmony export */   colCount: () => (/* binding */ colCount),\n/* harmony export */   columnIsHeader: () => (/* binding */ columnIsHeader),\n/* harmony export */   columnResizing: () => (/* binding */ columnResizing),\n/* harmony export */   columnResizingPluginKey: () => (/* binding */ columnResizingPluginKey),\n/* harmony export */   deleteCellSelection: () => (/* binding */ deleteCellSelection),\n/* harmony export */   deleteColumn: () => (/* binding */ deleteColumn),\n/* harmony export */   deleteRow: () => (/* binding */ deleteRow),\n/* harmony export */   deleteTable: () => (/* binding */ deleteTable),\n/* harmony export */   findCell: () => (/* binding */ findCell),\n/* harmony export */   fixTables: () => (/* binding */ fixTables),\n/* harmony export */   fixTablesKey: () => (/* binding */ fixTablesKey),\n/* harmony export */   goToNextCell: () => (/* binding */ goToNextCell),\n/* harmony export */   handlePaste: () => (/* binding */ handlePaste),\n/* harmony export */   inSameTable: () => (/* binding */ inSameTable),\n/* harmony export */   isInTable: () => (/* binding */ isInTable),\n/* harmony export */   mergeCells: () => (/* binding */ mergeCells),\n/* harmony export */   moveCellForward: () => (/* binding */ moveCellForward),\n/* harmony export */   nextCell: () => (/* binding */ nextCell),\n/* harmony export */   pointsAtCell: () => (/* binding */ pointsAtCell),\n/* harmony export */   removeColSpan: () => (/* binding */ removeColSpan),\n/* harmony export */   removeColumn: () => (/* binding */ removeColumn),\n/* harmony export */   removeRow: () => (/* binding */ removeRow),\n/* harmony export */   rowIsHeader: () => (/* binding */ rowIsHeader),\n/* harmony export */   selectedRect: () => (/* binding */ selectedRect),\n/* harmony export */   selectionCell: () => (/* binding */ selectionCell),\n/* harmony export */   setCellAttr: () => (/* binding */ setCellAttr),\n/* harmony export */   splitCell: () => (/* binding */ splitCell),\n/* harmony export */   splitCellWithType: () => (/* binding */ splitCellWithType),\n/* harmony export */   tableEditing: () => (/* binding */ tableEditing),\n/* harmony export */   tableEditingKey: () => (/* binding */ tableEditingKey),\n/* harmony export */   tableNodeTypes: () => (/* binding */ tableNodeTypes),\n/* harmony export */   tableNodes: () => (/* binding */ tableNodes),\n/* harmony export */   toggleHeader: () => (/* binding */ toggleHeader),\n/* harmony export */   toggleHeaderCell: () => (/* binding */ toggleHeaderCell),\n/* harmony export */   toggleHeaderColumn: () => (/* binding */ toggleHeaderColumn),\n/* harmony export */   toggleHeaderRow: () => (/* binding */ toggleHeaderRow),\n/* harmony export */   updateColumnsOnResize: () => (/* binding */ updateColumnsOnResize)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-keymap */ \"(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n// src/index.ts\n\n\n// src/cellselection.ts\n\n\n\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  if (width === 0 || height === 0)\n    (problems || (problems = [])).push({ type: \"zero_sized\" });\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\n\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return _CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return _CellSelection.colSelection($anchorCell, $headCell);\n      else return new _CellSelection($anchorCell, $headCell);\n    }\n    return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty : content\n      );\n    }\n    const sel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isCellBoundarySelection(sel)) {\n    normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.from);\n  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\n\nvar fixTablesKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    } else if (prob.type == \"zero_sized\") {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\n\n\n\n\n// src/commands.ts\n\n\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */ new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\n// src/copypaste.ts\n\n\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__.keydownHandler)({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($next, 1);\n      else if (dir < 0)\n        newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;\n      else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\n\n\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, defaultCellMinWidth) {\n    this.node = node;\n    this.defaultCellMinWidth = defaultCellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.table.style.setProperty(\n      \"--default-cell-min-width\",\n      `${defaultCellMinWidth}px`\n    );\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(\n      node,\n      this.colgroup,\n      this.table,\n      this.defaultCellMinWidth\n    );\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col2 = document.createElement(\"col\");\n        col2.style.width = cssWidth;\n        colgroup.appendChild(col2);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {\n  var _a;\n  if (!view.editable) return false;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        dragged,\n        defaultCellMinWidth\n      );\n    }\n  }\n  displayColumnWidth(\n    view,\n    pluginState.activeHandle,\n    width,\n    defaultCellMinWidth\n  );\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, resizeMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    defaultCellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  var _a;\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(\n            start + cellPos,\n            start + cellPos + table.nodeAt(cellPos).nodeSize,\n            {\n              class: \"column-resize-dragging\"\n            }\n          )\n        );\n      }\n      decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(pos, dom));\n    }\n  }\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations);\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10YWJsZXMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NEOztBQUV0RDtBQUNvRDtBQU16QjtBQUNrQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBaUQ7QUFDdkU7QUFDQTtBQUNBLHNCQUFzQixnRUFBZ0U7QUFDdEY7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRCxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQXdERSIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXHByb3NlbWlycm9yLXRhYmxlc1xcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMiB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuXG4vLyBzcmMvY2VsbHNlbGVjdGlvbi50c1xuaW1wb3J0IHsgRnJhZ21lbnQsIFNsaWNlIH0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQge1xuICBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb24yLFxuICBTZWxlY3Rpb24sXG4gIFNlbGVjdGlvblJhbmdlLFxuICBUZXh0U2VsZWN0aW9uXG59IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7XG5cbi8vIHNyYy90YWJsZW1hcC50c1xudmFyIHJlYWRGcm9tQ2FjaGU7XG52YXIgYWRkVG9DYWNoZTtcbmlmICh0eXBlb2YgV2Vha01hcCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGxldCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICByZWFkRnJvbUNhY2hlID0gKGtleSkgPT4gY2FjaGUuZ2V0KGtleSk7XG4gIGFkZFRvQ2FjaGUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59IGVsc2Uge1xuICBjb25zdCBjYWNoZSA9IFtdO1xuICBjb25zdCBjYWNoZVNpemUgPSAxMDtcbiAgbGV0IGNhY2hlUG9zID0gMDtcbiAgcmVhZEZyb21DYWNoZSA9IChrZXkpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgaWYgKGNhY2hlW2ldID09IGtleSkgcmV0dXJuIGNhY2hlW2kgKyAxXTtcbiAgfTtcbiAgYWRkVG9DYWNoZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKGNhY2hlUG9zID09IGNhY2hlU2l6ZSkgY2FjaGVQb3MgPSAwO1xuICAgIGNhY2hlW2NhY2hlUG9zKytdID0ga2V5O1xuICAgIHJldHVybiBjYWNoZVtjYWNoZVBvcysrXSA9IHZhbHVlO1xuICB9O1xufVxudmFyIFRhYmxlTWFwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBtYXAsIHByb2JsZW1zKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMucHJvYmxlbXMgPSBwcm9ibGVtcztcbiAgfVxuICAvLyBGaW5kIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgZmluZENlbGwocG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VyUG9zID0gdGhpcy5tYXBbaV07XG4gICAgICBpZiAoY3VyUG9zICE9IHBvcykgY29udGludWU7XG4gICAgICBjb25zdCBsZWZ0ID0gaSAlIHRoaXMud2lkdGg7XG4gICAgICBjb25zdCB0b3AgPSBpIC8gdGhpcy53aWR0aCB8IDA7XG4gICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgIGxldCBib3R0b20gPSB0b3AgKyAxO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IHJpZ2h0IDwgdGhpcy53aWR0aCAmJiB0aGlzLm1hcFtpICsgal0gPT0gY3VyUG9zOyBqKyspIHtcbiAgICAgICAgcmlnaHQrKztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAxOyBib3R0b20gPCB0aGlzLmhlaWdodCAmJiB0aGlzLm1hcFtpICsgdGhpcy53aWR0aCAqIGpdID09IGN1clBvczsgaisrKSB7XG4gICAgICAgIGJvdHRvbSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICB9XG4gIC8vIEZpbmQgdGhlIGxlZnQgc2lkZSBvZiB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbENvdW50KHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm1hcFtpXSA9PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGkgJSB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgfVxuICAvLyBGaW5kIHRoZSBuZXh0IGNlbGwgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgY2VsbFxuICAvLyBhdCBgcG9zYCwgaWYgYW55LlxuICBuZXh0Q2VsbChwb3MsIGF4aXMsIGRpcikge1xuICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSB0aGlzLmZpbmRDZWxsKHBvcyk7XG4gICAgaWYgKGF4aXMgPT0gXCJob3JpelwiKSB7XG4gICAgICBpZiAoZGlyIDwgMCA/IGxlZnQgPT0gMCA6IHJpZ2h0ID09IHRoaXMud2lkdGgpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMubWFwW3RvcCAqIHRoaXMud2lkdGggKyAoZGlyIDwgMCA/IGxlZnQgLSAxIDogcmlnaHQpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpciA8IDAgPyB0b3AgPT0gMCA6IGJvdHRvbSA9PSB0aGlzLmhlaWdodCkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5tYXBbbGVmdCArIHRoaXMud2lkdGggKiAoZGlyIDwgMCA/IHRvcCAtIDEgOiBib3R0b20pXTtcbiAgICB9XG4gIH1cbiAgLy8gR2V0IHRoZSByZWN0YW5nbGUgc3Bhbm5pbmcgdGhlIHR3byBnaXZlbiBjZWxscy5cbiAgcmVjdEJldHdlZW4oYSwgYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IGxlZnRBLFxuICAgICAgcmlnaHQ6IHJpZ2h0QSxcbiAgICAgIHRvcDogdG9wQSxcbiAgICAgIGJvdHRvbTogYm90dG9tQVxuICAgIH0gPSB0aGlzLmZpbmRDZWxsKGEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IGxlZnRCLFxuICAgICAgcmlnaHQ6IHJpZ2h0QixcbiAgICAgIHRvcDogdG9wQixcbiAgICAgIGJvdHRvbTogYm90dG9tQlxuICAgIH0gPSB0aGlzLmZpbmRDZWxsKGIpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBNYXRoLm1pbihsZWZ0QSwgbGVmdEIpLFxuICAgICAgdG9wOiBNYXRoLm1pbih0b3BBLCB0b3BCKSxcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChyaWdodEEsIHJpZ2h0QiksXG4gICAgICBib3R0b206IE1hdGgubWF4KGJvdHRvbUEsIGJvdHRvbUIpXG4gICAgfTtcbiAgfVxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIGFsbCBjZWxscyB0aGF0IGhhdmUgdGhlIHRvcCBsZWZ0IGNvcm5lciBpblxuICAvLyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICBjZWxsc0luUmVjdChyZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIGZvciAobGV0IHJvdyA9IHJlY3QudG9wOyByb3cgPCByZWN0LmJvdHRvbTsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IHJlY3QubGVmdDsgY29sIDwgcmVjdC5yaWdodDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByb3cgKiB0aGlzLndpZHRoICsgY29sO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLm1hcFtpbmRleF07XG4gICAgICAgIGlmIChzZWVuW3Bvc10pIGNvbnRpbnVlO1xuICAgICAgICBzZWVuW3Bvc10gPSB0cnVlO1xuICAgICAgICBpZiAoY29sID09IHJlY3QubGVmdCAmJiBjb2wgJiYgdGhpcy5tYXBbaW5kZXggLSAxXSA9PSBwb3MgfHwgcm93ID09IHJlY3QudG9wICYmIHJvdyAmJiB0aGlzLm1hcFtpbmRleCAtIHRoaXMud2lkdGhdID09IHBvcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcm93IGFuZCBjb2x1bW5cbiAgLy8gc3RhcnRzLCBvciB3b3VsZCBzdGFydCwgaWYgYSBjZWxsIHN0YXJ0ZWQgdGhlcmUuXG4gIHBvc2l0aW9uQXQocm93LCBjb2wsIHRhYmxlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHJvd1N0YXJ0ID0gMDsgOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvd0VuZCA9IHJvd1N0YXJ0ICsgdGFibGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICBpZiAoaSA9PSByb3cpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gY29sICsgcm93ICogdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3Qgcm93RW5kSW5kZXggPSAocm93ICsgMSkgKiB0aGlzLndpZHRoO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCByb3dFbmRJbmRleCAmJiB0aGlzLm1hcFtpbmRleF0gPCByb3dTdGFydCkgaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIGluZGV4ID09IHJvd0VuZEluZGV4ID8gcm93RW5kIC0gMSA6IHRoaXMubWFwW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJvd1N0YXJ0ID0gcm93RW5kO1xuICAgIH1cbiAgfVxuICAvLyBGaW5kIHRoZSB0YWJsZSBtYXAgZm9yIHRoZSBnaXZlbiB0YWJsZSBub2RlLlxuICBzdGF0aWMgZ2V0KHRhYmxlKSB7XG4gICAgcmV0dXJuIHJlYWRGcm9tQ2FjaGUodGFibGUpIHx8IGFkZFRvQ2FjaGUodGFibGUsIGNvbXB1dGVNYXAodGFibGUpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNvbXB1dGVNYXAodGFibGUpIHtcbiAgaWYgKHRhYmxlLnR5cGUuc3BlYy50YWJsZVJvbGUgIT0gXCJ0YWJsZVwiKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm90IGEgdGFibGUgbm9kZTogXCIgKyB0YWJsZS50eXBlLm5hbWUpO1xuICBjb25zdCB3aWR0aCA9IGZpbmRXaWR0aCh0YWJsZSksIGhlaWdodCA9IHRhYmxlLmNoaWxkQ291bnQ7XG4gIGNvbnN0IG1hcCA9IFtdO1xuICBsZXQgbWFwUG9zID0gMDtcbiAgbGV0IHByb2JsZW1zID0gbnVsbDtcbiAgY29uc3QgY29sV2lkdGhzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBlID0gd2lkdGggKiBoZWlnaHQ7IGkgPCBlOyBpKyspIG1hcFtpXSA9IDA7XG4gIGZvciAobGV0IHJvdyA9IDAsIHBvcyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCByb3dOb2RlID0gdGFibGUuY2hpbGQocm93KTtcbiAgICBwb3MrKztcbiAgICBmb3IgKGxldCBpID0gMDsgOyBpKyspIHtcbiAgICAgIHdoaWxlIChtYXBQb3MgPCBtYXAubGVuZ3RoICYmIG1hcFttYXBQb3NdICE9IDApIG1hcFBvcysrO1xuICAgICAgaWYgKGkgPT0gcm93Tm9kZS5jaGlsZENvdW50KSBicmVhaztcbiAgICAgIGNvbnN0IGNlbGxOb2RlID0gcm93Tm9kZS5jaGlsZChpKTtcbiAgICAgIGNvbnN0IHsgY29sc3Bhbiwgcm93c3BhbiwgY29sd2lkdGggfSA9IGNlbGxOb2RlLmF0dHJzO1xuICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCByb3dzcGFuOyBoKyspIHtcbiAgICAgICAgaWYgKGggKyByb3cgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgKHByb2JsZW1zIHx8IChwcm9ibGVtcyA9IFtdKSkucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIm92ZXJsb25nX3Jvd3NwYW5cIixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIG46IHJvd3NwYW4gLSBoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBtYXBQb3MgKyBoICogd2lkdGg7XG4gICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgY29sc3BhbjsgdysrKSB7XG4gICAgICAgICAgaWYgKG1hcFtzdGFydCArIHddID09IDApIG1hcFtzdGFydCArIHddID0gcG9zO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIChwcm9ibGVtcyB8fCAocHJvYmxlbXMgPSBbXSkpLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcImNvbGxpc2lvblwiLFxuICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgbjogY29sc3BhbiAtIHdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGNvbFcgPSBjb2x3aWR0aCAmJiBjb2x3aWR0aFt3XTtcbiAgICAgICAgICBpZiAoY29sVykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhJbmRleCA9IChzdGFydCArIHcpICUgd2lkdGggKiAyLCBwcmV2ID0gY29sV2lkdGhzW3dpZHRoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCBwcmV2ICE9IGNvbFcgJiYgY29sV2lkdGhzW3dpZHRoSW5kZXggKyAxXSA9PSAxKSB7XG4gICAgICAgICAgICAgIGNvbFdpZHRoc1t3aWR0aEluZGV4XSA9IGNvbFc7XG4gICAgICAgICAgICAgIGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0gPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2ID09IGNvbFcpIHtcbiAgICAgICAgICAgICAgY29sV2lkdGhzW3dpZHRoSW5kZXggKyAxXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWFwUG9zICs9IGNvbHNwYW47XG4gICAgICBwb3MgKz0gY2VsbE5vZGUubm9kZVNpemU7XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdGVkUG9zID0gKHJvdyArIDEpICogd2lkdGg7XG4gICAgbGV0IG1pc3NpbmcgPSAwO1xuICAgIHdoaWxlIChtYXBQb3MgPCBleHBlY3RlZFBvcykgaWYgKG1hcFttYXBQb3MrK10gPT0gMCkgbWlzc2luZysrO1xuICAgIGlmIChtaXNzaW5nKVxuICAgICAgKHByb2JsZW1zIHx8IChwcm9ibGVtcyA9IFtdKSkucHVzaCh7IHR5cGU6IFwibWlzc2luZ1wiLCByb3csIG46IG1pc3NpbmcgfSk7XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMClcbiAgICAocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHsgdHlwZTogXCJ6ZXJvX3NpemVkXCIgfSk7XG4gIGNvbnN0IHRhYmxlTWFwID0gbmV3IFRhYmxlTWFwKHdpZHRoLCBoZWlnaHQsIG1hcCwgcHJvYmxlbXMpO1xuICBsZXQgYmFkV2lkdGhzID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyAhYmFkV2lkdGhzICYmIGkgPCBjb2xXaWR0aHMubGVuZ3RoOyBpICs9IDIpXG4gICAgaWYgKGNvbFdpZHRoc1tpXSAhPSBudWxsICYmIGNvbFdpZHRoc1tpICsgMV0gPCBoZWlnaHQpIGJhZFdpZHRocyA9IHRydWU7XG4gIGlmIChiYWRXaWR0aHMpIGZpbmRCYWRDb2xXaWR0aHModGFibGVNYXAsIGNvbFdpZHRocywgdGFibGUpO1xuICByZXR1cm4gdGFibGVNYXA7XG59XG5mdW5jdGlvbiBmaW5kV2lkdGgodGFibGUpIHtcbiAgbGV0IHdpZHRoID0gLTE7XG4gIGxldCBoYXNSb3dTcGFuID0gZmFsc2U7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRhYmxlLmNoaWxkQ291bnQ7IHJvdysrKSB7XG4gICAgY29uc3Qgcm93Tm9kZSA9IHRhYmxlLmNoaWxkKHJvdyk7XG4gICAgbGV0IHJvd1dpZHRoID0gMDtcbiAgICBpZiAoaGFzUm93U3BhbilcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93OyBqKyspIHtcbiAgICAgICAgY29uc3QgcHJldlJvdyA9IHRhYmxlLmNoaWxkKGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZSb3cuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2VsbCA9IHByZXZSb3cuY2hpbGQoaSk7XG4gICAgICAgICAgaWYgKGogKyBjZWxsLmF0dHJzLnJvd3NwYW4gPiByb3cpIHJvd1dpZHRoICs9IGNlbGwuYXR0cnMuY29sc3BhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Tm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dOb2RlLmNoaWxkKGkpO1xuICAgICAgcm93V2lkdGggKz0gY2VsbC5hdHRycy5jb2xzcGFuO1xuICAgICAgaWYgKGNlbGwuYXR0cnMucm93c3BhbiA+IDEpIGhhc1Jvd1NwYW4gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAod2lkdGggPT0gLTEpIHdpZHRoID0gcm93V2lkdGg7XG4gICAgZWxzZSBpZiAod2lkdGggIT0gcm93V2lkdGgpIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHJvd1dpZHRoKTtcbiAgfVxuICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiBmaW5kQmFkQ29sV2lkdGhzKG1hcCwgY29sV2lkdGhzLCB0YWJsZSkge1xuICBpZiAoIW1hcC5wcm9ibGVtcykgbWFwLnByb2JsZW1zID0gW107XG4gIGNvbnN0IHNlZW4gPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFtpXTtcbiAgICBpZiAoc2Vlbltwb3NdKSBjb250aW51ZTtcbiAgICBzZWVuW3Bvc10gPSB0cnVlO1xuICAgIGNvbnN0IG5vZGUgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IG51bGw7XG4gICAgY29uc3QgYXR0cnMgPSBub2RlLmF0dHJzO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXR0cnMuY29sc3BhbjsgaisrKSB7XG4gICAgICBjb25zdCBjb2wgPSAoaSArIGopICUgbWFwLndpZHRoO1xuICAgICAgY29uc3QgY29sV2lkdGggPSBjb2xXaWR0aHNbY29sICogMl07XG4gICAgICBpZiAoY29sV2lkdGggIT0gbnVsbCAmJiAoIWF0dHJzLmNvbHdpZHRoIHx8IGF0dHJzLmNvbHdpZHRoW2pdICE9IGNvbFdpZHRoKSlcbiAgICAgICAgKHVwZGF0ZWQgfHwgKHVwZGF0ZWQgPSBmcmVzaENvbFdpZHRoKGF0dHJzKSkpW2pdID0gY29sV2lkdGg7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkKVxuICAgICAgbWFwLnByb2JsZW1zLnVuc2hpZnQoe1xuICAgICAgICB0eXBlOiBcImNvbHdpZHRoIG1pc21hdGNoXCIsXG4gICAgICAgIHBvcyxcbiAgICAgICAgY29sd2lkdGg6IHVwZGF0ZWRcbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmcmVzaENvbFdpZHRoKGF0dHJzKSB7XG4gIGlmIChhdHRycy5jb2x3aWR0aCkgcmV0dXJuIGF0dHJzLmNvbHdpZHRoLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmNvbHNwYW47IGkrKykgcmVzdWx0LnB1c2goMCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsLnRzXG5pbXBvcnQgeyBQbHVnaW5LZXkgfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcblxuLy8gc3JjL3NjaGVtYS50c1xuZnVuY3Rpb24gZ2V0Q2VsbEF0dHJzKGRvbSwgZXh0cmFBdHRycykge1xuICBpZiAodHlwZW9mIGRvbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCB3aWR0aEF0dHIgPSBkb20uZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2x3aWR0aFwiKTtcbiAgY29uc3Qgd2lkdGhzID0gd2lkdGhBdHRyICYmIC9eXFxkKygsXFxkKykqJC8udGVzdCh3aWR0aEF0dHIpID8gd2lkdGhBdHRyLnNwbGl0KFwiLFwiKS5tYXAoKHMpID0+IE51bWJlcihzKSkgOiBudWxsO1xuICBjb25zdCBjb2xzcGFuID0gTnVtYmVyKGRvbS5nZXRBdHRyaWJ1dGUoXCJjb2xzcGFuXCIpIHx8IDEpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgY29sc3BhbixcbiAgICByb3dzcGFuOiBOdW1iZXIoZG9tLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIikgfHwgMSksXG4gICAgY29sd2lkdGg6IHdpZHRocyAmJiB3aWR0aHMubGVuZ3RoID09IGNvbHNwYW4gPyB3aWR0aHMgOiBudWxsXG4gIH07XG4gIGZvciAoY29uc3QgcHJvcCBpbiBleHRyYUF0dHJzKSB7XG4gICAgY29uc3QgZ2V0dGVyID0gZXh0cmFBdHRyc1twcm9wXS5nZXRGcm9tRE9NO1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyICYmIGdldHRlcihkb20pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldENlbGxBdHRycyhub2RlLCBleHRyYUF0dHJzKSB7XG4gIGNvbnN0IGF0dHJzID0ge307XG4gIGlmIChub2RlLmF0dHJzLmNvbHNwYW4gIT0gMSkgYXR0cnMuY29sc3BhbiA9IG5vZGUuYXR0cnMuY29sc3BhbjtcbiAgaWYgKG5vZGUuYXR0cnMucm93c3BhbiAhPSAxKSBhdHRycy5yb3dzcGFuID0gbm9kZS5hdHRycy5yb3dzcGFuO1xuICBpZiAobm9kZS5hdHRycy5jb2x3aWR0aClcbiAgICBhdHRyc1tcImRhdGEtY29sd2lkdGhcIl0gPSBub2RlLmF0dHJzLmNvbHdpZHRoLmpvaW4oXCIsXCIpO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZXh0cmFBdHRycykge1xuICAgIGNvbnN0IHNldHRlciA9IGV4dHJhQXR0cnNbcHJvcF0uc2V0RE9NQXR0cjtcbiAgICBpZiAoc2V0dGVyKSBzZXR0ZXIobm9kZS5hdHRyc1twcm9wXSwgYXR0cnMpO1xuICB9XG4gIHJldHVybiBhdHRycztcbn1cbmZ1bmN0aW9uIHRhYmxlTm9kZXMob3B0aW9ucykge1xuICBjb25zdCBleHRyYUF0dHJzID0gb3B0aW9ucy5jZWxsQXR0cmlidXRlcyB8fCB7fTtcbiAgY29uc3QgY2VsbEF0dHJzID0ge1xuICAgIGNvbHNwYW46IHsgZGVmYXVsdDogMSB9LFxuICAgIHJvd3NwYW46IHsgZGVmYXVsdDogMSB9LFxuICAgIGNvbHdpZHRoOiB7IGRlZmF1bHQ6IG51bGwgfVxuICB9O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZXh0cmFBdHRycylcbiAgICBjZWxsQXR0cnNbcHJvcF0gPSB7IGRlZmF1bHQ6IGV4dHJhQXR0cnNbcHJvcF0uZGVmYXVsdCB9O1xuICByZXR1cm4ge1xuICAgIHRhYmxlOiB7XG4gICAgICBjb250ZW50OiBcInRhYmxlX3JvdytcIixcbiAgICAgIHRhYmxlUm9sZTogXCJ0YWJsZVwiLFxuICAgICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgICAgZ3JvdXA6IG9wdGlvbnMudGFibGVHcm91cCxcbiAgICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidGFibGVcIiB9XSxcbiAgICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gW1widGFibGVcIiwgW1widGJvZHlcIiwgMF1dO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVfcm93OiB7XG4gICAgICBjb250ZW50OiBcIih0YWJsZV9jZWxsIHwgdGFibGVfaGVhZGVyKSpcIixcbiAgICAgIHRhYmxlUm9sZTogXCJyb3dcIixcbiAgICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidHJcIiB9XSxcbiAgICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gW1widHJcIiwgMF07XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZV9jZWxsOiB7XG4gICAgICBjb250ZW50OiBvcHRpb25zLmNlbGxDb250ZW50LFxuICAgICAgYXR0cnM6IGNlbGxBdHRycyxcbiAgICAgIHRhYmxlUm9sZTogXCJjZWxsXCIsXG4gICAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgICBwYXJzZURPTTogW1xuICAgICAgICB7IHRhZzogXCJ0ZFwiLCBnZXRBdHRyczogKGRvbSkgPT4gZ2V0Q2VsbEF0dHJzKGRvbSwgZXh0cmFBdHRycykgfVxuICAgICAgXSxcbiAgICAgIHRvRE9NKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcInRkXCIsIHNldENlbGxBdHRycyhub2RlLCBleHRyYUF0dHJzKSwgMF07XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZV9oZWFkZXI6IHtcbiAgICAgIGNvbnRlbnQ6IG9wdGlvbnMuY2VsbENvbnRlbnQsXG4gICAgICBhdHRyczogY2VsbEF0dHJzLFxuICAgICAgdGFibGVSb2xlOiBcImhlYWRlcl9jZWxsXCIsXG4gICAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgICBwYXJzZURPTTogW1xuICAgICAgICB7IHRhZzogXCJ0aFwiLCBnZXRBdHRyczogKGRvbSkgPT4gZ2V0Q2VsbEF0dHJzKGRvbSwgZXh0cmFBdHRycykgfVxuICAgICAgXSxcbiAgICAgIHRvRE9NKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcInRoXCIsIHNldENlbGxBdHRycyhub2RlLCBleHRyYUF0dHJzKSwgMF07XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdGFibGVOb2RlVHlwZXMoc2NoZW1hKSB7XG4gIGxldCByZXN1bHQgPSBzY2hlbWEuY2FjaGVkLnRhYmxlTm9kZVR5cGVzO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHNjaGVtYS5jYWNoZWQudGFibGVOb2RlVHlwZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2NoZW1hLm5vZGVzW25hbWVdLCByb2xlID0gdHlwZS5zcGVjLnRhYmxlUm9sZTtcbiAgICAgIGlmIChyb2xlKSByZXN1bHRbcm9sZV0gPSB0eXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXRpbC50c1xudmFyIHRhYmxlRWRpdGluZ0tleSA9IG5ldyBQbHVnaW5LZXkoXCJzZWxlY3RpbmdDZWxsc1wiKTtcbmZ1bmN0aW9uIGNlbGxBcm91bmQoJHBvcykge1xuICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPiAwOyBkLS0pXG4gICAgaWYgKCRwb3Mubm9kZShkKS50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIpXG4gICAgICByZXR1cm4gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5iZWZvcmUoZCArIDEpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjZWxsV3JhcHBpbmcoJHBvcykge1xuICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+IDA7IGQtLSkge1xuICAgIGNvbnN0IHJvbGUgPSAkcG9zLm5vZGUoZCkudHlwZS5zcGVjLnRhYmxlUm9sZTtcbiAgICBpZiAocm9sZSA9PT0gXCJjZWxsXCIgfHwgcm9sZSA9PT0gXCJoZWFkZXJfY2VsbFwiKSByZXR1cm4gJHBvcy5ub2RlKGQpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNJblRhYmxlKHN0YXRlKSB7XG4gIGNvbnN0ICRoZWFkID0gc3RhdGUuc2VsZWN0aW9uLiRoZWFkO1xuICBmb3IgKGxldCBkID0gJGhlYWQuZGVwdGg7IGQgPiAwOyBkLS0pXG4gICAgaWYgKCRoZWFkLm5vZGUoZCkudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uQ2VsbChzdGF0ZSkge1xuICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGlmIChcIiRhbmNob3JDZWxsXCIgaW4gc2VsICYmIHNlbC4kYW5jaG9yQ2VsbCkge1xuICAgIHJldHVybiBzZWwuJGFuY2hvckNlbGwucG9zID4gc2VsLiRoZWFkQ2VsbC5wb3MgPyBzZWwuJGFuY2hvckNlbGwgOiBzZWwuJGhlYWRDZWxsO1xuICB9IGVsc2UgaWYgKFwibm9kZVwiIGluIHNlbCAmJiBzZWwubm9kZSAmJiBzZWwubm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09IFwiY2VsbFwiKSB7XG4gICAgcmV0dXJuIHNlbC4kYW5jaG9yO1xuICB9XG4gIGNvbnN0ICRjZWxsID0gY2VsbEFyb3VuZChzZWwuJGhlYWQpIHx8IGNlbGxOZWFyKHNlbC4kaGVhZCk7XG4gIGlmICgkY2VsbCkge1xuICAgIHJldHVybiAkY2VsbDtcbiAgfVxuICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCBmb3VuZCBhcm91bmQgcG9zaXRpb24gJHtzZWwuaGVhZH1gKTtcbn1cbmZ1bmN0aW9uIGNlbGxOZWFyKCRwb3MpIHtcbiAgZm9yIChsZXQgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgcG9zID0gJHBvcy5wb3M7IGFmdGVyOyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQsIHBvcysrKSB7XG4gICAgY29uc3Qgcm9sZSA9IGFmdGVyLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gIH1cbiAgZm9yIChsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBwb3MgPSAkcG9zLnBvczsgYmVmb3JlOyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkLCBwb3MtLSkge1xuICAgIGNvbnN0IHJvbGUgPSBiZWZvcmUudHlwZS5zcGVjLnRhYmxlUm9sZTtcbiAgICBpZiAocm9sZSA9PSBcImNlbGxcIiB8fCByb2xlID09IFwiaGVhZGVyX2NlbGxcIilcbiAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKHBvcyAtIGJlZm9yZS5ub2RlU2l6ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvaW50c0F0Q2VsbCgkcG9zKSB7XG4gIHJldHVybiAkcG9zLnBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIgJiYgISEkcG9zLm5vZGVBZnRlcjtcbn1cbmZ1bmN0aW9uIG1vdmVDZWxsRm9yd2FyZCgkcG9zKSB7XG4gIHJldHVybiAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArICRwb3Mubm9kZUFmdGVyLm5vZGVTaXplKTtcbn1cbmZ1bmN0aW9uIGluU2FtZVRhYmxlKCRjZWxsQSwgJGNlbGxCKSB7XG4gIHJldHVybiAkY2VsbEEuZGVwdGggPT0gJGNlbGxCLmRlcHRoICYmICRjZWxsQS5wb3MgPj0gJGNlbGxCLnN0YXJ0KC0xKSAmJiAkY2VsbEEucG9zIDw9ICRjZWxsQi5lbmQoLTEpO1xufVxuZnVuY3Rpb24gZmluZENlbGwoJHBvcykge1xuICByZXR1cm4gVGFibGVNYXAuZ2V0KCRwb3Mubm9kZSgtMSkpLmZpbmRDZWxsKCRwb3MucG9zIC0gJHBvcy5zdGFydCgtMSkpO1xufVxuZnVuY3Rpb24gY29sQ291bnQoJHBvcykge1xuICByZXR1cm4gVGFibGVNYXAuZ2V0KCRwb3Mubm9kZSgtMSkpLmNvbENvdW50KCRwb3MucG9zIC0gJHBvcy5zdGFydCgtMSkpO1xufVxuZnVuY3Rpb24gbmV4dENlbGwoJHBvcywgYXhpcywgZGlyKSB7XG4gIGNvbnN0IHRhYmxlID0gJHBvcy5ub2RlKC0xKTtcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgY29uc3QgdGFibGVTdGFydCA9ICRwb3Muc3RhcnQoLTEpO1xuICBjb25zdCBtb3ZlZCA9IG1hcC5uZXh0Q2VsbCgkcG9zLnBvcyAtIHRhYmxlU3RhcnQsIGF4aXMsIGRpcik7XG4gIHJldHVybiBtb3ZlZCA9PSBudWxsID8gbnVsbCA6ICRwb3Mubm9kZSgwKS5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtb3ZlZCk7XG59XG5mdW5jdGlvbiByZW1vdmVDb2xTcGFuKGF0dHJzLCBwb3MsIG4gPSAxKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uYXR0cnMsIGNvbHNwYW46IGF0dHJzLmNvbHNwYW4gLSBuIH07XG4gIGlmIChyZXN1bHQuY29sd2lkdGgpIHtcbiAgICByZXN1bHQuY29sd2lkdGggPSByZXN1bHQuY29sd2lkdGguc2xpY2UoKTtcbiAgICByZXN1bHQuY29sd2lkdGguc3BsaWNlKHBvcywgbik7XG4gICAgaWYgKCFyZXN1bHQuY29sd2lkdGguc29tZSgodykgPT4gdyA+IDApKSByZXN1bHQuY29sd2lkdGggPSBudWxsO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhZGRDb2xTcGFuKGF0dHJzLCBwb3MsIG4gPSAxKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uYXR0cnMsIGNvbHNwYW46IGF0dHJzLmNvbHNwYW4gKyBuIH07XG4gIGlmIChyZXN1bHQuY29sd2lkdGgpIHtcbiAgICByZXN1bHQuY29sd2lkdGggPSByZXN1bHQuY29sd2lkdGguc2xpY2UoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykgcmVzdWx0LmNvbHdpZHRoLnNwbGljZShwb3MsIDAsIDApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb2x1bW5Jc0hlYWRlcihtYXAsIHRhYmxlLCBjb2wpIHtcbiAgY29uc3QgaGVhZGVyQ2VsbCA9IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5oZWFkZXJfY2VsbDtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspXG4gICAgaWYgKHRhYmxlLm5vZGVBdChtYXAubWFwW2NvbCArIHJvdyAqIG1hcC53aWR0aF0pLnR5cGUgIT0gaGVhZGVyQ2VsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9jZWxsc2VsZWN0aW9uLnRzXG52YXIgQ2VsbFNlbGVjdGlvbiA9IGNsYXNzIF9DZWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgLy8gQSB0YWJsZSBzZWxlY3Rpb24gaXMgaWRlbnRpZmllZCBieSBpdHMgYW5jaG9yIGFuZCBoZWFkIGNlbGxzLiBUaGVcbiAgLy8gcG9zaXRpb25zIGdpdmVuIHRvIHRoaXMgY29uc3RydWN0b3Igc2hvdWxkIHBvaW50IF9iZWZvcmVfIHR3b1xuICAvLyBjZWxscyBpbiB0aGUgc2FtZSB0YWJsZS4gVGhleSBtYXkgYmUgdGhlIHNhbWUsIHRvIHNlbGVjdCBhIHNpbmdsZVxuICAvLyBjZWxsLlxuICBjb25zdHJ1Y3RvcigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsID0gJGFuY2hvckNlbGwpIHtcbiAgICBjb25zdCB0YWJsZSA9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9ICRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCByZWN0ID0gbWFwLnJlY3RCZXR3ZWVuKFxuICAgICAgJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCxcbiAgICAgICRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCBkb2MgPSAkYW5jaG9yQ2VsbC5ub2RlKDApO1xuICAgIGNvbnN0IGNlbGxzID0gbWFwLmNlbGxzSW5SZWN0KHJlY3QpLmZpbHRlcigocCkgPT4gcCAhPSAkaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY2VsbHMudW5zaGlmdCgkaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgcmFuZ2VzID0gY2VsbHMubWFwKChwb3MpID0+IHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgIGlmICghY2VsbCkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJvbSA9IHRhYmxlU3RhcnQgKyBwb3MgKyAxO1xuICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShcbiAgICAgICAgZG9jLnJlc29sdmUoZnJvbSksXG4gICAgICAgIGRvYy5yZXNvbHZlKGZyb20gKyBjZWxsLmNvbnRlbnQuc2l6ZSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgc3VwZXIocmFuZ2VzWzBdLiRmcm9tLCByYW5nZXNbMF0uJHRvLCByYW5nZXMpO1xuICAgIHRoaXMuJGFuY2hvckNlbGwgPSAkYW5jaG9yQ2VsbDtcbiAgICB0aGlzLiRoZWFkQ2VsbCA9ICRoZWFkQ2VsbDtcbiAgfVxuICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgY29uc3QgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLiRhbmNob3JDZWxsLnBvcykpO1xuICAgIGNvbnN0ICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuJGhlYWRDZWxsLnBvcykpO1xuICAgIGlmIChwb2ludHNBdENlbGwoJGFuY2hvckNlbGwpICYmIHBvaW50c0F0Q2VsbCgkaGVhZENlbGwpICYmIGluU2FtZVRhYmxlKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpKSB7XG4gICAgICBjb25zdCB0YWJsZUNoYW5nZWQgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpICE9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgICAgaWYgKHRhYmxlQ2hhbmdlZCAmJiB0aGlzLmlzUm93U2VsZWN0aW9uKCkpXG4gICAgICAgIHJldHVybiBfQ2VsbFNlbGVjdGlvbi5yb3dTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gICAgICBlbHNlIGlmICh0YWJsZUNoYW5nZWQgJiYgdGhpcy5pc0NvbFNlbGVjdGlvbigpKVxuICAgICAgICByZXR1cm4gX0NlbGxTZWxlY3Rpb24uY29sU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICAgICAgZWxzZSByZXR1cm4gbmV3IF9DZWxsU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICB9XG4gIC8vIFJldHVybnMgYSByZWN0YW5ndWxhciBzbGljZSBvZiB0YWJsZSByb3dzIGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkXG4gIC8vIGNlbGxzLlxuICBjb250ZW50KCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSB0aGlzLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCByZWN0ID0gbWFwLnJlY3RCZXR3ZWVuKFxuICAgICAgdGhpcy4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0LFxuICAgICAgdGhpcy4kaGVhZENlbGwucG9zIC0gdGFibGVTdGFydFxuICAgICk7XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICBmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSB7XG4gICAgICBjb25zdCByb3dDb250ZW50ID0gW107XG4gICAgICBmb3IgKGxldCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIHJlY3QubGVmdCwgY29sID0gcmVjdC5sZWZ0OyBjb2wgPCByZWN0LnJpZ2h0OyBjb2wrKywgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICAgICAgaWYgKHNlZW5bcG9zXSkgY29udGludWU7XG4gICAgICAgIHNlZW5bcG9zXSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNlbGxSZWN0ID0gbWFwLmZpbmRDZWxsKHBvcyk7XG4gICAgICAgIGxldCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoYE5vIGNlbGwgd2l0aCBvZmZzZXQgJHtwb3N9IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0cmFMZWZ0ID0gcmVjdC5sZWZ0IC0gY2VsbFJlY3QubGVmdDtcbiAgICAgICAgY29uc3QgZXh0cmFSaWdodCA9IGNlbGxSZWN0LnJpZ2h0IC0gcmVjdC5yaWdodDtcbiAgICAgICAgaWYgKGV4dHJhTGVmdCA+IDAgfHwgZXh0cmFSaWdodCA+IDApIHtcbiAgICAgICAgICBsZXQgYXR0cnMgPSBjZWxsLmF0dHJzO1xuICAgICAgICAgIGlmIChleHRyYUxlZnQgPiAwKSB7XG4gICAgICAgICAgICBhdHRycyA9IHJlbW92ZUNvbFNwYW4oYXR0cnMsIDAsIGV4dHJhTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYVJpZ2h0ID4gMCkge1xuICAgICAgICAgICAgYXR0cnMgPSByZW1vdmVDb2xTcGFuKFxuICAgICAgICAgICAgICBhdHRycyxcbiAgICAgICAgICAgICAgYXR0cnMuY29sc3BhbiAtIGV4dHJhUmlnaHQsXG4gICAgICAgICAgICAgIGV4dHJhUmlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjZWxsUmVjdC5sZWZ0IDwgcmVjdC5sZWZ0KSB7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZUFuZEZpbGwoYXR0cnMpO1xuICAgICAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgICAgYENvdWxkIG5vdCBjcmVhdGUgY2VsbCB3aXRoIGF0dHJzICR7SlNPTi5zdHJpbmdpZnkoYXR0cnMpfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGUoYXR0cnMsIGNlbGwuY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsUmVjdC50b3AgPCByZWN0LnRvcCB8fCBjZWxsUmVjdC5ib3R0b20gPiByZWN0LmJvdHRvbSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgICAgICAgLi4uY2VsbC5hdHRycyxcbiAgICAgICAgICAgIHJvd3NwYW46IE1hdGgubWluKGNlbGxSZWN0LmJvdHRvbSwgcmVjdC5ib3R0b20pIC0gTWF0aC5tYXgoY2VsbFJlY3QudG9wLCByZWN0LnRvcClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChjZWxsUmVjdC50b3AgPCByZWN0LnRvcCkge1xuICAgICAgICAgICAgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGVBbmRGaWxsKGF0dHJzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGUoYXR0cnMsIGNlbGwuY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvd0NvbnRlbnQucHVzaChjZWxsKTtcbiAgICAgIH1cbiAgICAgIHJvd3MucHVzaCh0YWJsZS5jaGlsZChyb3cpLmNvcHkoRnJhZ21lbnQuZnJvbShyb3dDb250ZW50KSkpO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaXNDb2xTZWxlY3Rpb24oKSAmJiB0aGlzLmlzUm93U2VsZWN0aW9uKCkgPyB0YWJsZSA6IHJvd3M7XG4gICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGZyYWdtZW50KSwgMSwgMSk7XG4gIH1cbiAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgY29uc3QgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldLCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgIHRyLnJlcGxhY2UoXG4gICAgICAgIG1hcHBpbmcubWFwKCRmcm9tLnBvcyksXG4gICAgICAgIG1hcHBpbmcubWFwKCR0by5wb3MpLFxuICAgICAgICBpID8gU2xpY2UuZW1wdHkgOiBjb250ZW50XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBzZWwgPSBTZWxlY3Rpb24uZmluZEZyb20oXG4gICAgICB0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcCh0aGlzLnRvKSksXG4gICAgICAtMVxuICAgICk7XG4gICAgaWYgKHNlbCkgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gIH1cbiAgcmVwbGFjZVdpdGgodHIsIG5vZGUpIHtcbiAgICB0aGlzLnJlcGxhY2UodHIsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG4gIH1cbiAgZm9yRWFjaENlbGwoZikge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSB0aGlzLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCBjZWxscyA9IG1hcC5jZWxsc0luUmVjdChcbiAgICAgIG1hcC5yZWN0QmV0d2VlbihcbiAgICAgICAgdGhpcy4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0LFxuICAgICAgICB0aGlzLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0XG4gICAgICApXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmKHRhYmxlLm5vZGVBdChjZWxsc1tpXSksIHRhYmxlU3RhcnQgKyBjZWxsc1tpXSk7XG4gICAgfVxuICB9XG4gIC8vIFRydWUgaWYgdGhpcyBzZWxlY3Rpb24gZ29lcyBhbGwgdGhlIHdheSBmcm9tIHRoZSB0b3AgdG8gdGhlXG4gIC8vIGJvdHRvbSBvZiB0aGUgdGFibGUuXG4gIGlzQ29sU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IGFuY2hvclRvcCA9IHRoaXMuJGFuY2hvckNlbGwuaW5kZXgoLTEpO1xuICAgIGNvbnN0IGhlYWRUb3AgPSB0aGlzLiRoZWFkQ2VsbC5pbmRleCgtMSk7XG4gICAgaWYgKE1hdGgubWluKGFuY2hvclRvcCwgaGVhZFRvcCkgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYW5jaG9yQm90dG9tID0gYW5jaG9yVG9wICsgdGhpcy4kYW5jaG9yQ2VsbC5ub2RlQWZ0ZXIuYXR0cnMucm93c3BhbjtcbiAgICBjb25zdCBoZWFkQm90dG9tID0gaGVhZFRvcCArIHRoaXMuJGhlYWRDZWxsLm5vZGVBZnRlci5hdHRycy5yb3dzcGFuO1xuICAgIHJldHVybiBNYXRoLm1heChhbmNob3JCb3R0b20sIGhlYWRCb3R0b20pID09IHRoaXMuJGhlYWRDZWxsLm5vZGUoLTEpLmNoaWxkQ291bnQ7XG4gIH1cbiAgLy8gUmV0dXJucyB0aGUgc21hbGxlc3QgY29sdW1uIHNlbGVjdGlvbiB0aGF0IGNvdmVycyB0aGUgZ2l2ZW4gYW5jaG9yXG4gIC8vIGFuZCBoZWFkIGNlbGwuXG4gIHN0YXRpYyBjb2xTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCA9ICRhbmNob3JDZWxsKSB7XG4gICAgY29uc3QgdGFibGUgPSAkYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSAkYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgYW5jaG9yUmVjdCA9IG1hcC5maW5kQ2VsbCgkYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCBoZWFkUmVjdCA9IG1hcC5maW5kQ2VsbCgkaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgZG9jID0gJGFuY2hvckNlbGwubm9kZSgwKTtcbiAgICBpZiAoYW5jaG9yUmVjdC50b3AgPD0gaGVhZFJlY3QudG9wKSB7XG4gICAgICBpZiAoYW5jaG9yUmVjdC50b3AgPiAwKVxuICAgICAgICAkYW5jaG9yQ2VsbCA9IGRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAubWFwW2FuY2hvclJlY3QubGVmdF0pO1xuICAgICAgaWYgKGhlYWRSZWN0LmJvdHRvbSA8IG1hcC5oZWlnaHQpXG4gICAgICAgICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKFxuICAgICAgICAgIHRhYmxlU3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIChtYXAuaGVpZ2h0IC0gMSkgKyBoZWFkUmVjdC5yaWdodCAtIDFdXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoZWFkUmVjdC50b3AgPiAwKVxuICAgICAgICAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLm1hcFtoZWFkUmVjdC5sZWZ0XSk7XG4gICAgICBpZiAoYW5jaG9yUmVjdC5ib3R0b20gPCBtYXAuaGVpZ2h0KVxuICAgICAgICAkYW5jaG9yQ2VsbCA9IGRvYy5yZXNvbHZlKFxuICAgICAgICAgIHRhYmxlU3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIChtYXAuaGVpZ2h0IC0gMSkgKyBhbmNob3JSZWN0LnJpZ2h0IC0gMV1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ2VsbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcbiAgfVxuICAvLyBUcnVlIGlmIHRoaXMgc2VsZWN0aW9uIGdvZXMgYWxsIHRoZSB3YXkgZnJvbSB0aGUgbGVmdCB0byB0aGVcbiAgLy8gcmlnaHQgb2YgdGhlIHRhYmxlLlxuICBpc1Jvd1NlbGVjdGlvbigpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBjb25zdCB0YWJsZVN0YXJ0ID0gdGhpcy4kYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgYW5jaG9yTGVmdCA9IG1hcC5jb2xDb3VudCh0aGlzLiRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IGhlYWRMZWZ0ID0gbWFwLmNvbENvdW50KHRoaXMuJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGlmIChNYXRoLm1pbihhbmNob3JMZWZ0LCBoZWFkTGVmdCkgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYW5jaG9yUmlnaHQgPSBhbmNob3JMZWZ0ICsgdGhpcy4kYW5jaG9yQ2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbjtcbiAgICBjb25zdCBoZWFkUmlnaHQgPSBoZWFkTGVmdCArIHRoaXMuJGhlYWRDZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuO1xuICAgIHJldHVybiBNYXRoLm1heChhbmNob3JSaWdodCwgaGVhZFJpZ2h0KSA9PSBtYXAud2lkdGg7XG4gIH1cbiAgZXEob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBfQ2VsbFNlbGVjdGlvbiAmJiBvdGhlci4kYW5jaG9yQ2VsbC5wb3MgPT0gdGhpcy4kYW5jaG9yQ2VsbC5wb3MgJiYgb3RoZXIuJGhlYWRDZWxsLnBvcyA9PSB0aGlzLiRoZWFkQ2VsbC5wb3M7XG4gIH1cbiAgLy8gUmV0dXJucyB0aGUgc21hbGxlc3Qgcm93IHNlbGVjdGlvbiB0aGF0IGNvdmVycyB0aGUgZ2l2ZW4gYW5jaG9yXG4gIC8vIGFuZCBoZWFkIGNlbGwuXG4gIHN0YXRpYyByb3dTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCA9ICRhbmNob3JDZWxsKSB7XG4gICAgY29uc3QgdGFibGUgPSAkYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSAkYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgYW5jaG9yUmVjdCA9IG1hcC5maW5kQ2VsbCgkYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCBoZWFkUmVjdCA9IG1hcC5maW5kQ2VsbCgkaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgZG9jID0gJGFuY2hvckNlbGwubm9kZSgwKTtcbiAgICBpZiAoYW5jaG9yUmVjdC5sZWZ0IDw9IGhlYWRSZWN0LmxlZnQpIHtcbiAgICAgIGlmIChhbmNob3JSZWN0LmxlZnQgPiAwKVxuICAgICAgICAkYW5jaG9yQ2VsbCA9IGRvYy5yZXNvbHZlKFxuICAgICAgICAgIHRhYmxlU3RhcnQgKyBtYXAubWFwW2FuY2hvclJlY3QudG9wICogbWFwLndpZHRoXVxuICAgICAgICApO1xuICAgICAgaWYgKGhlYWRSZWN0LnJpZ2h0IDwgbWFwLndpZHRoKVxuICAgICAgICAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAoaGVhZFJlY3QudG9wICsgMSkgLSAxXVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGVhZFJlY3QubGVmdCA+IDApXG4gICAgICAgICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAubWFwW2hlYWRSZWN0LnRvcCAqIG1hcC53aWR0aF0pO1xuICAgICAgaWYgKGFuY2hvclJlY3QucmlnaHQgPCBtYXAud2lkdGgpXG4gICAgICAgICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUoXG4gICAgICAgICAgdGFibGVTdGFydCArIG1hcC5tYXBbbWFwLndpZHRoICogKGFuY2hvclJlY3QudG9wICsgMSkgLSAxXVxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9DZWxsU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICBhbmNob3I6IHRoaXMuJGFuY2hvckNlbGwucG9zLFxuICAgICAgaGVhZDogdGhpcy4kaGVhZENlbGwucG9zXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBfQ2VsbFNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvciksIGRvYy5yZXNvbHZlKGpzb24uaGVhZCkpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoZG9jLCBhbmNob3JDZWxsLCBoZWFkQ2VsbCA9IGFuY2hvckNlbGwpIHtcbiAgICByZXR1cm4gbmV3IF9DZWxsU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGFuY2hvckNlbGwpLCBkb2MucmVzb2x2ZShoZWFkQ2VsbCkpO1xuICB9XG4gIGdldEJvb2ttYXJrKCkge1xuICAgIHJldHVybiBuZXcgQ2VsbEJvb2ttYXJrKHRoaXMuJGFuY2hvckNlbGwucG9zLCB0aGlzLiRoZWFkQ2VsbC5wb3MpO1xuICB9XG59O1xuQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuU2VsZWN0aW9uLmpzb25JRChcImNlbGxcIiwgQ2VsbFNlbGVjdGlvbik7XG52YXIgQ2VsbEJvb2ttYXJrID0gY2xhc3MgX0NlbGxCb29rbWFyayB7XG4gIGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gIH1cbiAgbWFwKG1hcHBpbmcpIHtcbiAgICByZXR1cm4gbmV3IF9DZWxsQm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgfVxuICByZXNvbHZlKGRvYykge1xuICAgIGNvbnN0ICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZSh0aGlzLmhlYWQpO1xuICAgIGlmICgkYW5jaG9yQ2VsbC5wYXJlbnQudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiICYmICRoZWFkQ2VsbC5wYXJlbnQudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiICYmICRhbmNob3JDZWxsLmluZGV4KCkgPCAkYW5jaG9yQ2VsbC5wYXJlbnQuY2hpbGRDb3VudCAmJiAkaGVhZENlbGwuaW5kZXgoKSA8ICRoZWFkQ2VsbC5wYXJlbnQuY2hpbGRDb3VudCAmJiBpblNhbWVUYWJsZSgkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKSlcbiAgICAgIHJldHVybiBuZXcgQ2VsbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcbiAgICBlbHNlIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZENlbGwsIDEpO1xuICB9XG59O1xuZnVuY3Rpb24gZHJhd0NlbGxTZWxlY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikpIHJldHVybiBudWxsO1xuICBjb25zdCBjZWxscyA9IFtdO1xuICBzdGF0ZS5zZWxlY3Rpb24uZm9yRWFjaENlbGwoKG5vZGUsIHBvcykgPT4ge1xuICAgIGNlbGxzLnB1c2goXG4gICAgICBEZWNvcmF0aW9uLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7IGNsYXNzOiBcInNlbGVjdGVkQ2VsbFwiIH0pXG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIGNlbGxzKTtcbn1cbmZ1bmN0aW9uIGlzQ2VsbEJvdW5kYXJ5U2VsZWN0aW9uKHsgJGZyb20sICR0byB9KSB7XG4gIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcyB8fCAkZnJvbS5wb3MgPCAkdG8ucG9zIC0gNikgcmV0dXJuIGZhbHNlO1xuICBsZXQgYWZ0ZXJGcm9tID0gJGZyb20ucG9zO1xuICBsZXQgYmVmb3JlVG8gPSAkdG8ucG9zO1xuICBsZXQgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgZm9yICg7IGRlcHRoID49IDA7IGRlcHRoLS0sIGFmdGVyRnJvbSsrKVxuICAgIGlmICgkZnJvbS5hZnRlcihkZXB0aCArIDEpIDwgJGZyb20uZW5kKGRlcHRoKSkgYnJlYWs7XG4gIGZvciAobGV0IGQgPSAkdG8uZGVwdGg7IGQgPj0gMDsgZC0tLCBiZWZvcmVUby0tKVxuICAgIGlmICgkdG8uYmVmb3JlKGQgKyAxKSA+ICR0by5zdGFydChkKSkgYnJlYWs7XG4gIHJldHVybiBhZnRlckZyb20gPT0gYmVmb3JlVG8gJiYgL3Jvd3x0YWJsZS8udGVzdCgkZnJvbS5ub2RlKGRlcHRoKS50eXBlLnNwZWMudGFibGVSb2xlKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbkFjcm9zc0NlbGxzKHsgJGZyb20sICR0byB9KSB7XG4gIGxldCBmcm9tQ2VsbEJvdW5kYXJ5Tm9kZTtcbiAgbGV0IHRvQ2VsbEJvdW5kYXJ5Tm9kZTtcbiAgZm9yIChsZXQgaSA9ICRmcm9tLmRlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRmcm9tLm5vZGUoaSk7XG4gICAgaWYgKG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PT0gXCJjZWxsXCIgfHwgbm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICAgIGZyb21DZWxsQm91bmRhcnlOb2RlID0gbm9kZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gJHRvLmRlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3Qgbm9kZSA9ICR0by5ub2RlKGkpO1xuICAgIGlmIChub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT09IFwiY2VsbFwiIHx8IG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PT0gXCJoZWFkZXJfY2VsbFwiKSB7XG4gICAgICB0b0NlbGxCb3VuZGFyeU5vZGUgPSBub2RlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tQ2VsbEJvdW5kYXJ5Tm9kZSAhPT0gdG9DZWxsQm91bmRhcnlOb2RlICYmICR0by5wYXJlbnRPZmZzZXQgPT09IDA7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3Rpb24oc3RhdGUsIHRyLCBhbGxvd1RhYmxlTm9kZVNlbGVjdGlvbikge1xuICBjb25zdCBzZWwgPSAodHIgfHwgc3RhdGUpLnNlbGVjdGlvbjtcbiAgY29uc3QgZG9jID0gKHRyIHx8IHN0YXRlKS5kb2M7XG4gIGxldCBub3JtYWxpemU7XG4gIGxldCByb2xlO1xuICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjIgJiYgKHJvbGUgPSBzZWwubm9kZS50eXBlLnNwZWMudGFibGVSb2xlKSkge1xuICAgIGlmIChyb2xlID09IFwiY2VsbFwiIHx8IHJvbGUgPT0gXCJoZWFkZXJfY2VsbFwiKSB7XG4gICAgICBub3JtYWxpemUgPSBDZWxsU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHNlbC5mcm9tKTtcbiAgICB9IGVsc2UgaWYgKHJvbGUgPT0gXCJyb3dcIikge1xuICAgICAgY29uc3QgJGNlbGwgPSBkb2MucmVzb2x2ZShzZWwuZnJvbSArIDEpO1xuICAgICAgbm9ybWFsaXplID0gQ2VsbFNlbGVjdGlvbi5yb3dTZWxlY3Rpb24oJGNlbGwsICRjZWxsKTtcbiAgICB9IGVsc2UgaWYgKCFhbGxvd1RhYmxlTm9kZVNlbGVjdGlvbikge1xuICAgICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHNlbC5ub2RlKTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gc2VsLmZyb20gKyAxO1xuICAgICAgY29uc3QgbGFzdENlbGwgPSBzdGFydCArIG1hcC5tYXBbbWFwLndpZHRoICogbWFwLmhlaWdodCAtIDFdO1xuICAgICAgbm9ybWFsaXplID0gQ2VsbFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBzdGFydCArIDEsIGxhc3RDZWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBpc0NlbGxCb3VuZGFyeVNlbGVjdGlvbihzZWwpKSB7XG4gICAgbm9ybWFsaXplID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBzZWwuZnJvbSk7XG4gIH0gZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBpc1RleHRTZWxlY3Rpb25BY3Jvc3NDZWxscyhzZWwpKSB7XG4gICAgbm9ybWFsaXplID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBzZWwuJGZyb20uc3RhcnQoKSwgc2VsLiRmcm9tLmVuZCgpKTtcbiAgfVxuICBpZiAobm9ybWFsaXplKSAodHIgfHwgKHRyID0gc3RhdGUudHIpKS5zZXRTZWxlY3Rpb24obm9ybWFsaXplKTtcbiAgcmV0dXJuIHRyO1xufVxuXG4vLyBzcmMvZml4dGFibGVzLnRzXG5pbXBvcnQgeyBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MiB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xudmFyIGZpeFRhYmxlc0tleSA9IG5ldyBQbHVnaW5LZXkyKFwiZml4LXRhYmxlc1wiKTtcbmZ1bmN0aW9uIGNoYW5nZWREZXNjZW5kYW50cyhvbGQsIGN1ciwgb2Zmc2V0LCBmKSB7XG4gIGNvbnN0IG9sZFNpemUgPSBvbGQuY2hpbGRDb3VudCwgY3VyU2l6ZSA9IGN1ci5jaGlsZENvdW50O1xuICBvdXRlcjogZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY3VyU2l6ZTsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjdXIuY2hpbGQoaSk7XG4gICAgZm9yIChsZXQgc2NhbiA9IGosIGUgPSBNYXRoLm1pbihvbGRTaXplLCBpICsgMyk7IHNjYW4gPCBlOyBzY2FuKyspIHtcbiAgICAgIGlmIChvbGQuY2hpbGQoc2NhbikgPT0gY2hpbGQpIHtcbiAgICAgICAgaiA9IHNjYW4gKyAxO1xuICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBmKGNoaWxkLCBvZmZzZXQpO1xuICAgIGlmIChqIDwgb2xkU2l6ZSAmJiBvbGQuY2hpbGQoaikuc2FtZU1hcmt1cChjaGlsZCkpXG4gICAgICBjaGFuZ2VkRGVzY2VuZGFudHMob2xkLmNoaWxkKGopLCBjaGlsZCwgb2Zmc2V0ICsgMSwgZik7XG4gICAgZWxzZSBjaGlsZC5ub2Rlc0JldHdlZW4oMCwgY2hpbGQuY29udGVudC5zaXplLCBmLCBvZmZzZXQgKyAxKTtcbiAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpeFRhYmxlcyhzdGF0ZSwgb2xkU3RhdGUpIHtcbiAgbGV0IHRyO1xuICBjb25zdCBjaGVjayA9IChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAobm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09IFwidGFibGVcIilcbiAgICAgIHRyID0gZml4VGFibGUoc3RhdGUsIG5vZGUsIHBvcywgdHIpO1xuICB9O1xuICBpZiAoIW9sZFN0YXRlKSBzdGF0ZS5kb2MuZGVzY2VuZGFudHMoY2hlY2spO1xuICBlbHNlIGlmIChvbGRTdGF0ZS5kb2MgIT0gc3RhdGUuZG9jKVxuICAgIGNoYW5nZWREZXNjZW5kYW50cyhvbGRTdGF0ZS5kb2MsIHN0YXRlLmRvYywgMCwgY2hlY2spO1xuICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBmaXhUYWJsZShzdGF0ZSwgdGFibGUsIHRhYmxlUG9zLCB0cikge1xuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICBpZiAoIW1hcC5wcm9ibGVtcykgcmV0dXJuIHRyO1xuICBpZiAoIXRyKSB0ciA9IHN0YXRlLnRyO1xuICBjb25zdCBtdXN0QWRkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLmhlaWdodDsgaSsrKSBtdXN0QWRkLnB1c2goMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLnByb2JsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvYiA9IG1hcC5wcm9ibGVtc1tpXTtcbiAgICBpZiAocHJvYi50eXBlID09IFwiY29sbGlzaW9uXCIpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocHJvYi5wb3MpO1xuICAgICAgaWYgKCFjZWxsKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGF0dHJzID0gY2VsbC5hdHRycztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXR0cnMucm93c3BhbjsgaisrKSBtdXN0QWRkW3Byb2Iucm93ICsgal0gKz0gcHJvYi5uO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgdHIubWFwcGluZy5tYXAodGFibGVQb3MgKyAxICsgcHJvYi5wb3MpLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW1vdmVDb2xTcGFuKGF0dHJzLCBhdHRycy5jb2xzcGFuIC0gcHJvYi5uLCBwcm9iLm4pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwibWlzc2luZ1wiKSB7XG4gICAgICBtdXN0QWRkW3Byb2Iucm93XSArPSBwcm9iLm47XG4gICAgfSBlbHNlIGlmIChwcm9iLnR5cGUgPT0gXCJvdmVybG9uZ19yb3dzcGFuXCIpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocHJvYi5wb3MpO1xuICAgICAgaWYgKCFjZWxsKSBjb250aW51ZTtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAodGFibGVQb3MgKyAxICsgcHJvYi5wb3MpLCBudWxsLCB7XG4gICAgICAgIC4uLmNlbGwuYXR0cnMsXG4gICAgICAgIHJvd3NwYW46IGNlbGwuYXR0cnMucm93c3BhbiAtIHByb2IublxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwcm9iLnR5cGUgPT0gXCJjb2x3aWR0aCBtaXNtYXRjaFwiKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHByb2IucG9zKTtcbiAgICAgIGlmICghY2VsbCkgY29udGludWU7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKHRhYmxlUG9zICsgMSArIHByb2IucG9zKSwgbnVsbCwge1xuICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICBjb2x3aWR0aDogcHJvYi5jb2x3aWR0aFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwcm9iLnR5cGUgPT0gXCJ6ZXJvX3NpemVkXCIpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRyLm1hcHBpbmcubWFwKHRhYmxlUG9zKTtcbiAgICAgIHRyLmRlbGV0ZShwb3MsIHBvcyArIHRhYmxlLm5vZGVTaXplKTtcbiAgICB9XG4gIH1cbiAgbGV0IGZpcnN0LCBsYXN0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG11c3RBZGQubGVuZ3RoOyBpKyspXG4gICAgaWYgKG11c3RBZGRbaV0pIHtcbiAgICAgIGlmIChmaXJzdCA9PSBudWxsKSBmaXJzdCA9IGk7XG4gICAgICBsYXN0ID0gaTtcbiAgICB9XG4gIGZvciAobGV0IGkgPSAwLCBwb3MgPSB0YWJsZVBvcyArIDE7IGkgPCBtYXAuaGVpZ2h0OyBpKyspIHtcbiAgICBjb25zdCByb3cgPSB0YWJsZS5jaGlsZChpKTtcbiAgICBjb25zdCBlbmQgPSBwb3MgKyByb3cubm9kZVNpemU7XG4gICAgY29uc3QgYWRkID0gbXVzdEFkZFtpXTtcbiAgICBpZiAoYWRkID4gMCkge1xuICAgICAgbGV0IHJvbGUgPSBcImNlbGxcIjtcbiAgICAgIGlmIChyb3cuZmlyc3RDaGlsZCkge1xuICAgICAgICByb2xlID0gcm93LmZpcnN0Q2hpbGQudHlwZS5zcGVjLnRhYmxlUm9sZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFkZDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpW3JvbGVdLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgICAgaWYgKG5vZGUpIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gKGkgPT0gMCB8fCBmaXJzdCA9PSBpIC0gMSkgJiYgbGFzdCA9PSBpID8gcG9zICsgMSA6IGVuZCAtIDE7XG4gICAgICB0ci5pbnNlcnQodHIubWFwcGluZy5tYXAoc2lkZSksIG5vZGVzKTtcbiAgICB9XG4gICAgcG9zID0gZW5kO1xuICB9XG4gIHJldHVybiB0ci5zZXRNZXRhKGZpeFRhYmxlc0tleSwgeyBmaXhUYWJsZXM6IHRydWUgfSk7XG59XG5cbi8vIHNyYy9pbnB1dC50c1xuaW1wb3J0IHsga2V5ZG93bkhhbmRsZXIgfSBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDQgfSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCB7XG4gIFNlbGVjdGlvbiBhcyBTZWxlY3Rpb24yLFxuICBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb24zXG59IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuXG4vLyBzcmMvY29tbWFuZHMudHNcbmltcG9ydCB7XG4gIEZyYWdtZW50IGFzIEZyYWdtZW50MixcbiAgU2xpY2UgYXMgU2xpY2UyXG59IGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuaW1wb3J0IHtcbiAgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uMlxufSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbmZ1bmN0aW9uIHNlbGVjdGVkUmVjdChzdGF0ZSkge1xuICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0ICRwb3MgPSBzZWxlY3Rpb25DZWxsKHN0YXRlKTtcbiAgY29uc3QgdGFibGUgPSAkcG9zLm5vZGUoLTEpO1xuICBjb25zdCB0YWJsZVN0YXJ0ID0gJHBvcy5zdGFydCgtMSk7XG4gIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGNvbnN0IHJlY3QgPSBzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uID8gbWFwLnJlY3RCZXR3ZWVuKFxuICAgIHNlbC4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0LFxuICAgIHNlbC4kaGVhZENlbGwucG9zIC0gdGFibGVTdGFydFxuICApIDogbWFwLmZpbmRDZWxsKCRwb3MucG9zIC0gdGFibGVTdGFydCk7XG4gIHJldHVybiB7IC4uLnJlY3QsIHRhYmxlU3RhcnQsIG1hcCwgdGFibGUgfTtcbn1cbmZ1bmN0aW9uIGFkZENvbHVtbih0ciwgeyBtYXAsIHRhYmxlU3RhcnQsIHRhYmxlIH0sIGNvbCkge1xuICBsZXQgcmVmQ29sdW1uID0gY29sID4gMCA/IC0xIDogMDtcbiAgaWYgKGNvbHVtbklzSGVhZGVyKG1hcCwgdGFibGUsIGNvbCArIHJlZkNvbHVtbikpIHtcbiAgICByZWZDb2x1bW4gPSBjb2wgPT0gMCB8fCBjb2wgPT0gbWFwLndpZHRoID8gbnVsbCA6IDA7XG4gIH1cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGNvbDtcbiAgICBpZiAoY29sID4gMCAmJiBjb2wgPCBtYXAud2lkdGggJiYgbWFwLm1hcFtpbmRleCAtIDFdID09IG1hcC5tYXBbaW5kZXhdKSB7XG4gICAgICBjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgIHRyLm1hcHBpbmcubWFwKHRhYmxlU3RhcnQgKyBwb3MpLFxuICAgICAgICBudWxsLFxuICAgICAgICBhZGRDb2xTcGFuKGNlbGwuYXR0cnMsIGNvbCAtIG1hcC5jb2xDb3VudChwb3MpKVxuICAgICAgKTtcbiAgICAgIHJvdyArPSBjZWxsLmF0dHJzLnJvd3NwYW4gLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gcmVmQ29sdW1uID09IG51bGwgPyB0YWJsZU5vZGVUeXBlcyh0YWJsZS50eXBlLnNjaGVtYSkuY2VsbCA6IHRhYmxlLm5vZGVBdChtYXAubWFwW2luZGV4ICsgcmVmQ29sdW1uXSkudHlwZTtcbiAgICAgIGNvbnN0IHBvcyA9IG1hcC5wb3NpdGlvbkF0KHJvdywgY29sLCB0YWJsZSk7XG4gICAgICB0ci5pbnNlcnQodHIubWFwcGluZy5tYXAodGFibGVTdGFydCArIHBvcyksIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gYWRkQ29sdW1uQmVmb3JlKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG4gICAgZGlzcGF0Y2goYWRkQ29sdW1uKHN0YXRlLnRyLCByZWN0LCByZWN0LmxlZnQpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFkZENvbHVtbkFmdGVyKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG4gICAgZGlzcGF0Y2goYWRkQ29sdW1uKHN0YXRlLnRyLCByZWN0LCByZWN0LnJpZ2h0KSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmVDb2x1bW4odHIsIHsgbWFwLCB0YWJsZSwgdGFibGVTdGFydCB9LCBjb2wpIHtcbiAgY29uc3QgbWFwU3RhcnQgPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyApIHtcbiAgICBjb25zdCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGNvbDtcbiAgICBjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgY29uc3QgYXR0cnMgPSBjZWxsLmF0dHJzO1xuICAgIGlmIChjb2wgPiAwICYmIG1hcC5tYXBbaW5kZXggLSAxXSA9PSBwb3MgfHwgY29sIDwgbWFwLndpZHRoIC0gMSAmJiBtYXAubWFwW2luZGV4ICsgMV0gPT0gcG9zKSB7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAodGFibGVTdGFydCArIHBvcyksXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlbW92ZUNvbFNwYW4oYXR0cnMsIGNvbCAtIG1hcC5jb2xDb3VudChwb3MpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhcnQgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAodGFibGVTdGFydCArIHBvcyk7XG4gICAgICB0ci5kZWxldGUoc3RhcnQsIHN0YXJ0ICsgY2VsbC5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIHJvdyArPSBhdHRycy5yb3dzcGFuO1xuICB9XG59XG5mdW5jdGlvbiBkZWxldGVDb2x1bW4oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKTtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgIGlmIChyZWN0LmxlZnQgPT0gMCAmJiByZWN0LnJpZ2h0ID09IHJlY3QubWFwLndpZHRoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IHJlY3QucmlnaHQgLSAxOyA7IGktLSkge1xuICAgICAgcmVtb3ZlQ29sdW1uKHRyLCByZWN0LCBpKTtcbiAgICAgIGlmIChpID09IHJlY3QubGVmdCkgYnJlYWs7XG4gICAgICBjb25zdCB0YWJsZSA9IHJlY3QudGFibGVTdGFydCA/IHRyLmRvYy5ub2RlQXQocmVjdC50YWJsZVN0YXJ0IC0gMSkgOiB0ci5kb2M7XG4gICAgICBpZiAoIXRhYmxlKSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJObyB0YWJsZSBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJlY3QudGFibGUgPSB0YWJsZTtcbiAgICAgIHJlY3QubWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICB9XG4gICAgZGlzcGF0Y2godHIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcm93SXNIZWFkZXIobWFwLCB0YWJsZSwgcm93KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgaGVhZGVyQ2VsbCA9IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5oZWFkZXJfY2VsbDtcbiAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgbWFwLndpZHRoOyBjb2wrKylcbiAgICBpZiAoKChfYSA9IHRhYmxlLm5vZGVBdChtYXAubWFwW2NvbCArIHJvdyAqIG1hcC53aWR0aF0pKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZSkgIT0gaGVhZGVyQ2VsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhZGRSb3codHIsIHsgbWFwLCB0YWJsZVN0YXJ0LCB0YWJsZSB9LCByb3cpIHtcbiAgdmFyIF9hO1xuICBsZXQgcm93UG9zID0gdGFibGVTdGFydDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3c7IGkrKykgcm93UG9zICs9IHRhYmxlLmNoaWxkKGkpLm5vZGVTaXplO1xuICBjb25zdCBjZWxscyA9IFtdO1xuICBsZXQgcmVmUm93ID0gcm93ID4gMCA/IC0xIDogMDtcbiAgaWYgKHJvd0lzSGVhZGVyKG1hcCwgdGFibGUsIHJvdyArIHJlZlJvdykpXG4gICAgcmVmUm93ID0gcm93ID09IDAgfHwgcm93ID09IG1hcC5oZWlnaHQgPyBudWxsIDogMDtcbiAgZm9yIChsZXQgY29sID0gMCwgaW5kZXggPSBtYXAud2lkdGggKiByb3c7IGNvbCA8IG1hcC53aWR0aDsgY29sKyssIGluZGV4KyspIHtcbiAgICBpZiAocm93ID4gMCAmJiByb3cgPCBtYXAuaGVpZ2h0ICYmIG1hcC5tYXBbaW5kZXhdID09IG1hcC5tYXBbaW5kZXggLSBtYXAud2lkdGhdKSB7XG4gICAgICBjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICAgIGNvbnN0IGF0dHJzID0gdGFibGUubm9kZUF0KHBvcykuYXR0cnM7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHRhYmxlU3RhcnQgKyBwb3MsIG51bGwsIHtcbiAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgIHJvd3NwYW46IGF0dHJzLnJvd3NwYW4gKyAxXG4gICAgICB9KTtcbiAgICAgIGNvbCArPSBhdHRycy5jb2xzcGFuIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IHJlZlJvdyA9PSBudWxsID8gdGFibGVOb2RlVHlwZXModGFibGUudHlwZS5zY2hlbWEpLmNlbGwgOiAoX2EgPSB0YWJsZS5ub2RlQXQobWFwLm1hcFtpbmRleCArIHJlZlJvdyAqIG1hcC53aWR0aF0pKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0eXBlID09IG51bGwgPyB2b2lkIDAgOiB0eXBlLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgIGlmIChub2RlKSBjZWxscy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICB0ci5pbnNlcnQocm93UG9zLCB0YWJsZU5vZGVUeXBlcyh0YWJsZS50eXBlLnNjaGVtYSkucm93LmNyZWF0ZShudWxsLCBjZWxscykpO1xuICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBhZGRSb3dCZWZvcmUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKTtcbiAgICBkaXNwYXRjaChhZGRSb3coc3RhdGUudHIsIHJlY3QsIHJlY3QudG9wKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhZGRSb3dBZnRlcihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGRpc3BhdGNoKGFkZFJvdyhzdGF0ZS50ciwgcmVjdCwgcmVjdC5ib3R0b20pKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJvdyh0ciwgeyBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0IH0sIHJvdykge1xuICBsZXQgcm93UG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3c7IGkrKykgcm93UG9zICs9IHRhYmxlLmNoaWxkKGkpLm5vZGVTaXplO1xuICBjb25zdCBuZXh0Um93ID0gcm93UG9zICsgdGFibGUuY2hpbGQocm93KS5ub2RlU2l6ZTtcbiAgY29uc3QgbWFwRnJvbSA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG4gIHRyLmRlbGV0ZShyb3dQb3MgKyB0YWJsZVN0YXJ0LCBuZXh0Um93ICsgdGFibGVTdGFydCk7XG4gIGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGxldCBjb2wgPSAwLCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aDsgY29sIDwgbWFwLndpZHRoOyBjb2wrKywgaW5kZXgrKykge1xuICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgIGlmIChzZWVuLmhhcyhwb3MpKSBjb250aW51ZTtcbiAgICBzZWVuLmFkZChwb3MpO1xuICAgIGlmIChyb3cgPiAwICYmIHBvcyA9PSBtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSkge1xuICAgICAgY29uc3QgYXR0cnMgPSB0YWJsZS5ub2RlQXQocG9zKS5hdHRycztcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgdGFibGVTdGFydCksIG51bGwsIHtcbiAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgIHJvd3NwYW46IGF0dHJzLnJvd3NwYW4gLSAxXG4gICAgICB9KTtcbiAgICAgIGNvbCArPSBhdHRycy5jb2xzcGFuIC0gMTtcbiAgICB9IGVsc2UgaWYgKHJvdyA8IG1hcC5oZWlnaHQgJiYgcG9zID09IG1hcC5tYXBbaW5kZXggKyBtYXAud2lkdGhdKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICBjb25zdCBhdHRycyA9IGNlbGwuYXR0cnM7XG4gICAgICBjb25zdCBjb3B5ID0gY2VsbC50eXBlLmNyZWF0ZShcbiAgICAgICAgeyAuLi5hdHRycywgcm93c3BhbjogY2VsbC5hdHRycy5yb3dzcGFuIC0gMSB9LFxuICAgICAgICBjZWxsLmNvbnRlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXdQb3MgPSBtYXAucG9zaXRpb25BdChyb3cgKyAxLCBjb2wsIHRhYmxlKTtcbiAgICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcCh0YWJsZVN0YXJ0ICsgbmV3UG9zKSwgY29weSk7XG4gICAgICBjb2wgKz0gYXR0cnMuY29sc3BhbiAtIDE7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWxldGVSb3coc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgdHIgPSBzdGF0ZS50cjtcbiAgICBpZiAocmVjdC50b3AgPT0gMCAmJiByZWN0LmJvdHRvbSA9PSByZWN0Lm1hcC5oZWlnaHQpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gcmVjdC5ib3R0b20gLSAxOyA7IGktLSkge1xuICAgICAgcmVtb3ZlUm93KHRyLCByZWN0LCBpKTtcbiAgICAgIGlmIChpID09IHJlY3QudG9wKSBicmVhaztcbiAgICAgIGNvbnN0IHRhYmxlID0gcmVjdC50YWJsZVN0YXJ0ID8gdHIuZG9jLm5vZGVBdChyZWN0LnRhYmxlU3RhcnQgLSAxKSA6IHRyLmRvYztcbiAgICAgIGlmICghdGFibGUpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIk5vIHRhYmxlIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgcmVjdC50YWJsZSA9IHRhYmxlO1xuICAgICAgcmVjdC5tYXAgPSBUYWJsZU1hcC5nZXQocmVjdC50YWJsZSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkoY2VsbCkge1xuICBjb25zdCBjID0gY2VsbC5jb250ZW50O1xuICByZXR1cm4gYy5jaGlsZENvdW50ID09IDEgJiYgYy5jaGlsZCgwKS5pc1RleHRibG9jayAmJiBjLmNoaWxkKDApLmNoaWxkQ291bnQgPT0gMDtcbn1cbmZ1bmN0aW9uIGNlbGxzT3ZlcmxhcFJlY3RhbmdsZSh7IHdpZHRoLCBoZWlnaHQsIG1hcCB9LCByZWN0KSB7XG4gIGxldCBpbmRleFRvcCA9IHJlY3QudG9wICogd2lkdGggKyByZWN0LmxlZnQsIGluZGV4TGVmdCA9IGluZGV4VG9wO1xuICBsZXQgaW5kZXhCb3R0b20gPSAocmVjdC5ib3R0b20gLSAxKSAqIHdpZHRoICsgcmVjdC5sZWZ0LCBpbmRleFJpZ2h0ID0gaW5kZXhUb3AgKyAocmVjdC5yaWdodCAtIHJlY3QubGVmdCAtIDEpO1xuICBmb3IgKGxldCBpID0gcmVjdC50b3A7IGkgPCByZWN0LmJvdHRvbTsgaSsrKSB7XG4gICAgaWYgKHJlY3QubGVmdCA+IDAgJiYgbWFwW2luZGV4TGVmdF0gPT0gbWFwW2luZGV4TGVmdCAtIDFdIHx8IHJlY3QucmlnaHQgPCB3aWR0aCAmJiBtYXBbaW5kZXhSaWdodF0gPT0gbWFwW2luZGV4UmlnaHQgKyAxXSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGluZGV4TGVmdCArPSB3aWR0aDtcbiAgICBpbmRleFJpZ2h0ICs9IHdpZHRoO1xuICB9XG4gIGZvciAobGV0IGkgPSByZWN0LmxlZnQ7IGkgPCByZWN0LnJpZ2h0OyBpKyspIHtcbiAgICBpZiAocmVjdC50b3AgPiAwICYmIG1hcFtpbmRleFRvcF0gPT0gbWFwW2luZGV4VG9wIC0gd2lkdGhdIHx8IHJlY3QuYm90dG9tIDwgaGVpZ2h0ICYmIG1hcFtpbmRleEJvdHRvbV0gPT0gbWFwW2luZGV4Qm90dG9tICsgd2lkdGhdKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaW5kZXhUb3ArKztcbiAgICBpbmRleEJvdHRvbSsrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2VsbHMoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKCEoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikgfHwgc2VsLiRhbmNob3JDZWxsLnBvcyA9PSBzZWwuJGhlYWRDZWxsLnBvcylcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB7IG1hcCB9ID0gcmVjdDtcbiAgaWYgKGNlbGxzT3ZlcmxhcFJlY3RhbmdsZShtYXAsIHJlY3QpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQyLmVtcHR5O1xuICAgIGxldCBtZXJnZWRQb3M7XG4gICAgbGV0IG1lcmdlZENlbGw7XG4gICAgZm9yIChsZXQgcm93ID0gcmVjdC50b3A7IHJvdyA8IHJlY3QuYm90dG9tOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gcmVjdC5sZWZ0OyBjb2wgPCByZWN0LnJpZ2h0OyBjb2wrKykge1xuICAgICAgICBjb25zdCBjZWxsUG9zID0gbWFwLm1hcFtyb3cgKiBtYXAud2lkdGggKyBjb2xdO1xuICAgICAgICBjb25zdCBjZWxsID0gcmVjdC50YWJsZS5ub2RlQXQoY2VsbFBvcyk7XG4gICAgICAgIGlmIChzZWVuW2NlbGxQb3NdIHx8ICFjZWxsKSBjb250aW51ZTtcbiAgICAgICAgc2VlbltjZWxsUG9zXSA9IHRydWU7XG4gICAgICAgIGlmIChtZXJnZWRQb3MgPT0gbnVsbCkge1xuICAgICAgICAgIG1lcmdlZFBvcyA9IGNlbGxQb3M7XG4gICAgICAgICAgbWVyZ2VkQ2VsbCA9IGNlbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5KGNlbGwpKSBjb250ZW50ID0gY29udGVudC5hcHBlbmQoY2VsbC5jb250ZW50KTtcbiAgICAgICAgICBjb25zdCBtYXBwZWQgPSB0ci5tYXBwaW5nLm1hcChjZWxsUG9zICsgcmVjdC50YWJsZVN0YXJ0KTtcbiAgICAgICAgICB0ci5kZWxldGUobWFwcGVkLCBtYXBwZWQgKyBjZWxsLm5vZGVTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWVyZ2VkUG9zID09IG51bGwgfHwgbWVyZ2VkQ2VsbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHIuc2V0Tm9kZU1hcmt1cChtZXJnZWRQb3MgKyByZWN0LnRhYmxlU3RhcnQsIG51bGwsIHtcbiAgICAgIC4uLmFkZENvbFNwYW4oXG4gICAgICAgIG1lcmdlZENlbGwuYXR0cnMsXG4gICAgICAgIG1lcmdlZENlbGwuYXR0cnMuY29sc3BhbixcbiAgICAgICAgcmVjdC5yaWdodCAtIHJlY3QubGVmdCAtIG1lcmdlZENlbGwuYXR0cnMuY29sc3BhblxuICAgICAgKSxcbiAgICAgIHJvd3NwYW46IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICB9KTtcbiAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICBjb25zdCBlbmQgPSBtZXJnZWRQb3MgKyAxICsgbWVyZ2VkQ2VsbC5jb250ZW50LnNpemU7XG4gICAgICBjb25zdCBzdGFydCA9IGlzRW1wdHkobWVyZ2VkQ2VsbCkgPyBtZXJnZWRQb3MgKyAxIDogZW5kO1xuICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnQgKyByZWN0LnRhYmxlU3RhcnQsIGVuZCArIHJlY3QudGFibGVTdGFydCwgY29udGVudCk7XG4gICAgfVxuICAgIHRyLnNldFNlbGVjdGlvbihcbiAgICAgIG5ldyBDZWxsU2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKG1lcmdlZFBvcyArIHJlY3QudGFibGVTdGFydCkpXG4gICAgKTtcbiAgICBkaXNwYXRjaCh0cik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzcGxpdENlbGwoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IG5vZGVUeXBlcyA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSk7XG4gIHJldHVybiBzcGxpdENlbGxXaXRoVHlwZSgoeyBub2RlIH0pID0+IHtcbiAgICByZXR1cm4gbm9kZVR5cGVzW25vZGUudHlwZS5zcGVjLnRhYmxlUm9sZV07XG4gIH0pKHN0YXRlLCBkaXNwYXRjaCk7XG59XG5mdW5jdGlvbiBzcGxpdENlbGxXaXRoVHlwZShnZXRDZWxsVHlwZSkge1xuICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGNlbGxOb2RlO1xuICAgIGxldCBjZWxsUG9zO1xuICAgIGlmICghKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pKSB7XG4gICAgICBjZWxsTm9kZSA9IGNlbGxXcmFwcGluZyhzZWwuJGZyb20pO1xuICAgICAgaWYgKCFjZWxsTm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY2VsbFBvcyA9IChfYSA9IGNlbGxBcm91bmQoc2VsLiRmcm9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlbC4kYW5jaG9yQ2VsbC5wb3MgIT0gc2VsLiRoZWFkQ2VsbC5wb3MpIHJldHVybiBmYWxzZTtcbiAgICAgIGNlbGxOb2RlID0gc2VsLiRhbmNob3JDZWxsLm5vZGVBZnRlcjtcbiAgICAgIGNlbGxQb3MgPSBzZWwuJGFuY2hvckNlbGwucG9zO1xuICAgIH1cbiAgICBpZiAoY2VsbE5vZGUgPT0gbnVsbCB8fCBjZWxsUG9zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNlbGxOb2RlLmF0dHJzLmNvbHNwYW4gPT0gMSAmJiBjZWxsTm9kZS5hdHRycy5yb3dzcGFuID09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBsZXQgYmFzZUF0dHJzID0gY2VsbE5vZGUuYXR0cnM7XG4gICAgICBjb25zdCBhdHRycyA9IFtdO1xuICAgICAgY29uc3QgY29sd2lkdGggPSBiYXNlQXR0cnMuY29sd2lkdGg7XG4gICAgICBpZiAoYmFzZUF0dHJzLnJvd3NwYW4gPiAxKSBiYXNlQXR0cnMgPSB7IC4uLmJhc2VBdHRycywgcm93c3BhbjogMSB9O1xuICAgICAgaWYgKGJhc2VBdHRycy5jb2xzcGFuID4gMSkgYmFzZUF0dHJzID0geyAuLi5iYXNlQXR0cnMsIGNvbHNwYW46IDEgfTtcbiAgICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0OyBpKyspXG4gICAgICAgIGF0dHJzLnB1c2goXG4gICAgICAgICAgY29sd2lkdGggPyB7XG4gICAgICAgICAgICAuLi5iYXNlQXR0cnMsXG4gICAgICAgICAgICBjb2x3aWR0aDogY29sd2lkdGggJiYgY29sd2lkdGhbaV0gPyBbY29sd2lkdGhbaV1dIDogbnVsbFxuICAgICAgICAgIH0gOiBiYXNlQXR0cnNcbiAgICAgICAgKTtcbiAgICAgIGxldCBsYXN0Q2VsbDtcbiAgICAgIGZvciAobGV0IHJvdyA9IHJlY3QudG9wOyByb3cgPCByZWN0LmJvdHRvbTsgcm93KyspIHtcbiAgICAgICAgbGV0IHBvcyA9IHJlY3QubWFwLnBvc2l0aW9uQXQocm93LCByZWN0LmxlZnQsIHJlY3QudGFibGUpO1xuICAgICAgICBpZiAocm93ID09IHJlY3QudG9wKSBwb3MgKz0gY2VsbE5vZGUubm9kZVNpemU7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IHJlY3QubGVmdCwgaSA9IDA7IGNvbCA8IHJlY3QucmlnaHQ7IGNvbCsrLCBpKyspIHtcbiAgICAgICAgICBpZiAoY29sID09IHJlY3QubGVmdCAmJiByb3cgPT0gcmVjdC50b3ApIGNvbnRpbnVlO1xuICAgICAgICAgIHRyLmluc2VydChcbiAgICAgICAgICAgIGxhc3RDZWxsID0gdHIubWFwcGluZy5tYXAocG9zICsgcmVjdC50YWJsZVN0YXJ0LCAxKSxcbiAgICAgICAgICAgIGdldENlbGxUeXBlKHsgbm9kZTogY2VsbE5vZGUsIHJvdywgY29sIH0pLmNyZWF0ZUFuZEZpbGwoYXR0cnNbaV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgY2VsbFBvcyxcbiAgICAgICAgZ2V0Q2VsbFR5cGUoeyBub2RlOiBjZWxsTm9kZSwgcm93OiByZWN0LnRvcCwgY29sOiByZWN0LmxlZnQgfSksXG4gICAgICAgIGF0dHJzWzBdXG4gICAgICApO1xuICAgICAgaWYgKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pXG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihcbiAgICAgICAgICBuZXcgQ2VsbFNlbGVjdGlvbihcbiAgICAgICAgICAgIHRyLmRvYy5yZXNvbHZlKHNlbC4kYW5jaG9yQ2VsbC5wb3MpLFxuICAgICAgICAgICAgbGFzdENlbGwgPyB0ci5kb2MucmVzb2x2ZShsYXN0Q2VsbCkgOiB2b2lkIDBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gc2V0Q2VsbEF0dHIobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0ICRjZWxsID0gc2VsZWN0aW9uQ2VsbChzdGF0ZSk7XG4gICAgaWYgKCRjZWxsLm5vZGVBZnRlci5hdHRyc1tuYW1lXSA9PT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbilcbiAgICAgICAgc3RhdGUuc2VsZWN0aW9uLmZvckVhY2hDZWxsKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBpZiAobm9kZS5hdHRyc1tuYW1lXSAhPT0gdmFsdWUpXG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgbnVsbCwge1xuICAgICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICBbbmFtZV06IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRyLnNldE5vZGVNYXJrdXAoJGNlbGwucG9zLCBudWxsLCB7XG4gICAgICAgICAgLi4uJGNlbGwubm9kZUFmdGVyLmF0dHJzLFxuICAgICAgICAgIFtuYW1lXTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZF90b2dnbGVIZWFkZXIodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBjb25zdCB0eXBlcyA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSk7XG4gICAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgIGNvbnN0IGNlbGxzID0gcmVjdC5tYXAuY2VsbHNJblJlY3QoXG4gICAgICAgIHR5cGUgPT0gXCJjb2x1bW5cIiA/IHtcbiAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxuICAgICAgICAgIGJvdHRvbTogcmVjdC5tYXAuaGVpZ2h0XG4gICAgICAgIH0gOiB0eXBlID09IFwicm93XCIgPyB7XG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICAgIHJpZ2h0OiByZWN0Lm1hcC53aWR0aCxcbiAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tXG4gICAgICAgIH0gOiByZWN0XG4gICAgICApO1xuICAgICAgY29uc3Qgbm9kZXMgPSBjZWxscy5tYXAoKHBvcykgPT4gcmVjdC50YWJsZS5ub2RlQXQocG9zKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAobm9kZXNbaV0udHlwZSA9PSB0eXBlcy5oZWFkZXJfY2VsbClcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICAgICAgcmVjdC50YWJsZVN0YXJ0ICsgY2VsbHNbaV0sXG4gICAgICAgICAgICB0eXBlcy5jZWxsLFxuICAgICAgICAgICAgbm9kZXNbaV0uYXR0cnNcbiAgICAgICAgICApO1xuICAgICAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgICAgICByZWN0LnRhYmxlU3RhcnQgKyBjZWxsc1tpXSxcbiAgICAgICAgICAgIHR5cGVzLmhlYWRlcl9jZWxsLFxuICAgICAgICAgICAgbm9kZXNbaV0uYXR0cnNcbiAgICAgICAgICApO1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyRW5hYmxlZEJ5VHlwZSh0eXBlLCByZWN0LCB0eXBlcykge1xuICBjb25zdCBjZWxsUG9zaXRpb25zID0gcmVjdC5tYXAuY2VsbHNJblJlY3Qoe1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiB0eXBlID09IFwicm93XCIgPyByZWN0Lm1hcC53aWR0aCA6IDEsXG4gICAgYm90dG9tOiB0eXBlID09IFwiY29sdW1uXCIgPyByZWN0Lm1hcC5oZWlnaHQgOiAxXG4gIH0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxQb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjZWxsID0gcmVjdC50YWJsZS5ub2RlQXQoY2VsbFBvc2l0aW9uc1tpXSk7XG4gICAgaWYgKGNlbGwgJiYgY2VsbC50eXBlICE9PSB0eXBlcy5oZWFkZXJfY2VsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRlcih0eXBlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgdXNlRGVwcmVjYXRlZExvZ2ljOiBmYWxzZSB9O1xuICBpZiAob3B0aW9ucy51c2VEZXByZWNhdGVkTG9naWMpIHJldHVybiBkZXByZWNhdGVkX3RvZ2dsZUhlYWRlcih0eXBlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3QgdHlwZXMgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpO1xuICAgICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSksIHRyID0gc3RhdGUudHI7XG4gICAgICBjb25zdCBpc0hlYWRlclJvd0VuYWJsZWQgPSBpc0hlYWRlckVuYWJsZWRCeVR5cGUoXCJyb3dcIiwgcmVjdCwgdHlwZXMpO1xuICAgICAgY29uc3QgaXNIZWFkZXJDb2x1bW5FbmFibGVkID0gaXNIZWFkZXJFbmFibGVkQnlUeXBlKFxuICAgICAgICBcImNvbHVtblwiLFxuICAgICAgICByZWN0LFxuICAgICAgICB0eXBlc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGlzSGVhZGVyRW5hYmxlZCA9IHR5cGUgPT09IFwiY29sdW1uXCIgPyBpc0hlYWRlclJvd0VuYWJsZWQgOiB0eXBlID09PSBcInJvd1wiID8gaXNIZWFkZXJDb2x1bW5FbmFibGVkIDogZmFsc2U7XG4gICAgICBjb25zdCBzZWxlY3Rpb25TdGFydHNBdCA9IGlzSGVhZGVyRW5hYmxlZCA/IDEgOiAwO1xuICAgICAgY29uc3QgY2VsbHNSZWN0ID0gdHlwZSA9PSBcImNvbHVtblwiID8ge1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IHNlbGVjdGlvblN0YXJ0c0F0LFxuICAgICAgICByaWdodDogMSxcbiAgICAgICAgYm90dG9tOiByZWN0Lm1hcC5oZWlnaHRcbiAgICAgIH0gOiB0eXBlID09IFwicm93XCIgPyB7XG4gICAgICAgIGxlZnQ6IHNlbGVjdGlvblN0YXJ0c0F0LFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiByZWN0Lm1hcC53aWR0aCxcbiAgICAgICAgYm90dG9tOiAxXG4gICAgICB9IDogcmVjdDtcbiAgICAgIGNvbnN0IG5ld1R5cGUgPSB0eXBlID09IFwiY29sdW1uXCIgPyBpc0hlYWRlckNvbHVtbkVuYWJsZWQgPyB0eXBlcy5jZWxsIDogdHlwZXMuaGVhZGVyX2NlbGwgOiB0eXBlID09IFwicm93XCIgPyBpc0hlYWRlclJvd0VuYWJsZWQgPyB0eXBlcy5jZWxsIDogdHlwZXMuaGVhZGVyX2NlbGwgOiB0eXBlcy5jZWxsO1xuICAgICAgcmVjdC5tYXAuY2VsbHNJblJlY3QoY2VsbHNSZWN0KS5mb3JFYWNoKChyZWxhdGl2ZUNlbGxQb3MpID0+IHtcbiAgICAgICAgY29uc3QgY2VsbFBvcyA9IHJlbGF0aXZlQ2VsbFBvcyArIHJlY3QudGFibGVTdGFydDtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRyLmRvYy5ub2RlQXQoY2VsbFBvcyk7XG4gICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChjZWxsUG9zLCBuZXdUeXBlLCBjZWxsLmF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxudmFyIHRvZ2dsZUhlYWRlclJvdyA9IHRvZ2dsZUhlYWRlcihcInJvd1wiLCB7XG4gIHVzZURlcHJlY2F0ZWRMb2dpYzogdHJ1ZVxufSk7XG52YXIgdG9nZ2xlSGVhZGVyQ29sdW1uID0gdG9nZ2xlSGVhZGVyKFwiY29sdW1uXCIsIHtcbiAgdXNlRGVwcmVjYXRlZExvZ2ljOiB0cnVlXG59KTtcbnZhciB0b2dnbGVIZWFkZXJDZWxsID0gdG9nZ2xlSGVhZGVyKFwiY2VsbFwiLCB7XG4gIHVzZURlcHJlY2F0ZWRMb2dpYzogdHJ1ZVxufSk7XG5mdW5jdGlvbiBmaW5kTmV4dENlbGwoJGNlbGwsIGRpcikge1xuICBpZiAoZGlyIDwgMCkge1xuICAgIGNvbnN0IGJlZm9yZSA9ICRjZWxsLm5vZGVCZWZvcmU7XG4gICAgaWYgKGJlZm9yZSkgcmV0dXJuICRjZWxsLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZTtcbiAgICBmb3IgKGxldCByb3cgPSAkY2VsbC5pbmRleCgtMSkgLSAxLCByb3dFbmQgPSAkY2VsbC5iZWZvcmUoKTsgcm93ID49IDA7IHJvdy0tKSB7XG4gICAgICBjb25zdCByb3dOb2RlID0gJGNlbGwubm9kZSgtMSkuY2hpbGQocm93KTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHJvd05vZGUubGFzdENoaWxkO1xuICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICByZXR1cm4gcm93RW5kIC0gMSAtIGxhc3RDaGlsZC5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICAgIHJvd0VuZCAtPSByb3dOb2RlLm5vZGVTaXplO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGNlbGwuaW5kZXgoKSA8ICRjZWxsLnBhcmVudC5jaGlsZENvdW50IC0gMSkge1xuICAgICAgcmV0dXJuICRjZWxsLnBvcyArICRjZWxsLm5vZGVBZnRlci5ub2RlU2l6ZTtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSAkY2VsbC5ub2RlKC0xKTtcbiAgICBmb3IgKGxldCByb3cgPSAkY2VsbC5pbmRleEFmdGVyKC0xKSwgcm93U3RhcnQgPSAkY2VsbC5hZnRlcigpOyByb3cgPCB0YWJsZS5jaGlsZENvdW50OyByb3crKykge1xuICAgICAgY29uc3Qgcm93Tm9kZSA9IHRhYmxlLmNoaWxkKHJvdyk7XG4gICAgICBpZiAocm93Tm9kZS5jaGlsZENvdW50KSByZXR1cm4gcm93U3RhcnQgKyAxO1xuICAgICAgcm93U3RhcnQgKz0gcm93Tm9kZS5ub2RlU2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnb1RvTmV4dENlbGwoZGlyZWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBjZWxsID0gZmluZE5leHRDZWxsKHNlbGVjdGlvbkNlbGwoc3RhdGUpLCBkaXJlY3Rpb24pO1xuICAgIGlmIChjZWxsID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGNvbnN0ICRjZWxsID0gc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG4gICAgICBkaXNwYXRjaChcbiAgICAgICAgc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24yLmJldHdlZW4oJGNlbGwsIG1vdmVDZWxsRm9yd2FyZCgkY2VsbCkpKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVRhYmxlKHN0YXRlLCBkaXNwYXRjaCkge1xuICBjb25zdCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiRhbmNob3I7XG4gIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID4gMDsgZC0tKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkKTtcbiAgICBpZiAobm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09IFwidGFibGVcIikge1xuICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICBzdGF0ZS50ci5kZWxldGUoJHBvcy5iZWZvcmUoZCksICRwb3MuYWZ0ZXIoZCkpLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZWxldGVDZWxsU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGlmICghKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgY29uc3QgYmFzZUNvbnRlbnQgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpLmNlbGwuY3JlYXRlQW5kRmlsbCgpLmNvbnRlbnQ7XG4gICAgc2VsLmZvckVhY2hDZWxsKChjZWxsLCBwb3MpID0+IHtcbiAgICAgIGlmICghY2VsbC5jb250ZW50LmVxKGJhc2VDb250ZW50KSlcbiAgICAgICAgdHIucmVwbGFjZShcbiAgICAgICAgICB0ci5tYXBwaW5nLm1hcChwb3MgKyAxKSxcbiAgICAgICAgICB0ci5tYXBwaW5nLm1hcChwb3MgKyBjZWxsLm5vZGVTaXplIC0gMSksXG4gICAgICAgICAgbmV3IFNsaWNlMihiYXNlQ29udGVudCwgMCwgMClcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBpZiAodHIuZG9jQ2hhbmdlZCkgZGlzcGF0Y2godHIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvY29weXBhc3RlLnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDMsIFNsaWNlIGFzIFNsaWNlMyB9IGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSBcInByb3NlbWlycm9yLXRyYW5zZm9ybVwiO1xuZnVuY3Rpb24gcGFzdGVkQ2VsbHMoc2xpY2UpIHtcbiAgaWYgKCFzbGljZS5zaXplKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgd2hpbGUgKGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxICYmIChvcGVuU3RhcnQgPiAwICYmIG9wZW5FbmQgPiAwIHx8IGNvbnRlbnQuY2hpbGQoMCkudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInRhYmxlXCIpKSB7XG4gICAgb3BlblN0YXJ0LS07XG4gICAgb3BlbkVuZC0tO1xuICAgIGNvbnRlbnQgPSBjb250ZW50LmNoaWxkKDApLmNvbnRlbnQ7XG4gIH1cbiAgY29uc3QgZmlyc3QgPSBjb250ZW50LmNoaWxkKDApO1xuICBjb25zdCByb2xlID0gZmlyc3QudHlwZS5zcGVjLnRhYmxlUm9sZTtcbiAgY29uc3Qgc2NoZW1hID0gZmlyc3QudHlwZS5zY2hlbWEsIHJvd3MgPSBbXTtcbiAgaWYgKHJvbGUgPT0gXCJyb3dcIikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgIGxldCBjZWxscyA9IGNvbnRlbnQuY2hpbGQoaSkuY29udGVudDtcbiAgICAgIGNvbnN0IGxlZnQgPSBpID8gMCA6IE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIDEpO1xuICAgICAgY29uc3QgcmlnaHQgPSBpIDwgY29udGVudC5jaGlsZENvdW50IC0gMSA/IDAgOiBNYXRoLm1heCgwLCBvcGVuRW5kIC0gMSk7XG4gICAgICBpZiAobGVmdCB8fCByaWdodClcbiAgICAgICAgY2VsbHMgPSBmaXRTbGljZShcbiAgICAgICAgICB0YWJsZU5vZGVUeXBlcyhzY2hlbWEpLnJvdyxcbiAgICAgICAgICBuZXcgU2xpY2UzKGNlbGxzLCBsZWZ0LCByaWdodClcbiAgICAgICAgKS5jb250ZW50O1xuICAgICAgcm93cy5wdXNoKGNlbGxzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocm9sZSA9PSBcImNlbGxcIiB8fCByb2xlID09IFwiaGVhZGVyX2NlbGxcIikge1xuICAgIHJvd3MucHVzaChcbiAgICAgIG9wZW5TdGFydCB8fCBvcGVuRW5kID8gZml0U2xpY2UoXG4gICAgICAgIHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkucm93LFxuICAgICAgICBuZXcgU2xpY2UzKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZClcbiAgICAgICkuY29udGVudCA6IGNvbnRlbnRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbnN1cmVSZWN0YW5ndWxhcihzY2hlbWEsIHJvd3MpO1xufVxuZnVuY3Rpb24gZW5zdXJlUmVjdGFuZ3VsYXIoc2NoZW1hLCByb3dzKSB7XG4gIGNvbnN0IHdpZHRocyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByb3cgPSByb3dzW2ldO1xuICAgIGZvciAobGV0IGogPSByb3cuY2hpbGRDb3VudCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBjb25zdCB7IHJvd3NwYW4sIGNvbHNwYW4gfSA9IHJvdy5jaGlsZChqKS5hdHRycztcbiAgICAgIGZvciAobGV0IHIgPSBpOyByIDwgaSArIHJvd3NwYW47IHIrKylcbiAgICAgICAgd2lkdGhzW3JdID0gKHdpZHRoc1tyXSB8fCAwKSArIGNvbHNwYW47XG4gICAgfVxuICB9XG4gIGxldCB3aWR0aCA9IDA7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgd2lkdGhzLmxlbmd0aDsgcisrKSB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB3aWR0aHNbcl0pO1xuICBmb3IgKGxldCByID0gMDsgciA8IHdpZHRocy5sZW5ndGg7IHIrKykge1xuICAgIGlmIChyID49IHJvd3MubGVuZ3RoKSByb3dzLnB1c2goRnJhZ21lbnQzLmVtcHR5KTtcbiAgICBpZiAod2lkdGhzW3JdIDwgd2lkdGgpIHtcbiAgICAgIGNvbnN0IGVtcHR5ID0gdGFibGVOb2RlVHlwZXMoc2NoZW1hKS5jZWxsLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gd2lkdGhzW3JdOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBjZWxscy5wdXNoKGVtcHR5KTtcbiAgICAgIH1cbiAgICAgIHJvd3Nbcl0gPSByb3dzW3JdLmFwcGVuZChGcmFnbWVudDMuZnJvbShjZWxscykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBoZWlnaHQ6IHJvd3MubGVuZ3RoLCB3aWR0aCwgcm93cyB9O1xufVxuZnVuY3Rpb24gZml0U2xpY2Uobm9kZVR5cGUsIHNsaWNlKSB7XG4gIGNvbnN0IG5vZGUgPSBub2RlVHlwZS5jcmVhdGVBbmRGaWxsKCk7XG4gIGNvbnN0IHRyID0gbmV3IFRyYW5zZm9ybShub2RlKS5yZXBsYWNlKDAsIG5vZGUuY29udGVudC5zaXplLCBzbGljZSk7XG4gIHJldHVybiB0ci5kb2M7XG59XG5mdW5jdGlvbiBjbGlwQ2VsbHMoeyB3aWR0aCwgaGVpZ2h0LCByb3dzIH0sIG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcbiAgaWYgKHdpZHRoICE9IG5ld1dpZHRoKSB7XG4gICAgY29uc3QgYWRkZWQgPSBbXTtcbiAgICBjb25zdCBuZXdSb3dzID0gW107XG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93cy5sZW5ndGg7IHJvdysrKSB7XG4gICAgICBjb25zdCBmcmFnID0gcm93c1tyb3ddLCBjZWxscyA9IFtdO1xuICAgICAgZm9yIChsZXQgY29sID0gYWRkZWRbcm93XSB8fCAwLCBpID0gMDsgY29sIDwgbmV3V2lkdGg7IGkrKykge1xuICAgICAgICBsZXQgY2VsbCA9IGZyYWcuY2hpbGQoaSAlIGZyYWcuY2hpbGRDb3VudCk7XG4gICAgICAgIGlmIChjb2wgKyBjZWxsLmF0dHJzLmNvbHNwYW4gPiBuZXdXaWR0aClcbiAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZUNoZWNrZWQoXG4gICAgICAgICAgICByZW1vdmVDb2xTcGFuKFxuICAgICAgICAgICAgICBjZWxsLmF0dHJzLFxuICAgICAgICAgICAgICBjZWxsLmF0dHJzLmNvbHNwYW4sXG4gICAgICAgICAgICAgIGNvbCArIGNlbGwuYXR0cnMuY29sc3BhbiAtIG5ld1dpZHRoXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2VsbC5jb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgY29sICs9IGNlbGwuYXR0cnMuY29sc3BhbjtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBjZWxsLmF0dHJzLnJvd3NwYW47IGorKylcbiAgICAgICAgICBhZGRlZFtyb3cgKyBqXSA9IChhZGRlZFtyb3cgKyBqXSB8fCAwKSArIGNlbGwuYXR0cnMuY29sc3BhbjtcbiAgICAgIH1cbiAgICAgIG5ld1Jvd3MucHVzaChGcmFnbWVudDMuZnJvbShjZWxscykpO1xuICAgIH1cbiAgICByb3dzID0gbmV3Um93cztcbiAgICB3aWR0aCA9IG5ld1dpZHRoO1xuICB9XG4gIGlmIChoZWlnaHQgIT0gbmV3SGVpZ2h0KSB7XG4gICAgY29uc3QgbmV3Um93cyA9IFtdO1xuICAgIGZvciAobGV0IHJvdyA9IDAsIGkgPSAwOyByb3cgPCBuZXdIZWlnaHQ7IHJvdysrLCBpKyspIHtcbiAgICAgIGNvbnN0IGNlbGxzID0gW10sIHNvdXJjZSA9IHJvd3NbaSAlIGhlaWdodF07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvdXJjZS5jaGlsZENvdW50OyBqKyspIHtcbiAgICAgICAgbGV0IGNlbGwgPSBzb3VyY2UuY2hpbGQoaik7XG4gICAgICAgIGlmIChyb3cgKyBjZWxsLmF0dHJzLnJvd3NwYW4gPiBuZXdIZWlnaHQpXG4gICAgICAgICAgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGUoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmNlbGwuYXR0cnMsXG4gICAgICAgICAgICAgIHJvd3NwYW46IE1hdGgubWF4KDEsIG5ld0hlaWdodCAtIGNlbGwuYXR0cnMucm93c3BhbilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsLmNvbnRlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuICAgICAgfVxuICAgICAgbmV3Um93cy5wdXNoKEZyYWdtZW50My5mcm9tKGNlbGxzKSk7XG4gICAgfVxuICAgIHJvd3MgPSBuZXdSb3dzO1xuICAgIGhlaWdodCA9IG5ld0hlaWdodDtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCByb3dzIH07XG59XG5mdW5jdGlvbiBncm93VGFibGUodHIsIG1hcCwgdGFibGUsIHN0YXJ0LCB3aWR0aCwgaGVpZ2h0LCBtYXBGcm9tKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHRyLmRvYy50eXBlLnNjaGVtYTtcbiAgY29uc3QgdHlwZXMgPSB0YWJsZU5vZGVUeXBlcyhzY2hlbWEpO1xuICBsZXQgZW1wdHk7XG4gIGxldCBlbXB0eUhlYWQ7XG4gIGlmICh3aWR0aCA+IG1hcC53aWR0aCkge1xuICAgIGZvciAobGV0IHJvdyA9IDAsIHJvd0VuZCA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7IHJvdysrKSB7XG4gICAgICBjb25zdCByb3dOb2RlID0gdGFibGUuY2hpbGQocm93KTtcbiAgICAgIHJvd0VuZCArPSByb3dOb2RlLm5vZGVTaXplO1xuICAgICAgY29uc3QgY2VsbHMgPSBbXTtcbiAgICAgIGxldCBhZGQ7XG4gICAgICBpZiAocm93Tm9kZS5sYXN0Q2hpbGQgPT0gbnVsbCB8fCByb3dOb2RlLmxhc3RDaGlsZC50eXBlID09IHR5cGVzLmNlbGwpXG4gICAgICAgIGFkZCA9IGVtcHR5IHx8IChlbXB0eSA9IHR5cGVzLmNlbGwuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgIGVsc2UgYWRkID0gZW1wdHlIZWFkIHx8IChlbXB0eUhlYWQgPSB0eXBlcy5oZWFkZXJfY2VsbC5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgZm9yIChsZXQgaSA9IG1hcC53aWR0aDsgaSA8IHdpZHRoOyBpKyspIGNlbGxzLnB1c2goYWRkKTtcbiAgICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChyb3dFbmQgLSAxICsgc3RhcnQpLCBjZWxscyk7XG4gICAgfVxuICB9XG4gIGlmIChoZWlnaHQgPiBtYXAuaGVpZ2h0KSB7XG4gICAgY29uc3QgY2VsbHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgc3RhcnQyID0gKG1hcC5oZWlnaHQgLSAxKSAqIG1hcC53aWR0aDsgaSA8IE1hdGgubWF4KG1hcC53aWR0aCwgd2lkdGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IGhlYWRlciA9IGkgPj0gbWFwLndpZHRoID8gZmFsc2UgOiB0YWJsZS5ub2RlQXQobWFwLm1hcFtzdGFydDIgKyBpXSkudHlwZSA9PSB0eXBlcy5oZWFkZXJfY2VsbDtcbiAgICAgIGNlbGxzLnB1c2goXG4gICAgICAgIGhlYWRlciA/IGVtcHR5SGVhZCB8fCAoZW1wdHlIZWFkID0gdHlwZXMuaGVhZGVyX2NlbGwuY3JlYXRlQW5kRmlsbCgpKSA6IGVtcHR5IHx8IChlbXB0eSA9IHR5cGVzLmNlbGwuY3JlYXRlQW5kRmlsbCgpKVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZW1wdHlSb3cgPSB0eXBlcy5yb3cuY3JlYXRlKG51bGwsIEZyYWdtZW50My5mcm9tKGNlbGxzKSksIHJvd3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gbWFwLmhlaWdodDsgaSA8IGhlaWdodDsgaSsrKSByb3dzLnB1c2goZW1wdHlSb3cpO1xuICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChzdGFydCArIHRhYmxlLm5vZGVTaXplIC0gMiksIHJvd3MpO1xuICB9XG4gIHJldHVybiAhIShlbXB0eSB8fCBlbXB0eUhlYWQpO1xufVxuZnVuY3Rpb24gaXNvbGF0ZUhvcml6b250YWwodHIsIG1hcCwgdGFibGUsIHN0YXJ0LCBsZWZ0LCByaWdodCwgdG9wLCBtYXBGcm9tKSB7XG4gIGlmICh0b3AgPT0gMCB8fCB0b3AgPT0gbWFwLmhlaWdodCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgZm9yIChsZXQgY29sID0gbGVmdDsgY29sIDwgcmlnaHQ7IGNvbCsrKSB7XG4gICAgY29uc3QgaW5kZXggPSB0b3AgKiBtYXAud2lkdGggKyBjb2wsIHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgIGlmIChtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSA9PSBwb3MpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgIGNvbnN0IHsgdG9wOiBjZWxsVG9wLCBsZWZ0OiBjZWxsTGVmdCB9ID0gbWFwLmZpbmRDZWxsKHBvcyk7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIHN0YXJ0KSwgbnVsbCwge1xuICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICByb3dzcGFuOiB0b3AgLSBjZWxsVG9wXG4gICAgICB9KTtcbiAgICAgIHRyLmluc2VydChcbiAgICAgICAgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAobWFwLnBvc2l0aW9uQXQodG9wLCBjZWxsTGVmdCwgdGFibGUpKSxcbiAgICAgICAgY2VsbC50eXBlLmNyZWF0ZUFuZEZpbGwoe1xuICAgICAgICAgIC4uLmNlbGwuYXR0cnMsXG4gICAgICAgICAgcm93c3BhbjogY2VsbFRvcCArIGNlbGwuYXR0cnMucm93c3BhbiAtIHRvcFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGNvbCArPSBjZWxsLmF0dHJzLmNvbHNwYW4gLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc29sYXRlVmVydGljYWwodHIsIG1hcCwgdGFibGUsIHN0YXJ0LCB0b3AsIGJvdHRvbSwgbGVmdCwgbWFwRnJvbSkge1xuICBpZiAobGVmdCA9PSAwIHx8IGxlZnQgPT0gbWFwLndpZHRoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGxldCByb3cgPSB0b3A7IHJvdyA8IGJvdHRvbTsgcm93KyspIHtcbiAgICBjb25zdCBpbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGxlZnQsIHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgIGlmIChtYXAubWFwW2luZGV4IC0gMV0gPT0gcG9zKSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICBjb25zdCBjZWxsTGVmdCA9IG1hcC5jb2xDb3VudChwb3MpO1xuICAgICAgY29uc3QgdXBkYXRlUG9zID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgc3RhcnQpO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgdXBkYXRlUG9zLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW1vdmVDb2xTcGFuKFxuICAgICAgICAgIGNlbGwuYXR0cnMsXG4gICAgICAgICAgbGVmdCAtIGNlbGxMZWZ0LFxuICAgICAgICAgIGNlbGwuYXR0cnMuY29sc3BhbiAtIChsZWZ0IC0gY2VsbExlZnQpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0ci5pbnNlcnQoXG4gICAgICAgIHVwZGF0ZVBvcyArIGNlbGwubm9kZVNpemUsXG4gICAgICAgIGNlbGwudHlwZS5jcmVhdGVBbmRGaWxsKFxuICAgICAgICAgIHJlbW92ZUNvbFNwYW4oY2VsbC5hdHRycywgMCwgbGVmdCAtIGNlbGxMZWZ0KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcm93ICs9IGNlbGwuYXR0cnMucm93c3BhbiAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGluc2VydENlbGxzKHN0YXRlLCBkaXNwYXRjaCwgdGFibGVTdGFydCwgcmVjdCwgY2VsbHMpIHtcbiAgbGV0IHRhYmxlID0gdGFibGVTdGFydCA/IHN0YXRlLmRvYy5ub2RlQXQodGFibGVTdGFydCAtIDEpIDogc3RhdGUuZG9jO1xuICBpZiAoIXRhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG4gIH1cbiAgbGV0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGNvbnN0IHsgdG9wLCBsZWZ0IH0gPSByZWN0O1xuICBjb25zdCByaWdodCA9IGxlZnQgKyBjZWxscy53aWR0aCwgYm90dG9tID0gdG9wICsgY2VsbHMuaGVpZ2h0O1xuICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICBsZXQgbWFwRnJvbSA9IDA7XG4gIGZ1bmN0aW9uIHJlY29tcCgpIHtcbiAgICB0YWJsZSA9IHRhYmxlU3RhcnQgPyB0ci5kb2Mubm9kZUF0KHRhYmxlU3RhcnQgLSAxKSA6IHRyLmRvYztcbiAgICBpZiAoIXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0YWJsZSBmb3VuZFwiKTtcbiAgICB9XG4gICAgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBtYXBGcm9tID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgfVxuICBpZiAoZ3Jvd1RhYmxlKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCByaWdodCwgYm90dG9tLCBtYXBGcm9tKSkgcmVjb21wKCk7XG4gIGlmIChpc29sYXRlSG9yaXpvbnRhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgbGVmdCwgcmlnaHQsIHRvcCwgbWFwRnJvbSkpXG4gICAgcmVjb21wKCk7XG4gIGlmIChpc29sYXRlSG9yaXpvbnRhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgbWFwRnJvbSkpXG4gICAgcmVjb21wKCk7XG4gIGlmIChpc29sYXRlVmVydGljYWwodHIsIG1hcCwgdGFibGUsIHRhYmxlU3RhcnQsIHRvcCwgYm90dG9tLCBsZWZ0LCBtYXBGcm9tKSlcbiAgICByZWNvbXAoKTtcbiAgaWYgKGlzb2xhdGVWZXJ0aWNhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgdG9wLCBib3R0b20sIHJpZ2h0LCBtYXBGcm9tKSlcbiAgICByZWNvbXAoKTtcbiAgZm9yIChsZXQgcm93ID0gdG9wOyByb3cgPCBib3R0b207IHJvdysrKSB7XG4gICAgY29uc3QgZnJvbSA9IG1hcC5wb3NpdGlvbkF0KHJvdywgbGVmdCwgdGFibGUpLCB0byA9IG1hcC5wb3NpdGlvbkF0KHJvdywgcmlnaHQsIHRhYmxlKTtcbiAgICB0ci5yZXBsYWNlKFxuICAgICAgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAoZnJvbSArIHRhYmxlU3RhcnQpLFxuICAgICAgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAodG8gKyB0YWJsZVN0YXJ0KSxcbiAgICAgIG5ldyBTbGljZTMoY2VsbHMucm93c1tyb3cgLSB0b3BdLCAwLCAwKVxuICAgICk7XG4gIH1cbiAgcmVjb21wKCk7XG4gIHRyLnNldFNlbGVjdGlvbihcbiAgICBuZXcgQ2VsbFNlbGVjdGlvbihcbiAgICAgIHRyLmRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAucG9zaXRpb25BdCh0b3AsIGxlZnQsIHRhYmxlKSksXG4gICAgICB0ci5kb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLnBvc2l0aW9uQXQoYm90dG9tIC0gMSwgcmlnaHQgLSAxLCB0YWJsZSkpXG4gICAgKVxuICApO1xuICBkaXNwYXRjaCh0cik7XG59XG5cbi8vIHNyYy9pbnB1dC50c1xudmFyIGhhbmRsZUtleURvd24gPSBrZXlkb3duSGFuZGxlcih7XG4gIEFycm93TGVmdDogYXJyb3coXCJob3JpelwiLCAtMSksXG4gIEFycm93UmlnaHQ6IGFycm93KFwiaG9yaXpcIiwgMSksXG4gIEFycm93VXA6IGFycm93KFwidmVydFwiLCAtMSksXG4gIEFycm93RG93bjogYXJyb3coXCJ2ZXJ0XCIsIDEpLFxuICBcIlNoaWZ0LUFycm93TGVmdFwiOiBzaGlmdEFycm93KFwiaG9yaXpcIiwgLTEpLFxuICBcIlNoaWZ0LUFycm93UmlnaHRcIjogc2hpZnRBcnJvdyhcImhvcml6XCIsIDEpLFxuICBcIlNoaWZ0LUFycm93VXBcIjogc2hpZnRBcnJvdyhcInZlcnRcIiwgLTEpLFxuICBcIlNoaWZ0LUFycm93RG93blwiOiBzaGlmdEFycm93KFwidmVydFwiLCAxKSxcbiAgQmFja3NwYWNlOiBkZWxldGVDZWxsU2VsZWN0aW9uLFxuICBcIk1vZC1CYWNrc3BhY2VcIjogZGVsZXRlQ2VsbFNlbGVjdGlvbixcbiAgRGVsZXRlOiBkZWxldGVDZWxsU2VsZWN0aW9uLFxuICBcIk1vZC1EZWxldGVcIjogZGVsZXRlQ2VsbFNlbGVjdGlvblxufSk7XG5mdW5jdGlvbiBtYXliZVNldFNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gsIHNlbGVjdGlvbikge1xuICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhcnJvdyhheGlzLCBkaXIpIHtcbiAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBpZiAoIXZpZXcpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBtYXliZVNldFNlbGVjdGlvbihcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBTZWxlY3Rpb24yLm5lYXIoc2VsLiRoZWFkQ2VsbCwgZGlyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGF4aXMgIT0gXCJob3JpelwiICYmICFzZWwuZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBlbmQgPSBhdEVuZE9mQ2VsbCh2aWV3LCBheGlzLCBkaXIpO1xuICAgIGlmIChlbmQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChheGlzID09IFwiaG9yaXpcIikge1xuICAgICAgcmV0dXJuIG1heWJlU2V0U2VsZWN0aW9uKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIFNlbGVjdGlvbjIubmVhcihzdGF0ZS5kb2MucmVzb2x2ZShzZWwuaGVhZCArIGRpciksIGRpcilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0ICRjZWxsID0gc3RhdGUuZG9jLnJlc29sdmUoZW5kKTtcbiAgICAgIGNvbnN0ICRuZXh0ID0gbmV4dENlbGwoJGNlbGwsIGF4aXMsIGRpcik7XG4gICAgICBsZXQgbmV3U2VsO1xuICAgICAgaWYgKCRuZXh0KSBuZXdTZWwgPSBTZWxlY3Rpb24yLm5lYXIoJG5leHQsIDEpO1xuICAgICAgZWxzZSBpZiAoZGlyIDwgMClcbiAgICAgICAgbmV3U2VsID0gU2VsZWN0aW9uMi5uZWFyKHN0YXRlLmRvYy5yZXNvbHZlKCRjZWxsLmJlZm9yZSgtMSkpLCAtMSk7XG4gICAgICBlbHNlIG5ld1NlbCA9IFNlbGVjdGlvbjIubmVhcihzdGF0ZS5kb2MucmVzb2x2ZSgkY2VsbC5hZnRlcigtMSkpLCAxKTtcbiAgICAgIHJldHVybiBtYXliZVNldFNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gsIG5ld1NlbCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc2hpZnRBcnJvdyhheGlzLCBkaXIpIHtcbiAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBpZiAoIXZpZXcpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGNlbGxTZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pIHtcbiAgICAgIGNlbGxTZWwgPSBzZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVuZCA9IGF0RW5kT2ZDZWxsKHZpZXcsIGF4aXMsIGRpcik7XG4gICAgICBpZiAoZW5kID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGNlbGxTZWwgPSBuZXcgQ2VsbFNlbGVjdGlvbihzdGF0ZS5kb2MucmVzb2x2ZShlbmQpKTtcbiAgICB9XG4gICAgY29uc3QgJGhlYWQgPSBuZXh0Q2VsbChjZWxsU2VsLiRoZWFkQ2VsbCwgYXhpcywgZGlyKTtcbiAgICBpZiAoISRoZWFkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG1heWJlU2V0U2VsZWN0aW9uKFxuICAgICAgc3RhdGUsXG4gICAgICBkaXNwYXRjaCxcbiAgICAgIG5ldyBDZWxsU2VsZWN0aW9uKGNlbGxTZWwuJGFuY2hvckNlbGwsICRoZWFkKVxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVUcmlwbGVDbGljayh2aWV3LCBwb3MpIHtcbiAgY29uc3QgZG9jID0gdmlldy5zdGF0ZS5kb2MsICRjZWxsID0gY2VsbEFyb3VuZChkb2MucmVzb2x2ZShwb3MpKTtcbiAgaWYgKCEkY2VsbCkgcmV0dXJuIGZhbHNlO1xuICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBDZWxsU2VsZWN0aW9uKCRjZWxsKSkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBhc3RlKHZpZXcsIF8sIHNsaWNlKSB7XG4gIGlmICghaXNJblRhYmxlKHZpZXcuc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gIGxldCBjZWxscyA9IHBhc3RlZENlbGxzKHNsaWNlKTtcbiAgY29uc3Qgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgaWYgKCFjZWxscylcbiAgICAgIGNlbGxzID0ge1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICByb3dzOiBbXG4gICAgICAgICAgRnJhZ21lbnQ0LmZyb20oXG4gICAgICAgICAgICBmaXRTbGljZSh0YWJsZU5vZGVUeXBlcyh2aWV3LnN0YXRlLnNjaGVtYSkuY2VsbCwgc2xpY2UpXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIGNvbnN0IHRhYmxlID0gc2VsLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IHN0YXJ0ID0gc2VsLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCByZWN0ID0gVGFibGVNYXAuZ2V0KHRhYmxlKS5yZWN0QmV0d2VlbihcbiAgICAgIHNlbC4kYW5jaG9yQ2VsbC5wb3MgLSBzdGFydCxcbiAgICAgIHNlbC4kaGVhZENlbGwucG9zIC0gc3RhcnRcbiAgICApO1xuICAgIGNlbGxzID0gY2xpcENlbGxzKGNlbGxzLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCByZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcbiAgICBpbnNlcnRDZWxscyh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCBzdGFydCwgcmVjdCwgY2VsbHMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGNlbGxzKSB7XG4gICAgY29uc3QgJGNlbGwgPSBzZWxlY3Rpb25DZWxsKHZpZXcuc3RhdGUpO1xuICAgIGNvbnN0IHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICAgIGluc2VydENlbGxzKFxuICAgICAgdmlldy5zdGF0ZSxcbiAgICAgIHZpZXcuZGlzcGF0Y2gsXG4gICAgICBzdGFydCxcbiAgICAgIFRhYmxlTWFwLmdldCgkY2VsbC5ub2RlKC0xKSkuZmluZENlbGwoJGNlbGwucG9zIC0gc3RhcnQpLFxuICAgICAgY2VsbHNcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKHZpZXcsIHN0YXJ0RXZlbnQpIHtcbiAgdmFyIF9hO1xuICBpZiAoc3RhcnRFdmVudC5jdHJsS2V5IHx8IHN0YXJ0RXZlbnQubWV0YUtleSkgcmV0dXJuO1xuICBjb25zdCBzdGFydERPTUNlbGwgPSBkb21JbkNlbGwodmlldywgc3RhcnRFdmVudC50YXJnZXQpO1xuICBsZXQgJGFuY2hvcjtcbiAgaWYgKHN0YXJ0RXZlbnQuc2hpZnRLZXkgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgc2V0Q2VsbFNlbGVjdGlvbih2aWV3LnN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yQ2VsbCwgc3RhcnRFdmVudCk7XG4gICAgc3RhcnRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2UgaWYgKHN0YXJ0RXZlbnQuc2hpZnRLZXkgJiYgc3RhcnRET01DZWxsICYmICgkYW5jaG9yID0gY2VsbEFyb3VuZCh2aWV3LnN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yKSkgIT0gbnVsbCAmJiAoKF9hID0gY2VsbFVuZGVyTW91c2Uodmlldywgc3RhcnRFdmVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wb3MpICE9ICRhbmNob3IucG9zKSB7XG4gICAgc2V0Q2VsbFNlbGVjdGlvbigkYW5jaG9yLCBzdGFydEV2ZW50KTtcbiAgICBzdGFydEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSBpZiAoIXN0YXJ0RE9NQ2VsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmdW5jdGlvbiBzZXRDZWxsU2VsZWN0aW9uKCRhbmNob3IyLCBldmVudCkge1xuICAgIGxldCAkaGVhZCA9IGNlbGxVbmRlck1vdXNlKHZpZXcsIGV2ZW50KTtcbiAgICBjb25zdCBzdGFydGluZyA9IHRhYmxlRWRpdGluZ0tleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKSA9PSBudWxsO1xuICAgIGlmICghJGhlYWQgfHwgIWluU2FtZVRhYmxlKCRhbmNob3IyLCAkaGVhZCkpIHtcbiAgICAgIGlmIChzdGFydGluZykgJGhlYWQgPSAkYW5jaG9yMjtcbiAgICAgIGVsc2UgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgQ2VsbFNlbGVjdGlvbigkYW5jaG9yMiwgJGhlYWQpO1xuICAgIGlmIChzdGFydGluZyB8fCAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgaWYgKHN0YXJ0aW5nKSB0ci5zZXRNZXRhKHRhYmxlRWRpdGluZ0tleSwgJGFuY2hvcjIucG9zKTtcbiAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wKTtcbiAgICB2aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBzdG9wKTtcbiAgICB2aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICBpZiAodGFibGVFZGl0aW5nS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpICE9IG51bGwpXG4gICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0TWV0YSh0YWJsZUVkaXRpbmdLZXksIC0xKSk7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShfZXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICBjb25zdCBhbmNob3IgPSB0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgbGV0ICRhbmNob3IyO1xuICAgIGlmIChhbmNob3IgIT0gbnVsbCkge1xuICAgICAgJGFuY2hvcjIgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgfSBlbHNlIGlmIChkb21JbkNlbGwodmlldywgZXZlbnQudGFyZ2V0KSAhPSBzdGFydERPTUNlbGwpIHtcbiAgICAgICRhbmNob3IyID0gY2VsbFVuZGVyTW91c2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICBpZiAoISRhbmNob3IyKSByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBpZiAoJGFuY2hvcjIpIHNldENlbGxTZWxlY3Rpb24oJGFuY2hvcjIsIGV2ZW50KTtcbiAgfVxuICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgc3RvcCk7XG4gIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIHN0b3ApO1xuICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbn1cbmZ1bmN0aW9uIGF0RW5kT2ZDZWxsKHZpZXcsIGF4aXMsIGRpcikge1xuICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24zKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgJGhlYWQgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBmb3IgKGxldCBkID0gJGhlYWQuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgIGNvbnN0IHBhcmVudCA9ICRoZWFkLm5vZGUoZCksIGluZGV4ID0gZGlyIDwgMCA/ICRoZWFkLmluZGV4KGQpIDogJGhlYWQuaW5kZXhBZnRlcihkKTtcbiAgICBpZiAoaW5kZXggIT0gKGRpciA8IDAgPyAwIDogcGFyZW50LmNoaWxkQ291bnQpKSByZXR1cm4gbnVsbDtcbiAgICBpZiAocGFyZW50LnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJjZWxsXCIgfHwgcGFyZW50LnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJoZWFkZXJfY2VsbFwiKSB7XG4gICAgICBjb25zdCBjZWxsUG9zID0gJGhlYWQuYmVmb3JlKGQpO1xuICAgICAgY29uc3QgZGlyU3RyID0gYXhpcyA9PSBcInZlcnRcIiA/IGRpciA+IDAgPyBcImRvd25cIiA6IFwidXBcIiA6IGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICAgIHJldHVybiB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpclN0cikgPyBjZWxsUG9zIDogbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkb21JbkNlbGwodmlldywgZG9tKSB7XG4gIGZvciAoOyBkb20gJiYgZG9tICE9IHZpZXcuZG9tOyBkb20gPSBkb20ucGFyZW50Tm9kZSkge1xuICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJURFwiIHx8IGRvbS5ub2RlTmFtZSA9PSBcIlRIXCIpIHtcbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2VsbFVuZGVyTW91c2UodmlldywgZXZlbnQpIHtcbiAgY29uc3QgbW91c2VQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHtcbiAgICBsZWZ0OiBldmVudC5jbGllbnRYLFxuICAgIHRvcDogZXZlbnQuY2xpZW50WVxuICB9KTtcbiAgaWYgKCFtb3VzZVBvcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtb3VzZVBvcyA/IGNlbGxBcm91bmQodmlldy5zdGF0ZS5kb2MucmVzb2x2ZShtb3VzZVBvcy5wb3MpKSA6IG51bGw7XG59XG5cbi8vIHNyYy9jb2x1bW5yZXNpemluZy50c1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MyB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuaW1wb3J0IHtcbiAgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMixcbiAgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MlxufSBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuXG4vLyBzcmMvdGFibGV2aWV3LnRzXG52YXIgVGFibGVWaWV3ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBkZWZhdWx0Q2VsbE1pbldpZHRoKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLmRlZmF1bHRDZWxsTWluV2lkdGggPSBkZWZhdWx0Q2VsbE1pbldpZHRoO1xuICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcInRhYmxlV3JhcHBlclwiO1xuICAgIHRoaXMudGFibGUgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGFibGVcIikpO1xuICAgIHRoaXMudGFibGUuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICBcIi0tZGVmYXVsdC1jZWxsLW1pbi13aWR0aFwiLFxuICAgICAgYCR7ZGVmYXVsdENlbGxNaW5XaWR0aH1weGBcbiAgICApO1xuICAgIHRoaXMuY29sZ3JvdXAgPSB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb2xncm91cFwiKSk7XG4gICAgdXBkYXRlQ29sdW1uc09uUmVzaXplKG5vZGUsIHRoaXMuY29sZ3JvdXAsIHRoaXMudGFibGUsIGRlZmF1bHRDZWxsTWluV2lkdGgpO1xuICAgIHRoaXMuY29udGVudERPTSA9IHRoaXMudGFibGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKTtcbiAgfVxuICB1cGRhdGUobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT0gdGhpcy5ub2RlLnR5cGUpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHVwZGF0ZUNvbHVtbnNPblJlc2l6ZShcbiAgICAgIG5vZGUsXG4gICAgICB0aGlzLmNvbGdyb3VwLFxuICAgICAgdGhpcy50YWJsZSxcbiAgICAgIHRoaXMuZGVmYXVsdENlbGxNaW5XaWR0aFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWdub3JlTXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmIChyZWNvcmQudGFyZ2V0ID09IHRoaXMudGFibGUgfHwgdGhpcy5jb2xncm91cC5jb250YWlucyhyZWNvcmQudGFyZ2V0KSk7XG4gIH1cbn07XG5mdW5jdGlvbiB1cGRhdGVDb2x1bW5zT25SZXNpemUobm9kZSwgY29sZ3JvdXAsIHRhYmxlLCBkZWZhdWx0Q2VsbE1pbldpZHRoLCBvdmVycmlkZUNvbCwgb3ZlcnJpZGVWYWx1ZSkge1xuICB2YXIgX2E7XG4gIGxldCB0b3RhbFdpZHRoID0gMDtcbiAgbGV0IGZpeGVkV2lkdGggPSB0cnVlO1xuICBsZXQgbmV4dERPTSA9IGNvbGdyb3VwLmZpcnN0Q2hpbGQ7XG4gIGNvbnN0IHJvdyA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgaWYgKCFyb3cpIHJldHVybjtcbiAgZm9yIChsZXQgaSA9IDAsIGNvbCA9IDA7IGkgPCByb3cuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgeyBjb2xzcGFuLCBjb2x3aWR0aCB9ID0gcm93LmNoaWxkKGkpLmF0dHJzO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sc3BhbjsgaisrLCBjb2wrKykge1xuICAgICAgY29uc3QgaGFzV2lkdGggPSBvdmVycmlkZUNvbCA9PSBjb2wgPyBvdmVycmlkZVZhbHVlIDogY29sd2lkdGggJiYgY29sd2lkdGhbal07XG4gICAgICBjb25zdCBjc3NXaWR0aCA9IGhhc1dpZHRoID8gaGFzV2lkdGggKyBcInB4XCIgOiBcIlwiO1xuICAgICAgdG90YWxXaWR0aCArPSBoYXNXaWR0aCB8fCBkZWZhdWx0Q2VsbE1pbldpZHRoO1xuICAgICAgaWYgKCFoYXNXaWR0aCkgZml4ZWRXaWR0aCA9IGZhbHNlO1xuICAgICAgaWYgKCFuZXh0RE9NKSB7XG4gICAgICAgIGNvbnN0IGNvbDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29sXCIpO1xuICAgICAgICBjb2wyLnN0eWxlLndpZHRoID0gY3NzV2lkdGg7XG4gICAgICAgIGNvbGdyb3VwLmFwcGVuZENoaWxkKGNvbDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5leHRET00uc3R5bGUud2lkdGggIT0gY3NzV2lkdGgpIHtcbiAgICAgICAgICBuZXh0RE9NLnN0eWxlLndpZHRoID0gY3NzV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dERPTSA9IG5leHRET00ubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdoaWxlIChuZXh0RE9NKSB7XG4gICAgY29uc3QgYWZ0ZXIgPSBuZXh0RE9NLm5leHRTaWJsaW5nO1xuICAgIChfYSA9IG5leHRET00ucGFyZW50Tm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKG5leHRET00pO1xuICAgIG5leHRET00gPSBhZnRlcjtcbiAgfVxuICBpZiAoZml4ZWRXaWR0aCkge1xuICAgIHRhYmxlLnN0eWxlLndpZHRoID0gdG90YWxXaWR0aCArIFwicHhcIjtcbiAgICB0YWJsZS5zdHlsZS5taW5XaWR0aCA9IFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgdGFibGUuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgIHRhYmxlLnN0eWxlLm1pbldpZHRoID0gdG90YWxXaWR0aCArIFwicHhcIjtcbiAgfVxufVxuXG4vLyBzcmMvY29sdW1ucmVzaXppbmcudHNcbnZhciBjb2x1bW5SZXNpemluZ1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkzKFxuICBcInRhYmxlQ29sdW1uUmVzaXppbmdcIlxuKTtcbmZ1bmN0aW9uIGNvbHVtblJlc2l6aW5nKHtcbiAgaGFuZGxlV2lkdGggPSA1LFxuICBjZWxsTWluV2lkdGggPSAyNSxcbiAgZGVmYXVsdENlbGxNaW5XaWR0aCA9IDEwMCxcbiAgVmlldyA9IFRhYmxlVmlldyxcbiAgbGFzdENvbHVtblJlc2l6YWJsZSA9IHRydWVcbn0gPSB7fSkge1xuICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LFxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KF8sIHN0YXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG5vZGVWaWV3cyA9IChfYiA9IChfYSA9IHBsdWdpbi5zcGVjKSA9PSBudWxsID8gdm9pZCAwIDogX2EucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5ub2RlVmlld3M7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSkudGFibGUubmFtZTtcbiAgICAgICAgaWYgKFZpZXcgJiYgbm9kZVZpZXdzKSB7XG4gICAgICAgICAgbm9kZVZpZXdzW3RhYmxlTmFtZV0gPSAobm9kZSwgdmlldykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3KG5vZGUsIGRlZmF1bHRDZWxsTWluV2lkdGgsIHZpZXcpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVTdGF0ZSgtMSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgIHJldHVybiBwcmV2LmFwcGx5KHRyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBhdHRyaWJ1dGVzOiAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBwbHVnaW5TdGF0ZSAmJiBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUgPiAtMSA/IHsgY2xhc3M6IFwicmVzaXplLWN1cnNvclwiIH0gOiB7fTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgbW91c2Vtb3ZlOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIGhhbmRsZVdpZHRoLCBsYXN0Q29sdW1uUmVzaXphYmxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VsZWF2ZTogKHZpZXcpID0+IHtcbiAgICAgICAgICBoYW5kbGVNb3VzZUxlYXZlKHZpZXcpO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWRvd246ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgIGhhbmRsZU1vdXNlRG93bjIodmlldywgZXZlbnQsIGNlbGxNaW5XaWR0aCwgZGVmYXVsdENlbGxNaW5XaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICBpZiAocGx1Z2luU3RhdGUgJiYgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlID4gLTEpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRGVjb3JhdGlvbnMoc3RhdGUsIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBub2RlVmlld3M6IHt9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBsdWdpbjtcbn1cbnZhciBSZXNpemVTdGF0ZSA9IGNsYXNzIF9SZXNpemVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGFjdGl2ZUhhbmRsZSwgZHJhZ2dpbmcpIHtcbiAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9IGFjdGl2ZUhhbmRsZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmc7XG4gIH1cbiAgYXBwbHkodHIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXM7XG4gICAgY29uc3QgYWN0aW9uID0gdHIuZ2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSk7XG4gICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24uc2V0SGFuZGxlICE9IG51bGwpXG4gICAgICByZXR1cm4gbmV3IF9SZXNpemVTdGF0ZShhY3Rpb24uc2V0SGFuZGxlLCBmYWxzZSk7XG4gICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24uc2V0RHJhZ2dpbmcgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBuZXcgX1Jlc2l6ZVN0YXRlKHN0YXRlLmFjdGl2ZUhhbmRsZSwgYWN0aW9uLnNldERyYWdnaW5nKTtcbiAgICBpZiAoc3RhdGUuYWN0aXZlSGFuZGxlID4gLTEgJiYgdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgbGV0IGhhbmRsZSA9IHRyLm1hcHBpbmcubWFwKHN0YXRlLmFjdGl2ZUhhbmRsZSwgLTEpO1xuICAgICAgaWYgKCFwb2ludHNBdENlbGwodHIuZG9jLnJlc29sdmUoaGFuZGxlKSkpIHtcbiAgICAgICAgaGFuZGxlID0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IF9SZXNpemVTdGF0ZShoYW5kbGUsIHN0YXRlLmRyYWdnaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xuZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCBoYW5kbGVXaWR0aCwgbGFzdENvbHVtblJlc2l6YWJsZSkge1xuICBpZiAoIXZpZXcuZWRpdGFibGUpIHJldHVybjtcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgaWYgKCFwbHVnaW5TdGF0ZSkgcmV0dXJuO1xuICBpZiAoIXBsdWdpblN0YXRlLmRyYWdnaW5nKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9tQ2VsbEFyb3VuZChldmVudC50YXJnZXQpO1xuICAgIGxldCBjZWxsID0gLTE7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKGV2ZW50LmNsaWVudFggLSBsZWZ0IDw9IGhhbmRsZVdpZHRoKVxuICAgICAgICBjZWxsID0gZWRnZUNlbGwodmlldywgZXZlbnQsIFwibGVmdFwiLCBoYW5kbGVXaWR0aCk7XG4gICAgICBlbHNlIGlmIChyaWdodCAtIGV2ZW50LmNsaWVudFggPD0gaGFuZGxlV2lkdGgpXG4gICAgICAgIGNlbGwgPSBlZGdlQ2VsbCh2aWV3LCBldmVudCwgXCJyaWdodFwiLCBoYW5kbGVXaWR0aCk7XG4gICAgfVxuICAgIGlmIChjZWxsICE9IHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSkge1xuICAgICAgaWYgKCFsYXN0Q29sdW1uUmVzaXphYmxlICYmIGNlbGwgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0ICRjZWxsID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShjZWxsKTtcbiAgICAgICAgY29uc3QgdGFibGUgPSAkY2VsbC5ub2RlKC0xKTtcbiAgICAgICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICAgICAgY29uc3QgdGFibGVTdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcbiAgICAgICAgY29uc3QgY29sID0gbWFwLmNvbENvdW50KCRjZWxsLnBvcyAtIHRhYmxlU3RhcnQpICsgJGNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW4gLSAxO1xuICAgICAgICBpZiAoY29sID09IG1hcC53aWR0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZUhhbmRsZSh2aWV3LCBjZWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUodmlldykge1xuICBpZiAoIXZpZXcuZWRpdGFibGUpIHJldHVybjtcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgaWYgKHBsdWdpblN0YXRlICYmIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xICYmICFwbHVnaW5TdGF0ZS5kcmFnZ2luZylcbiAgICB1cGRhdGVIYW5kbGUodmlldywgLTEpO1xufVxuZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duMih2aWV3LCBldmVudCwgY2VsbE1pbldpZHRoLCBkZWZhdWx0Q2VsbE1pbldpZHRoKSB7XG4gIHZhciBfYTtcbiAgaWYgKCF2aWV3LmVkaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHdpbiA9IChfYSA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpICE9IG51bGwgPyBfYSA6IHdpbmRvdztcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgaWYgKCFwbHVnaW5TdGF0ZSB8fCBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUgPT0gLTEgfHwgcGx1Z2luU3RhdGUuZHJhZ2dpbmcpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBjZWxsID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSk7XG4gIGNvbnN0IHdpZHRoID0gY3VycmVudENvbFdpZHRoKHZpZXcsIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSwgY2VsbC5hdHRycyk7XG4gIHZpZXcuZGlzcGF0Y2goXG4gICAgdmlldy5zdGF0ZS50ci5zZXRNZXRhKGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LCB7XG4gICAgICBzZXREcmFnZ2luZzogeyBzdGFydFg6IGV2ZW50LmNsaWVudFgsIHN0YXJ0V2lkdGg6IHdpZHRoIH1cbiAgICB9KVxuICApO1xuICBmdW5jdGlvbiBmaW5pc2goZXZlbnQyKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZpbmlzaCk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgY29uc3QgcGx1Z2luU3RhdGUyID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgaWYgKHBsdWdpblN0YXRlMiA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2luU3RhdGUyLmRyYWdnaW5nKSB7XG4gICAgICB1cGRhdGVDb2x1bW5XaWR0aChcbiAgICAgICAgdmlldyxcbiAgICAgICAgcGx1Z2luU3RhdGUyLmFjdGl2ZUhhbmRsZSxcbiAgICAgICAgZHJhZ2dlZFdpZHRoKHBsdWdpblN0YXRlMi5kcmFnZ2luZywgZXZlbnQyLCBjZWxsTWluV2lkdGgpXG4gICAgICApO1xuICAgICAgdmlldy5kaXNwYXRjaChcbiAgICAgICAgdmlldy5zdGF0ZS50ci5zZXRNZXRhKGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LCB7IHNldERyYWdnaW5nOiBudWxsIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtb3ZlKGV2ZW50Mikge1xuICAgIGlmICghZXZlbnQyLndoaWNoKSByZXR1cm4gZmluaXNoKGV2ZW50Mik7XG4gICAgY29uc3QgcGx1Z2luU3RhdGUyID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgaWYgKCFwbHVnaW5TdGF0ZTIpIHJldHVybjtcbiAgICBpZiAocGx1Z2luU3RhdGUyLmRyYWdnaW5nKSB7XG4gICAgICBjb25zdCBkcmFnZ2VkID0gZHJhZ2dlZFdpZHRoKHBsdWdpblN0YXRlMi5kcmFnZ2luZywgZXZlbnQyLCBjZWxsTWluV2lkdGgpO1xuICAgICAgZGlzcGxheUNvbHVtbldpZHRoKFxuICAgICAgICB2aWV3LFxuICAgICAgICBwbHVnaW5TdGF0ZTIuYWN0aXZlSGFuZGxlLFxuICAgICAgICBkcmFnZ2VkLFxuICAgICAgICBkZWZhdWx0Q2VsbE1pbldpZHRoXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBkaXNwbGF5Q29sdW1uV2lkdGgoXG4gICAgdmlldyxcbiAgICBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUsXG4gICAgd2lkdGgsXG4gICAgZGVmYXVsdENlbGxNaW5XaWR0aFxuICApO1xuICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmluaXNoKTtcbiAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3VycmVudENvbFdpZHRoKHZpZXcsIGNlbGxQb3MsIHsgY29sc3BhbiwgY29sd2lkdGggfSkge1xuICBjb25zdCB3aWR0aCA9IGNvbHdpZHRoICYmIGNvbHdpZHRoW2NvbHdpZHRoLmxlbmd0aCAtIDFdO1xuICBpZiAod2lkdGgpIHJldHVybiB3aWR0aDtcbiAgY29uc3QgZG9tID0gdmlldy5kb21BdFBvcyhjZWxsUG9zKTtcbiAgY29uc3Qgbm9kZSA9IGRvbS5ub2RlLmNoaWxkTm9kZXNbZG9tLm9mZnNldF07XG4gIGxldCBkb21XaWR0aCA9IG5vZGUub2Zmc2V0V2lkdGgsIHBhcnRzID0gY29sc3BhbjtcbiAgaWYgKGNvbHdpZHRoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzcGFuOyBpKyspXG4gICAgICBpZiAoY29sd2lkdGhbaV0pIHtcbiAgICAgICAgZG9tV2lkdGggLT0gY29sd2lkdGhbaV07XG4gICAgICAgIHBhcnRzLS07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGRvbVdpZHRoIC8gcGFydHM7XG59XG5mdW5jdGlvbiBkb21DZWxsQXJvdW5kKHRhcmdldCkge1xuICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC5ub2RlTmFtZSAhPSBcIlREXCIgJiYgdGFyZ2V0Lm5vZGVOYW1lICE9IFwiVEhcIilcbiAgICB0YXJnZXQgPSB0YXJnZXQuY2xhc3NMaXN0ICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJQcm9zZU1pcnJvclwiKSA/IG51bGwgOiB0YXJnZXQucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGVkZ2VDZWxsKHZpZXcsIGV2ZW50LCBzaWRlLCBoYW5kbGVXaWR0aCkge1xuICBjb25zdCBvZmZzZXQgPSBzaWRlID09IFwicmlnaHRcIiA/IC1oYW5kbGVXaWR0aCA6IGhhbmRsZVdpZHRoO1xuICBjb25zdCBmb3VuZCA9IHZpZXcucG9zQXRDb29yZHMoe1xuICAgIGxlZnQ6IGV2ZW50LmNsaWVudFggKyBvZmZzZXQsXG4gICAgdG9wOiBldmVudC5jbGllbnRZXG4gIH0pO1xuICBpZiAoIWZvdW5kKSByZXR1cm4gLTE7XG4gIGNvbnN0IHsgcG9zIH0gPSBmb3VuZDtcbiAgY29uc3QgJGNlbGwgPSBjZWxsQXJvdW5kKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKSk7XG4gIGlmICghJGNlbGwpIHJldHVybiAtMTtcbiAgaWYgKHNpZGUgPT0gXCJyaWdodFwiKSByZXR1cm4gJGNlbGwucG9zO1xuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQoJGNlbGwubm9kZSgtMSkpLCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcbiAgY29uc3QgaW5kZXggPSBtYXAubWFwLmluZGV4T2YoJGNlbGwucG9zIC0gc3RhcnQpO1xuICByZXR1cm4gaW5kZXggJSBtYXAud2lkdGggPT0gMCA/IC0xIDogc3RhcnQgKyBtYXAubWFwW2luZGV4IC0gMV07XG59XG5mdW5jdGlvbiBkcmFnZ2VkV2lkdGgoZHJhZ2dpbmcsIGV2ZW50LCByZXNpemVNaW5XaWR0aCkge1xuICBjb25zdCBvZmZzZXQgPSBldmVudC5jbGllbnRYIC0gZHJhZ2dpbmcuc3RhcnRYO1xuICByZXR1cm4gTWF0aC5tYXgocmVzaXplTWluV2lkdGgsIGRyYWdnaW5nLnN0YXJ0V2lkdGggKyBvZmZzZXQpO1xufVxuZnVuY3Rpb24gdXBkYXRlSGFuZGxlKHZpZXcsIHZhbHVlKSB7XG4gIHZpZXcuZGlzcGF0Y2goXG4gICAgdmlldy5zdGF0ZS50ci5zZXRNZXRhKGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LCB7IHNldEhhbmRsZTogdmFsdWUgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbHVtbldpZHRoKHZpZXcsIGNlbGwsIHdpZHRoKSB7XG4gIGNvbnN0ICRjZWxsID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShjZWxsKTtcbiAgY29uc3QgdGFibGUgPSAkY2VsbC5ub2RlKC0xKSwgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKSwgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gIGNvbnN0IGNvbCA9IG1hcC5jb2xDb3VudCgkY2VsbC5wb3MgLSBzdGFydCkgKyAkY2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbiAtIDE7XG4gIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCBtYXBJbmRleCA9IHJvdyAqIG1hcC53aWR0aCArIGNvbDtcbiAgICBpZiAocm93ICYmIG1hcC5tYXBbbWFwSW5kZXhdID09IG1hcC5tYXBbbWFwSW5kZXggLSBtYXAud2lkdGhdKSBjb250aW51ZTtcbiAgICBjb25zdCBwb3MgPSBtYXAubWFwW21hcEluZGV4XTtcbiAgICBjb25zdCBhdHRycyA9IHRhYmxlLm5vZGVBdChwb3MpLmF0dHJzO1xuICAgIGNvbnN0IGluZGV4ID0gYXR0cnMuY29sc3BhbiA9PSAxID8gMCA6IGNvbCAtIG1hcC5jb2xDb3VudChwb3MpO1xuICAgIGlmIChhdHRycy5jb2x3aWR0aCAmJiBhdHRycy5jb2x3aWR0aFtpbmRleF0gPT0gd2lkdGgpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGNvbHdpZHRoID0gYXR0cnMuY29sd2lkdGggPyBhdHRycy5jb2x3aWR0aC5zbGljZSgpIDogemVyb2VzKGF0dHJzLmNvbHNwYW4pO1xuICAgIGNvbHdpZHRoW2luZGV4XSA9IHdpZHRoO1xuICAgIHRyLnNldE5vZGVNYXJrdXAoc3RhcnQgKyBwb3MsIG51bGwsIHsgLi4uYXR0cnMsIGNvbHdpZHRoIH0pO1xuICB9XG4gIGlmICh0ci5kb2NDaGFuZ2VkKSB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIGRpc3BsYXlDb2x1bW5XaWR0aCh2aWV3LCBjZWxsLCB3aWR0aCwgZGVmYXVsdENlbGxNaW5XaWR0aCkge1xuICBjb25zdCAkY2VsbCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG4gIGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSksIHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICBjb25zdCBjb2wgPSBUYWJsZU1hcC5nZXQodGFibGUpLmNvbENvdW50KCRjZWxsLnBvcyAtIHN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcbiAgbGV0IGRvbSA9IHZpZXcuZG9tQXRQb3MoJGNlbGwuc3RhcnQoLTEpKS5ub2RlO1xuICB3aGlsZSAoZG9tICYmIGRvbS5ub2RlTmFtZSAhPSBcIlRBQkxFXCIpIHtcbiAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgfVxuICBpZiAoIWRvbSkgcmV0dXJuO1xuICB1cGRhdGVDb2x1bW5zT25SZXNpemUoXG4gICAgdGFibGUsXG4gICAgZG9tLmZpcnN0Q2hpbGQsXG4gICAgZG9tLFxuICAgIGRlZmF1bHRDZWxsTWluV2lkdGgsXG4gICAgY29sLFxuICAgIHdpZHRoXG4gICk7XG59XG5mdW5jdGlvbiB6ZXJvZXMobikge1xuICByZXR1cm4gQXJyYXkobikuZmlsbCgwKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURlY29yYXRpb25zKHN0YXRlLCBjZWxsKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgY29uc3QgJGNlbGwgPSBzdGF0ZS5kb2MucmVzb2x2ZShjZWxsKTtcbiAgY29uc3QgdGFibGUgPSAkY2VsbC5ub2RlKC0xKTtcbiAgaWYgKCF0YWJsZSkge1xuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0Mi5lbXB0eTtcbiAgfVxuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICBjb25zdCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcbiAgY29uc3QgY29sID0gbWFwLmNvbENvdW50KCRjZWxsLnBvcyAtIHN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbCArIHJvdyAqIG1hcC53aWR0aDtcbiAgICBpZiAoKGNvbCA9PSBtYXAud2lkdGggLSAxIHx8IG1hcC5tYXBbaW5kZXhdICE9IG1hcC5tYXBbaW5kZXggKyAxXSkgJiYgKHJvdyA9PSAwIHx8IG1hcC5tYXBbaW5kZXhdICE9IG1hcC5tYXBbaW5kZXggLSBtYXAud2lkdGhdKSkge1xuICAgICAgY29uc3QgY2VsbFBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgICAgY29uc3QgcG9zID0gc3RhcnQgKyBjZWxsUG9zICsgdGFibGUubm9kZUF0KGNlbGxQb3MpLm5vZGVTaXplIC0gMTtcbiAgICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkb20uY2xhc3NOYW1lID0gXCJjb2x1bW4tcmVzaXplLWhhbmRsZVwiO1xuICAgICAgaWYgKChfYSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRyYWdnaW5nKSB7XG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goXG4gICAgICAgICAgRGVjb3JhdGlvbjIubm9kZShcbiAgICAgICAgICAgIHN0YXJ0ICsgY2VsbFBvcyxcbiAgICAgICAgICAgIHN0YXJ0ICsgY2VsbFBvcyArIHRhYmxlLm5vZGVBdChjZWxsUG9zKS5ub2RlU2l6ZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3M6IFwiY29sdW1uLXJlc2l6ZS1kcmFnZ2luZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVjb3JhdGlvbnMucHVzaChEZWNvcmF0aW9uMi53aWRnZXQocG9zLCBkb20pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIERlY29yYXRpb25TZXQyLmNyZWF0ZShzdGF0ZS5kb2MsIGRlY29yYXRpb25zKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiB0YWJsZUVkaXRpbmcoe1xuICBhbGxvd1RhYmxlTm9kZVNlbGVjdGlvbiA9IGZhbHNlXG59ID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4yKHtcbiAgICBrZXk6IHRhYmxlRWRpdGluZ0tleSxcbiAgICAvLyBUaGlzIHBpZWNlIG9mIHN0YXRlIGlzIHVzZWQgdG8gcmVtZW1iZXIgd2hlbiBhIG1vdXNlLWRyYWdcbiAgICAvLyBjZWxsLXNlbGVjdGlvbiBpcyBoYXBwZW5pbmcsIHNvIHRoYXQgaXQgY2FuIGNvbnRpbnVlIGV2ZW4gYXNcbiAgICAvLyB0cmFuc2FjdGlvbnMgKHdoaWNoIG1pZ2h0IG1vdmUgaXRzIGFuY2hvciBjZWxsKSBjb21lIGluLlxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBhcHBseSh0ciwgY3VyKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHRyLmdldE1ldGEodGFibGVFZGl0aW5nS2V5KTtcbiAgICAgICAgaWYgKHNldCAhPSBudWxsKSByZXR1cm4gc2V0ID09IC0xID8gbnVsbCA6IHNldDtcbiAgICAgICAgaWYgKGN1ciA9PSBudWxsIHx8ICF0ci5kb2NDaGFuZ2VkKSByZXR1cm4gY3VyO1xuICAgICAgICBjb25zdCB7IGRlbGV0ZWQsIHBvcyB9ID0gdHIubWFwcGluZy5tYXBSZXN1bHQoY3VyKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBudWxsIDogcG9zO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGRlY29yYXRpb25zOiBkcmF3Q2VsbFNlbGVjdGlvbixcbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBtb3VzZWRvd246IGhhbmRsZU1vdXNlRG93blxuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNlbGVjdGlvbkJldHdlZW4odmlldykge1xuICAgICAgICByZXR1cm4gdGFibGVFZGl0aW5nS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpICE9IG51bGwgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbiA6IG51bGw7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVHJpcGxlQ2xpY2ssXG4gICAgICBoYW5kbGVLZXlEb3duLFxuICAgICAgaGFuZGxlUGFzdGVcbiAgICB9LFxuICAgIGFwcGVuZFRyYW5zYWN0aW9uKF8sIG9sZFN0YXRlLCBzdGF0ZSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGZpeFRhYmxlcyhzdGF0ZSwgb2xkU3RhdGUpLFxuICAgICAgICBhbGxvd1RhYmxlTm9kZVNlbGVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgQ2VsbEJvb2ttYXJrLFxuICBDZWxsU2VsZWN0aW9uLFxuICBSZXNpemVTdGF0ZSxcbiAgVGFibGVNYXAsXG4gIFRhYmxlVmlldyxcbiAgY2xpcENlbGxzIGFzIF9fY2xpcENlbGxzLFxuICBpbnNlcnRDZWxscyBhcyBfX2luc2VydENlbGxzLFxuICBwYXN0ZWRDZWxscyBhcyBfX3Bhc3RlZENlbGxzLFxuICBhZGRDb2xTcGFuLFxuICBhZGRDb2x1bW4sXG4gIGFkZENvbHVtbkFmdGVyLFxuICBhZGRDb2x1bW5CZWZvcmUsXG4gIGFkZFJvdyxcbiAgYWRkUm93QWZ0ZXIsXG4gIGFkZFJvd0JlZm9yZSxcbiAgY2VsbEFyb3VuZCxcbiAgY2VsbE5lYXIsXG4gIGNvbENvdW50LFxuICBjb2x1bW5Jc0hlYWRlcixcbiAgY29sdW1uUmVzaXppbmcsXG4gIGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LFxuICBkZWxldGVDZWxsU2VsZWN0aW9uLFxuICBkZWxldGVDb2x1bW4sXG4gIGRlbGV0ZVJvdyxcbiAgZGVsZXRlVGFibGUsXG4gIGZpbmRDZWxsLFxuICBmaXhUYWJsZXMsXG4gIGZpeFRhYmxlc0tleSxcbiAgZ29Ub05leHRDZWxsLFxuICBoYW5kbGVQYXN0ZSxcbiAgaW5TYW1lVGFibGUsXG4gIGlzSW5UYWJsZSxcbiAgbWVyZ2VDZWxscyxcbiAgbW92ZUNlbGxGb3J3YXJkLFxuICBuZXh0Q2VsbCxcbiAgcG9pbnRzQXRDZWxsLFxuICByZW1vdmVDb2xTcGFuLFxuICByZW1vdmVDb2x1bW4sXG4gIHJlbW92ZVJvdyxcbiAgcm93SXNIZWFkZXIsXG4gIHNlbGVjdGVkUmVjdCxcbiAgc2VsZWN0aW9uQ2VsbCxcbiAgc2V0Q2VsbEF0dHIsXG4gIHNwbGl0Q2VsbCxcbiAgc3BsaXRDZWxsV2l0aFR5cGUsXG4gIHRhYmxlRWRpdGluZyxcbiAgdGFibGVFZGl0aW5nS2V5LFxuICB0YWJsZU5vZGVUeXBlcyxcbiAgdGFibGVOb2RlcyxcbiAgdG9nZ2xlSGVhZGVyLFxuICB0b2dnbGVIZWFkZXJDZWxsLFxuICB0b2dnbGVIZWFkZXJDb2x1bW4sXG4gIHRvZ2dsZUhlYWRlclJvdyxcbiAgdXBkYXRlQ29sdW1uc09uUmVzaXplXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-tables/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rope-sequence/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RopeSequence);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3BlLXNlcXVlbmNlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVSxvQkFBb0IsVUFBVTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IsUUFBUSw4Q0FBOEM7QUFDdEQ7O0FBRUE7QUFDQSwyQkFBMkIsU0FBUztBQUNwQyxRQUFRLDhDQUE4QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsZ0RBQWdEOztBQUVoRCwrQ0FBK0M7O0FBRS9DOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSx5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsWUFBWSxFQUFDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xccm9wZS1zZXF1ZW5jZVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEdPT0RfTEVBRl9TSVpFID0gMjAwO1xuXG4vLyA6OiBjbGFzczxUPiBBIHJvcGUgc2VxdWVuY2UgaXMgYSBwZXJzaXN0ZW50IHNlcXVlbmNlIGRhdGEgc3RydWN0dXJlXG4vLyB0aGF0IHN1cHBvcnRzIGFwcGVuZGluZywgcHJlcGVuZGluZywgYW5kIHNsaWNpbmcgd2l0aG91dCBkb2luZyBhXG4vLyBmdWxsIGNvcHkuIEl0IGlzIHJlcHJlc2VudGVkIGFzIGEgbW9zdGx5LWJhbGFuY2VkIHRyZWUuXG52YXIgUm9wZVNlcXVlbmNlID0gZnVuY3Rpb24gUm9wZVNlcXVlbmNlICgpIHt9O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICBvdGhlciA9IFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKTtcblxuICByZXR1cm4gKCF0aGlzLmxlbmd0aCAmJiBvdGhlcikgfHxcbiAgICAob3RoZXIubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgdGhpcy5sZWFmQXBwZW5kKG90aGVyKSkgfHxcbiAgICAodGhpcy5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiBvdGhlci5sZWFmUHJlcGVuZCh0aGlzKSkgfHxcbiAgICB0aGlzLmFwcGVuZElubmVyKG90aGVyKVxufTtcblxuLy8gOjogKHVuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+Pikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gUHJlcGVuZCBhbiBhcnJheSBvciBvdGhlciByb3BlIHRvIHRoaXMgb25lLCByZXR1cm5pbmcgYSBuZXcgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKS5hcHBlbmQodGhpcylcbn07XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlcikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXBlc2VudGluZyBhIHN1Yi1zZXF1ZW5jZSBvZiB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tID49IHRvKSB7IHJldHVybiBSb3BlU2VxdWVuY2UuZW1wdHkgfVxuICByZXR1cm4gdGhpcy5zbGljZUlubmVyKE1hdGgubWF4KDAsIGZyb20pLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pKVxufTtcblxuLy8gOjogKG51bWJlcikg4oaSIFRcbi8vIFJldHJpZXZlIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQgfVxuICByZXR1cm4gdGhpcy5nZXRJbm5lcihpKVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSDihpIgP2Jvb2wsID9udW1iZXIsID9udW1iZXIpXG4vLyBDYWxsIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGJldHdlZW4gdGhlIGdpdmVuXG4vLyBpbmRpY2VzLiBUaGlzIHRlbmRzIHRvIGJlIG1vcmUgZWZmaWNpZW50IHRoYW4gbG9vcGluZyBvdmVyIHRoZVxuLy8gaW5kaWNlcyBhbmQgY2FsbGluZyBgZ2V0YCwgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgdG8gZGVzY2VuZCB0aGVcbi8vIHRyZWUgZm9yIGV2ZXJ5IGVsZW1lbnQuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA8PSB0bylcbiAgICB7IHRoaXMuZm9yRWFjaElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSDihpIgVSwgP251bWJlciwgP251bWJlcikg4oaSIFtVXVxuLy8gTWFwIHRoZSBnaXZlbiBmdW5jdGlvbnMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHJvcGUsIHByb2R1Y2luZ1xuLy8gYSBmbGF0IGFycmF5LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbHQsIGkpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGYoZWx0LCBpKSk7IH0sIGZyb20sIHRvKTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOjogKD91bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIOKGkiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBhcnJheSwgb3IgcmV0dXJuIHRoZSByb3BlXG4vLyBpdHNlbGYgaWYgYSByb3BlIHdhcyBnaXZlbi5cblJvcGVTZXF1ZW5jZS5mcm9tID0gZnVuY3Rpb24gZnJvbSAodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSb3BlU2VxdWVuY2UpIHsgcmV0dXJuIHZhbHVlcyB9XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA/IG5ldyBMZWFmKHZhbHVlcykgOiBSb3BlU2VxdWVuY2UuZW1wdHlcbn07XG5cbnZhciBMZWFmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIExlYWYodmFsdWVzKSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIExlYWYuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBMZWFmLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIExlYWYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVhZjtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBsZW5ndGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZGVwdGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBMZWFmLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLnNsaWNlKGZyb20sIHRvKSlcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb20gLSAxOyBpID49IHRvOyBpLS0pXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuY29uY2F0KG90aGVyLmZsYXR0ZW4oKSkpIH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKG90aGVyLmZsYXR0ZW4oKS5jb25jYXQodGhpcy52YWx1ZXMpKSB9XG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmxlbmd0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuZGVwdGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMZWFmLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIExlYWY7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG4vLyA6OiBSb3BlU2VxdWVuY2Vcbi8vIFRoZSBlbXB0eSByb3BlIHNlcXVlbmNlLlxuUm9wZVNlcXVlbmNlLmVtcHR5ID0gbmV3IExlYWYoW10pO1xuXG52YXIgQXBwZW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIEFwcGVuZChsZWZ0LCByaWdodCkge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGg7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKSArIDE7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIEFwcGVuZC5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIEFwcGVuZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBBcHBlbmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXBwZW5kO1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnJpZ2h0LmZsYXR0ZW4oKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gaSA8IHRoaXMubGVmdC5sZW5ndGggPyB0aGlzLmxlZnQuZ2V0KGkpIDogdGhpcy5yaWdodC5nZXQoaSAtIHRoaXMubGVmdC5sZW5ndGgpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbm5lcihmLCBmcm9tLCBNYXRoLm1pbih0bywgbGVmdExlbiksIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbm5lcihmLCBNYXRoLm1heChmcm9tIC0gbGVmdExlbiwgMCksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tIC0gbGVmdExlbiwgTWF0aC5tYXgodG8sIGxlZnRMZW4pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgTWF0aC5taW4oZnJvbSwgbGVmdExlbiksIHRvLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmICh0byA8PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgdG8pIH1cbiAgICBpZiAoZnJvbSA+PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLnJpZ2h0LnNsaWNlKGZyb20gLSBsZWZ0TGVuLCB0byAtIGxlZnRMZW4pIH1cbiAgICByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIGxlZnRMZW4pLmFwcGVuZCh0aGlzLnJpZ2h0LnNsaWNlKDAsIHRvIC0gbGVmdExlbikpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLnJpZ2h0LmxlYWZBcHBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIGlubmVyKSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMubGVmdC5sZWFmUHJlcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKGlubmVyLCB0aGlzLnJpZ2h0KSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlZnQuZGVwdGggPj0gTWF0aC5tYXgodGhpcy5yaWdodC5kZXB0aCwgb3RoZXIuZGVwdGgpICsgMSlcbiAgICAgIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBuZXcgQXBwZW5kKHRoaXMucmlnaHQsIG90aGVyKSkgfVxuICAgIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxuICB9O1xuXG4gIHJldHVybiBBcHBlbmQ7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBSb3BlU2VxdWVuY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rope-sequence/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/w3c-keyname/index.js":
/*!*******************************************!*\
  !*** ./node_modules/w3c-keyname/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   keyName: () => (/* binding */ keyName),\n/* harmony export */   shift: () => (/* binding */ shift)\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n}\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n}\n\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.\n  // On IE, shift effect is never included in `.key`.\n  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||\n      ie && event.shiftKey && event.key && event.key.length == 1 ||\n      event.key == \"Unidentified\"\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLEdBQUc7O0FBRTdFO0FBQ0EsZ0JBQWdCLFFBQVE7O0FBRXhCO0FBQ0EsZ0JBQWdCLFNBQVM7O0FBRXpCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFx3M2Mta2V5bmFtZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBPbiBtYWNPUywga2V5cyBoZWxkIHdpdGggU2hpZnQgYW5kIENtZCBkb24ndCByZWZsZWN0IHRoZSBlZmZlY3Qgb2YgU2hpZnQgaW4gYC5rZXlgLlxuICAvLyBPbiBJRSwgc2hpZnQgZWZmZWN0IGlzIG5ldmVyIGluY2x1ZGVkIGluIGAua2V5YC5cbiAgdmFyIGlnbm9yZUtleSA9IG1hYyAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHxcbiAgICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/w3c-keyname/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/y-prosemirror/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/y-prosemirror/src/lib.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutePositionToRelativePosition: () => (/* binding */ absolutePositionToRelativePosition),\n/* harmony export */   initProseMirrorDoc: () => (/* binding */ initProseMirrorDoc),\n/* harmony export */   prosemirrorJSONToYDoc: () => (/* binding */ prosemirrorJSONToYDoc),\n/* harmony export */   prosemirrorJSONToYXmlFragment: () => (/* binding */ prosemirrorJSONToYXmlFragment),\n/* harmony export */   prosemirrorToYDoc: () => (/* binding */ prosemirrorToYDoc),\n/* harmony export */   prosemirrorToYXmlFragment: () => (/* binding */ prosemirrorToYXmlFragment),\n/* harmony export */   relativePositionToAbsolutePosition: () => (/* binding */ relativePositionToAbsolutePosition),\n/* harmony export */   setMeta: () => (/* binding */ setMeta),\n/* harmony export */   yDocToProsemirror: () => (/* binding */ yDocToProsemirror),\n/* harmony export */   yDocToProsemirrorJSON: () => (/* binding */ yDocToProsemirrorJSON),\n/* harmony export */   yXmlFragmentToProseMirrorFragment: () => (/* binding */ yXmlFragmentToProseMirrorFragment),\n/* harmony export */   yXmlFragmentToProseMirrorRootNode: () => (/* binding */ yXmlFragmentToProseMirrorRootNode),\n/* harmony export */   yXmlFragmentToProsemirror: () => (/* binding */ yXmlFragmentToProsemirror),\n/* harmony export */   yXmlFragmentToProsemirrorJSON: () => (/* binding */ yXmlFragmentToProsemirrorJSON)\n/* harmony export */ });\n/* harmony import */ var _plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/sync-plugin.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/keys.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(app-pages-browser)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/error */ \"(app-pages-browser)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/map */ \"(app-pages-browser)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/eventloop */ \"(app-pages-browser)/./node_modules/lib0/eventloop.js\");\n // eslint-disable-line\n\n\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, Node | Array<Node>>} ProsemirrorMapping\n */\n\n/**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */\nlet viewsToUpdate = null\n\nconst updateMetas = () => {\n  const ups = /** @type {Map<EditorView, Map<any, any>>} */ (viewsToUpdate)\n  viewsToUpdate = null\n  ups.forEach((metas, view) => {\n    const tr = view.state.tr\n    const syncState = _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n      metas.forEach((val, key) => {\n        tr.setMeta(key, val)\n      })\n      view.dispatch(tr)\n    }\n  })\n}\n\nconst setMeta = (view, key, value) => {\n  if (!viewsToUpdate) {\n    viewsToUpdate = new Map()\n    lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__.timeout(0, updateMetas)\n  }\n  lib0_map__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(viewsToUpdate, view, lib0_map__WEBPACK_IMPORTED_MODULE_2__.create).set(key, value)\n}\n\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */\nconst absolutePositionToRelativePosition = (pos, type, mapping) => {\n  if (pos === 0) {\n    return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, 0, -1)\n  }\n  /**\n   * @type {any}\n   */\n  let n = type._first === null ? null : /** @type {Y.ContentType} */ (type._first.content).type\n  while (n !== null && type !== n) {\n    if (n instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n      if (n._length >= pos) {\n        return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(n, pos, -1)\n      } else {\n        pos -= n._length\n      }\n      if (n._item !== null && n._item.next !== null) {\n        n = /** @type {Y.ContentType} */ (n._item.next.content).type\n      } else {\n        do {\n          n = n._item === null ? null : n._item.parent\n          pos--\n        } while (n !== type && n !== null && n._item !== null && n._item.next === null)\n        if (n !== null && n !== type) {\n          // @ts-gnore we know that n.next !== null because of above loop conditition\n          n = n._item === null ? null : /** @type {Y.ContentType} */ (/** @type Y.Item */ (n._item.next).content).type\n        }\n      }\n    } else {\n      const pNodeSize = /** @type {any} */ (mapping.get(n) || { nodeSize: 0 }).nodeSize\n      if (n._first !== null && pos < pNodeSize) {\n        n = /** @type {Y.ContentType} */ (n._first.content).type\n        pos--\n      } else {\n        if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n          // edge case, should end in this paragraph\n          return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n        }\n        pos -= pNodeSize\n        if (n._item !== null && n._item.next !== null) {\n          n = /** @type {Y.ContentType} */ (n._item.next.content).type\n        } else {\n          if (pos === 0) {\n            // set to end of n.parent\n            n = n._item === null ? n : n._item.parent\n            return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n          }\n          do {\n            n = /** @type {Y.Item} */ (n._item).parent\n            pos--\n          } while (n !== type && /** @type {Y.Item} */ (n._item).next === null)\n          // if n is null at this point, we have an unexpected case\n          if (n !== type) {\n            // We know that n._item.next is defined because of above loop condition\n            n = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (/** @type {Y.Item} */ (n._item).next).content).type\n          }\n        }\n      }\n    }\n    if (n === null) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase()\n    }\n    if (pos === 0 && n.constructor !== yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText && n !== type) { // TODO: set to <= 0\n      return createRelativePosition(n._item.parent, n._item)\n    }\n  }\n  return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, type._length, -1)\n}\n\nconst createRelativePosition = (type, item) => {\n  let typeid = null\n  let tname = null\n  if (type._item === null) {\n    tname = yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(type)\n  } else {\n    typeid = yjs__WEBPACK_IMPORTED_MODULE_3__.createID(type._item.id.client, type._item.id.clock)\n  }\n  return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(typeid, tname, item.id)\n}\n\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n * @return {null|number}\n */\nconst relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n  const decodedPos = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(relPos, y)\n  if (decodedPos === null || (decodedPos.type !== documentType && !yjs__WEBPACK_IMPORTED_MODULE_3__.isParentOf(documentType, decodedPos.type._item))) {\n    return null\n  }\n  let type = decodedPos.type\n  let pos = 0\n  if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n    pos = decodedPos.index\n  } else if (type._item === null || !type._item.deleted) {\n    let n = type._first\n    let i = 0\n    while (i < type._length && i < decodedPos.index && n !== null) {\n      if (!n.deleted) {\n        const t = /** @type {Y.ContentType} */ (n.content).type\n        i++\n        if (t instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n          pos += t._length\n        } else {\n          pos += /** @type {any} */ (mapping.get(t)).nodeSize\n        }\n      }\n      n = /** @type {Y.Item} */ (n.right)\n    }\n    pos += 1 // increase because we go out of n\n  }\n  while (type !== documentType && type._item !== null) {\n    // @ts-ignore\n    const parent = type._item.parent\n    // @ts-ignore\n    if (parent._item === null || !parent._item.deleted) {\n      pos += 1 // the start tag\n      let n = /** @type {Y.AbstractType} */ (parent)._first\n      // now iterate until we found type\n      while (n !== null) {\n        const contentType = /** @type {Y.ContentType} */ (n.content).type\n        if (contentType === type) {\n          break\n        }\n        if (!n.deleted) {\n          if (contentType instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n            pos += contentType._length\n          } else {\n            pos += /** @type {any} */ (mapping.get(contentType)).nodeSize\n          }\n        }\n        n = n.right\n      }\n    }\n    type = /** @type {Y.AbstractType} */ (parent)\n  }\n  return pos - 1 // we don't count the most outer tag, because it is a fragment\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror fragment.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createEmptyMeta)()\n    )\n  ).filter((n) => n !== null)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent)\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror node.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) =>\n  schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema))\n\n/**\n * The initial ProseMirror content should be supplied by Yjs. This function transforms a Y.Fragment\n * to a ProseMirror Doc node and creates a mapping that is used by the sync plugin.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nconst initProseMirrorDoc = (yXmlFragment, schema) => {\n  const meta = (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createEmptyMeta)()\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      meta\n    )\n  ).filter((n) => n !== null)\n  const doc = schema.topNodeType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent))\n  return { doc, meta: meta.mapping }\n}\n\n/**\n * Utility method to convert a Prosemirror Doc Node into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Node} doc\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorToYDoc (doc, xmlFragment = 'prosemirror') {\n  const ydoc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc()\n  const type = /** @type {Y.XmlFragment} */ (ydoc.get(xmlFragment, yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment))\n  if (!type.doc) {\n    return ydoc\n  }\n\n  prosemirrorToYXmlFragment(doc, type)\n  return type.doc\n}\n\n/**\n * Utility method to update an empty Y.XmlFragment with content from a Prosemirror Doc Node.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * Note: The Y.XmlFragment does not need to be part of a Y.Doc document at the time that this\n * method is called, but it must be added before any other operations are performed on it.\n *\n * @param {Node} doc prosemirror document.\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorToYXmlFragment (doc, xmlFragment) {\n  const type = xmlFragment || new yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment()\n  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(undefined) }\n  ;(0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.updateYFragment)(ydoc, type, doc, { mapping: new Map(), isOMark: new Map() })\n  return type\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorJSONToYDoc (schema, state, xmlFragment = 'prosemirror') {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYDoc(doc, xmlFragment)\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorJSONToYXmlFragment (schema, state, xmlFragment) {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYXmlFragment(doc, xmlFragment)\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.Doc} ydoc\n * @return {Node}\n */\nfunction yDocToProsemirror (schema, ydoc) {\n  const state = yDocToProsemirrorJSON(ydoc)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.XmlFragment to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.XmlFragment} xmlFragment\n * @return {Node}\n */\nfunction yXmlFragmentToProsemirror (schema, xmlFragment) {\n  const state = yXmlFragmentToProsemirrorJSON(xmlFragment)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.Doc} ydoc\n * @param {string} xmlFragment\n * @return {Record<string, any>}\n */\nfunction yDocToProsemirrorJSON (\n  ydoc,\n  xmlFragment = 'prosemirror'\n) {\n  return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment))\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.XmlFragment} xmlFragment The fragment, which must be part of a Y.Doc.\n * @return {Record<string, any>}\n */\nfunction yXmlFragmentToProsemirrorJSON (xmlFragment) {\n  const items = xmlFragment.toArray()\n\n  /**\n   * @param {Y.AbstractType} item\n   */\n  const serialize = item => {\n    /**\n     * @type {Object} NodeObject\n     * @property {string} NodeObject.type\n     * @property {Record<string, string>=} NodeObject.attrs\n     * @property {Array<NodeObject>=} NodeObject.content\n     */\n    let response\n\n    // TODO: Must be a better way to detect text nodes than this\n    if (item instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n      const delta = item.toDelta()\n      response = delta.map(/** @param {any} d */ (d) => {\n        const text = {\n          type: 'text',\n          text: d.insert\n        }\n        if (d.attributes) {\n          text.marks = Object.keys(d.attributes).map((type_) => {\n            const attrs = d.attributes[type_]\n            const type = (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.yattr2markname)(type_)\n            const mark = {\n              type\n            }\n            if (Object.keys(attrs)) {\n              mark.attrs = attrs\n            }\n            return mark\n          })\n        }\n        return text\n      })\n    } else if (item instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlElement) {\n      response = {\n        type: item.nodeName\n      }\n\n      const attrs = item.getAttributes()\n      if (Object.keys(attrs).length) {\n        response.attrs = attrs\n      }\n\n      const children = item.toArray()\n      if (children.length) {\n        response.content = children.map(serialize).flat()\n      }\n    } else {\n      // expected either Y.XmlElement or Y.XmlText\n      lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase()\n    }\n\n    return response\n  }\n\n  return {\n    type: 'doc',\n    content: items.map(serialize)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9saWIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1IO0FBQ2pFO0FBQzFCO0FBQ3FCO0FBQ2E7QUFDdkI7QUFDSjtBQUNZOztBQUUzQztBQUNBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDREQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBLElBQUksbURBQWlCO0FBQ3JCO0FBQ0EsRUFBRSxvREFBa0Isc0JBQXNCLDRDQUFVO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxvQkFBb0I7QUFDL0IsWUFBWSxLQUFLO0FBQ2pCO0FBQ087QUFDUDtBQUNBLFdBQVcsb0VBQXFDO0FBQ2hEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBLHFCQUFxQix3Q0FBUztBQUM5QjtBQUNBLGVBQWUsb0VBQXFDO0FBQ3BELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1DQUFtQyxLQUFLLHdCQUF3QixhQUFhO0FBQzdFO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFCQUFxQixpREFBa0IsMERBQTBELGdEQUFpQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtB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QUFDTjtBQUNBLE1BQU0sc0RBQW9CO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXHktcHJvc2VtaXJyb3JcXHNyY1xcbGliLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVwZGF0ZVlGcmFnbWVudCwgY3JlYXRlTm9kZUZyb21ZRWxlbWVudCwgeWF0dHIybWFya25hbWUsIGNyZWF0ZUVtcHR5TWV0YSB9IGZyb20gJy4vcGx1Z2lucy9zeW5jLXBsdWdpbi5qcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgeVN5bmNQbHVnaW5LZXkgfSBmcm9tICcuL3BsdWdpbnMva2V5cy5qcydcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IE5vZGUsIFNjaGVtYSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCcgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICdsaWIwL2V2ZW50bG9vcCdcblxuLyoqXG4gKiBFaXRoZXIgYSBub2RlIGlmIHR5cGUgaXMgWVhtbEVsZW1lbnQgb3IgYW4gQXJyYXkgb2YgdGV4dCBub2RlcyBpZiBZWG1sVGV4dFxuICogQHR5cGVkZWYge01hcDxZLkFic3RyYWN0VHlwZSwgTm9kZSB8IEFycmF5PE5vZGU+Pn0gUHJvc2VtaXJyb3JNYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBJcyBudWxsIGlmIG5vIHRpbWVvdXQgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBJcyBkZWZpbmVkIGlmIGEgdGltZW91dCBpcyBpbiBwcm9ncmVzcy5cbiAqIE1hcHMgZnJvbSB2aWV3XG4gKiBAdHlwZSB7TWFwPEVkaXRvclZpZXcsIE1hcDxhbnksIGFueT4+fG51bGx9XG4gKi9cbmxldCB2aWV3c1RvVXBkYXRlID0gbnVsbFxuXG5jb25zdCB1cGRhdGVNZXRhcyA9ICgpID0+IHtcbiAgY29uc3QgdXBzID0gLyoqIEB0eXBlIHtNYXA8RWRpdG9yVmlldywgTWFwPGFueSwgYW55Pj59ICovICh2aWV3c1RvVXBkYXRlKVxuICB2aWV3c1RvVXBkYXRlID0gbnVsbFxuICB1cHMuZm9yRWFjaCgobWV0YXMsIHZpZXcpID0+IHtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHJcbiAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuICAgIGlmIChzeW5jU3RhdGUgJiYgc3luY1N0YXRlLmJpbmRpbmcgJiYgIXN5bmNTdGF0ZS5iaW5kaW5nLmlzRGVzdHJveWVkKSB7XG4gICAgICBtZXRhcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgICAgICB0ci5zZXRNZXRhKGtleSwgdmFsKVxuICAgICAgfSlcbiAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3Qgc2V0TWV0YSA9ICh2aWV3LCBrZXksIHZhbHVlKSA9PiB7XG4gIGlmICghdmlld3NUb1VwZGF0ZSkge1xuICAgIHZpZXdzVG9VcGRhdGUgPSBuZXcgTWFwKClcbiAgICBldmVudGxvb3AudGltZW91dCgwLCB1cGRhdGVNZXRhcylcbiAgfVxuICBtYXAuc2V0SWZVbmRlZmluZWQodmlld3NUb1VwZGF0ZSwgdmlldywgbWFwLmNyZWF0ZSkuc2V0KGtleSwgdmFsdWUpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIFByb3NlbWlycm9yIGJhc2VkIGFic29sdXRlIHBvc2l0aW9uIHRvIGEgWWpzIEN1cnNvciAocmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIFlqcyBtb2RlbCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB0eXBlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7YW55fSByZWxhdGl2ZSBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3QgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiA9IChwb3MsIHR5cGUsIG1hcHBpbmcpID0+IHtcbiAgaWYgKHBvcyA9PT0gMCkge1xuICAgIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIDAsIC0xKVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IG4gPSB0eXBlLl9maXJzdCA9PT0gbnVsbCA/IG51bGwgOiAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICh0eXBlLl9maXJzdC5jb250ZW50KS50eXBlXG4gIHdoaWxlIChuICE9PSBudWxsICYmIHR5cGUgIT09IG4pIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgaWYgKG4uX2xlbmd0aCA+PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgobiwgcG9zLCAtMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyAtPSBuLl9sZW5ndGhcbiAgICAgIH1cbiAgICAgIGlmIChuLl9pdGVtICE9PSBudWxsICYmIG4uX2l0ZW0ubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAobi5faXRlbS5uZXh0LmNvbnRlbnQpLnR5cGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiBuLl9pdGVtLnBhcmVudFxuICAgICAgICAgIHBvcy0tXG4gICAgICAgIH0gd2hpbGUgKG4gIT09IHR5cGUgJiYgbiAhPT0gbnVsbCAmJiBuLl9pdGVtICE9PSBudWxsICYmIG4uX2l0ZW0ubmV4dCA9PT0gbnVsbClcbiAgICAgICAgaWYgKG4gIT09IG51bGwgJiYgbiAhPT0gdHlwZSkge1xuICAgICAgICAgIC8vIEB0cy1nbm9yZSB3ZSBrbm93IHRoYXQgbi5uZXh0ICE9PSBudWxsIGJlY2F1c2Ugb2YgYWJvdmUgbG9vcCBjb25kaXRpdGlvblxuICAgICAgICAgIG4gPSBuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKC8qKiBAdHlwZSBZLkl0ZW0gKi8gKG4uX2l0ZW0ubmV4dCkuY29udGVudCkudHlwZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBOb2RlU2l6ZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQobikgfHwgeyBub2RlU2l6ZTogMCB9KS5ub2RlU2l6ZVxuICAgICAgaWYgKG4uX2ZpcnN0ICE9PSBudWxsICYmIHBvcyA8IHBOb2RlU2l6ZSkge1xuICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAobi5fZmlyc3QuY29udGVudCkudHlwZVxuICAgICAgICBwb3MtLVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gMSAmJiBuLl9sZW5ndGggPT09IDAgJiYgcE5vZGVTaXplID4gMSkge1xuICAgICAgICAgIC8vIGVkZ2UgY2FzZSwgc2hvdWxkIGVuZCBpbiB0aGlzIHBhcmFncmFwaFxuICAgICAgICAgIHJldHVybiBuZXcgWS5SZWxhdGl2ZVBvc2l0aW9uKG4uX2l0ZW0gPT09IG51bGwgPyBudWxsIDogbi5faXRlbS5pZCwgbi5faXRlbSA9PT0gbnVsbCA/IFkuZmluZFJvb3RUeXBlS2V5KG4pIDogbnVsbCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgICBwb3MgLT0gcE5vZGVTaXplXG4gICAgICAgIGlmIChuLl9pdGVtICE9PSBudWxsICYmIG4uX2l0ZW0ubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgIG4gPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLl9pdGVtLm5leHQuY29udGVudCkudHlwZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwb3MgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHNldCB0byBlbmQgb2Ygbi5wYXJlbnRcbiAgICAgICAgICAgIG4gPSBuLl9pdGVtID09PSBudWxsID8gbiA6IG4uX2l0ZW0ucGFyZW50XG4gICAgICAgICAgICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbihuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IG4uX2l0ZW0uaWQsIG4uX2l0ZW0gPT09IG51bGwgPyBZLmZpbmRSb290VHlwZUtleShuKSA6IG51bGwsIG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLnBhcmVudFxuICAgICAgICAgICAgcG9zLS1cbiAgICAgICAgICB9IHdoaWxlIChuICE9PSB0eXBlICYmIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAobi5faXRlbSkubmV4dCA9PT0gbnVsbClcbiAgICAgICAgICAvLyBpZiBuIGlzIG51bGwgYXQgdGhpcyBwb2ludCwgd2UgaGF2ZSBhbiB1bmV4cGVjdGVkIGNhc2VcbiAgICAgICAgICBpZiAobiAhPT0gdHlwZSkge1xuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGF0IG4uX2l0ZW0ubmV4dCBpcyBkZWZpbmVkIGJlY2F1c2Ugb2YgYWJvdmUgbG9vcCBjb25kaXRpb25cbiAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICgvKiogQHR5cGUge1kuSXRlbX0gKi8gKC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAobi5faXRlbSkubmV4dCkuY29udGVudCkudHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBpZiAocG9zID09PSAwICYmIG4uY29uc3RydWN0b3IgIT09IFkuWG1sVGV4dCAmJiBuICE9PSB0eXBlKSB7IC8vIFRPRE86IHNldCB0byA8PSAwXG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbihuLl9pdGVtLnBhcmVudCwgbi5faXRlbSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgodHlwZSwgdHlwZS5fbGVuZ3RoLCAtMSlcbn1cblxuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtKSA9PiB7XG4gIGxldCB0eXBlaWQgPSBudWxsXG4gIGxldCB0bmFtZSA9IG51bGxcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IFkuZmluZFJvb3RUeXBlS2V5KHR5cGUpXG4gIH0gZWxzZSB7XG4gICAgdHlwZWlkID0gWS5jcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jaylcbiAgfVxuICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbih0eXBlaWQsIHRuYW1lLCBpdGVtLmlkKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5Eb2N9IHlcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gZG9jdW1lbnRUeXBlIFRvcCBsZXZlbCB0eXBlIHRoYXQgaXMgYm91bmQgdG8gcFZpZXdcbiAqIEBwYXJhbSB7YW55fSByZWxQb3MgRW5jb2RlZCBZanMgYmFzZWQgcmVsYXRpdmUgcG9zaXRpb25cbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtudWxsfG51bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24gPSAoeSwgZG9jdW1lbnRUeXBlLCByZWxQb3MsIG1hcHBpbmcpID0+IHtcbiAgY29uc3QgZGVjb2RlZFBvcyA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKHJlbFBvcywgeSlcbiAgaWYgKGRlY29kZWRQb3MgPT09IG51bGwgfHwgKGRlY29kZWRQb3MudHlwZSAhPT0gZG9jdW1lbnRUeXBlICYmICFZLmlzUGFyZW50T2YoZG9jdW1lbnRUeXBlLCBkZWNvZGVkUG9zLnR5cGUuX2l0ZW0pKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbGV0IHR5cGUgPSBkZWNvZGVkUG9zLnR5cGVcbiAgbGV0IHBvcyA9IDBcbiAgaWYgKHR5cGUuY29uc3RydWN0b3IgPT09IFkuWG1sVGV4dCkge1xuICAgIHBvcyA9IGRlY29kZWRQb3MuaW5kZXhcbiAgfSBlbHNlIGlmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICBsZXQgbiA9IHR5cGUuX2ZpcnN0XG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKGkgPCB0eXBlLl9sZW5ndGggJiYgaSA8IGRlY29kZWRQb3MuaW5kZXggJiYgbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgdCA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgICAgICBpKytcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBZLlhtbFRleHQpIHtcbiAgICAgICAgICBwb3MgKz0gdC5fbGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQodCkpLm5vZGVTaXplXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4ucmlnaHQpXG4gICAgfVxuICAgIHBvcyArPSAxIC8vIGluY3JlYXNlIGJlY2F1c2Ugd2UgZ28gb3V0IG9mIG5cbiAgfVxuICB3aGlsZSAodHlwZSAhPT0gZG9jdW1lbnRUeXBlICYmIHR5cGUuX2l0ZW0gIT09IG51bGwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgcGFyZW50ID0gdHlwZS5faXRlbS5wYXJlbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHBhcmVudC5faXRlbSA9PT0gbnVsbCB8fCAhcGFyZW50Ll9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgIHBvcyArPSAxIC8vIHRoZSBzdGFydCB0YWdcbiAgICAgIGxldCBuID0gLyoqIEB0eXBlIHtZLkFic3RyYWN0VHlwZX0gKi8gKHBhcmVudCkuX2ZpcnN0XG4gICAgICAvLyBub3cgaXRlcmF0ZSB1bnRpbCB3ZSBmb3VuZCB0eXBlXG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlIGluc3RhbmNlb2YgWS5YbWxUZXh0KSB7XG4gICAgICAgICAgICBwb3MgKz0gY29udGVudFR5cGUuX2xlbmd0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gLyoqIEB0eXBlIHthbnl9ICovIChtYXBwaW5nLmdldChjb250ZW50VHlwZSkpLm5vZGVTaXplXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG4gPSBuLnJpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge1kuQWJzdHJhY3RUeXBlfSAqLyAocGFyZW50KVxuICB9XG4gIHJldHVybiBwb3MgLSAxIC8vIHdlIGRvbid0IGNvdW50IHRoZSBtb3N0IG91dGVyIHRhZywgYmVjYXVzZSBpdCBpcyBhIGZyYWdtZW50XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBhbiBZLkZyYWdtZW50IHRvIGEgUHJvc2VNaXJyb3IgZnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnRcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JGcmFnbWVudCA9ICh5WG1sRnJhZ21lbnQsIHNjaGVtYSkgPT4ge1xuICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSB5WG1sRnJhZ21lbnQudG9BcnJheSgpLm1hcCgodCkgPT5cbiAgICBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovICh0KSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIGNyZWF0ZUVtcHR5TWV0YSgpXG4gICAgKVxuICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShmcmFnbWVudENvbnRlbnQpXG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBhbiBZLkZyYWdtZW50IHRvIGEgUHJvc2VNaXJyb3Igbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHlYbWxGcmFnbWVudFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICovXG5leHBvcnQgY29uc3QgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlID0gKHlYbWxGcmFnbWVudCwgc2NoZW1hKSA9PlxuICBzY2hlbWEudG9wTm9kZVR5cGUuY3JlYXRlKG51bGwsIHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JGcmFnbWVudCh5WG1sRnJhZ21lbnQsIHNjaGVtYSkpXG5cbi8qKlxuICogVGhlIGluaXRpYWwgUHJvc2VNaXJyb3IgY29udGVudCBzaG91bGQgYmUgc3VwcGxpZWQgYnkgWWpzLiBUaGlzIGZ1bmN0aW9uIHRyYW5zZm9ybXMgYSBZLkZyYWdtZW50XG4gKiB0byBhIFByb3NlTWlycm9yIERvYyBub2RlIGFuZCBjcmVhdGVzIGEgbWFwcGluZyB0aGF0IGlzIHVzZWQgYnkgdGhlIHN5bmMgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0UHJvc2VNaXJyb3JEb2MgPSAoeVhtbEZyYWdtZW50LCBzY2hlbWEpID0+IHtcbiAgY29uc3QgbWV0YSA9IGNyZWF0ZUVtcHR5TWV0YSgpXG4gIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHlYbWxGcmFnbWVudC50b0FycmF5KCkubWFwKCh0KSA9PlxuICAgIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHQpLFxuICAgICAgc2NoZW1hLFxuICAgICAgbWV0YVxuICAgIClcbiAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gIGNvbnN0IGRvYyA9IHNjaGVtYS50b3BOb2RlVHlwZS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbUFycmF5KGZyYWdtZW50Q29udGVudCkpXG4gIHJldHVybiB7IGRvYywgbWV0YTogbWV0YS5tYXBwaW5nIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgUHJvc2VtaXJyb3IgRG9jIE5vZGUgaW50byBhIFkuRG9jLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZG9jXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1kuRG9jfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JUb1lEb2MgKGRvYywgeG1sRnJhZ21lbnQgPSAncHJvc2VtaXJyb3InKSB7XG4gIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoKVxuICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAoeWRvYy5nZXQoeG1sRnJhZ21lbnQsIFkuWG1sRnJhZ21lbnQpKVxuICBpZiAoIXR5cGUuZG9jKSB7XG4gICAgcmV0dXJuIHlkb2NcbiAgfVxuXG4gIHByb3NlbWlycm9yVG9ZWG1sRnJhZ21lbnQoZG9jLCB0eXBlKVxuICByZXR1cm4gdHlwZS5kb2Ncbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byB1cGRhdGUgYW4gZW1wdHkgWS5YbWxGcmFnbWVudCB3aXRoIGNvbnRlbnQgZnJvbSBhIFByb3NlbWlycm9yIERvYyBOb2RlLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIE5vdGU6IFRoZSBZLlhtbEZyYWdtZW50IGRvZXMgbm90IG5lZWQgdG8gYmUgcGFydCBvZiBhIFkuRG9jIGRvY3VtZW50IGF0IHRoZSB0aW1lIHRoYXQgdGhpc1xuICogbWV0aG9kIGlzIGNhbGxlZCwgYnV0IGl0IG11c3QgYmUgYWRkZWQgYmVmb3JlIGFueSBvdGhlciBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gaXQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBkb2MgcHJvc2VtaXJyb3IgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IFt4bWxGcmFnbWVudF0gSWYgc3VwcGxpZWQsIGFuIHhtbCBmcmFnbWVudCB0byBiZVxuICogICBwb3B1bGF0ZWQgZnJvbSB0aGUgcHJvc2VtaXJyb3Igc3RhdGU7IG90aGVyd2lzZSBhIG5ldyBYbWxGcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtZLlhtbEZyYWdtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudCAoZG9jLCB4bWxGcmFnbWVudCkge1xuICBjb25zdCB0eXBlID0geG1sRnJhZ21lbnQgfHwgbmV3IFkuWG1sRnJhZ21lbnQoKVxuICBjb25zdCB5ZG9jID0gdHlwZS5kb2MgPyB0eXBlLmRvYyA6IHsgdHJhbnNhY3Q6ICh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24odW5kZWZpbmVkKSB9XG4gIHVwZGF0ZVlGcmFnbWVudCh5ZG9jLCB0eXBlLCBkb2MsIHsgbWFwcGluZzogbmV3IE1hcCgpLCBpc09NYXJrOiBuZXcgTWFwKCkgfSlcbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTiBpbnRvIGEgWS5Eb2MuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHthbnl9IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1kuRG9jfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JKU09OVG9ZRG9jIChzY2hlbWEsIHN0YXRlLCB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcicpIHtcbiAgY29uc3QgZG9jID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxuICByZXR1cm4gcHJvc2VtaXJyb3JUb1lEb2MoZG9jLCB4bWxGcmFnbWVudClcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTiB0byBhIFkuWG1sRnJhZ21lbnRcbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIGV4aXN0aW5nIGNvbnRlbnQgdG8gWS5Eb2MgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogbm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIFkuRG9jIGZyb20gYSBkYXRhYmFzZSBvbmNlXG4gKiBjb2xsYWJvcmF0aW9uIGhhcyBiZWd1biBhcyBhbGwgaGlzdG9yeSB3aWxsIGJlIGxvc3RcbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge2FueX0gc3RhdGVcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gW3htbEZyYWdtZW50XSBJZiBzdXBwbGllZCwgYW4geG1sIGZyYWdtZW50IHRvIGJlXG4gKiAgIHBvcHVsYXRlZCBmcm9tIHRoZSBwcm9zZW1pcnJvciBzdGF0ZTsgb3RoZXJ3aXNlIGEgbmV3IFhtbEZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1kuWG1sRnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvckpTT05Ub1lYbWxGcmFnbWVudCAoc2NoZW1hLCBzdGF0ZSwgeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgZG9jID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxuICByZXR1cm4gcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudChkb2MsIHhtbEZyYWdtZW50KVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlYCBpbnN0ZWFkXG4gKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIGEgUHJvc2VtaXJyb3IgRG9jIG5vZGUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtZLkRvY30geWRvY1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlEb2NUb1Byb3NlbWlycm9yIChzY2hlbWEsIHlkb2MpIHtcbiAgY29uc3Qgc3RhdGUgPSB5RG9jVG9Qcm9zZW1pcnJvckpTT04oeWRvYylcbiAgcmV0dXJuIE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbn1cblxuLyoqXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5YbWxGcmFnbWVudCB0byBhIFByb3NlbWlycm9yIERvYyBub2RlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9yIChzY2hlbWEsIHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IHN0YXRlID0geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeG1sRnJhZ21lbnQpXG4gIHJldHVybiBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG59XG5cbi8qKlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlYCBpbnN0ZWFkXG4gKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1kuRG9jfSB5ZG9jXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5RG9jVG9Qcm9zZW1pcnJvckpTT04gKFxuICB5ZG9jLFxuICB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcidcbikge1xuICByZXR1cm4geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeWRvYy5nZXRYbWxGcmFnbWVudCh4bWxGcmFnbWVudCkpXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OLlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnQgVGhlIGZyYWdtZW50LCB3aGljaCBtdXN0IGJlIHBhcnQgb2YgYSBZLkRvYy5cbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTiAoeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgaXRlbXMgPSB4bWxGcmFnbWVudC50b0FycmF5KClcblxuICAvKipcbiAgICogQHBhcmFtIHtZLkFic3RyYWN0VHlwZX0gaXRlbVxuICAgKi9cbiAgY29uc3Qgc2VyaWFsaXplID0gaXRlbSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH0gTm9kZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBOb2RlT2JqZWN0LnR5cGVcbiAgICAgKiBAcHJvcGVydHkge1JlY29yZDxzdHJpbmcsIHN0cmluZz49fSBOb2RlT2JqZWN0LmF0dHJzXG4gICAgICogQHByb3BlcnR5IHtBcnJheTxOb2RlT2JqZWN0Pj19IE5vZGVPYmplY3QuY29udGVudFxuICAgICAqL1xuICAgIGxldCByZXNwb25zZVxuXG4gICAgLy8gVE9ETzogTXVzdCBiZSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRleHQgbm9kZXMgdGhhbiB0aGlzXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBZLlhtbFRleHQpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXRlbS50b0RlbHRhKClcbiAgICAgIHJlc3BvbnNlID0gZGVsdGEubWFwKC8qKiBAcGFyYW0ge2FueX0gZCAqLyAoZCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiBkLmluc2VydFxuICAgICAgICB9XG4gICAgICAgIGlmIChkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB0ZXh0Lm1hcmtzID0gT2JqZWN0LmtleXMoZC5hdHRyaWJ1dGVzKS5tYXAoKHR5cGVfKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGQuYXR0cmlidXRlc1t0eXBlX11cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB5YXR0cjJtYXJrbmFtZSh0eXBlXylcbiAgICAgICAgICAgIGNvbnN0IG1hcmsgPSB7XG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRycykpIHtcbiAgICAgICAgICAgICAgbWFyay5hdHRycyA9IGF0dHJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFya1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50KSB7XG4gICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogaXRlbS5ub2RlTmFtZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRycyA9IGl0ZW0uZ2V0QXR0cmlidXRlcygpXG4gICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgICAgICByZXNwb25zZS5hdHRycyA9IGF0dHJzXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gaXRlbS50b0FycmF5KClcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVzcG9uc2UuY29udGVudCA9IGNoaWxkcmVuLm1hcChzZXJpYWxpemUpLmZsYXQoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleHBlY3RlZCBlaXRoZXIgWS5YbWxFbGVtZW50IG9yIFkuWG1sVGV4dFxuICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnZG9jJyxcbiAgICBjb250ZW50OiBpdGVtcy5tYXAoc2VyaWFsaXplKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/y-prosemirror/src/lib.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/cursor-plugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDecorations: () => (/* binding */ createDecorations),\n/* harmony export */   defaultAwarenessStateFilter: () => (/* binding */ defaultAwarenessStateFilter),\n/* harmony export */   defaultCursorBuilder: () => (/* binding */ defaultCursorBuilder),\n/* harmony export */   defaultSelectionBuilder: () => (/* binding */ defaultSelectionBuilder),\n/* harmony export */   yCursorPlugin: () => (/* binding */ yCursorPlugin)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(app-pages-browser)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/awareness */ \"(app-pages-browser)/./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/math */ \"(app-pages-browser)/./node_modules/lib0/math.js\");\n\n // eslint-disable-line\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n\n/**\n * Default awareness state filter\n *\n * @param {number} currentClientId current client id\n * @param {number} userClientId user client id\n * @param {any} _user user data\n * @return {boolean}\n */\nconst defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId\n\n/**\n * Default generator for a cursor element\n *\n * @param {any} user user data\n * @return {HTMLElement}\n */\nconst defaultCursorBuilder = (user) => {\n  const cursor = document.createElement('span')\n  cursor.classList.add('ProseMirror-yjs-cursor')\n  cursor.setAttribute('style', `border-color: ${user.color}`)\n  const userDiv = document.createElement('div')\n  userDiv.setAttribute('style', `background-color: ${user.color}`)\n  userDiv.insertBefore(document.createTextNode(user.name), null)\n  const nonbreakingSpace1 = document.createTextNode('\\u2060')\n  const nonbreakingSpace2 = document.createTextNode('\\u2060')\n  cursor.insertBefore(nonbreakingSpace1, null)\n  cursor.insertBefore(userDiv, null)\n  cursor.insertBefore(nonbreakingSpace2, null)\n  return cursor\n}\n\n/**\n * Default generator for the selection attributes\n *\n * @param {any} user user data\n * @return {import('prosemirror-view').DecorationAttrs}\n */\nconst defaultSelectionBuilder = (user) => {\n  return {\n    style: `background-color: ${user.color}70`,\n    class: 'ProseMirror-yjs-selection'\n  }\n}\n\nconst rxValidColor = /^#[0-9a-fA-F]{6}$/\n\n/**\n * @param {any} state\n * @param {Awareness} awareness\n * @param {function(number, number, any):boolean} awarenessFilter\n * @param {(user: { name: string, color: string }, clientId: number) => Element} createCursor\n * @param {(user: { name: string, color: string }, clientId: number) => import('prosemirror-view').DecorationAttrs} createSelection\n * @return {any} DecorationSet\n */\nconst createDecorations = (\n  state,\n  awareness,\n  awarenessFilter,\n  createCursor,\n  createSelection\n) => {\n  const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(state)\n  const y = ystate.doc\n  const decorations = []\n  if (\n    ystate.snapshot != null || ystate.prevSnapshot != null ||\n    ystate.binding.mapping.size === 0\n  ) {\n    // do not render cursors while snapshot is active\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, [])\n  }\n  awareness.getStates().forEach((aw, clientId) => {\n    if (!awarenessFilter(y.clientID, clientId, aw)) {\n      return\n    }\n\n    if (aw.cursor != null) {\n      const user = aw.user || {}\n      if (user.color == null) {\n        user.color = '#ffa500'\n      } else if (!rxValidColor.test(user.color)) {\n        // We only support 6-digit RGB colors in y-prosemirror\n        console.warn('A user uses an unsupported color format', user)\n      }\n      if (user.name == null) {\n        user.name = `User: ${clientId}`\n      }\n      let anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n        y,\n        ystate.type,\n        yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.anchor),\n        ystate.binding.mapping\n      )\n      let head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n        y,\n        ystate.type,\n        yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.head),\n        ystate.binding.mapping\n      )\n      if (anchor !== null && head !== null) {\n        const maxsize = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(state.doc.content.size - 1, 0)\n        anchor = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, maxsize)\n        head = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(head, maxsize)\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(head, () => createCursor(user, clientId), {\n            key: clientId + '',\n            side: 10\n          })\n        )\n        const from = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, head)\n        const to = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(anchor, head)\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.inline(from, to, createSelection(user, clientId), {\n            inclusiveEnd: true,\n            inclusiveStart: false\n          })\n        )\n      }\n    }\n  })\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations)\n}\n\n/**\n * A prosemirror plugin that listens to awareness information on Yjs.\n * This requires that a `prosemirrorPlugin` is also bound to the prosemirror.\n *\n * @public\n * @param {Awareness} awareness\n * @param {object} opts\n * @param {function(any, any, any):boolean} [opts.awarenessStateFilter]\n * @param {(user: any, clientId: number) => HTMLElement} [opts.cursorBuilder]\n * @param {(user: any, clientId: number) => import('prosemirror-view').DecorationAttrs} [opts.selectionBuilder]\n * @param {function(any):any} [opts.getSelection]\n * @param {string} [cursorStateField] By default all editor bindings use the awareness 'cursor' field to propagate cursor information.\n * @return {any}\n */\nconst yCursorPlugin = (\n  awareness,\n  {\n    awarenessStateFilter = defaultAwarenessStateFilter,\n    cursorBuilder = defaultCursorBuilder,\n    selectionBuilder = defaultSelectionBuilder,\n    getSelection = (state) => state.selection\n  } = {},\n  cursorStateField = 'cursor'\n) =>\n  new prosemirror_state__WEBPACK_IMPORTED_MODULE_6__.Plugin({\n    key: _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey,\n    state: {\n      init (_, state) {\n        return createDecorations(\n          state,\n          awareness,\n          awarenessStateFilter,\n          cursorBuilder,\n          selectionBuilder\n        )\n      },\n      apply (tr, prevState, _oldState, newState) {\n        const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(newState)\n        const yCursorState = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey)\n        if (\n          (ystate && ystate.isChangeOrigin) ||\n          (yCursorState && yCursorState.awarenessUpdated)\n        ) {\n          return createDecorations(\n            newState,\n            awareness,\n            awarenessStateFilter,\n            cursorBuilder,\n            selectionBuilder\n          )\n        }\n        return prevState.map(tr.mapping, tr.doc)\n      }\n    },\n    props: {\n      decorations: (state) => {\n        return _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey.getState(state)\n      }\n    },\n    view: (view) => {\n      const awarenessListener = () => {\n        // @ts-ignore\n        if (view.docView) {\n          (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.setMeta)(view, _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey, { awarenessUpdated: true })\n        }\n      }\n      const updateCursorInfo = () => {\n        const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(view.state)\n        // @note We make implicit checks when checking for the cursor property\n        const current = awareness.getLocalState() || {}\n        if (view.hasFocus()) {\n          const selection = getSelection(view.state)\n          /**\n           * @type {Y.RelativePosition}\n           */\n          const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(\n            selection.anchor,\n            ystate.type,\n            ystate.binding.mapping\n          )\n          /**\n           * @type {Y.RelativePosition}\n           */\n          const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(\n            selection.head,\n            ystate.type,\n            ystate.binding.mapping\n          )\n          if (\n            current.cursor == null ||\n            !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(\n              yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor),\n              anchor\n            ) ||\n            !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(\n              yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.head),\n              head\n            )\n          ) {\n            awareness.setLocalStateField(cursorStateField, {\n              anchor,\n              head\n            })\n          }\n        } else if (\n          current.cursor != null &&\n          (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(\n            ystate.doc,\n            ystate.type,\n            yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor),\n            ystate.binding.mapping\n          ) !== null\n        ) {\n          // delete cursor information if current cursor information is owned by this editor binding\n          awareness.setLocalStateField(cursorStateField, null)\n        }\n      }\n      awareness.on('change', awarenessListener)\n      view.dom.addEventListener('focusin', updateCursorInfo)\n      view.dom.addEventListener('focusout', updateCursorInfo)\n      return {\n        update: updateCursorInfo,\n        destroy: () => {\n          view.dom.removeEventListener('focusin', updateCursorInfo)\n          view.dom.removeEventListener('focusout', updateCursorInfo)\n          awareness.off('change', awarenessListener)\n          awareness.setLocalStateField(cursorStateField, null)\n        }\n      }\n    }\n  })\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL2N1cnNvci1wbHVnaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQ3FDLENBQUM7QUFDbkIsQ0FBQztBQUNNLENBQUM7QUFLakM7QUFDMEM7O0FBRTNCOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxFQUFFOztBQUV0QztBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFdBQVc7QUFDdEIsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyxTQUFTLDZCQUE2QixnQ0FBZ0M7QUFDakYsV0FBVyxTQUFTLDZCQUE2QixtRUFBbUU7QUFDcEgsWUFBWSxLQUFLO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBLG1CQUFtQiwyRUFBa0M7QUFDckQ7QUFDQTtBQUNBLFFBQVEsK0RBQWdDO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUIsMkVBQWtDO0FBQ25EO0FBQ0E7QUFDQSxRQUFRLCtEQUFnQztBQUN4QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQVE7QUFDaEMsaUJBQWlCLDBDQUFRO0FBQ3pCLGVBQWUsMENBQVE7QUFDdkI7QUFDQSxVQUFVLHdEQUFVO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxxQkFBcUIsMENBQVE7QUFDN0IsbUJBQW1CLDBDQUFRO0FBQzNCO0FBQ0EsVUFBVSx3REFBVTtBQUNwQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLDJEQUFhO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsOENBQThDO0FBQ3pELFdBQVcsNkVBQTZFO0FBQ3hGLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxNQUFNLHFEQUFNO0FBQ1osU0FBUyxzREFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLG9EQUFjO0FBQ3JDLHdDQUF3QyxzREFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxzREFBZ0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdEQUFPLE9BQU8sc0RBQWdCLElBQUksd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvREFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EseUJBQXlCLDJFQUFrQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsdUJBQXVCLDJFQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUEwQjtBQUN2QyxjQUFjLCtEQUFnQztBQUM5QztBQUNBO0FBQ0EsYUFBYSx5REFBMEI7QUFDdkMsY0FBYywrREFBZ0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSwyRUFBa0M7QUFDNUM7QUFDQTtBQUNBLFlBQVksK0RBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xceS1wcm9zZW1pcnJvclxcc3JjXFxwbHVnaW5zXFxjdXJzb3ItcGx1Z2luLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyBBd2FyZW5lc3MgfSBmcm9tIFwieS1wcm90b2NvbHMvYXdhcmVuZXNzXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7XG4gIGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24sXG4gIHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24sXG4gIHNldE1ldGFcbn0gZnJvbSAnLi4vbGliLmpzJ1xuaW1wb3J0IHsgeUN1cnNvclBsdWdpbktleSwgeVN5bmNQbHVnaW5LZXkgfSBmcm9tICcuL2tleXMuanMnXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuXG4vKipcbiAqIERlZmF1bHQgYXdhcmVuZXNzIHN0YXRlIGZpbHRlclxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50Q2xpZW50SWQgY3VycmVudCBjbGllbnQgaWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB1c2VyQ2xpZW50SWQgdXNlciBjbGllbnQgaWRcbiAqIEBwYXJhbSB7YW55fSBfdXNlciB1c2VyIGRhdGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0QXdhcmVuZXNzU3RhdGVGaWx0ZXIgPSAoY3VycmVudENsaWVudElkLCB1c2VyQ2xpZW50SWQsIF91c2VyKSA9PiBjdXJyZW50Q2xpZW50SWQgIT09IHVzZXJDbGllbnRJZFxuXG4vKipcbiAqIERlZmF1bHQgZ2VuZXJhdG9yIGZvciBhIGN1cnNvciBlbGVtZW50XG4gKlxuICogQHBhcmFtIHthbnl9IHVzZXIgdXNlciBkYXRhXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRDdXJzb3JCdWlsZGVyID0gKHVzZXIpID0+IHtcbiAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIGN1cnNvci5jbGFzc0xpc3QuYWRkKCdQcm9zZU1pcnJvci15anMtY3Vyc29yJylcbiAgY3Vyc29yLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgYm9yZGVyLWNvbG9yOiAke3VzZXIuY29sb3J9YClcbiAgY29uc3QgdXNlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHVzZXJEaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9YClcbiAgdXNlckRpdi5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodXNlci5uYW1lKSwgbnVsbClcbiAgY29uc3Qgbm9uYnJlYWtpbmdTcGFjZTEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjA2MCcpXG4gIGNvbnN0IG5vbmJyZWFraW5nU3BhY2UyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTIwNjAnKVxuICBjdXJzb3IuaW5zZXJ0QmVmb3JlKG5vbmJyZWFraW5nU3BhY2UxLCBudWxsKVxuICBjdXJzb3IuaW5zZXJ0QmVmb3JlKHVzZXJEaXYsIG51bGwpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUobm9uYnJlYWtpbmdTcGFjZTIsIG51bGwpXG4gIHJldHVybiBjdXJzb3Jcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGdlbmVyYXRvciBmb3IgdGhlIHNlbGVjdGlvbiBhdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtIHthbnl9IHVzZXIgdXNlciBkYXRhXG4gKiBAcmV0dXJuIHtpbXBvcnQoJ3Byb3NlbWlycm9yLXZpZXcnKS5EZWNvcmF0aW9uQXR0cnN9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U2VsZWN0aW9uQnVpbGRlciA9ICh1c2VyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9NzBgLFxuICAgIGNsYXNzOiAnUHJvc2VNaXJyb3IteWpzLXNlbGVjdGlvbidcbiAgfVxufVxuXG5jb25zdCByeFZhbGlkQ29sb3IgPSAvXiNbMC05YS1mQS1GXXs2fSQvXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHN0YXRlXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBhbnkpOmJvb2xlYW59IGF3YXJlbmVzc0ZpbHRlclxuICogQHBhcmFtIHsodXNlcjogeyBuYW1lOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcgfSwgY2xpZW50SWQ6IG51bWJlcikgPT4gRWxlbWVudH0gY3JlYXRlQ3Vyc29yXG4gKiBAcGFyYW0geyh1c2VyOiB7IG5hbWU6IHN0cmluZywgY29sb3I6IHN0cmluZyB9LCBjbGllbnRJZDogbnVtYmVyKSA9PiBpbXBvcnQoJ3Byb3NlbWlycm9yLXZpZXcnKS5EZWNvcmF0aW9uQXR0cnN9IGNyZWF0ZVNlbGVjdGlvblxuICogQHJldHVybiB7YW55fSBEZWNvcmF0aW9uU2V0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWNvcmF0aW9ucyA9IChcbiAgc3RhdGUsXG4gIGF3YXJlbmVzcyxcbiAgYXdhcmVuZXNzRmlsdGVyLFxuICBjcmVhdGVDdXJzb3IsXG4gIGNyZWF0ZVNlbGVjdGlvblxuKSA9PiB7XG4gIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICBjb25zdCB5ID0geXN0YXRlLmRvY1xuICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdXG4gIGlmIChcbiAgICB5c3RhdGUuc25hcHNob3QgIT0gbnVsbCB8fCB5c3RhdGUucHJldlNuYXBzaG90ICE9IG51bGwgfHxcbiAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nLnNpemUgPT09IDBcbiAgKSB7XG4gICAgLy8gZG8gbm90IHJlbmRlciBjdXJzb3JzIHdoaWxlIHNuYXBzaG90IGlzIGFjdGl2ZVxuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtdKVxuICB9XG4gIGF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5mb3JFYWNoKChhdywgY2xpZW50SWQpID0+IHtcbiAgICBpZiAoIWF3YXJlbmVzc0ZpbHRlcih5LmNsaWVudElELCBjbGllbnRJZCwgYXcpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYXcuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdy51c2VyIHx8IHt9XG4gICAgICBpZiAodXNlci5jb2xvciA9PSBudWxsKSB7XG4gICAgICAgIHVzZXIuY29sb3IgPSAnI2ZmYTUwMCdcbiAgICAgIH0gZWxzZSBpZiAoIXJ4VmFsaWRDb2xvci50ZXN0KHVzZXIuY29sb3IpKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCA2LWRpZ2l0IFJHQiBjb2xvcnMgaW4geS1wcm9zZW1pcnJvclxuICAgICAgICBjb25zb2xlLndhcm4oJ0EgdXNlciB1c2VzIGFuIHVuc3VwcG9ydGVkIGNvbG9yIGZvcm1hdCcsIHVzZXIpXG4gICAgICB9XG4gICAgICBpZiAodXNlci5uYW1lID09IG51bGwpIHtcbiAgICAgICAgdXNlci5uYW1lID0gYFVzZXI6ICR7Y2xpZW50SWR9YFxuICAgICAgfVxuICAgICAgbGV0IGFuY2hvciA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgIHksXG4gICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihhdy5jdXJzb3IuYW5jaG9yKSxcbiAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgbGV0IGhlYWQgPSByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uKFxuICAgICAgICB5LFxuICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oYXcuY3Vyc29yLmhlYWQpLFxuICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICApXG4gICAgICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWF4c2l6ZSA9IG1hdGgubWF4KHN0YXRlLmRvYy5jb250ZW50LnNpemUgLSAxLCAwKVxuICAgICAgICBhbmNob3IgPSBtYXRoLm1pbihhbmNob3IsIG1heHNpemUpXG4gICAgICAgIGhlYWQgPSBtYXRoLm1pbihoZWFkLCBtYXhzaXplKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERlY29yYXRpb24ud2lkZ2V0KGhlYWQsICgpID0+IGNyZWF0ZUN1cnNvcih1c2VyLCBjbGllbnRJZCksIHtcbiAgICAgICAgICAgIGtleTogY2xpZW50SWQgKyAnJyxcbiAgICAgICAgICAgIHNpZGU6IDEwXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBmcm9tID0gbWF0aC5taW4oYW5jaG9yLCBoZWFkKVxuICAgICAgICBjb25zdCB0byA9IG1hdGgubWF4KGFuY2hvciwgaGVhZClcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcbiAgICAgICAgICBEZWNvcmF0aW9uLmlubGluZShmcm9tLCB0bywgY3JlYXRlU2VsZWN0aW9uKHVzZXIsIGNsaWVudElkKSwge1xuICAgICAgICAgICAgaW5jbHVzaXZlRW5kOiB0cnVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlU3RhcnQ6IGZhbHNlXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgZGVjb3JhdGlvbnMpXG59XG5cbi8qKlxuICogQSBwcm9zZW1pcnJvciBwbHVnaW4gdGhhdCBsaXN0ZW5zIHRvIGF3YXJlbmVzcyBpbmZvcm1hdGlvbiBvbiBZanMuXG4gKiBUaGlzIHJlcXVpcmVzIHRoYXQgYSBgcHJvc2VtaXJyb3JQbHVnaW5gIGlzIGFsc28gYm91bmQgdG8gdGhlIHByb3NlbWlycm9yLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSwgYW55LCBhbnkpOmJvb2xlYW59IFtvcHRzLmF3YXJlbmVzc1N0YXRlRmlsdGVyXVxuICogQHBhcmFtIHsodXNlcjogYW55LCBjbGllbnRJZDogbnVtYmVyKSA9PiBIVE1MRWxlbWVudH0gW29wdHMuY3Vyc29yQnVpbGRlcl1cbiAqIEBwYXJhbSB7KHVzZXI6IGFueSwgY2xpZW50SWQ6IG51bWJlcikgPT4gaW1wb3J0KCdwcm9zZW1pcnJvci12aWV3JykuRGVjb3JhdGlvbkF0dHJzfSBbb3B0cy5zZWxlY3Rpb25CdWlsZGVyXVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gW29wdHMuZ2V0U2VsZWN0aW9uXVxuICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdGF0ZUZpZWxkXSBCeSBkZWZhdWx0IGFsbCBlZGl0b3IgYmluZGluZ3MgdXNlIHRoZSBhd2FyZW5lc3MgJ2N1cnNvcicgZmllbGQgdG8gcHJvcGFnYXRlIGN1cnNvciBpbmZvcm1hdGlvbi5cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZXhwb3J0IGNvbnN0IHlDdXJzb3JQbHVnaW4gPSAoXG4gIGF3YXJlbmVzcyxcbiAge1xuICAgIGF3YXJlbmVzc1N0YXRlRmlsdGVyID0gZGVmYXVsdEF3YXJlbmVzc1N0YXRlRmlsdGVyLFxuICAgIGN1cnNvckJ1aWxkZXIgPSBkZWZhdWx0Q3Vyc29yQnVpbGRlcixcbiAgICBzZWxlY3Rpb25CdWlsZGVyID0gZGVmYXVsdFNlbGVjdGlvbkJ1aWxkZXIsXG4gICAgZ2V0U2VsZWN0aW9uID0gKHN0YXRlKSA9PiBzdGF0ZS5zZWxlY3Rpb25cbiAgfSA9IHt9LFxuICBjdXJzb3JTdGF0ZUZpZWxkID0gJ2N1cnNvcidcbikgPT5cbiAgbmV3IFBsdWdpbih7XG4gICAga2V5OiB5Q3Vyc29yUGx1Z2luS2V5LFxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0IChfLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdGlvbnMoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYXdhcmVuZXNzLFxuICAgICAgICAgIGF3YXJlbmVzc1N0YXRlRmlsdGVyLFxuICAgICAgICAgIGN1cnNvckJ1aWxkZXIsXG4gICAgICAgICAgc2VsZWN0aW9uQnVpbGRlclxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgYXBwbHkgKHRyLCBwcmV2U3RhdGUsIF9vbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgY29uc3QgeXN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUobmV3U3RhdGUpXG4gICAgICAgIGNvbnN0IHlDdXJzb3JTdGF0ZSA9IHRyLmdldE1ldGEoeUN1cnNvclBsdWdpbktleSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgICh5c3RhdGUgJiYgeXN0YXRlLmlzQ2hhbmdlT3JpZ2luKSB8fFxuICAgICAgICAgICh5Q3Vyc29yU3RhdGUgJiYgeUN1cnNvclN0YXRlLmF3YXJlbmVzc1VwZGF0ZWQpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVEZWNvcmF0aW9ucyhcbiAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgYXdhcmVuZXNzLFxuICAgICAgICAgICAgYXdhcmVuZXNzU3RhdGVGaWx0ZXIsXG4gICAgICAgICAgICBjdXJzb3JCdWlsZGVyLFxuICAgICAgICAgICAgc2VsZWN0aW9uQnVpbGRlclxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlLm1hcCh0ci5tYXBwaW5nLCB0ci5kb2MpXG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgZGVjb3JhdGlvbnM6IChzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4geUN1cnNvclBsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIHZpZXc6ICh2aWV3KSA9PiB7XG4gICAgICBjb25zdCBhd2FyZW5lc3NMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodmlldy5kb2NWaWV3KSB7XG4gICAgICAgICAgc2V0TWV0YSh2aWV3LCB5Q3Vyc29yUGx1Z2luS2V5LCB7IGF3YXJlbmVzc1VwZGF0ZWQ6IHRydWUgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdXBkYXRlQ3Vyc29ySW5mbyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeXN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICAgICAgLy8gQG5vdGUgV2UgbWFrZSBpbXBsaWNpdCBjaGVja3Mgd2hlbiBjaGVja2luZyBmb3IgdGhlIGN1cnNvciBwcm9wZXJ0eVxuICAgICAgICBjb25zdCBjdXJyZW50ID0gYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSB8fCB7fVxuICAgICAgICBpZiAodmlldy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHZpZXcuc3RhdGUpXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUge1kuUmVsYXRpdmVQb3NpdGlvbn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBhbmNob3IgPSBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uKFxuICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgICAgIClcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7WS5SZWxhdGl2ZVBvc2l0aW9ufVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IGhlYWQgPSBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uKFxuICAgICAgICAgICAgc2VsZWN0aW9uLmhlYWQsXG4gICAgICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgICAgIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY3VycmVudC5jdXJzb3IgPT0gbnVsbCB8fFxuICAgICAgICAgICAgIVkuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKFxuICAgICAgICAgICAgICBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJyZW50LmN1cnNvci5hbmNob3IpLFxuICAgICAgICAgICAgICBhbmNob3JcbiAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhcbiAgICAgICAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oY3VycmVudC5jdXJzb3IuaGVhZCksXG4gICAgICAgICAgICAgIGhlYWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoY3Vyc29yU3RhdGVGaWVsZCwge1xuICAgICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICAgIGhlYWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGN1cnJlbnQuY3Vyc29yICE9IG51bGwgJiZcbiAgICAgICAgICByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uKFxuICAgICAgICAgICAgeXN0YXRlLmRvYyxcbiAgICAgICAgICAgIHlzdGF0ZS50eXBlLFxuICAgICAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oY3VycmVudC5jdXJzb3IuYW5jaG9yKSxcbiAgICAgICAgICAgIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmdcbiAgICAgICAgICApICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGRlbGV0ZSBjdXJzb3IgaW5mb3JtYXRpb24gaWYgY3VycmVudCBjdXJzb3IgaW5mb3JtYXRpb24gaXMgb3duZWQgYnkgdGhpcyBlZGl0b3IgYmluZGluZ1xuICAgICAgICAgIGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoY3Vyc29yU3RhdGVGaWVsZCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhcmVuZXNzLm9uKCdjaGFuZ2UnLCBhd2FyZW5lc3NMaXN0ZW5lcilcbiAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB1cGRhdGVDdXJzb3JJbmZvKVxuICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB1cGRhdGVDdXJzb3JJbmZvKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlOiB1cGRhdGVDdXJzb3JJbmZvLFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB1cGRhdGVDdXJzb3JJbmZvKVxuICAgICAgICAgIGF3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIGF3YXJlbmVzc0xpc3RlbmVyKVxuICAgICAgICAgIGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoY3Vyc29yU3RhdGVGaWVsZCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yCursorPluginKey: () => (/* binding */ yCursorPluginKey),\n/* harmony export */   ySyncPluginKey: () => (/* binding */ ySyncPluginKey),\n/* harmony export */   yUndoPluginKey: () => (/* binding */ yUndoPluginKey)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n // eslint-disable-line\n\n/**\n * The unique prosemirror plugin key for syncPlugin\n *\n * @public\n */\nconst ySyncPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-sync')\n\n/**\n * The unique prosemirror plugin key for undoPlugin\n *\n * @public\n */\nconst yUndoPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-undo')\n\n/**\n * The unique prosemirror plugin key for cursorPlugin\n *\n * @public\n */\nconst yCursorPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('yjs-cursor')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL2tleXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQix3REFBUzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQix3REFBUzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2Qix3REFBUyIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXHktcHJvc2VtaXJyb3JcXHNyY1xccGx1Z2luc1xca2V5cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW5LZXkgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIFRoZSB1bmlxdWUgcHJvc2VtaXJyb3IgcGx1Z2luIGtleSBmb3Igc3luY1BsdWdpblxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHlTeW5jUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgneS1zeW5jJylcblxuLyoqXG4gKiBUaGUgdW5pcXVlIHByb3NlbWlycm9yIHBsdWdpbiBrZXkgZm9yIHVuZG9QbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5VW5kb1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3ktdW5kbycpXG5cbi8qKlxuICogVGhlIHVuaXF1ZSBwcm9zZW1pcnJvciBwbHVnaW4ga2V5IGZvciBjdXJzb3JQbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5Q3Vyc29yUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgneWpzLWN1cnNvcicpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/sync-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProsemirrorBinding: () => (/* binding */ ProsemirrorBinding),\n/* harmony export */   attributesToMarks: () => (/* binding */ attributesToMarks),\n/* harmony export */   createEmptyMeta: () => (/* binding */ createEmptyMeta),\n/* harmony export */   createNodeFromYElement: () => (/* binding */ createNodeFromYElement),\n/* harmony export */   getRelativeSelection: () => (/* binding */ getRelativeSelection),\n/* harmony export */   isVisible: () => (/* binding */ isVisible),\n/* harmony export */   updateYFragment: () => (/* binding */ updateYFragment),\n/* harmony export */   ySyncPlugin: () => (/* binding */ ySyncPlugin),\n/* harmony export */   yattr2markname: () => (/* binding */ yattr2markname)\n/* harmony export */ });\n/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/mutex */ \"(app-pages-browser)/./node_modules/lib0/mutex.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/math */ \"(app-pages-browser)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/object */ \"(app-pages-browser)/./node_modules/lib0/object.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/set */ \"(app-pages-browser)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_diff__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/diff */ \"(app-pages-browser)/./node_modules/lib0/diff.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/error */ \"(app-pages-browser)/./node_modules/lib0/error.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(app-pages-browser)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/random */ \"(app-pages-browser)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/environment */ \"(app-pages-browser)/./node_modules/lib0/environment.js\");\n/* harmony import */ var lib0_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/dom */ \"(app-pages-browser)/./node_modules/lib0/dom.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/eventloop */ \"(app-pages-browser)/./node_modules/lib0/eventloop.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/map */ \"(app-pages-browser)/./node_modules/lib0/map.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/utils.js\");\n/**\n * @module bindings/prosemirror\n */\n\n\n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} BindingMetadata\n * @property {ProsemirrorMapping} BindingMetadata.mapping\n * @property {Map<import('prosemirror-model').MarkType, boolean>} BindingMetadata.isOMark - is overlapping mark\n */\n\n/**\n * @return BindingMetadata\n */\nconst createEmptyMeta = () => ({\n  mapping: new Map(),\n  isOMark: new Map()\n})\n\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */\nconst isVisible = (item, snapshot) =>\n  snapshot === undefined\n    ? !item.deleted\n    : (snapshot.sv.has(item.id.client) && /** @type {number} */\n      (snapshot.sv.get(item.id.client)) > item.id.clock &&\n      !yjs__WEBPACK_IMPORTED_MODULE_0__.isDeleted(snapshot.ds, item.id))\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType<any>, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */\n\n/**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */\n\n/**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n * @property {ProsemirrorMapping} [YSyncOpts.mapping]\n * @property {function} [YSyncOpts.onFirstRender] Fired when the content from Yjs is initially rendered to ProseMirror\n */\n\n/**\n * @type {Array<ColorDef>}\n */\nconst defaultColors = [{ light: '#ecd44433', dark: '#ecd444' }]\n\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */\nconst getUserColor = (colorMapping, colors, user) => {\n  // @todo do not hit the same color twice if possible\n  if (!colorMapping.has(user)) {\n    if (colorMapping.size < colors.length) {\n      const usedColors = lib0_set__WEBPACK_IMPORTED_MODULE_1__.create()\n      colorMapping.forEach((color) => usedColors.add(color))\n      colors = colors.filter((color) => !usedColors.has(color))\n    }\n    colorMapping.set(user, lib0_random__WEBPACK_IMPORTED_MODULE_2__.oneOf(colors))\n  }\n  return /** @type {ColorDef} */ (colorMapping.get(user))\n}\n\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */\nconst ySyncPlugin = (yXmlFragment, {\n  colors = defaultColors,\n  colorMapping = new Map(),\n  permanentUserData = null,\n  onFirstRender = () => {},\n  mapping\n} = {}) => {\n  let initialContentChanged = false\n  const binding = new ProsemirrorBinding(yXmlFragment, mapping)\n  const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({\n    props: {\n      editable: (state) => {\n        const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(state)\n        return syncState.snapshot == null && syncState.prevSnapshot == null\n      }\n    },\n    key: _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey,\n    state: {\n      /**\n       * @returns {any}\n       */\n      init: (_initargs, _state) => {\n        return {\n          type: yXmlFragment,\n          doc: yXmlFragment.doc,\n          binding,\n          snapshot: null,\n          prevSnapshot: null,\n          isChangeOrigin: false,\n          isUndoRedoOperation: false,\n          addToHistory: true,\n          colors,\n          colorMapping,\n          permanentUserData\n        }\n      },\n      apply: (tr, pluginState) => {\n        const change = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n        if (change !== undefined) {\n          pluginState = Object.assign({}, pluginState)\n          for (const key in change) {\n            pluginState[key] = change[key]\n          }\n        }\n        pluginState.addToHistory = tr.getMeta('addToHistory') !== false\n        // always set isChangeOrigin. If undefined, this is not change origin.\n        pluginState.isChangeOrigin = change !== undefined &&\n          !!change.isChangeOrigin\n        pluginState.isUndoRedoOperation = change !== undefined && !!change.isChangeOrigin && !!change.isUndoRedoOperation\n        if (binding.prosemirrorView !== null) {\n          if (\n            change !== undefined &&\n            (change.snapshot != null || change.prevSnapshot != null)\n          ) {\n            // snapshot changed, rerender next\n            lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n              if (binding.prosemirrorView == null) {\n                return\n              }\n              if (change.restore == null) {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.prevSnapshot,\n                  pluginState\n                )\n              } else {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.snapshot,\n                  pluginState\n                )\n                // reset to current prosemirror state\n                delete pluginState.restore\n                delete pluginState.snapshot\n                delete pluginState.prevSnapshot\n                binding.mux(() => {\n                  binding._prosemirrorChanged(\n                    binding.prosemirrorView.state.doc\n                  )\n                })\n              }\n            })\n          }\n        }\n        return pluginState\n      }\n    },\n    view: (view) => {\n      binding.initView(view)\n      if (mapping == null) {\n        // force rerender to update the bindings mapping\n        binding._forceRerender()\n      }\n      onFirstRender()\n      return {\n        update: () => {\n          const pluginState = plugin.getState(view.state)\n          if (\n            pluginState.snapshot == null && pluginState.prevSnapshot == null\n          ) {\n            if (\n              // If the content doesn't change initially, we don't render anything to Yjs\n              // If the content was cleared by a user action, we want to catch the change and\n              // represent it in Yjs\n              initialContentChanged ||\n              view.state.doc.content.findDiffStart(\n                view.state.doc.type.createAndFill().content\n              ) !== null\n            ) {\n              initialContentChanged = true\n              if (\n                pluginState.addToHistory === false &&\n                !pluginState.isChangeOrigin\n              ) {\n                const yUndoPluginState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.yUndoPluginKey.getState(view.state)\n                /**\n                 * @type {Y.UndoManager}\n                 */\n                const um = yUndoPluginState && yUndoPluginState.undoManager\n                if (um) {\n                  um.stopCapturing()\n                }\n              }\n              binding.mux(() => {\n                /** @type {Y.Doc} */ (pluginState.doc).transact((tr) => {\n                  tr.meta.set('addToHistory', pluginState.addToHistory)\n                  binding._prosemirrorChanged(view.state.doc)\n                }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n              })\n            }\n          }\n        },\n        destroy: () => {\n          binding.destroy()\n        }\n      }\n    }\n  })\n  return plugin\n}\n\n/**\n * @param {any} tr\n * @param {any} relSel\n * @param {ProsemirrorBinding} binding\n */\nconst restoreRelativeSelection = (tr, relSel, binding) => {\n  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n    if (relSel.type === 'all') {\n      tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.AllSelection(tr.doc))\n    } else {\n      const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(\n        binding.doc,\n        binding.type,\n        relSel.anchor,\n        binding.mapping\n      )\n      const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(\n        binding.doc,\n        binding.type,\n        relSel.head,\n        binding.mapping\n      )\n      if (anchor !== null && head !== null) {\n        tr = tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, anchor, head))\n      }\n    }\n  }\n}\n\n/**\n * @param {ProsemirrorBinding} pmbinding\n * @param {import('prosemirror-state').EditorState} state\n */\nconst getRelativeSelection = (pmbinding, state) => ({\n  type: /** @type {any} */ (state.selection).jsonID,\n  anchor: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(\n    state.selection.anchor,\n    pmbinding.type,\n    pmbinding.mapping\n  ),\n  head: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(\n    state.selection.head,\n    pmbinding.type,\n    pmbinding.mapping\n  )\n})\n\n/**\n * Binding for prosemirror.\n *\n * @protected\n */\nclass ProsemirrorBinding {\n  /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {ProsemirrorMapping} mapping\n   */\n  constructor (yXmlFragment, mapping = new Map()) {\n    this.type = yXmlFragment\n    /**\n     * this will be set once the view is created\n     * @type {any}\n     */\n    this.prosemirrorView = null\n    this.mux = (0,lib0_mutex__WEBPACK_IMPORTED_MODULE_7__.createMutex)()\n    this.mapping = mapping\n    /**\n     * Is overlapping mark - i.e. mark does not exclude itself.\n     *\n     * @type {Map<import('prosemirror-model').MarkType, boolean>}\n     */\n    this.isOMark = new Map()\n    this._observeFunction = this._typeChanged.bind(this)\n    /**\n     * @type {Y.Doc}\n     */\n    // @ts-ignore\n    this.doc = yXmlFragment.doc\n    /**\n     * current selection as relative positions in the Yjs model\n     */\n    this.beforeTransactionSelection = null\n    this.beforeAllTransactions = () => {\n      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {\n        this.beforeTransactionSelection = getRelativeSelection(\n          this,\n          this.prosemirrorView.state\n        )\n      }\n    }\n    this.afterAllTransactions = () => {\n      this.beforeTransactionSelection = null\n    }\n    this._domSelectionInView = null\n  }\n\n  /**\n   * Create a transaction for changing the prosemirror state.\n   *\n   * @returns\n   */\n  get _tr () {\n    return this.prosemirrorView.state.tr.setMeta('addToHistory', false)\n  }\n\n  _isLocalCursorInView () {\n    if (!this.prosemirrorView.hasFocus()) return false\n    if (lib0_environment__WEBPACK_IMPORTED_MODULE_8__.isBrowser && this._domSelectionInView === null) {\n      // Calculate the domSelectionInView and clear by next tick after all events are finished\n      lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n        this._domSelectionInView = null\n      })\n      this._domSelectionInView = this._isDomSelectionInView()\n    }\n    return this._domSelectionInView\n  }\n\n  _isDomSelectionInView () {\n    const selection = this.prosemirrorView._root.getSelection()\n\n    if (selection == null || selection.anchorNode == null) return false\n\n    const range = this.prosemirrorView._root.createRange()\n    range.setStart(selection.anchorNode, selection.anchorOffset)\n    range.setEnd(selection.focusNode, selection.focusOffset)\n\n    // This is a workaround for an edgecase where getBoundingClientRect will\n    // return zero values if the selection is collapsed at the start of a newline\n    // see reference here: https://stackoverflow.com/a/59780954\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      // probably buggy newline behavior, explicitly select the node contents\n      if (range.startContainer && range.collapsed) {\n        range.selectNodeContents(range.startContainer)\n      }\n    }\n\n    const bounding = range.getBoundingClientRect()\n    const documentElement = lib0_dom__WEBPACK_IMPORTED_MODULE_9__.doc.documentElement\n\n    return bounding.bottom >= 0 && bounding.right >= 0 &&\n      bounding.left <=\n        (window.innerWidth || documentElement.clientWidth || 0) &&\n      bounding.top <= (window.innerHeight || documentElement.clientHeight || 0)\n  }\n\n  /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   */\n  renderSnapshot (snapshot, prevSnapshot) {\n    if (!prevSnapshot) {\n      prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.createSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.createDeleteSet(), new Map())\n    }\n    this.prosemirrorView.dispatch(\n      this._tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot, prevSnapshot })\n    )\n  }\n\n  unrenderSnapshot () {\n    this.mapping.clear()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot: null, prevSnapshot: null })\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _forceRerender () {\n    this.mapping.clear()\n    this.mux(() => {\n      // If this is a forced rerender, this might neither happen as a pm change nor within a Yjs\n      // transaction. Then the \"before selection\" doesn't exist. In this case, we need to create a\n      // relative position before replacing content. Fixes #126\n      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      if (sel) {\n        /**\n         * If the Prosemirror document we just created from this.type is\n         * smaller than the previous document, the selection might be\n         * out of bound, which would make Prosemirror throw an error.\n         */\n        const clampedAnchor = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(lib0_math__WEBPACK_IMPORTED_MODULE_11__.max(sel.anchor, 0), tr.doc.content.size)\n        const clampedHead = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(lib0_math__WEBPACK_IMPORTED_MODULE_11__.max(sel.head, 0), tr.doc.content.size)\n\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, clampedAnchor, clampedHead))\n      }\n      this.prosemirrorView.dispatch(\n        tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true, binding: this })\n      )\n    })\n  }\n\n  /**\n   * @param {Y.Snapshot|Uint8Array} snapshot\n   * @param {Y.Snapshot|Uint8Array} prevSnapshot\n   * @param {Object} pluginState\n   */\n  _renderSnapshot (snapshot, prevSnapshot, pluginState) {\n    /**\n     * The document that contains the full history of this document.\n     * @type {Y.Doc}\n     */\n    let historyDoc = this.doc\n    if (!snapshot) {\n      snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc)\n    }\n    if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {\n      if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {\n        // expected both snapshots to be v2 updates\n        lib0_error__WEBPACK_IMPORTED_MODULE_12__.unexpectedCase()\n      }\n      historyDoc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc({ gc: false })\n      yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, prevSnapshot)\n      prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc)\n      yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, snapshot)\n      snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc)\n    }\n    // clear mapping because we are going to rerender\n    this.mapping.clear()\n    this.mux(() => {\n      historyDoc.transact((transaction) => {\n        // before rendering, we are going to sanitize ops and split deleted ops\n        // if they were deleted by seperate users.\n        /**\n         * @type {Y.PermanentUserData}\n         */\n        const pud = pluginState.permanentUserData\n        if (pud) {\n          pud.dss.forEach((ds) => {\n            yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, ds, (_item) => {})\n          })\n        }\n        /**\n         * @param {'removed'|'added'} type\n         * @param {Y.ID} id\n         */\n        const computeYChange = (type, id) => {\n          const user = type === 'added'\n            ? pud.getUserByClientId(id.client)\n            : pud.getUserByDeletedId(id)\n          return {\n            user,\n            type,\n            color: getUserColor(\n              pluginState.colorMapping,\n              pluginState.colors,\n              user\n            )\n          }\n        }\n        // Create document fragment and render\n        const fragmentContent = yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(\n          this.type,\n          new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)\n        ).map((t) => {\n          if (\n            !t._item.deleted || isVisible(t._item, snapshot) ||\n            isVisible(t._item, prevSnapshot)\n          ) {\n            return createNodeFromYElement(\n              t,\n              this.prosemirrorView.state.schema,\n              { mapping: new Map(), isOMark: new Map() },\n              snapshot,\n              prevSnapshot,\n              computeYChange\n            )\n          } else {\n            // No need to render elements that are not visible by either snapshot.\n            // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n            return null\n          }\n        }).filter((n) => n !== null)\n        // @ts-ignore\n        const tr = this._tr.replace(\n          0,\n          this.prosemirrorView.state.doc.content.size,\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n        )\n        this.prosemirrorView.dispatch(\n          tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true })\n        )\n      }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    })\n  }\n\n  /**\n   * @param {Array<Y.YEvent<any>>} events\n   * @param {Y.Transaction} transaction\n   */\n  _typeChanged (events, transaction) {\n    if (this.prosemirrorView == null) return\n    const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(this.prosemirrorView.state)\n    if (\n      events.length === 0 || syncState.snapshot != null ||\n      syncState.prevSnapshot != null\n    ) {\n      // drop out if snapshot is active\n      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot)\n      return\n    }\n    this.mux(() => {\n      /**\n       * @param {any} _\n       * @param {Y.AbstractType<any>} type\n       */\n      const delType = (_, type) => this.mapping.delete(type)\n      yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(\n        transaction,\n        transaction.deleteSet,\n        (struct) => {\n          if (struct.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.Item) {\n            const type = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (struct).content).type\n            type && this.mapping.delete(type)\n          }\n        }\n      )\n      transaction.changed.forEach(delType)\n      transaction.changedParentTypes.forEach(delType)\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeIfNotExists(\n          /** @type {Y.XmlElement | Y.XmlHook} */ (t),\n          this.prosemirrorView.state.schema,\n          this\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      let tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0)\n      )\n      restoreRelativeSelection(tr, this.beforeTransactionSelection, this)\n      tr = tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.UndoManager })\n      if (\n        this.beforeTransactionSelection !== null && this._isLocalCursorInView()\n      ) {\n        tr.scrollIntoView()\n      }\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  /**\n   * @param {import('prosemirror-model').Node} doc\n   */\n  _prosemirrorChanged (doc) {\n    this.doc.transact(() => {\n      updateYFragment(this.doc, this.type, doc, this)\n      this.beforeTransactionSelection = getRelativeSelection(\n        this,\n        this.prosemirrorView.state\n      )\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n  }\n\n  /**\n   * View is ready to listen to changes. Register observers.\n   * @param {any} prosemirrorView\n   */\n  initView (prosemirrorView) {\n    if (this.prosemirrorView != null) this.destroy()\n    this.prosemirrorView = prosemirrorView\n    this.doc.on('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.on('afterAllTransactions', this.afterAllTransactions)\n    this.type.observeDeep(this._observeFunction)\n  }\n\n  destroy () {\n    if (this.prosemirrorView == null) return\n    this.prosemirrorView = null\n    this.type.unobserveDeep(this._observeFunction)\n    this.doc.off('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.off('afterAllTransactions', this.afterAllTransactions)\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {BindingMetadata} meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */\nconst createNodeIfNotExists = (\n  el,\n  schema,\n  meta,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const node = /** @type {PModel.Node} */ (meta.mapping.get(el))\n  if (node === undefined) {\n    if (el instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      return createNodeFromYElement(\n        el,\n        schema,\n        meta,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n    } else {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_12__.methodUnimplemented() // we are currently not handling hooks\n    }\n  }\n  return node\n}\n\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {BindingMetadata} meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */\nconst createNodeFromYElement = (\n  el,\n  schema,\n  meta,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const children = []\n  /**\n   * @param {Y.XmlElement | Y.XmlText} type\n   */\n  const createChildren = (type) => {\n    if (type instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      const n = createNodeIfNotExists(\n        type,\n        schema,\n        meta,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (n !== null) {\n        children.push(n)\n      }\n    } else {\n      // If the next ytext exists and was created by us, move the content to the current ytext.\n      // This is a fix for #160 -- duplication of characters when two Y.Text exist next to each\n      // other.\n      const nextytext = /** @type {Y.ContentType} */ (type._item.right?.content)?.type\n      if (nextytext instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Text && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {\n        type.applyDelta([\n          { retain: type.length },\n          ...nextytext.toDelta()\n        ])\n        nextytext.doc.transact(tr => {\n          nextytext._item.delete(tr)\n        })\n      }\n      // now create the prosemirror text nodes\n      const ns = createTextNodesFromYText(\n        type,\n        schema,\n        meta,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (ns !== null) {\n        ns.forEach((textchild) => {\n          if (textchild !== null) {\n            children.push(textchild)\n          }\n        })\n      }\n    }\n  }\n  if (snapshot === undefined || prevSnapshot === undefined) {\n    el.toArray().forEach(createChildren)\n  } else {\n    yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(el, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv))\n      .forEach(createChildren)\n  }\n  try {\n    const attrs = el.getAttributes(snapshot)\n    if (snapshot !== undefined) {\n      if (!isVisible(/** @type {Y.Item} */ (el._item), snapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('removed', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'removed' }\n      } else if (!isVisible(/** @type {Y.Item} */ (el._item), prevSnapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('added', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'added' }\n      }\n    }\n    const node = schema.node(el.nodeName, attrs, children)\n    meta.mapping.set(el, node)\n    return node\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (el.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (el._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    meta.mapping.delete(el)\n    return null\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {import('prosemirror-model').Schema} schema\n * @param {BindingMetadata} _meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */\nconst createTextNodesFromYText = (\n  text,\n  schema,\n  _meta,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const nodes = []\n  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange)\n  try {\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i]\n      nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)))\n    }\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (text.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (text._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    return null\n  }\n  // @ts-ignore\n  return nodes\n}\n\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {BindingMetadata} meta\n * @return {Y.XmlText}\n */\nconst createTypeFromTextNodes = (nodes, meta) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText()\n  const delta = nodes.map((node) => ({\n    // @ts-ignore\n    insert: node.text,\n    attributes: marksToAttributes(node.marks, meta)\n  }))\n  type.applyDelta(delta)\n  meta.mapping.set(type, nodes)\n  return type\n}\n\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {BindingMetadata} meta\n * @return {Y.XmlElement}\n */\nconst createTypeFromElementNode = (node, meta) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement(node.type.name)\n  for (const key in node.attrs) {\n    const val = node.attrs[key]\n    if (val !== null && key !== 'ychange') {\n      type.setAttribute(key, val)\n    }\n  }\n  type.insert(\n    0,\n    normalizePNodeContent(node).map((n) =>\n      createTypeFromTextOrElementNode(n, meta)\n    )\n  )\n  meta.mapping.set(type, node)\n  return type\n}\n\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {BindingMetadata} meta\n * @return {Y.XmlElement|Y.XmlText}\n */\nconst createTypeFromTextOrElementNode = (node, meta) =>\n  node instanceof Array\n    ? createTypeFromTextNodes(node, meta)\n    : createTypeFromElementNode(node, meta)\n\n/**\n * @param {any} val\n */\nconst isObject = (val) => typeof val === 'object' && val !== null\n\n/**\n * @param {any} pattrs\n * @param {any} yattrs\n */\nconst equalAttrs = (pattrs, yattrs) => {\n  const keys = Object.keys(pattrs).filter((key) => pattrs[key] !== null)\n  let eq =\n    keys.length ===\n      Object.keys(yattrs).filter((key) => yattrs[key] !== null).length\n  for (let i = 0; i < keys.length && eq; i++) {\n    const key = keys[i]\n    const l = pattrs[key]\n    const r = yattrs[key]\n    eq = key === 'ychange' || l === r ||\n      (isObject(l) && isObject(r) && equalAttrs(l, r))\n  }\n  return eq\n}\n\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */\n\n/**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */\nconst normalizePNodeContent = (pnode) => {\n  const c = pnode.content.content\n  const res = []\n  for (let i = 0; i < c.length; i++) {\n    const n = c[i]\n    if (n.isText) {\n      const textNodes = []\n      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n        textNodes.push(tnode)\n      }\n      i--\n      res.push(textNodes)\n    } else {\n      res.push(n)\n    }\n  }\n  return res\n}\n\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */\nconst equalYTextPText = (ytext, ptexts) => {\n  const delta = ytext.toDelta()\n  return delta.length === ptexts.length &&\n    delta.every(/** @type {(d:any,i:number) => boolean} */ (d, i) =>\n      d.insert === /** @type {any} */ (ptexts[i]).text &&\n      lib0_object__WEBPACK_IMPORTED_MODULE_13__.keys(d.attributes || {}).length === ptexts[i].marks.length &&\n      lib0_object__WEBPACK_IMPORTED_MODULE_13__.every(d.attributes, (attr, yattrname) => {\n        const markname = yattr2markname(yattrname)\n        const pmarks = ptexts[i].marks\n        return equalAttrs(attr, pmarks.find(/** @param {any} mark */ mark => mark.type.name === markname)?.attrs)\n      })\n    )\n}\n\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */\nconst equalYTypePNode = (ytype, pnode) => {\n  if (\n    ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && !(pnode instanceof Array) &&\n    matchNodeName(ytype, pnode)\n  ) {\n    const normalizedContent = normalizePNodeContent(pnode)\n    return ytype._length === normalizedContent.length &&\n      equalAttrs(ytype.getAttributes(), pnode.attrs) &&\n      ytype.toArray().every((ychild, i) =>\n        equalYTypePNode(ychild, normalizedContent[i])\n      )\n  }\n  return ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && pnode instanceof Array &&\n    equalYTextPText(ytype, pnode)\n}\n\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */\nconst mappedIdentity = (mapped, pcontent) =>\n  mapped === pcontent ||\n  (mapped instanceof Array && pcontent instanceof Array &&\n    mapped.length === pcontent.length && mapped.every((a, i) =>\n    pcontent[i] === a\n  ))\n\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {BindingMetadata} meta\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */\nconst computeChildEqualityFactor = (ytype, pnode, meta) => {\n  const yChildren = ytype.toArray()\n  const pChildren = normalizePNodeContent(pnode)\n  const pChildCnt = pChildren.length\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(yChildCnt, pChildCnt)\n  let left = 0\n  let right = 0\n  let foundMappedChild = false\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (mappedIdentity(meta.mapping.get(leftY), leftP)) {\n      foundMappedChild = true // definite (good) match!\n    } else if (!equalYTypePNode(leftY, leftP)) {\n      break\n    }\n  }\n  for (; left + right < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (mappedIdentity(meta.mapping.get(rightY), rightP)) {\n      foundMappedChild = true\n    } else if (!equalYTypePNode(rightY, rightP)) {\n      break\n    }\n  }\n  return {\n    equalityFactor: left + right,\n    foundMappedChild\n  }\n}\n\n/**\n * @param {Y.Text} ytext\n */\nconst ytextTrans = (ytext) => {\n  let str = ''\n  /**\n   * @type {Y.Item|null}\n   */\n  let n = ytext._start\n  const nAttrs = {}\n  while (n !== null) {\n    if (!n.deleted) {\n      if (n.countable && n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentString) {\n        str += n.content.str\n      } else if (n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentFormat) {\n        nAttrs[n.content.key] = null\n      }\n    }\n    n = n.right\n  }\n  return {\n    str,\n    nAttrs\n  }\n}\n\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {BindingMetadata} meta\n */\nconst updateYText = (ytext, ptexts, meta) => {\n  meta.mapping.set(ytext, ptexts)\n  const { nAttrs, str } = ytextTrans(ytext)\n  const content = ptexts.map((p) => ({\n    insert: /** @type {any} */ (p).text,\n    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks, meta))\n  }))\n  const { insert, remove, index } = (0,lib0_diff__WEBPACK_IMPORTED_MODULE_14__.simpleDiff)(\n    str,\n    content.map((c) => c.insert).join('')\n  )\n  ytext.delete(index, remove)\n  ytext.insert(index, insert)\n  ytext.applyDelta(\n    content.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))\n  )\n}\n\nconst hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/\n/**\n * @param {string} attrName\n */\nconst yattr2markname = attrName => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName\n\n/**\n * @todo move this to markstoattributes\n *\n * @param {Object<string, any>} attrs\n * @param {import('prosemirror-model').Schema} schema\n */\nconst attributesToMarks = (attrs, schema) => {\n  /**\n   * @type {Array<import('prosemirror-model').Mark>}\n   */\n  const marks = []\n  for (const markName in attrs) {\n    // remove hashes if necessary\n    marks.push(schema.mark(yattr2markname(markName), attrs[markName]))\n  }\n  return marks\n}\n\n/**\n * @param {Array<import('prosemirror-model').Mark>} marks\n * @param {BindingMetadata} meta\n */\nconst marksToAttributes = (marks, meta) => {\n  const pattrs = {}\n  marks.forEach((mark) => {\n    if (mark.type.name !== 'ychange') {\n      const isOverlapping = lib0_map__WEBPACK_IMPORTED_MODULE_15__.setIfUndefined(meta.isOMark, mark.type, () => !mark.type.excludes(mark.type))\n      pattrs[isOverlapping ? `${mark.type.name}--${_utils_js__WEBPACK_IMPORTED_MODULE_16__.hashOfJSON(mark.toJSON())}` : mark.type.name] = mark.attrs\n    }\n  })\n  return pattrs\n}\n\n/**\n * Update a yDom node by syncing the current content of the prosemirror node.\n *\n * This is a y-prosemirror internal feature that you can use at your own risk.\n *\n * @private\n * @unstable\n *\n * @param {{transact: Function}} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {BindingMetadata} meta\n */\nconst updateYFragment = (y, yDomFragment, pNode, meta) => {\n  if (\n    yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n    yDomFragment.nodeName !== pNode.type.name\n  ) {\n    throw new Error('node name mismatch!')\n  }\n  meta.mapping.set(yDomFragment, pNode)\n  // update attributes\n  if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n    const yDomAttrs = yDomFragment.getAttributes()\n    const pAttrs = pNode.attrs\n    for (const key in pAttrs) {\n      if (pAttrs[key] !== null) {\n        if (yDomAttrs[key] !== pAttrs[key] && key !== 'ychange') {\n          yDomFragment.setAttribute(key, pAttrs[key])\n        }\n      } else {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n    // remove all keys that are no longer in pAttrs\n    for (const key in yDomAttrs) {\n      if (pAttrs[key] === undefined) {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n  }\n  // update children\n  const pChildren = normalizePNodeContent(pNode)\n  const pChildCnt = pChildren.length\n  const yChildren = yDomFragment.toArray()\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(pChildCnt, yChildCnt)\n  let left = 0\n  let right = 0\n  // find number of matching elements from left\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (!mappedIdentity(meta.mapping.get(leftY), leftP)) {\n      if (equalYTypePNode(leftY, leftP)) {\n        // update mapping\n        meta.mapping.set(leftY, leftP)\n      } else {\n        break\n      }\n    }\n  }\n  // find number of matching elements from right\n  for (; right + left + 1 < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (!mappedIdentity(meta.mapping.get(rightY), rightP)) {\n      if (equalYTypePNode(rightY, rightP)) {\n        // update mapping\n        meta.mapping.set(rightY, rightP)\n      } else {\n        break\n      }\n    }\n  }\n  y.transact(() => {\n    // try to compare and update\n    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n      const leftY = yChildren[left]\n      const leftP = pChildren[left]\n      const rightY = yChildren[yChildCnt - right - 1]\n      const rightP = pChildren[pChildCnt - right - 1]\n      if (leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && leftP instanceof Array) {\n        if (!equalYTextPText(leftY, leftP)) {\n          updateYText(leftY, leftP, meta)\n        }\n        left += 1\n      } else {\n        let updateLeft = leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n          matchNodeName(leftY, leftP)\n        let updateRight = rightY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement &&\n          matchNodeName(rightY, rightP)\n        if (updateLeft && updateRight) {\n          // decide which which element to update\n          const equalityLeft = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            meta\n          )\n          const equalityRight = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            meta\n          )\n          if (\n            equalityLeft.foundMappedChild && !equalityRight.foundMappedChild\n          ) {\n            updateRight = false\n          } else if (\n            !equalityLeft.foundMappedChild && equalityRight.foundMappedChild\n          ) {\n            updateLeft = false\n          } else if (\n            equalityLeft.equalityFactor < equalityRight.equalityFactor\n          ) {\n            updateLeft = false\n          } else {\n            updateRight = false\n          }\n        }\n        if (updateLeft) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            meta\n          )\n          left += 1\n        } else if (updateRight) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            meta\n          )\n          right += 1\n        } else {\n          meta.mapping.delete(yDomFragment.get(left))\n          yDomFragment.delete(left, 1)\n          yDomFragment.insert(left, [\n            createTypeFromTextOrElementNode(leftP, meta)\n          ])\n          left += 1\n        }\n      }\n    }\n    const yDelLen = yChildCnt - left - right\n    if (\n      yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText\n    ) {\n      meta.mapping.delete(yChildren[0])\n      // Edge case handling https://github.com/yjs/y-prosemirror/issues/108\n      // Only delete the content of the Y.Text to retain remote changes on the same Y.Text object\n      yChildren[0].delete(0, yChildren[0].length)\n    } else if (yDelLen > 0) {\n      yDomFragment.slice(left, left + yDelLen).forEach(type => meta.mapping.delete(type))\n      yDomFragment.delete(left, yDelLen)\n    }\n    if (left + right < pChildCnt) {\n      const ins = []\n      for (let i = left; i < pChildCnt - right; i++) {\n        ins.push(createTypeFromTextOrElementNode(pChildren[i], meta))\n      }\n      yDomFragment.insert(left, ins)\n    }\n  }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n}\n\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */\nconst matchNodeName = (yElement, pNode) =>\n  !(pNode instanceof Array) && yElement.nodeName === pNode.type.name\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL3N5bmMtcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUV3QztBQUNHO0FBQzZCLENBQUM7QUFDeEM7QUFDSTtBQUNOO0FBQ087QUFDSDtBQUN1QjtBQUNsQztBQUlOO0FBQ21CO0FBQ1U7QUFDaEI7QUFDWTtBQUNaO0FBQ0s7O0FBRXBDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsb0RBQW9EO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQSxPQUFPLDBDQUFXOztBQUVsQjtBQUNBO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekU7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLHNCQUFzQjtBQUNwQyxjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLFVBQVU7QUFDeEI7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUIscUNBQXFDOztBQUU5RDtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQVk7QUFDdkM7QUFDQSxvQkFBb0IsVUFBVTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFdBQVc7QUFDdEIsWUFBWSxLQUFLO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0EscUJBQXFCLHFEQUFNO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQWM7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxTQUFTLG9EQUFjO0FBQ3ZCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0NBQWtDLG9EQUFjO0FBQ2hEO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0RBQWM7QUFDdkQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsb0RBQWM7QUFDakMsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBWTtBQUN0QyxNQUFNO0FBQ04scUJBQXFCLDJFQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJFQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNERBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLHlDQUF5QztBQUNwRDtBQUNPO0FBQ1AsbUJBQW1CLEtBQUs7QUFDeEIsVUFBVSwyRUFBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJFQUFrQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZUFBZSx1REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsdURBQXFCO0FBQzdCO0FBQ0EsTUFBTSxtREFBaUI7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIseUNBQU87O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQ0FBZ0IsQ0FBQyxnREFBaUI7QUFDdkQ7QUFDQTtBQUNBLHVCQUF1QixvREFBYyxJQUFJLHdCQUF3QjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBWSxDQUFDLHdEQUFlO0FBQ3hDO0FBQ0EsaUJBQWlCLG9EQUFjLElBQUksb0NBQW9DO0FBQ3ZFO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFZLENBQUMsd0RBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQVEsQ0FBQywyQ0FBUTtBQUMvQyw0QkFBNEIsMkNBQVEsQ0FBQywyQ0FBUTs7QUFFN0Msd0JBQXdCLDREQUFhO0FBQ3JDO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQWMsSUFBSSxxQ0FBcUM7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlDQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBb0I7QUFDNUI7QUFDQSx1QkFBdUIsb0NBQUssR0FBRyxXQUFXO0FBQzFDLE1BQU0sOENBQWU7QUFDckIscUJBQXFCLHlDQUFVO0FBQy9CLE1BQU0sOENBQWU7QUFDckIsaUJBQWlCLHlDQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUF1QiwrQkFBK0I7QUFDbEUsV0FBVztBQUNYO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUF5QjtBQUN6RDtBQUNBLGNBQWMseUNBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFZLENBQUMsd0RBQWU7QUFDMUM7QUFDQTtBQUNBLHFCQUFxQixvREFBYyxJQUFJLHNCQUFzQjtBQUM3RDtBQUNBLE9BQU8sRUFBRSxvREFBYztBQUN2QixLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEIsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0EsTUFBTSxzREFBdUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFDQUFNO0FBQzNDLG9DQUFvQyxlQUFlLGVBQWUsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBWSxDQUFDLHdEQUFlO0FBQ3hDO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQWMsSUFBSSx5RUFBeUUsNENBQWEsRUFBRTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLG9EQUFjO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLHlDQUF5QztBQUNwRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQSxzQkFBc0IsMkNBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLDREQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsS0FBSztBQUNoQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcseUNBQXlDO0FBQ3BELFlBQVksb0JBQW9CO0FBQ2hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0Esd0JBQXdCLDJDQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQsK0JBQStCLHFDQUFNO0FBQ3JDO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSSx3REFBeUIsU0FBUyx5Q0FBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCxjQUFjO0FBQ2QsUUFBUSwrQkFBK0IsUUFBUTtBQUMvQztBQUNBLCtDQUErQyxRQUFRO0FBQ3ZELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCLEtBQUssRUFBRSxvREFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsV0FBVyx5Q0FBeUM7QUFDcEQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCLEtBQUssRUFBRSxvREFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxtQkFBbUIsd0NBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BEOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hELDhCQUE4QixLQUFLO0FBQ25DLE1BQU0sOENBQVcsbUJBQW1CO0FBQ3BDLE1BQU0sK0NBQVk7QUFDbEI7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBUztBQUNuQztBQUNBOztBQUVBO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQsV0FBVyxrQ0FBa0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsaUJBQWlCO0FBQzVCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUJBQXVCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4Q0FBZTtBQUM3RDtBQUNBLFFBQVEsOEJBQThCLDhDQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsZ0NBQWdDO0FBQ2hDLEdBQUc7QUFDSCxVQUFVLHdCQUF3QixFQUFFLHNEQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBbUQ7QUFDN0U7QUFDQTs7QUFFQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ087QUFDUDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxREFBa0I7QUFDOUMsZ0NBQWdDLGVBQWUsSUFBSSxrREFBZ0IsZ0JBQWdCO0FBQ25GO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLFdBQVcsZUFBZTtBQUMxQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDTztBQUNQO0FBQ0EsNEJBQTRCLDJDQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyQkFBMkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMENBQTBDLDJDQUFZO0FBQ3REO0FBQ0EsNENBQTRDLDJDQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0Qyx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx3Q0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG9EQUFjO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFx0dW9uLWlvLXYxXFxub2RlX21vZHVsZXNcXHktcHJvc2VtaXJyb3JcXHNyY1xccGx1Z2luc1xcc3luYy1wbHVnaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGJpbmRpbmdzL3Byb3NlbWlycm9yXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlTXV0ZXggfSBmcm9tICdsaWIwL211dGV4J1xuaW1wb3J0ICogYXMgUE1vZGVsIGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJ1xuaW1wb3J0IHsgQWxsU2VsZWN0aW9uLCBQbHVnaW4sIFRleHRTZWxlY3Rpb24gfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnbGliMC9vYmplY3QnXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnbGliMC9zZXQnXG5pbXBvcnQgeyBzaW1wbGVEaWZmIH0gZnJvbSAnbGliMC9kaWZmJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5LCB5VW5kb1BsdWdpbktleSB9IGZyb20gJy4va2V5cy5qcydcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHtcbiAgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbixcbiAgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvblxufSBmcm9tICcuLi9saWIuanMnXG5pbXBvcnQgKiBhcyByYW5kb20gZnJvbSAnbGliMC9yYW5kb20nXG5pbXBvcnQgKiBhcyBlbnZpcm9ubWVudCBmcm9tICdsaWIwL2Vudmlyb25tZW50J1xuaW1wb3J0ICogYXMgZG9tIGZyb20gJ2xpYjAvZG9tJ1xuaW1wb3J0ICogYXMgZXZlbnRsb29wIGZyb20gJ2xpYjAvZXZlbnRsb29wJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQmluZGluZ01ldGFkYXRhXG4gKiBAcHJvcGVydHkge1Byb3NlbWlycm9yTWFwcGluZ30gQmluZGluZ01ldGFkYXRhLm1hcHBpbmdcbiAqIEBwcm9wZXJ0eSB7TWFwPGltcG9ydCgncHJvc2VtaXJyb3ItbW9kZWwnKS5NYXJrVHlwZSwgYm9vbGVhbj59IEJpbmRpbmdNZXRhZGF0YS5pc09NYXJrIC0gaXMgb3ZlcmxhcHBpbmcgbWFya1xuICovXG5cbi8qKlxuICogQHJldHVybiBCaW5kaW5nTWV0YWRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVtcHR5TWV0YSA9ICgpID0+ICh7XG4gIG1hcHBpbmc6IG5ldyBNYXAoKSxcbiAgaXNPTWFyazogbmV3IE1hcCgpXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7WS5JdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT5cbiAgc25hcHNob3QgPT09IHVuZGVmaW5lZFxuICAgID8gIWl0ZW0uZGVsZXRlZFxuICAgIDogKHNuYXBzaG90LnN2LmhhcyhpdGVtLmlkLmNsaWVudCkgJiYgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAoc25hcHNob3Quc3YuZ2V0KGl0ZW0uaWQuY2xpZW50KSkgPiBpdGVtLmlkLmNsb2NrICYmXG4gICAgICAhWS5pc0RlbGV0ZWQoc25hcHNob3QuZHMsIGl0ZW0uaWQpKVxuXG4vKipcbiAqIEVpdGhlciBhIG5vZGUgaWYgdHlwZSBpcyBZWG1sRWxlbWVudCBvciBhbiBBcnJheSBvZiB0ZXh0IG5vZGVzIGlmIFlYbWxUZXh0XG4gKiBAdHlwZWRlZiB7TWFwPFkuQWJzdHJhY3RUeXBlPGFueT4sIFBNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+Pn0gUHJvc2VtaXJyb3JNYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xvckRlZlxuICogQHByb3BlcnR5IHtzdHJpbmd9IENvbG9yRGVmLmxpZ2h0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gQ29sb3JEZWYuZGFya1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWVN5bmNPcHRzXG4gKiBAcHJvcGVydHkge0FycmF5PENvbG9yRGVmPn0gW1lTeW5jT3B0cy5jb2xvcnNdXG4gKiBAcHJvcGVydHkge01hcDxzdHJpbmcsQ29sb3JEZWY+fSBbWVN5bmNPcHRzLmNvbG9yTWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7WS5QZXJtYW5lbnRVc2VyRGF0YXxudWxsfSBbWVN5bmNPcHRzLnBlcm1hbmVudFVzZXJEYXRhXVxuICogQHByb3BlcnR5IHtQcm9zZW1pcnJvck1hcHBpbmd9IFtZU3luY09wdHMubWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtZU3luY09wdHMub25GaXJzdFJlbmRlcl0gRmlyZWQgd2hlbiB0aGUgY29udGVudCBmcm9tIFlqcyBpcyBpbml0aWFsbHkgcmVuZGVyZWQgdG8gUHJvc2VNaXJyb3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxDb2xvckRlZj59XG4gKi9cbmNvbnN0IGRlZmF1bHRDb2xvcnMgPSBbeyBsaWdodDogJyNlY2Q0NDQzMycsIGRhcms6ICcjZWNkNDQ0JyB9XVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxDb2xvckRlZj59IGNvbG9yTWFwcGluZ1xuICogQHBhcmFtIHtBcnJheTxDb2xvckRlZj59IGNvbG9yc1xuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJcbiAqIEByZXR1cm4ge0NvbG9yRGVmfVxuICovXG5jb25zdCBnZXRVc2VyQ29sb3IgPSAoY29sb3JNYXBwaW5nLCBjb2xvcnMsIHVzZXIpID0+IHtcbiAgLy8gQHRvZG8gZG8gbm90IGhpdCB0aGUgc2FtZSBjb2xvciB0d2ljZSBpZiBwb3NzaWJsZVxuICBpZiAoIWNvbG9yTWFwcGluZy5oYXModXNlcikpIHtcbiAgICBpZiAoY29sb3JNYXBwaW5nLnNpemUgPCBjb2xvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1c2VkQ29sb3JzID0gc2V0LmNyZWF0ZSgpXG4gICAgICBjb2xvck1hcHBpbmcuZm9yRWFjaCgoY29sb3IpID0+IHVzZWRDb2xvcnMuYWRkKGNvbG9yKSlcbiAgICAgIGNvbG9ycyA9IGNvbG9ycy5maWx0ZXIoKGNvbG9yKSA9PiAhdXNlZENvbG9ycy5oYXMoY29sb3IpKVxuICAgIH1cbiAgICBjb2xvck1hcHBpbmcuc2V0KHVzZXIsIHJhbmRvbS5vbmVPZihjb2xvcnMpKVxuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0NvbG9yRGVmfSAqLyAoY29sb3JNYXBwaW5nLmdldCh1c2VyKSlcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBsaXN0ZW5zIHRvIGNoYW5nZXMgaW4gcHJvc2VtaXJyb3IgdmlldyBhbmQga2VlcHMgeVhtbFN0YXRlIGFuZCB2aWV3IGluIHN5bmMuXG4gKlxuICogVGhpcyBwbHVnaW4gYWxzbyBrZWVwcyByZWZlcmVuY2VzIHRvIHRoZSB0eXBlIGFuZCB0aGUgc2hhcmVkIGRvY3VtZW50IHNvIG90aGVyIHBsdWdpbnMgY2FuIGFjY2VzcyBpdC5cbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1lTeW5jT3B0c30gb3B0c1xuICogQHJldHVybiB7YW55fSBSZXR1cm5zIGEgcHJvc2VtaXJyb3IgcGx1Z2luIHRoYXQgYmluZHMgdG8gdGhpcyB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY1BsdWdpbiA9ICh5WG1sRnJhZ21lbnQsIHtcbiAgY29sb3JzID0gZGVmYXVsdENvbG9ycyxcbiAgY29sb3JNYXBwaW5nID0gbmV3IE1hcCgpLFxuICBwZXJtYW5lbnRVc2VyRGF0YSA9IG51bGwsXG4gIG9uRmlyc3RSZW5kZXIgPSAoKSA9PiB7fSxcbiAgbWFwcGluZ1xufSA9IHt9KSA9PiB7XG4gIGxldCBpbml0aWFsQ29udGVudENoYW5nZWQgPSBmYWxzZVxuICBjb25zdCBiaW5kaW5nID0gbmV3IFByb3NlbWlycm9yQmluZGluZyh5WG1sRnJhZ21lbnQsIG1hcHBpbmcpXG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHByb3BzOiB7XG4gICAgICBlZGl0YWJsZTogKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNTdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgICByZXR1cm4gc3luY1N0YXRlLnNuYXBzaG90ID09IG51bGwgJiYgc3luY1N0YXRlLnByZXZTbmFwc2hvdCA9PSBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBrZXk6IHlTeW5jUGx1Z2luS2V5LFxuICAgIHN0YXRlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICAgKi9cbiAgICAgIGluaXQ6IChfaW5pdGFyZ3MsIF9zdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHlYbWxGcmFnbWVudCxcbiAgICAgICAgICBkb2M6IHlYbWxGcmFnbWVudC5kb2MsXG4gICAgICAgICAgYmluZGluZyxcbiAgICAgICAgICBzbmFwc2hvdDogbnVsbCxcbiAgICAgICAgICBwcmV2U25hcHNob3Q6IG51bGwsXG4gICAgICAgICAgaXNDaGFuZ2VPcmlnaW46IGZhbHNlLFxuICAgICAgICAgIGlzVW5kb1JlZG9PcGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGFkZFRvSGlzdG9yeTogdHJ1ZSxcbiAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgY29sb3JNYXBwaW5nLFxuICAgICAgICAgIHBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcHBseTogKHRyLCBwbHVnaW5TdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0ci5nZXRNZXRhKHlTeW5jUGx1Z2luS2V5KVxuICAgICAgICBpZiAoY2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwbHVnaW5TdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBsdWdpblN0YXRlKVxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZSkge1xuICAgICAgICAgICAgcGx1Z2luU3RhdGVba2V5XSA9IGNoYW5nZVtrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdWdpblN0YXRlLmFkZFRvSGlzdG9yeSA9IHRyLmdldE1ldGEoJ2FkZFRvSGlzdG9yeScpICE9PSBmYWxzZVxuICAgICAgICAvLyBhbHdheXMgc2V0IGlzQ2hhbmdlT3JpZ2luLiBJZiB1bmRlZmluZWQsIHRoaXMgaXMgbm90IGNoYW5nZSBvcmlnaW4uXG4gICAgICAgIHBsdWdpblN0YXRlLmlzQ2hhbmdlT3JpZ2luID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAhIWNoYW5nZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICBwbHVnaW5TdGF0ZS5pc1VuZG9SZWRvT3BlcmF0aW9uID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiYgISFjaGFuZ2UuaXNDaGFuZ2VPcmlnaW4gJiYgISFjaGFuZ2UuaXNVbmRvUmVkb09wZXJhdGlvblxuICAgICAgICBpZiAoYmluZGluZy5wcm9zZW1pcnJvclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaGFuZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zbmFwc2hvdCAhPSBudWxsIHx8IGNoYW5nZS5wcmV2U25hcHNob3QgIT0gbnVsbClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHNuYXBzaG90IGNoYW5nZWQsIHJlcmVuZGVyIG5leHRcbiAgICAgICAgICAgIGV2ZW50bG9vcC50aW1lb3V0KDAsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJvc2VtaXJyb3JWaWV3ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgIHBsdWdpblN0YXRlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgcGx1Z2luU3RhdGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdG8gY3VycmVudCBwcm9zZW1pcnJvciBzdGF0ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW5TdGF0ZS5yZXN0b3JlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnNuYXBzaG90XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnByZXZTbmFwc2hvdFxuICAgICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmcuX3Byb3NlbWlycm9yQ2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsdWdpblN0YXRlXG4gICAgICB9XG4gICAgfSxcbiAgICB2aWV3OiAodmlldykgPT4ge1xuICAgICAgYmluZGluZy5pbml0Vmlldyh2aWV3KVxuICAgICAgaWYgKG1hcHBpbmcgPT0gbnVsbCkge1xuICAgICAgICAvLyBmb3JjZSByZXJlbmRlciB0byB1cGRhdGUgdGhlIGJpbmRpbmdzIG1hcHBpbmdcbiAgICAgICAgYmluZGluZy5fZm9yY2VSZXJlbmRlcigpXG4gICAgICB9XG4gICAgICBvbkZpcnN0UmVuZGVyKClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gcGx1Z2luLmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGx1Z2luU3RhdGUuc25hcHNob3QgPT0gbnVsbCAmJiBwbHVnaW5TdGF0ZS5wcmV2U25hcHNob3QgPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyBJZiB0aGUgY29udGVudCBkb2Vzbid0IGNoYW5nZSBpbml0aWFsbHksIHdlIGRvbid0IHJlbmRlciBhbnl0aGluZyB0byBZanNcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgd2FzIGNsZWFyZWQgYnkgYSB1c2VyIGFjdGlvbiwgd2Ugd2FudCB0byBjYXRjaCB0aGUgY2hhbmdlIGFuZFxuICAgICAgICAgICAgICAvLyByZXByZXNlbnQgaXQgaW4gWWpzXG4gICAgICAgICAgICAgIGluaXRpYWxDb250ZW50Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICB2aWV3LnN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5kb2MudHlwZS5jcmVhdGVBbmRGaWxsKCkuY29udGVudFxuICAgICAgICAgICAgICApICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnRDaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYWRkVG9IaXN0b3J5ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFwbHVnaW5TdGF0ZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5VW5kb1BsdWdpblN0YXRlID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7WS5VbmRvTWFuYWdlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB1bSA9IHlVbmRvUGx1Z2luU3RhdGUgJiYgeVVuZG9QbHVnaW5TdGF0ZS51bmRvTWFuYWdlclxuICAgICAgICAgICAgICAgIGlmICh1bSkge1xuICAgICAgICAgICAgICAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge1kuRG9jfSAqLyAocGx1Z2luU3RhdGUuZG9jKS50cmFuc2FjdCgodHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyLm1ldGEuc2V0KCdhZGRUb0hpc3RvcnknLCBwbHVnaW5TdGF0ZS5hZGRUb0hpc3RvcnkpXG4gICAgICAgICAgICAgICAgICBiaW5kaW5nLl9wcm9zZW1pcnJvckNoYW5nZWQodmlldy5zdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgYmluZGluZy5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHBsdWdpblxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB0clxuICogQHBhcmFtIHthbnl9IHJlbFNlbFxuICogQHBhcmFtIHtQcm9zZW1pcnJvckJpbmRpbmd9IGJpbmRpbmdcbiAqL1xuY29uc3QgcmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uID0gKHRyLCByZWxTZWwsIGJpbmRpbmcpID0+IHtcbiAgaWYgKHJlbFNlbCAhPT0gbnVsbCAmJiByZWxTZWwuYW5jaG9yICE9PSBudWxsICYmIHJlbFNlbC5oZWFkICE9PSBudWxsKSB7XG4gICAgaWYgKHJlbFNlbC50eXBlID09PSAnYWxsJykge1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBBbGxTZWxlY3Rpb24odHIuZG9jKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYW5jaG9yID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgYmluZGluZy5kb2MsXG4gICAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgICAgcmVsU2VsLmFuY2hvcixcbiAgICAgICAgYmluZGluZy5tYXBwaW5nXG4gICAgICApXG4gICAgICBjb25zdCBoZWFkID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgYmluZGluZy5kb2MsXG4gICAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgICAgcmVsU2VsLmhlYWQsXG4gICAgICAgIGJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsKSB7XG4gICAgICAgIHRyID0gdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYW5jaG9yLCBoZWFkKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yQmluZGluZ30gcG1iaW5kaW5nXG4gKiBAcGFyYW0ge2ltcG9ydCgncHJvc2VtaXJyb3Itc3RhdGUnKS5FZGl0b3JTdGF0ZX0gc3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJlbGF0aXZlU2VsZWN0aW9uID0gKHBtYmluZGluZywgc3RhdGUpID0+ICh7XG4gIHR5cGU6IC8qKiBAdHlwZSB7YW55fSAqLyAoc3RhdGUuc2VsZWN0aW9uKS5qc29uSUQsXG4gIGFuY2hvcjogYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICBzdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLFxuICAgIHBtYmluZGluZy50eXBlLFxuICAgIHBtYmluZGluZy5tYXBwaW5nXG4gICksXG4gIGhlYWQ6IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgc3RhdGUuc2VsZWN0aW9uLmhlYWQsXG4gICAgcG1iaW5kaW5nLnR5cGUsXG4gICAgcG1iaW5kaW5nLm1hcHBpbmdcbiAgKVxufSlcblxuLyoqXG4gKiBCaW5kaW5nIGZvciBwcm9zZW1pcnJvci5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9zZW1pcnJvckJpbmRpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnQgVGhlIGJpbmQgc291cmNlXG4gICAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeVhtbEZyYWdtZW50LCBtYXBwaW5nID0gbmV3IE1hcCgpKSB7XG4gICAgdGhpcy50eXBlID0geVhtbEZyYWdtZW50XG4gICAgLyoqXG4gICAgICogdGhpcyB3aWxsIGJlIHNldCBvbmNlIHRoZSB2aWV3IGlzIGNyZWF0ZWRcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3ID0gbnVsbFxuICAgIHRoaXMubXV4ID0gY3JlYXRlTXV0ZXgoKVxuICAgIHRoaXMubWFwcGluZyA9IG1hcHBpbmdcbiAgICAvKipcbiAgICAgKiBJcyBvdmVybGFwcGluZyBtYXJrIC0gaS5lLiBtYXJrIGRvZXMgbm90IGV4Y2x1ZGUgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFya1R5cGUsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMuaXNPTWFyayA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX29ic2VydmVGdW5jdGlvbiA9IHRoaXMuX3R5cGVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WS5Eb2N9XG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZG9jID0geVhtbEZyYWdtZW50LmRvY1xuICAgIC8qKlxuICAgICAqIGN1cnJlbnQgc2VsZWN0aW9uIGFzIHJlbGF0aXZlIHBvc2l0aW9ucyBpbiB0aGUgWWpzIG1vZGVsXG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB0aGlzLmJlZm9yZUFsbFRyYW5zYWN0aW9ucyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID09PSBudWxsICYmIHRoaXMucHJvc2VtaXJyb3JWaWV3ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IGdldFJlbGF0aXZlU2VsZWN0aW9uKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zID0gKCkgPT4ge1xuICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGZvciBjaGFuZ2luZyB0aGUgcHJvc2VtaXJyb3Igc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXQgX3RyICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUudHIuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG4gIH1cblxuICBfaXNMb2NhbEN1cnNvckluVmlldyAoKSB7XG4gICAgaWYgKCF0aGlzLnByb3NlbWlycm9yVmlldy5oYXNGb2N1cygpKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoZW52aXJvbm1lbnQuaXNCcm93c2VyICYmIHRoaXMuX2RvbVNlbGVjdGlvbkluVmlldyA9PT0gbnVsbCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkb21TZWxlY3Rpb25JblZpZXcgYW5kIGNsZWFyIGJ5IG5leHQgdGljayBhZnRlciBhbGwgZXZlbnRzIGFyZSBmaW5pc2hlZFxuICAgICAgZXZlbnRsb29wLnRpbWVvdXQoMCwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSBudWxsXG4gICAgICB9KVxuICAgICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gdGhpcy5faXNEb21TZWxlY3Rpb25JblZpZXcoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3XG4gIH1cblxuICBfaXNEb21TZWxlY3Rpb25JblZpZXcgKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmdldFNlbGVjdGlvbigpXG5cbiAgICBpZiAoc2VsZWN0aW9uID09IG51bGwgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCByYW5nZSA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmNyZWF0ZVJhbmdlKClcbiAgICByYW5nZS5zZXRTdGFydChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldClcbiAgICByYW5nZS5zZXRFbmQoc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KVxuXG4gICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGFuIGVkZ2VjYXNlIHdoZXJlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB3aWxsXG4gICAgLy8gcmV0dXJuIHplcm8gdmFsdWVzIGlmIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkIGF0IHRoZSBzdGFydCBvZiBhIG5ld2xpbmVcbiAgICAvLyBzZWUgcmVmZXJlbmNlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81OTc4MDk1NFxuICAgIGNvbnN0IHJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKVxuICAgIGlmIChyZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHByb2JhYmx5IGJ1Z2d5IG5ld2xpbmUgYmVoYXZpb3IsIGV4cGxpY2l0bHkgc2VsZWN0IHRoZSBub2RlIGNvbnRlbnRzXG4gICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIgJiYgcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhyYW5nZS5zdGFydENvbnRhaW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBib3VuZGluZyA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZG9tLmRvYy5kb2N1bWVudEVsZW1lbnRcblxuICAgIHJldHVybiBib3VuZGluZy5ib3R0b20gPj0gMCAmJiBib3VuZGluZy5yaWdodCA+PSAwICYmXG4gICAgICBib3VuZGluZy5sZWZ0IDw9XG4gICAgICAgICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgJiZcbiAgICAgIGJvdW5kaW5nLnRvcCA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R9IHNuYXBzaG90XG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gcHJldlNuYXBzaG90XG4gICAqL1xuICByZW5kZXJTbmFwc2hvdCAoc25hcHNob3QsIHByZXZTbmFwc2hvdCkge1xuICAgIGlmICghcHJldlNuYXBzaG90KSB7XG4gICAgICBwcmV2U25hcHNob3QgPSBZLmNyZWF0ZVNuYXBzaG90KFkuY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSlcbiAgICB9XG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICB0aGlzLl90ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IHNuYXBzaG90LCBwcmV2U25hcHNob3QgfSlcbiAgICApXG4gIH1cblxuICB1bnJlbmRlclNuYXBzaG90ICgpIHtcbiAgICB0aGlzLm1hcHBpbmcuY2xlYXIoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHRoaXMudHlwZS50b0FycmF5KCkubWFwKCh0KSA9PlxuICAgICAgICBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKVxuICAgICAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsXG4gICAgICAgIG5ldyBQTW9kZWwuU2xpY2UoUE1vZGVsLkZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgIClcbiAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgc25hcHNob3Q6IG51bGwsIHByZXZTbmFwc2hvdDogbnVsbCB9KVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIpXG4gICAgfSlcbiAgfVxuXG4gIF9mb3JjZVJlcmVuZGVyICgpIHtcbiAgICB0aGlzLm1hcHBpbmcuY2xlYXIoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmb3JjZWQgcmVyZW5kZXIsIHRoaXMgbWlnaHQgbmVpdGhlciBoYXBwZW4gYXMgYSBwbSBjaGFuZ2Ugbm9yIHdpdGhpbiBhIFlqc1xuICAgICAgLy8gdHJhbnNhY3Rpb24uIFRoZW4gdGhlIFwiYmVmb3JlIHNlbGVjdGlvblwiIGRvZXNuJ3QgZXhpc3QuIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBjcmVhdGUgYVxuICAgICAgLy8gcmVsYXRpdmUgcG9zaXRpb24gYmVmb3JlIHJlcGxhY2luZyBjb250ZW50LiBGaXhlcyAjMTI2XG4gICAgICBjb25zdCBzZWwgPSB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uICE9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNlbGVjdGlvblxuICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gdGhpcy50eXBlLnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgICAgIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovICh0KSxcbiAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApXG4gICAgICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKVxuICAgICAgaWYgKHNlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIFByb3NlbWlycm9yIGRvY3VtZW50IHdlIGp1c3QgY3JlYXRlZCBmcm9tIHRoaXMudHlwZSBpc1xuICAgICAgICAgKiBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzIGRvY3VtZW50LCB0aGUgc2VsZWN0aW9uIG1pZ2h0IGJlXG4gICAgICAgICAqIG91dCBvZiBib3VuZCwgd2hpY2ggd291bGQgbWFrZSBQcm9zZW1pcnJvciB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNsYW1wZWRBbmNob3IgPSBtYXRoLm1pbihtYXRoLm1heChzZWwuYW5jaG9yLCAwKSwgdHIuZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgY29uc3QgY2xhbXBlZEhlYWQgPSBtYXRoLm1pbihtYXRoLm1heChzZWwuaGVhZCwgMCksIHRyLmRvYy5jb250ZW50LnNpemUpXG5cbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgY2xhbXBlZEFuY2hvciwgY2xhbXBlZEhlYWQpKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgaXNDaGFuZ2VPcmlnaW46IHRydWUsIGJpbmRpbmc6IHRoaXMgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdHxVaW50OEFycmF5fSBzbmFwc2hvdFxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R8VWludDhBcnJheX0gcHJldlNuYXBzaG90XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5TdGF0ZVxuICAgKi9cbiAgX3JlbmRlclNuYXBzaG90IChzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBwbHVnaW5TdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkb2N1bWVudCB0aGF0IGNvbnRhaW5zIHRoZSBmdWxsIGhpc3Rvcnkgb2YgdGhpcyBkb2N1bWVudC5cbiAgICAgKiBAdHlwZSB7WS5Eb2N9XG4gICAgICovXG4gICAgbGV0IGhpc3RvcnlEb2MgPSB0aGlzLmRvY1xuICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgIHNuYXBzaG90ID0gWS5zbmFwc2hvdCh0aGlzLmRvYylcbiAgICB9XG4gICAgaWYgKHNuYXBzaG90IGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBwcmV2U25hcHNob3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBpZiAoIShzbmFwc2hvdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEocHJldlNuYXBzaG90IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgLy8gZXhwZWN0ZWQgYm90aCBzbmFwc2hvdHMgdG8gYmUgdjIgdXBkYXRlc1xuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgICB9XG4gICAgICBoaXN0b3J5RG9jID0gbmV3IFkuRG9jKHsgZ2M6IGZhbHNlIH0pXG4gICAgICBZLmFwcGx5VXBkYXRlVjIoaGlzdG9yeURvYywgcHJldlNuYXBzaG90KVxuICAgICAgcHJldlNuYXBzaG90ID0gWS5zbmFwc2hvdChoaXN0b3J5RG9jKVxuICAgICAgWS5hcHBseVVwZGF0ZVYyKGhpc3RvcnlEb2MsIHNuYXBzaG90KVxuICAgICAgc25hcHNob3QgPSBZLnNuYXBzaG90KGhpc3RvcnlEb2MpXG4gICAgfVxuICAgIC8vIGNsZWFyIG1hcHBpbmcgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gcmVyZW5kZXJcbiAgICB0aGlzLm1hcHBpbmcuY2xlYXIoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIGhpc3RvcnlEb2MudHJhbnNhY3QoKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIC8vIGJlZm9yZSByZW5kZXJpbmcsIHdlIGFyZSBnb2luZyB0byBzYW5pdGl6ZSBvcHMgYW5kIHNwbGl0IGRlbGV0ZWQgb3BzXG4gICAgICAgIC8vIGlmIHRoZXkgd2VyZSBkZWxldGVkIGJ5IHNlcGVyYXRlIHVzZXJzLlxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1kuUGVybWFuZW50VXNlckRhdGF9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwdWQgPSBwbHVnaW5TdGF0ZS5wZXJtYW5lbnRVc2VyRGF0YVxuICAgICAgICBpZiAocHVkKSB7XG4gICAgICAgICAgcHVkLmRzcy5mb3JFYWNoKChkcykgPT4ge1xuICAgICAgICAgICAgWS5pdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIGRzLCAoX2l0ZW0pID0+IHt9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7J3JlbW92ZWQnfCdhZGRlZCd9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtZLklEfSBpZFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29tcHV0ZVlDaGFuZ2UgPSAodHlwZSwgaWQpID0+IHtcbiAgICAgICAgICBjb25zdCB1c2VyID0gdHlwZSA9PT0gJ2FkZGVkJ1xuICAgICAgICAgICAgPyBwdWQuZ2V0VXNlckJ5Q2xpZW50SWQoaWQuY2xpZW50KVxuICAgICAgICAgICAgOiBwdWQuZ2V0VXNlckJ5RGVsZXRlZElkKGlkKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGNvbG9yOiBnZXRVc2VyQ29sb3IoXG4gICAgICAgICAgICAgIHBsdWdpblN0YXRlLmNvbG9yTWFwcGluZyxcbiAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuY29sb3JzLFxuICAgICAgICAgICAgICB1c2VyXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBkb2N1bWVudCBmcmFnbWVudCBhbmQgcmVuZGVyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IFkudHlwZUxpc3RUb0FycmF5U25hcHNob3QoXG4gICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgIG5ldyBZLlNuYXBzaG90KHByZXZTbmFwc2hvdC5kcywgc25hcHNob3Quc3YpXG4gICAgICAgICkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXQuX2l0ZW0uZGVsZXRlZCB8fCBpc1Zpc2libGUodC5faXRlbSwgc25hcHNob3QpIHx8XG4gICAgICAgICAgICBpc1Zpc2libGUodC5faXRlbSwgcHJldlNuYXBzaG90KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNjaGVtYSxcbiAgICAgICAgICAgICAgeyBtYXBwaW5nOiBuZXcgTWFwKCksIGlzT01hcms6IG5ldyBNYXAoKSB9LFxuICAgICAgICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHJlbmRlciBlbGVtZW50cyB0aGF0IGFyZSBub3QgdmlzaWJsZSBieSBlaXRoZXIgc25hcHNob3QuXG4gICAgICAgICAgICAvLyBJZiBhIGNsaWVudCBhZGRzIGFuZCBkZWxldGVzIGNvbnRlbnQgaW4gdGhlIHNhbWUgc25hcHNob3QgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgYnkgZWl0aGVyIHNuYXBzaG90LlxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLFxuICAgICAgICAgIG5ldyBQTW9kZWwuU2xpY2UoUE1vZGVsLkZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5kaXNwYXRjaChcbiAgICAgICAgICB0ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IGlzQ2hhbmdlT3JpZ2luOiB0cnVlIH0pXG4gICAgICAgIClcbiAgICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxZLllFdmVudDxhbnk+Pn0gZXZlbnRzXG4gICAqIEBwYXJhbSB7WS5UcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIF90eXBlQ2hhbmdlZCAoZXZlbnRzLCB0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLnByb3NlbWlycm9yVmlldyA9PSBudWxsKSByZXR1cm5cbiAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZSlcbiAgICBpZiAoXG4gICAgICBldmVudHMubGVuZ3RoID09PSAwIHx8IHN5bmNTdGF0ZS5zbmFwc2hvdCAhPSBudWxsIHx8XG4gICAgICBzeW5jU3RhdGUucHJldlNuYXBzaG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIC8vIGRyb3Agb3V0IGlmIHNuYXBzaG90IGlzIGFjdGl2ZVxuICAgICAgdGhpcy5yZW5kZXJTbmFwc2hvdChzeW5jU3RhdGUuc25hcHNob3QsIHN5bmNTdGF0ZS5wcmV2U25hcHNob3QpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2FueX0gX1xuICAgICAgICogQHBhcmFtIHtZLkFic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbFR5cGUgPSAoXywgdHlwZSkgPT4gdGhpcy5tYXBwaW5nLmRlbGV0ZSh0eXBlKVxuICAgICAgWS5pdGVyYXRlRGVsZXRlZFN0cnVjdHMoXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGVTZXQsXG4gICAgICAgIChzdHJ1Y3QpID0+IHtcbiAgICAgICAgICBpZiAoc3RydWN0LmNvbnN0cnVjdG9yID09PSBZLkl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICgvKiogQHR5cGUge1kuSXRlbX0gKi8gKHN0cnVjdCkuY29udGVudCkudHlwZVxuICAgICAgICAgICAgdHlwZSAmJiB0aGlzLm1hcHBpbmcuZGVsZXRlKHR5cGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goZGVsVHlwZSlcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5mb3JFYWNoKGRlbFR5cGUpXG4gICAgICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSB0aGlzLnR5cGUudG9BcnJheSgpLm1hcCgodCkgPT5cbiAgICAgICAgY3JlYXRlTm9kZUlmTm90RXhpc3RzKFxuICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50IHwgWS5YbWxIb29rfSAqLyAodCksXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKVxuICAgICAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsZXQgdHIgPSB0aGlzLl90ci5yZXBsYWNlKFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLFxuICAgICAgICBuZXcgUE1vZGVsLlNsaWNlKFBNb2RlbC5GcmFnbWVudC5mcm9tKGZyYWdtZW50Q29udGVudCksIDAsIDApXG4gICAgICApXG4gICAgICByZXN0b3JlUmVsYXRpdmVTZWxlY3Rpb24odHIsIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24sIHRoaXMpXG4gICAgICB0ciA9IHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgaXNDaGFuZ2VPcmlnaW46IHRydWUsIGlzVW5kb1JlZG9PcGVyYXRpb246IHRyYW5zYWN0aW9uLm9yaWdpbiBpbnN0YW5jZW9mIFkuVW5kb01hbmFnZXIgfSlcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiAhPT0gbnVsbCAmJiB0aGlzLl9pc0xvY2FsQ3Vyc29ySW5WaWV3KClcbiAgICAgICkge1xuICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG4gICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5kaXNwYXRjaCh0cilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdwcm9zZW1pcnJvci1tb2RlbCcpLk5vZGV9IGRvY1xuICAgKi9cbiAgX3Byb3NlbWlycm9yQ2hhbmdlZCAoZG9jKSB7XG4gICAgdGhpcy5kb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgdXBkYXRlWUZyYWdtZW50KHRoaXMuZG9jLCB0aGlzLnR5cGUsIGRvYywgdGhpcylcbiAgICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPSBnZXRSZWxhdGl2ZVNlbGVjdGlvbihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGVcbiAgICAgIClcbiAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBWaWV3IGlzIHJlYWR5IHRvIGxpc3RlbiB0byBjaGFuZ2VzLiBSZWdpc3RlciBvYnNlcnZlcnMuXG4gICAqIEBwYXJhbSB7YW55fSBwcm9zZW1pcnJvclZpZXdcbiAgICovXG4gIGluaXRWaWV3IChwcm9zZW1pcnJvclZpZXcpIHtcbiAgICBpZiAodGhpcy5wcm9zZW1pcnJvclZpZXcgIT0gbnVsbCkgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLnByb3NlbWlycm9yVmlldyA9IHByb3NlbWlycm9yVmlld1xuICAgIHRoaXMuZG9jLm9uKCdiZWZvcmVBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmJlZm9yZUFsbFRyYW5zYWN0aW9ucylcbiAgICB0aGlzLmRvYy5vbignYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zKVxuICAgIHRoaXMudHlwZS5vYnNlcnZlRGVlcCh0aGlzLl9vYnNlcnZlRnVuY3Rpb24pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5wcm9zZW1pcnJvclZpZXcgPT0gbnVsbCkgcmV0dXJuXG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcgPSBudWxsXG4gICAgdGhpcy50eXBlLnVub2JzZXJ2ZURlZXAodGhpcy5fb2JzZXJ2ZUZ1bmN0aW9uKVxuICAgIHRoaXMuZG9jLm9mZignYmVmb3JlQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5iZWZvcmVBbGxUcmFuc2FjdGlvbnMpXG4gICAgdGhpcy5kb2Mub2ZmKCdhZnRlckFsbFRyYW5zYWN0aW9ucycsIHRoaXMuYWZ0ZXJBbGxUcmFuc2FjdGlvbnMpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnQgfCBZLlhtbEhvb2t9IGVsXG4gKiBAcGFyYW0ge1BNb2RlbC5TY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3NuYXBzaG90XVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbcHJldlNuYXBzaG90XVxuICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBZLklEKTphbnl9IFtjb21wdXRlWUNoYW5nZV1cbiAqIEByZXR1cm4ge1BNb2RlbC5Ob2RlIHwgbnVsbH1cbiAqL1xuY29uc3QgY3JlYXRlTm9kZUlmTm90RXhpc3RzID0gKFxuICBlbCxcbiAgc2NoZW1hLFxuICBtZXRhLFxuICBzbmFwc2hvdCxcbiAgcHJldlNuYXBzaG90LFxuICBjb21wdXRlWUNoYW5nZVxuKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAobWV0YS5tYXBwaW5nLmdldChlbCkpXG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICBlbCxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtZXRhLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKCkgLy8gd2UgYXJlIGN1cnJlbnRseSBub3QgaGFuZGxpbmcgaG9va3NcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge2FueX0gc2NoZW1hXG4gKiBAcGFyYW0ge0JpbmRpbmdNZXRhZGF0YX0gbWV0YVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbc25hcHNob3RdXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtwcmV2U25hcHNob3RdXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCdyZW1vdmVkJyB8ICdhZGRlZCcsIFkuSUQpOmFueX0gW2NvbXB1dGVZQ2hhbmdlXVxuICogQHJldHVybiB7UE1vZGVsLk5vZGUgfCBudWxsfSBSZXR1cm5zIG5vZGUgaWYgbm9kZSBjb3VsZCBiZSBjcmVhdGVkLiBPdGhlcndpc2UgaXQgZGVsZXRlcyB0aGUgeWpzIHR5cGUgYW5kIHJldHVybnMgbnVsbFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlTm9kZUZyb21ZRWxlbWVudCA9IChcbiAgZWwsXG4gIHNjaGVtYSxcbiAgbWV0YSxcbiAgc25hcHNob3QsXG4gIHByZXZTbmFwc2hvdCxcbiAgY29tcHV0ZVlDaGFuZ2VcbikgPT4ge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuWG1sRWxlbWVudCB8IFkuWG1sVGV4dH0gdHlwZVxuICAgKi9cbiAgY29uc3QgY3JlYXRlQ2hpbGRyZW4gPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50KSB7XG4gICAgICBjb25zdCBuID0gY3JlYXRlTm9kZUlmTm90RXhpc3RzKFxuICAgICAgICB0eXBlLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG1ldGEsXG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBwcmV2U25hcHNob3QsXG4gICAgICAgIGNvbXB1dGVZQ2hhbmdlXG4gICAgICApXG4gICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKG4pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBuZXh0IHl0ZXh0IGV4aXN0cyBhbmQgd2FzIGNyZWF0ZWQgYnkgdXMsIG1vdmUgdGhlIGNvbnRlbnQgdG8gdGhlIGN1cnJlbnQgeXRleHQuXG4gICAgICAvLyBUaGlzIGlzIGEgZml4IGZvciAjMTYwIC0tIGR1cGxpY2F0aW9uIG9mIGNoYXJhY3RlcnMgd2hlbiB0d28gWS5UZXh0IGV4aXN0IG5leHQgdG8gZWFjaFxuICAgICAgLy8gb3RoZXIuXG4gICAgICBjb25zdCBuZXh0eXRleHQgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICh0eXBlLl9pdGVtLnJpZ2h0Py5jb250ZW50KT8udHlwZVxuICAgICAgaWYgKG5leHR5dGV4dCBpbnN0YW5jZW9mIFkuVGV4dCAmJiAhbmV4dHl0ZXh0Ll9pdGVtLmRlbGV0ZWQgJiYgbmV4dHl0ZXh0Ll9pdGVtLmlkLmNsaWVudCA9PT0gbmV4dHl0ZXh0LmRvYy5jbGllbnRJRCkge1xuICAgICAgICB0eXBlLmFwcGx5RGVsdGEoW1xuICAgICAgICAgIHsgcmV0YWluOiB0eXBlLmxlbmd0aCB9LFxuICAgICAgICAgIC4uLm5leHR5dGV4dC50b0RlbHRhKClcbiAgICAgICAgXSlcbiAgICAgICAgbmV4dHl0ZXh0LmRvYy50cmFuc2FjdCh0ciA9PiB7XG4gICAgICAgICAgbmV4dHl0ZXh0Ll9pdGVtLmRlbGV0ZSh0cilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIC8vIG5vdyBjcmVhdGUgdGhlIHByb3NlbWlycm9yIHRleHQgbm9kZXNcbiAgICAgIGNvbnN0IG5zID0gY3JlYXRlVGV4dE5vZGVzRnJvbVlUZXh0KFxuICAgICAgICB0eXBlLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG1ldGEsXG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBwcmV2U25hcHNob3QsXG4gICAgICAgIGNvbXB1dGVZQ2hhbmdlXG4gICAgICApXG4gICAgICBpZiAobnMgIT09IG51bGwpIHtcbiAgICAgICAgbnMuZm9yRWFjaCgodGV4dGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKHRleHRjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0Y2hpbGQpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCB8fCBwcmV2U25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGVsLnRvQXJyYXkoKS5mb3JFYWNoKGNyZWF0ZUNoaWxkcmVuKVxuICB9IGVsc2Uge1xuICAgIFkudHlwZUxpc3RUb0FycmF5U25hcHNob3QoZWwsIG5ldyBZLlNuYXBzaG90KHByZXZTbmFwc2hvdC5kcywgc25hcHNob3Quc3YpKVxuICAgICAgLmZvckVhY2goY3JlYXRlQ2hpbGRyZW4pXG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBhdHRycyA9IGVsLmdldEF0dHJpYnV0ZXMoc25hcHNob3QpXG4gICAgaWYgKHNuYXBzaG90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghaXNWaXNpYmxlKC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLCBzbmFwc2hvdCkpIHtcbiAgICAgICAgYXR0cnMueWNoYW5nZSA9IGNvbXB1dGVZQ2hhbmdlXG4gICAgICAgICAgPyBjb21wdXRlWUNoYW5nZSgncmVtb3ZlZCcsIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLmlkKVxuICAgICAgICAgIDogeyB0eXBlOiAncmVtb3ZlZCcgfVxuICAgICAgfSBlbHNlIGlmICghaXNWaXNpYmxlKC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLCBwcmV2U25hcHNob3QpKSB7XG4gICAgICAgIGF0dHJzLnljaGFuZ2UgPSBjb21wdXRlWUNoYW5nZVxuICAgICAgICAgID8gY29tcHV0ZVlDaGFuZ2UoJ2FkZGVkJywgLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSkuaWQpXG4gICAgICAgICAgOiB7IHR5cGU6ICdhZGRlZCcgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlID0gc2NoZW1hLm5vZGUoZWwubm9kZU5hbWUsIGF0dHJzLCBjaGlsZHJlbilcbiAgICBtZXRhLm1hcHBpbmcuc2V0KGVsLCBub2RlKVxuICAgIHJldHVybiBub2RlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBhbiBlcnJvciBvY2N1cmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzdWx0IG9mIGEgY29uY3VycmVudCBhY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtZLkRvY30gKi8gKGVsLmRvYykudHJhbnNhY3QoKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgbWV0YS5tYXBwaW5nLmRlbGV0ZShlbClcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge2ltcG9ydCgncHJvc2VtaXJyb3ItbW9kZWwnKS5TY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IF9tZXRhXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtBcnJheTxQTW9kZWwuTm9kZT58bnVsbH1cbiAqL1xuY29uc3QgY3JlYXRlVGV4dE5vZGVzRnJvbVlUZXh0ID0gKFxuICB0ZXh0LFxuICBzY2hlbWEsXG4gIF9tZXRhLFxuICBzbmFwc2hvdCxcbiAgcHJldlNuYXBzaG90LFxuICBjb21wdXRlWUNoYW5nZVxuKSA9PiB7XG4gIGNvbnN0IG5vZGVzID0gW11cbiAgY29uc3QgZGVsdGFzID0gdGV4dC50b0RlbHRhKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIGNvbXB1dGVZQ2hhbmdlKVxuICB0cnkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IGRlbHRhc1tpXVxuICAgICAgbm9kZXMucHVzaChzY2hlbWEudGV4dChkZWx0YS5pbnNlcnQsIGF0dHJpYnV0ZXNUb01hcmtzKGRlbHRhLmF0dHJpYnV0ZXMsIHNjaGVtYSkpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGFuIGVycm9yIG9jY3VyZWQgd2hpbGUgY3JlYXRpbmcgdGhlIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSByZXN1bHQgb2YgYSBjb25jdXJyZW50IGFjdGlvbi5cbiAgICAvKiogQHR5cGUge1kuRG9jfSAqLyAodGV4dC5kb2MpLnRyYW5zYWN0KCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgLyoqIEB0eXBlIHtZLkl0ZW19ICovICh0ZXh0Ll9pdGVtKS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBub2Rlc1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IG5vZGVzIHByb3NlbWlycm9yIG5vZGVcbiAqIEBwYXJhbSB7QmluZGluZ01ldGFkYXRhfSBtZXRhXG4gKiBAcmV0dXJuIHtZLlhtbFRleHR9XG4gKi9cbmNvbnN0IGNyZWF0ZVR5cGVGcm9tVGV4dE5vZGVzID0gKG5vZGVzLCBtZXRhKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBuZXcgWS5YbWxUZXh0KClcbiAgY29uc3QgZGVsdGEgPSBub2Rlcy5tYXAoKG5vZGUpID0+ICh7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGluc2VydDogbm9kZS50ZXh0LFxuICAgIGF0dHJpYnV0ZXM6IG1hcmtzVG9BdHRyaWJ1dGVzKG5vZGUubWFya3MsIG1ldGEpXG4gIH0pKVxuICB0eXBlLmFwcGx5RGVsdGEoZGVsdGEpXG4gIG1ldGEubWFwcGluZy5zZXQodHlwZSwgbm9kZXMpXG4gIHJldHVybiB0eXBlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YW55fSBub2RlIHByb3NlbWlycm9yIG5vZGVcbiAqIEBwYXJhbSB7QmluZGluZ01ldGFkYXRhfSBtZXRhXG4gKiBAcmV0dXJuIHtZLlhtbEVsZW1lbnR9XG4gKi9cbmNvbnN0IGNyZWF0ZVR5cGVGcm9tRWxlbWVudE5vZGUgPSAobm9kZSwgbWV0YSkgPT4ge1xuICBjb25zdCB0eXBlID0gbmV3IFkuWG1sRWxlbWVudChub2RlLnR5cGUubmFtZSlcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS5hdHRycykge1xuICAgIGNvbnN0IHZhbCA9IG5vZGUuYXR0cnNba2V5XVxuICAgIGlmICh2YWwgIT09IG51bGwgJiYga2V5ICE9PSAneWNoYW5nZScpIHtcbiAgICAgIHR5cGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKVxuICAgIH1cbiAgfVxuICB0eXBlLmluc2VydChcbiAgICAwLFxuICAgIG5vcm1hbGl6ZVBOb2RlQ29udGVudChub2RlKS5tYXAoKG4pID0+XG4gICAgICBjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKG4sIG1ldGEpXG4gICAgKVxuICApXG4gIG1ldGEubWFwcGluZy5zZXQodHlwZSwgbm9kZSlcbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQTW9kZWwuTm9kZXxBcnJheTxQTW9kZWwuTm9kZT59IG5vZGUgcHJvc2VtaXJyb3IgdGV4dCBub2RlXG4gKiBAcGFyYW0ge0JpbmRpbmdNZXRhZGF0YX0gbWV0YVxuICogQHJldHVybiB7WS5YbWxFbGVtZW50fFkuWG1sVGV4dH1cbiAqL1xuY29uc3QgY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZSA9IChub2RlLCBtZXRhKSA9PlxuICBub2RlIGluc3RhbmNlb2YgQXJyYXlcbiAgICA/IGNyZWF0ZVR5cGVGcm9tVGV4dE5vZGVzKG5vZGUsIG1ldGEpXG4gICAgOiBjcmVhdGVUeXBlRnJvbUVsZW1lbnROb2RlKG5vZGUsIG1ldGEpXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbFxuICovXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbFxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBwYXR0cnNcbiAqIEBwYXJhbSB7YW55fSB5YXR0cnNcbiAqL1xuY29uc3QgZXF1YWxBdHRycyA9IChwYXR0cnMsIHlhdHRycykgPT4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGF0dHJzKS5maWx0ZXIoKGtleSkgPT4gcGF0dHJzW2tleV0gIT09IG51bGwpXG4gIGxldCBlcSA9XG4gICAga2V5cy5sZW5ndGggPT09XG4gICAgICBPYmplY3Qua2V5cyh5YXR0cnMpLmZpbHRlcigoa2V5KSA9PiB5YXR0cnNba2V5XSAhPT0gbnVsbCkubGVuZ3RoXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggJiYgZXE7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBjb25zdCBsID0gcGF0dHJzW2tleV1cbiAgICBjb25zdCByID0geWF0dHJzW2tleV1cbiAgICBlcSA9IGtleSA9PT0gJ3ljaGFuZ2UnIHx8IGwgPT09IHIgfHxcbiAgICAgIChpc09iamVjdChsKSAmJiBpc09iamVjdChyKSAmJiBlcXVhbEF0dHJzKGwsIHIpKVxuICB9XG4gIHJldHVybiBlcVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtBcnJheTxBcnJheTxQTW9kZWwuTm9kZT58UE1vZGVsLk5vZGU+fSBOb3JtYWxpemVkUE5vZGVDb250ZW50XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcG5vZGVcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRQTm9kZUNvbnRlbnR9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVBOb2RlQ29udGVudCA9IChwbm9kZSkgPT4ge1xuICBjb25zdCBjID0gcG5vZGUuY29udGVudC5jb250ZW50XG4gIGNvbnN0IHJlcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG4gPSBjW2ldXG4gICAgaWYgKG4uaXNUZXh0KSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZXMgPSBbXVxuICAgICAgZm9yIChsZXQgdG5vZGUgPSBjW2ldOyBpIDwgYy5sZW5ndGggJiYgdG5vZGUuaXNUZXh0OyB0bm9kZSA9IGNbKytpXSkge1xuICAgICAgICB0ZXh0Tm9kZXMucHVzaCh0bm9kZSlcbiAgICAgIH1cbiAgICAgIGktLVxuICAgICAgcmVzLnB1c2godGV4dE5vZGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMucHVzaChuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbFRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHB0ZXh0c1xuICovXG5jb25zdCBlcXVhbFlUZXh0UFRleHQgPSAoeXRleHQsIHB0ZXh0cykgPT4ge1xuICBjb25zdCBkZWx0YSA9IHl0ZXh0LnRvRGVsdGEoKVxuICByZXR1cm4gZGVsdGEubGVuZ3RoID09PSBwdGV4dHMubGVuZ3RoICYmXG4gICAgZGVsdGEuZXZlcnkoLyoqIEB0eXBlIHsoZDphbnksaTpudW1iZXIpID0+IGJvb2xlYW59ICovIChkLCBpKSA9PlxuICAgICAgZC5pbnNlcnQgPT09IC8qKiBAdHlwZSB7YW55fSAqLyAocHRleHRzW2ldKS50ZXh0ICYmXG4gICAgICBvYmplY3Qua2V5cyhkLmF0dHJpYnV0ZXMgfHwge30pLmxlbmd0aCA9PT0gcHRleHRzW2ldLm1hcmtzLmxlbmd0aCAmJlxuICAgICAgb2JqZWN0LmV2ZXJ5KGQuYXR0cmlidXRlcywgKGF0dHIsIHlhdHRybmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBtYXJrbmFtZSA9IHlhdHRyMm1hcmtuYW1lKHlhdHRybmFtZSlcbiAgICAgICAgY29uc3QgcG1hcmtzID0gcHRleHRzW2ldLm1hcmtzXG4gICAgICAgIHJldHVybiBlcXVhbEF0dHJzKGF0dHIsIHBtYXJrcy5maW5kKC8qKiBAcGFyYW0ge2FueX0gbWFyayAqLyBtYXJrID0+IG1hcmsudHlwZS5uYW1lID09PSBtYXJrbmFtZSk/LmF0dHJzKVxuICAgICAgfSlcbiAgICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR8WS5YbWxUZXh0fFkuWG1sSG9va30geXR5cGVcbiAqIEBwYXJhbSB7YW55fEFycmF5PGFueT59IHBub2RlXG4gKi9cbmNvbnN0IGVxdWFsWVR5cGVQTm9kZSA9ICh5dHlwZSwgcG5vZGUpID0+IHtcbiAgaWYgKFxuICAgIHl0eXBlIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50ICYmICEocG5vZGUgaW5zdGFuY2VvZiBBcnJheSkgJiZcbiAgICBtYXRjaE5vZGVOYW1lKHl0eXBlLCBwbm9kZSlcbiAgKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZENvbnRlbnQgPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocG5vZGUpXG4gICAgcmV0dXJuIHl0eXBlLl9sZW5ndGggPT09IG5vcm1hbGl6ZWRDb250ZW50Lmxlbmd0aCAmJlxuICAgICAgZXF1YWxBdHRycyh5dHlwZS5nZXRBdHRyaWJ1dGVzKCksIHBub2RlLmF0dHJzKSAmJlxuICAgICAgeXR5cGUudG9BcnJheSgpLmV2ZXJ5KCh5Y2hpbGQsIGkpID0+XG4gICAgICAgIGVxdWFsWVR5cGVQTm9kZSh5Y2hpbGQsIG5vcm1hbGl6ZWRDb250ZW50W2ldKVxuICAgICAgKVxuICB9XG4gIHJldHVybiB5dHlwZSBpbnN0YW5jZW9mIFkuWG1sVGV4dCAmJiBwbm9kZSBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgZXF1YWxZVGV4dFBUZXh0KHl0eXBlLCBwbm9kZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+IHwgdW5kZWZpbmVkfSBtYXBwZWRcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGUgfCBBcnJheTxQTW9kZWwuTm9kZT59IHBjb250ZW50XG4gKi9cbmNvbnN0IG1hcHBlZElkZW50aXR5ID0gKG1hcHBlZCwgcGNvbnRlbnQpID0+XG4gIG1hcHBlZCA9PT0gcGNvbnRlbnQgfHxcbiAgKG1hcHBlZCBpbnN0YW5jZW9mIEFycmF5ICYmIHBjb250ZW50IGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICBtYXBwZWQubGVuZ3RoID09PSBwY29udGVudC5sZW5ndGggJiYgbWFwcGVkLmV2ZXJ5KChhLCBpKSA9PlxuICAgIHBjb250ZW50W2ldID09PSBhXG4gICkpXG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR9IHl0eXBlXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlfSBwbm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEByZXR1cm4ge3sgZm91bmRNYXBwZWRDaGlsZDogYm9vbGVhbiwgZXF1YWxpdHlGYWN0b3I6IG51bWJlciB9fVxuICovXG5jb25zdCBjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvciA9ICh5dHlwZSwgcG5vZGUsIG1ldGEpID0+IHtcbiAgY29uc3QgeUNoaWxkcmVuID0geXR5cGUudG9BcnJheSgpXG4gIGNvbnN0IHBDaGlsZHJlbiA9IG5vcm1hbGl6ZVBOb2RlQ29udGVudChwbm9kZSlcbiAgY29uc3QgcENoaWxkQ250ID0gcENoaWxkcmVuLmxlbmd0aFxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHlDaGlsZENudCwgcENoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICBsZXQgZm91bmRNYXBwZWRDaGlsZCA9IGZhbHNlXG4gIGZvciAoOyBsZWZ0IDwgbWluQ250OyBsZWZ0KyspIHtcbiAgICBjb25zdCBsZWZ0WSA9IHlDaGlsZHJlbltsZWZ0XVxuICAgIGNvbnN0IGxlZnRQID0gcENoaWxkcmVuW2xlZnRdXG4gICAgaWYgKG1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGZvdW5kTWFwcGVkQ2hpbGQgPSB0cnVlIC8vIGRlZmluaXRlIChnb29kKSBtYXRjaCFcbiAgICB9IGVsc2UgaWYgKCFlcXVhbFlUeXBlUE5vZGUobGVmdFksIGxlZnRQKSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yICg7IGxlZnQgKyByaWdodCA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAobWFwcGVkSWRlbnRpdHkobWV0YS5tYXBwaW5nLmdldChyaWdodFkpLCByaWdodFApKSB7XG4gICAgICBmb3VuZE1hcHBlZENoaWxkID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoIWVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXF1YWxpdHlGYWN0b3I6IGxlZnQgKyByaWdodCxcbiAgICBmb3VuZE1hcHBlZENoaWxkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuVGV4dH0geXRleHRcbiAqL1xuY29uc3QgeXRleHRUcmFucyA9ICh5dGV4dCkgPT4ge1xuICBsZXQgc3RyID0gJydcbiAgLyoqXG4gICAqIEB0eXBlIHtZLkl0ZW18bnVsbH1cbiAgICovXG4gIGxldCBuID0geXRleHQuX3N0YXJ0XG4gIGNvbnN0IG5BdHRycyA9IHt9XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgIGlmIChuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQgaW5zdGFuY2VvZiBZLkNvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IG4uY29udGVudC5zdHJcbiAgICAgIH0gZWxzZSBpZiAobi5jb250ZW50IGluc3RhbmNlb2YgWS5Db250ZW50Rm9ybWF0KSB7XG4gICAgICAgIG5BdHRyc1tuLmNvbnRlbnQua2V5XSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0cixcbiAgICBuQXR0cnNcbiAgfVxufVxuXG4vKipcbiAqIEB0b2RvIHRlc3QgdGhpcyBtb3JlXG4gKlxuICogQHBhcmFtIHtZLlRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHB0ZXh0c1xuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuY29uc3QgdXBkYXRlWVRleHQgPSAoeXRleHQsIHB0ZXh0cywgbWV0YSkgPT4ge1xuICBtZXRhLm1hcHBpbmcuc2V0KHl0ZXh0LCBwdGV4dHMpXG4gIGNvbnN0IHsgbkF0dHJzLCBzdHIgfSA9IHl0ZXh0VHJhbnMoeXRleHQpXG4gIGNvbnN0IGNvbnRlbnQgPSBwdGV4dHMubWFwKChwKSA9PiAoe1xuICAgIGluc2VydDogLyoqIEB0eXBlIHthbnl9ICovIChwKS50ZXh0LFxuICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5hc3NpZ24oe30sIG5BdHRycywgbWFya3NUb0F0dHJpYnV0ZXMocC5tYXJrcywgbWV0YSkpXG4gIH0pKVxuICBjb25zdCB7IGluc2VydCwgcmVtb3ZlLCBpbmRleCB9ID0gc2ltcGxlRGlmZihcbiAgICBzdHIsXG4gICAgY29udGVudC5tYXAoKGMpID0+IGMuaW5zZXJ0KS5qb2luKCcnKVxuICApXG4gIHl0ZXh0LmRlbGV0ZShpbmRleCwgcmVtb3ZlKVxuICB5dGV4dC5pbnNlcnQoaW5kZXgsIGluc2VydClcbiAgeXRleHQuYXBwbHlEZWx0YShcbiAgICBjb250ZW50Lm1hcCgoYykgPT4gKHsgcmV0YWluOiBjLmluc2VydC5sZW5ndGgsIGF0dHJpYnV0ZXM6IGMuYXR0cmlidXRlcyB9KSlcbiAgKVxufVxuXG5jb25zdCBoYXNoZWRNYXJrTmFtZVJlZ2V4ID0gLyguKikoLS1bYS16QS1aMC05Ky89XXs4fSkkL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IHlhdHRyMm1hcmtuYW1lID0gYXR0ck5hbWUgPT4gaGFzaGVkTWFya05hbWVSZWdleC5leGVjKGF0dHJOYW1lKT8uWzFdID8/IGF0dHJOYW1lXG5cbi8qKlxuICogQHRvZG8gbW92ZSB0aGlzIHRvIG1hcmtzdG9hdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBhdHRyc1xuICogQHBhcmFtIHtpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuU2NoZW1hfSBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IGF0dHJpYnV0ZXNUb01hcmtzID0gKGF0dHJzLCBzY2hlbWEpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFyaz59XG4gICAqL1xuICBjb25zdCBtYXJrcyA9IFtdXG4gIGZvciAoY29uc3QgbWFya05hbWUgaW4gYXR0cnMpIHtcbiAgICAvLyByZW1vdmUgaGFzaGVzIGlmIG5lY2Vzc2FyeVxuICAgIG1hcmtzLnB1c2goc2NoZW1hLm1hcmsoeWF0dHIybWFya25hbWUobWFya05hbWUpLCBhdHRyc1ttYXJrTmFtZV0pKVxuICB9XG4gIHJldHVybiBtYXJrc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCdwcm9zZW1pcnJvci1tb2RlbCcpLk1hcms+fSBtYXJrc1xuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuY29uc3QgbWFya3NUb0F0dHJpYnV0ZXMgPSAobWFya3MsIG1ldGEpID0+IHtcbiAgY29uc3QgcGF0dHJzID0ge31cbiAgbWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgIGlmIChtYXJrLnR5cGUubmFtZSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICBjb25zdCBpc092ZXJsYXBwaW5nID0gbWFwLnNldElmVW5kZWZpbmVkKG1ldGEuaXNPTWFyaywgbWFyay50eXBlLCAoKSA9PiAhbWFyay50eXBlLmV4Y2x1ZGVzKG1hcmsudHlwZSkpXG4gICAgICBwYXR0cnNbaXNPdmVybGFwcGluZyA/IGAke21hcmsudHlwZS5uYW1lfS0tJHt1dGlscy5oYXNoT2ZKU09OKG1hcmsudG9KU09OKCkpfWAgOiBtYXJrLnR5cGUubmFtZV0gPSBtYXJrLmF0dHJzXG4gICAgfVxuICB9KVxuICByZXR1cm4gcGF0dHJzXG59XG5cbi8qKlxuICogVXBkYXRlIGEgeURvbSBub2RlIGJ5IHN5bmNpbmcgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgcHJvc2VtaXJyb3Igbm9kZS5cbiAqXG4gKiBUaGlzIGlzIGEgeS1wcm9zZW1pcnJvciBpbnRlcm5hbCBmZWF0dXJlIHRoYXQgeW91IGNhbiB1c2UgYXQgeW91ciBvd24gcmlzay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHVuc3RhYmxlXG4gKlxuICogQHBhcmFtIHt7dHJhbnNhY3Q6IEZ1bmN0aW9ufX0geVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5RG9tRnJhZ21lbnRcbiAqIEBwYXJhbSB7YW55fSBwTm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVlGcmFnbWVudCA9ICh5LCB5RG9tRnJhZ21lbnQsIHBOb2RlLCBtZXRhKSA9PiB7XG4gIGlmIChcbiAgICB5RG9tRnJhZ21lbnQgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiZcbiAgICB5RG9tRnJhZ21lbnQubm9kZU5hbWUgIT09IHBOb2RlLnR5cGUubmFtZVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgbmFtZSBtaXNtYXRjaCEnKVxuICB9XG4gIG1ldGEubWFwcGluZy5zZXQoeURvbUZyYWdtZW50LCBwTm9kZSlcbiAgLy8gdXBkYXRlIGF0dHJpYnV0ZXNcbiAgaWYgKHlEb21GcmFnbWVudCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgIGNvbnN0IHlEb21BdHRycyA9IHlEb21GcmFnbWVudC5nZXRBdHRyaWJ1dGVzKClcbiAgICBjb25zdCBwQXR0cnMgPSBwTm9kZS5hdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBBdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh5RG9tQXR0cnNba2V5XSAhPT0gcEF0dHJzW2tleV0gJiYga2V5ICE9PSAneWNoYW5nZScpIHtcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuc2V0QXR0cmlidXRlKGtleSwgcEF0dHJzW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlEb21GcmFnbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHBBdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHlEb21BdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeURvbUZyYWdtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHVwZGF0ZSBjaGlsZHJlblxuICBjb25zdCBwQ2hpbGRyZW4gPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocE5vZGUpXG4gIGNvbnN0IHBDaGlsZENudCA9IHBDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgeUNoaWxkcmVuID0geURvbUZyYWdtZW50LnRvQXJyYXkoKVxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHBDaGlsZENudCwgeUNoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICAvLyBmaW5kIG51bWJlciBvZiBtYXRjaGluZyBlbGVtZW50cyBmcm9tIGxlZnRcbiAgZm9yICg7IGxlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGlmIChlcXVhbFlUeXBlUE5vZGUobGVmdFksIGxlZnRQKSkge1xuICAgICAgICAvLyB1cGRhdGUgbWFwcGluZ1xuICAgICAgICBtZXRhLm1hcHBpbmcuc2V0KGxlZnRZLCBsZWZ0UClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGZpbmQgbnVtYmVyIG9mIG1hdGNoaW5nIGVsZW1lbnRzIGZyb20gcmlnaHRcbiAgZm9yICg7IHJpZ2h0ICsgbGVmdCArIDEgPCBtaW5DbnQ7IHJpZ2h0KyspIHtcbiAgICBjb25zdCByaWdodFkgPSB5Q2hpbGRyZW5beUNoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgIGNvbnN0IHJpZ2h0UCA9IHBDaGlsZHJlbltwQ2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgaWYgKCFtYXBwZWRJZGVudGl0eShtZXRhLm1hcHBpbmcuZ2V0KHJpZ2h0WSksIHJpZ2h0UCkpIHtcbiAgICAgIGlmIChlcXVhbFlUeXBlUE5vZGUocmlnaHRZLCByaWdodFApKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBtYXBwaW5nXG4gICAgICAgIG1ldGEubWFwcGluZy5zZXQocmlnaHRZLCByaWdodFApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB5LnRyYW5zYWN0KCgpID0+IHtcbiAgICAvLyB0cnkgdG8gY29tcGFyZSBhbmQgdXBkYXRlXG4gICAgd2hpbGUgKHlDaGlsZENudCAtIGxlZnQgLSByaWdodCA+IDAgJiYgcENoaWxkQ250IC0gbGVmdCAtIHJpZ2h0ID4gMCkge1xuICAgICAgY29uc3QgbGVmdFkgPSB5Q2hpbGRyZW5bbGVmdF1cbiAgICAgIGNvbnN0IGxlZnRQID0gcENoaWxkcmVuW2xlZnRdXG4gICAgICBjb25zdCByaWdodFkgPSB5Q2hpbGRyZW5beUNoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICAgIGlmIChsZWZ0WSBpbnN0YW5jZW9mIFkuWG1sVGV4dCAmJiBsZWZ0UCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGlmICghZXF1YWxZVGV4dFBUZXh0KGxlZnRZLCBsZWZ0UCkpIHtcbiAgICAgICAgICB1cGRhdGVZVGV4dChsZWZ0WSwgbGVmdFAsIG1ldGEpXG4gICAgICAgIH1cbiAgICAgICAgbGVmdCArPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdXBkYXRlTGVmdCA9IGxlZnRZIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50ICYmXG4gICAgICAgICAgbWF0Y2hOb2RlTmFtZShsZWZ0WSwgbGVmdFApXG4gICAgICAgIGxldCB1cGRhdGVSaWdodCA9IHJpZ2h0WSBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCAmJlxuICAgICAgICAgIG1hdGNoTm9kZU5hbWUocmlnaHRZLCByaWdodFApXG4gICAgICAgIGlmICh1cGRhdGVMZWZ0ICYmIHVwZGF0ZVJpZ2h0KSB7XG4gICAgICAgICAgLy8gZGVjaWRlIHdoaWNoIHdoaWNoIGVsZW1lbnQgdG8gdXBkYXRlXG4gICAgICAgICAgY29uc3QgZXF1YWxpdHlMZWZ0ID0gY29tcHV0ZUNoaWxkRXF1YWxpdHlGYWN0b3IoXG4gICAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKGxlZnRZKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UE1vZGVsLk5vZGV9ICovIChsZWZ0UCksXG4gICAgICAgICAgICBtZXRhXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGVxdWFsaXR5UmlnaHQgPSBjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvcihcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAocmlnaHRZKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UE1vZGVsLk5vZGV9ICovIChyaWdodFApLFxuICAgICAgICAgICAgbWV0YVxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBlcXVhbGl0eUxlZnQuZm91bmRNYXBwZWRDaGlsZCAmJiAhZXF1YWxpdHlSaWdodC5mb3VuZE1hcHBlZENoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB1cGRhdGVSaWdodCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICFlcXVhbGl0eUxlZnQuZm91bmRNYXBwZWRDaGlsZCAmJiBlcXVhbGl0eVJpZ2h0LmZvdW5kTWFwcGVkQ2hpbGRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHVwZGF0ZUxlZnQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBlcXVhbGl0eUxlZnQuZXF1YWxpdHlGYWN0b3IgPCBlcXVhbGl0eVJpZ2h0LmVxdWFsaXR5RmFjdG9yXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB1cGRhdGVMZWZ0ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlUmlnaHQgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlTGVmdCkge1xuICAgICAgICAgIHVwZGF0ZVlGcmFnbWVudChcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRnJhZ21lbnR9ICovIChsZWZ0WSksXG4gICAgICAgICAgICAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAobGVmdFApLFxuICAgICAgICAgICAgbWV0YVxuICAgICAgICAgIClcbiAgICAgICAgICBsZWZ0ICs9IDFcbiAgICAgICAgfSBlbHNlIGlmICh1cGRhdGVSaWdodCkge1xuICAgICAgICAgIHVwZGF0ZVlGcmFnbWVudChcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRnJhZ21lbnR9ICovIChyaWdodFkpLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKHJpZ2h0UCksXG4gICAgICAgICAgICBtZXRhXG4gICAgICAgICAgKVxuICAgICAgICAgIHJpZ2h0ICs9IDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRhLm1hcHBpbmcuZGVsZXRlKHlEb21GcmFnbWVudC5nZXQobGVmdCkpXG4gICAgICAgICAgeURvbUZyYWdtZW50LmRlbGV0ZShsZWZ0LCAxKVxuICAgICAgICAgIHlEb21GcmFnbWVudC5pbnNlcnQobGVmdCwgW1xuICAgICAgICAgICAgY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZShsZWZ0UCwgbWV0YSlcbiAgICAgICAgICBdKVxuICAgICAgICAgIGxlZnQgKz0gMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHlEZWxMZW4gPSB5Q2hpbGRDbnQgLSBsZWZ0IC0gcmlnaHRcbiAgICBpZiAoXG4gICAgICB5Q2hpbGRDbnQgPT09IDEgJiYgcENoaWxkQ250ID09PSAwICYmIHlDaGlsZHJlblswXSBpbnN0YW5jZW9mIFkuWG1sVGV4dFxuICAgICkge1xuICAgICAgbWV0YS5tYXBwaW5nLmRlbGV0ZSh5Q2hpbGRyZW5bMF0pXG4gICAgICAvLyBFZGdlIGNhc2UgaGFuZGxpbmcgaHR0cHM6Ly9naXRodWIuY29tL3lqcy95LXByb3NlbWlycm9yL2lzc3Vlcy8xMDhcbiAgICAgIC8vIE9ubHkgZGVsZXRlIHRoZSBjb250ZW50IG9mIHRoZSBZLlRleHQgdG8gcmV0YWluIHJlbW90ZSBjaGFuZ2VzIG9uIHRoZSBzYW1lIFkuVGV4dCBvYmplY3RcbiAgICAgIHlDaGlsZHJlblswXS5kZWxldGUoMCwgeUNoaWxkcmVuWzBdLmxlbmd0aClcbiAgICB9IGVsc2UgaWYgKHlEZWxMZW4gPiAwKSB7XG4gICAgICB5RG9tRnJhZ21lbnQuc2xpY2UobGVmdCwgbGVmdCArIHlEZWxMZW4pLmZvckVhY2godHlwZSA9PiBtZXRhLm1hcHBpbmcuZGVsZXRlKHR5cGUpKVxuICAgICAgeURvbUZyYWdtZW50LmRlbGV0ZShsZWZ0LCB5RGVsTGVuKVxuICAgIH1cbiAgICBpZiAobGVmdCArIHJpZ2h0IDwgcENoaWxkQ250KSB7XG4gICAgICBjb25zdCBpbnMgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPCBwQ2hpbGRDbnQgLSByaWdodDsgaSsrKSB7XG4gICAgICAgIGlucy5wdXNoKGNyZWF0ZVR5cGVGcm9tVGV4dE9yRWxlbWVudE5vZGUocENoaWxkcmVuW2ldLCBtZXRhKSlcbiAgICAgIH1cbiAgICAgIHlEb21GcmFnbWVudC5pbnNlcnQobGVmdCwgaW5zKVxuICAgIH1cbiAgfSwgeVN5bmNQbHVnaW5LZXkpXG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1kuWG1sRWxlbWVudH0geUVsZW1lbnRcbiAqIEBwYXJhbSB7YW55fSBwTm9kZSBQcm9zZW1pcnJvciBOb2RlXG4gKi9cbmNvbnN0IG1hdGNoTm9kZU5hbWUgPSAoeUVsZW1lbnQsIHBOb2RlKSA9PlxuICAhKHBOb2RlIGluc3RhbmNlb2YgQXJyYXkpICYmIHlFbGVtZW50Lm5vZGVOYW1lID09PSBwTm9kZS50eXBlLm5hbWVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/undo-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultDeleteFilter: () => (/* binding */ defaultDeleteFilter),\n/* harmony export */   defaultProtectedNodes: () => (/* binding */ defaultProtectedNodes),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   yUndoPlugin: () => (/* binding */ yUndoPlugin)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var _sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sync-plugin.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"(app-pages-browser)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ \"(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n // eslint-disable-line\n\n\n\n\n\nconst undo = state => {\n  const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.undo()\n    return true\n  }\n}\n\nconst redo = state => {\n  const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.redo()\n    return true\n  }\n}\n\nconst defaultProtectedNodes = new Set(['paragraph'])\n\nconst defaultDeleteFilter = (item, protectedNodes) => !(item instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Item) ||\n!(item.content instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.ContentType) ||\n!(item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Text ||\n  (item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement && protectedNodes.has(item.content.type.nodeName))) ||\nitem.content.type._length === 0\n\nconst yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n  key: _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey,\n  state: {\n    init: (initargs, state) => {\n      // TODO: check if plugin order matches and fix\n      const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state)\n      const _undoManager = undoManager || new yjs__WEBPACK_IMPORTED_MODULE_1__.UndoManager(ystate.type, {\n        trackedOrigins: new Set([_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey].concat(trackedOrigins)),\n        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),\n        captureTransaction: tr => tr.meta.get('addToHistory') !== false\n      })\n      return {\n        undoManager: _undoManager,\n        prevSel: null,\n        hasUndoOps: _undoManager.undoStack.length > 0,\n        hasRedoOps: _undoManager.redoStack.length > 0\n      }\n    },\n    /**\n     * @returns {any}\n     */\n    apply: (tr, val, oldState, state) => {\n      const binding = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state).binding\n      const undoManager = val.undoManager\n      const hasUndoOps = undoManager.undoStack.length > 0\n      const hasRedoOps = undoManager.redoStack.length > 0\n      if (binding) {\n        return {\n          undoManager,\n          prevSel: (0,_sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__.getRelativeSelection)(binding, oldState),\n          hasUndoOps,\n          hasRedoOps\n        }\n      } else {\n        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n          return Object.assign({}, val, {\n            hasUndoOps: undoManager.undoStack.length > 0,\n            hasRedoOps: undoManager.redoStack.length > 0\n          })\n        } else { // nothing changed\n          return val\n        }\n      }\n    }\n  },\n  view: view => {\n    const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).undoManager\n    undoManager.on('stack-item-added', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        stackItem.meta.set(binding, _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).prevSel)\n      }\n    })\n    undoManager.on('stack-item-popped', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection\n      }\n    })\n    return {\n      destroy: () => {\n        undoManager.destroy()\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL3VuZG8tcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwQzs7QUFFYTtBQUNlO0FBQ1o7O0FBRW5EO0FBQ1Asc0JBQXNCLG9EQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxzQkFBc0Isb0RBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQSx3RUFBd0UscUNBQUk7QUFDbkYsMEJBQTBCLDRDQUFXO0FBQ3JDLCtCQUErQixxQ0FBSTtBQUNuQyxnQ0FBZ0MsMkNBQVU7QUFDMUM7O0FBRU8sdUJBQXVCLGtGQUFrRixJQUFJLFNBQVMscURBQU07QUFDbkksT0FBTyxvREFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQWM7QUFDbkMsOENBQThDLDRDQUFXO0FBQ3pELGlDQUFpQyxvREFBYztBQUMvQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxRUFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLG9EQUFjO0FBQ2pDLHdCQUF3QixvREFBYztBQUN0QywwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0Esb0NBQW9DLG9EQUFjO0FBQ2xEO0FBQ0EsS0FBSztBQUNMLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcdHVvbi1pby12MVxcbm9kZV9tb2R1bGVzXFx5LXByb3NlbWlycm9yXFxzcmNcXHBsdWdpbnNcXHVuZG8tcGx1Z2luLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmltcG9ydCB7IGdldFJlbGF0aXZlU2VsZWN0aW9uIH0gZnJvbSAnLi9zeW5jLXBsdWdpbi5qcydcbmltcG9ydCB7IFVuZG9NYW5hZ2VyLCBJdGVtLCBDb250ZW50VHlwZSwgWG1sRWxlbWVudCwgVGV4dCB9IGZyb20gJ3lqcydcbmltcG9ydCB7IHlVbmRvUGx1Z2luS2V5LCB5U3luY1BsdWdpbktleSB9IGZyb20gJy4va2V5cy5qcydcblxuZXhwb3J0IGNvbnN0IHVuZG8gPSBzdGF0ZSA9PiB7XG4gIGNvbnN0IHVuZG9NYW5hZ2VyID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpLnVuZG9NYW5hZ2VyXG4gIGlmICh1bmRvTWFuYWdlciAhPSBudWxsKSB7XG4gICAgdW5kb01hbmFnZXIudW5kbygpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVkbyA9IHN0YXRlID0+IHtcbiAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkudW5kb01hbmFnZXJcbiAgaWYgKHVuZG9NYW5hZ2VyICE9IG51bGwpIHtcbiAgICB1bmRvTWFuYWdlci5yZWRvKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvdGVjdGVkTm9kZXMgPSBuZXcgU2V0KFsncGFyYWdyYXBoJ10pXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0RGVsZXRlRmlsdGVyID0gKGl0ZW0sIHByb3RlY3RlZE5vZGVzKSA9PiAhKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSB8fFxuIShpdGVtLmNvbnRlbnQgaW5zdGFuY2VvZiBDb250ZW50VHlwZSkgfHxcbiEoaXRlbS5jb250ZW50LnR5cGUgaW5zdGFuY2VvZiBUZXh0IHx8XG4gIChpdGVtLmNvbnRlbnQudHlwZSBpbnN0YW5jZW9mIFhtbEVsZW1lbnQgJiYgcHJvdGVjdGVkTm9kZXMuaGFzKGl0ZW0uY29udGVudC50eXBlLm5vZGVOYW1lKSkpIHx8XG5pdGVtLmNvbnRlbnQudHlwZS5fbGVuZ3RoID09PSAwXG5cbmV4cG9ydCBjb25zdCB5VW5kb1BsdWdpbiA9ICh7IHByb3RlY3RlZE5vZGVzID0gZGVmYXVsdFByb3RlY3RlZE5vZGVzLCB0cmFja2VkT3JpZ2lucyA9IFtdLCB1bmRvTWFuYWdlciA9IG51bGwgfSA9IHt9KSA9PiBuZXcgUGx1Z2luKHtcbiAga2V5OiB5VW5kb1BsdWdpbktleSxcbiAgc3RhdGU6IHtcbiAgICBpbml0OiAoaW5pdGFyZ3MsIHN0YXRlKSA9PiB7XG4gICAgICAvLyBUT0RPOiBjaGVjayBpZiBwbHVnaW4gb3JkZXIgbWF0Y2hlcyBhbmQgZml4XG4gICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSlcbiAgICAgIGNvbnN0IF91bmRvTWFuYWdlciA9IHVuZG9NYW5hZ2VyIHx8IG5ldyBVbmRvTWFuYWdlcih5c3RhdGUudHlwZSwge1xuICAgICAgICB0cmFja2VkT3JpZ2luczogbmV3IFNldChbeVN5bmNQbHVnaW5LZXldLmNvbmNhdCh0cmFja2VkT3JpZ2lucykpLFxuICAgICAgICBkZWxldGVGaWx0ZXI6IChpdGVtKSA9PiBkZWZhdWx0RGVsZXRlRmlsdGVyKGl0ZW0sIHByb3RlY3RlZE5vZGVzKSxcbiAgICAgICAgY2FwdHVyZVRyYW5zYWN0aW9uOiB0ciA9PiB0ci5tZXRhLmdldCgnYWRkVG9IaXN0b3J5JykgIT09IGZhbHNlXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5kb01hbmFnZXI6IF91bmRvTWFuYWdlcixcbiAgICAgICAgcHJldlNlbDogbnVsbCxcbiAgICAgICAgaGFzVW5kb09wczogX3VuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwLFxuICAgICAgICBoYXNSZWRvT3BzOiBfdW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgYXBwbHk6ICh0ciwgdmFsLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkuYmluZGluZ1xuICAgICAgY29uc3QgdW5kb01hbmFnZXIgPSB2YWwudW5kb01hbmFnZXJcbiAgICAgIGNvbnN0IGhhc1VuZG9PcHMgPSB1bmRvTWFuYWdlci51bmRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgY29uc3QgaGFzUmVkb09wcyA9IHVuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPiAwXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuZG9NYW5hZ2VyLFxuICAgICAgICAgIHByZXZTZWw6IGdldFJlbGF0aXZlU2VsZWN0aW9uKGJpbmRpbmcsIG9sZFN0YXRlKSxcbiAgICAgICAgICBoYXNVbmRvT3BzLFxuICAgICAgICAgIGhhc1JlZG9PcHNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhhc1VuZG9PcHMgIT09IHZhbC5oYXNVbmRvT3BzIHx8IGhhc1JlZG9PcHMgIT09IHZhbC5oYXNSZWRvT3BzKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHZhbCwge1xuICAgICAgICAgICAgaGFzVW5kb09wczogdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICBoYXNSZWRvT3BzOiB1bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7IC8vIG5vdGhpbmcgY2hhbmdlZFxuICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdmlldzogdmlldyA9PiB7XG4gICAgY29uc3QgeXN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICBjb25zdCB1bmRvTWFuYWdlciA9IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpLnVuZG9NYW5hZ2VyXG4gICAgdW5kb01hbmFnZXIub24oJ3N0YWNrLWl0ZW0tYWRkZWQnLCAoeyBzdGFja0l0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgYmluZGluZyA9IHlzdGF0ZS5iaW5kaW5nXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBzdGFja0l0ZW0ubWV0YS5zZXQoYmluZGluZywgeVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkucHJldlNlbClcbiAgICAgIH1cbiAgICB9KVxuICAgIHVuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLXBvcHBlZCcsICh7IHN0YWNrSXRlbSB9KSA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0geXN0YXRlLmJpbmRpbmdcbiAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPSBzdGFja0l0ZW0ubWV0YS5nZXQoYmluZGluZykgfHwgYmluZGluZy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHtcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgdW5kb01hbmFnZXIuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/y-prosemirror/src/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/y-prosemirror/src/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashOfJSON: () => (/* binding */ hashOfJSON)\n/* harmony export */ });\n/* harmony import */ var lib0_hash_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/hash/sha256 */ \"(app-pages-browser)/./node_modules/lib0/hash/sha256.js\");\n/* harmony import */ var lib0_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/buffer */ \"(app-pages-browser)/./node_modules/lib0/buffer.js\");\n\n\n\n/**\n * Custom function to transform sha256 hash to N byte\n *\n * @param {Uint8Array} digest\n */\nconst _convolute = digest => {\n  const N = 6\n  for (let i = N; i < digest.length; i++) {\n    digest[i % N] = digest[i % N] ^ digest[i]\n  }\n  return digest.slice(0, N)\n}\n\n/**\n * @param {any} json\n */\nconst hashOfJSON = (json) => lib0_buffer__WEBPACK_IMPORTED_MODULE_0__.toBase64(_convolute(lib0_hash_sha256__WEBPACK_IMPORTED_MODULE_1__.digest(lib0_buffer__WEBPACK_IMPORTED_MODULE_0__.encodeAny(json))))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEM7QUFDUjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDTyw2QkFBNkIsaURBQVksWUFBWSxvREFBYSxDQUFDLGtEQUFhIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXHR1b24taW8tdjFcXG5vZGVfbW9kdWxlc1xceS1wcm9zZW1pcnJvclxcc3JjXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzaGEyNTYgZnJvbSAnbGliMC9oYXNoL3NoYTI1NidcbmltcG9ydCAqIGFzIGJ1ZiBmcm9tICdsaWIwL2J1ZmZlcidcblxuLyoqXG4gKiBDdXN0b20gZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHNoYTI1NiBoYXNoIHRvIE4gYnl0ZVxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGlnZXN0XG4gKi9cbmNvbnN0IF9jb252b2x1dGUgPSBkaWdlc3QgPT4ge1xuICBjb25zdCBOID0gNlxuICBmb3IgKGxldCBpID0gTjsgaSA8IGRpZ2VzdC5sZW5ndGg7IGkrKykge1xuICAgIGRpZ2VzdFtpICUgTl0gPSBkaWdlc3RbaSAlIE5dIF4gZGlnZXN0W2ldXG4gIH1cbiAgcmV0dXJuIGRpZ2VzdC5zbGljZSgwLCBOKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBqc29uXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoT2ZKU09OID0gKGpzb24pID0+IGJ1Zi50b0Jhc2U2NChfY29udm9sdXRlKHNoYTI1Ni5kaWdlc3QoYnVmLmVuY29kZUFueShqc29uKSkpKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/y-prosemirror/src/utils.js\n"));

/***/ })

}]);